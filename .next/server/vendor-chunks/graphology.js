"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphology";
exports.ids = ["vendor-chunks/graphology"];
exports.modules = {

/***/ "(ssr)/./node_modules/graphology/dist/graphology.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/graphology/dist/graphology.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DirectedGraph: () => (/* binding */ DirectedGraph),\n/* harmony export */   Graph: () => (/* binding */ Graph),\n/* harmony export */   InvalidArgumentsGraphError: () => (/* binding */ InvalidArgumentsGraphError),\n/* harmony export */   MultiDirectedGraph: () => (/* binding */ MultiDirectedGraph),\n/* harmony export */   MultiGraph: () => (/* binding */ MultiGraph),\n/* harmony export */   MultiUndirectedGraph: () => (/* binding */ MultiUndirectedGraph),\n/* harmony export */   NotFoundGraphError: () => (/* binding */ NotFoundGraphError),\n/* harmony export */   UndirectedGraph: () => (/* binding */ UndirectedGraph),\n/* harmony export */   UsageGraphError: () => (/* binding */ UsageGraphError),\n/* harmony export */   \"default\": () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n\n\n/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nfunction getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nfunction isPlainObject(value) {\n  // NOTE: as per https://github.com/graphology/graphology/issues/149\n  // this function has been loosened not to reject object instances\n  // coming from other JavaScript contexts. It has also been chosen\n  // not to improve it to avoid obvious false positives and avoid\n  // taking a performance hit. People should really use TypeScript\n  // if they want to avoid feeding subtly irrelvant attribute objects.\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nfunction isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nfunction privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nfunction readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nfunction validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nfunction incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n\n/**\n * Chains multiple iterators into a single iterator.\n *\n * @param {...Iterator} iterables\n * @returns {Iterator}\n */\nfunction chain() {\n  const iterables = arguments;\n  let current = null;\n  let i = -1;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step = null;\n\n      do {\n        if (current === null) {\n          i++;\n          if (i >= iterables.length) return {done: true};\n          current = iterables[i][Symbol.iterator]();\n        }\n        step = current.next();\n        if (step.done) {\n          current = null;\n          continue;\n        }\n        break;\n        // eslint-disable-next-line no-constant-condition\n      } while (true);\n\n      return step;\n    }\n  };\n}\n\nfunction emptyIterator() {\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      return {done: true};\n    }\n  };\n}\n\n/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nclass GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nclass InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nclass NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nclass UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n\n/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nfunction MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nfunction DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nfunction UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nfunction EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n\nEdgeData.prototype.attach = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  // Handling source\n  this.source[outKey][target] = this;\n\n  if (this.undirected && source === target) return;\n\n  // Handling target\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.attachMulti = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Handling source\n  const adj = this.source[outKey];\n  const head = adj[target];\n\n  if (typeof head === 'undefined') {\n    adj[target] = this;\n\n    // Self-loop optimization\n    if (!(this.undirected && source === target)) {\n      // Handling target\n      this.target[inKey][source] = this;\n    }\n\n    return;\n  }\n\n  // Prepending to doubly-linked list\n  head.previous = this;\n  this.next = head;\n\n  // Pointing to new head\n  // NOTE: use mutating swap later to avoid lookup?\n  adj[target] = this;\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.detach = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  delete this.source[outKey][target];\n\n  // No-op delete in case of undirected self-loop\n  delete this.target[inKey][source];\n};\n\nEdgeData.prototype.detachMulti = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Deleting from doubly-linked list\n  if (this.previous === undefined) {\n    // We are dealing with the head\n\n    // Should we delete the adjacency entry because it is now empty?\n    if (this.next === undefined) {\n      delete this.source[outKey][target];\n\n      // No-op delete in case of undirected self-loop\n      delete this.target[inKey][source];\n    } else {\n      // Detaching\n      this.next.previous = undefined;\n\n      // NOTE: could avoid the lookups by creating a #.become mutating method\n      this.source[outKey][target] = this.next;\n\n      // No-op delete in case of undirected self-loop\n      this.target[inKey][source] = this.next;\n    }\n  } else {\n    // We are dealing with another list node\n    this.previous.next = this.next;\n\n    // If not last\n    if (this.next !== undefined) {\n      this.next.previous = this.previous;\n    }\n  }\n};\n\n/**\n * Graphology Node Attributes methods\n * ===================================\n */\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nfunction attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n\n/**\n * Graphology Edge Attributes methods\n * ===================================\n */\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nfunction attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n\n/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(breakable, object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction forEachMulti(breakable, object, callback, avoid) {\n  let edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    edgeData = object[k];\n\n    do {\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (breakable && shouldBreak) return edgeData.key;\n\n      edgeData = edgeData.next;\n    } while (edgeData !== undefined);\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let edgeData;\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      do {\n        if (!edgeData) {\n          if (i >= l) return {done: true};\n\n          const k = keys[i++];\n\n          if (k === avoid) {\n            edgeData = undefined;\n            continue;\n          }\n\n          edgeData = object[k];\n        } else {\n          edgeData = edgeData.next;\n        }\n      } while (!edgeData);\n\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(breakable, object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    ) &&\n    breakable\n  )\n    return edgeData.key;\n}\n\nfunction forEachForKeyMulti(breakable, object, k, callback) {\n  let edgeData = object[k];\n\n  if (!edgeData) return;\n\n  let shouldBreak = false;\n\n  do {\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n\n    edgeData = edgeData.next;\n  } while (edgeData !== undefined);\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  let edgeData = object[k];\n\n  if (edgeData.next !== undefined) {\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        if (!edgeData) return {done: true};\n\n        const value = {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        };\n\n        edgeData = edgeData.next;\n\n        return {\n          done: false,\n          value\n        };\n      }\n    };\n  }\n\n  let done = false;\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      if (done === true) return {done: true};\n      done = true;\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    return Array.from(graph._edges.keys());\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(breakable, graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (breakable && shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return emptyIterator();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step, data;\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        step = iterator.next();\n\n        if (step.done) return step;\n\n        data = step.value;\n\n        if (shouldFilter && data.undirected !== mask) continue;\n\n        break;\n      }\n\n      const value = {\n        edge: data.key,\n        attributes: data.attributes,\n        source: data.source.key,\n        target: data.target.key,\n        sourceAttributes: data.source.attributes,\n        targetAttributes: data.target.attributes,\n        undirected: data.undirected\n      };\n\n      return {value, done: false};\n    }\n  };\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(\n  breakable,\n  multi,\n  type,\n  direction,\n  nodeData,\n  callback\n) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(breakable, nodeData.in, callback);\n\n      if (breakable && found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(\n        breakable,\n        nodeData.out,\n        callback,\n        !direction ? nodeData.key : undefined\n      );\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(breakable, nodeData.undirected, callback);\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {\n    edges.push(key);\n  });\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : undefined)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  breakable,\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(breakable, sourceData.in, target, callback);\n\n      if (breakable && found) return found;\n    }\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      (direction || sourceData.key !== target)\n    ) {\n      found = fn(breakable, sourceData.out, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(breakable, sourceData.undirected, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForPath(\n    false,\n    type,\n    multi,\n    direction,\n    sourceData,\n    target,\n    function (key) {\n      edges.push(key);\n    }\n  );\n\n  return edges;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out &&\n      (direction || sourceData.key !== target)\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(false, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        false,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        false,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(true, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        true,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        true,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nfunction attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n\n/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Helpers.\n */\nfunction CompositeSetWrapper() {\n  this.A = null;\n  this.B = null;\n}\n\nCompositeSetWrapper.prototype.wrap = function (set) {\n  if (this.A === null) this.A = set;\n  else if (this.B === null) this.B = set;\n};\n\nCompositeSetWrapper.prototype.has = function (key) {\n  if (this.A !== null && key in this.A) return true;\n  if (this.B !== null && key in this.B) return true;\n  return false;\n};\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectOnce(breakable, visited, nodeData, object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited && visited.has(neighborData.key)) continue;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (breakable && shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighbor(breakable, type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.undirected,\n        callback\n      );\n\n    if (typeof direction === 'string')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData[direction],\n        callback\n      );\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.in,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.in);\n    }\n    if (direction !== 'in') {\n      found = forEachInObjectOnce(\n        breakable,\n        visited,\n        nodeData,\n        nodeData.out,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    found = forEachInObjectOnce(\n      breakable,\n      visited,\n      nodeData,\n      nodeData.undirected,\n      callback\n    );\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  const neighbors = [];\n\n  forEachNeighbor(false, type, direction, nodeData, function (key) {\n    neighbors.push(key);\n  });\n\n  return neighbors;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let neighborData = null;\n\n      do {\n        if (i >= l) {\n          if (visited) visited.wrap(object);\n          return {done: true};\n        }\n\n        const edgeData = object[keys[i++]];\n\n        const sourceData = edgeData.source;\n        const targetData = edgeData.target;\n\n        neighborData = sourceData === nodeData ? targetData : sourceData;\n\n        if (visited && visited.has(neighborData.key)) {\n          neighborData = null;\n          continue;\n        }\n      } while (neighborData === null);\n\n      return {\n        done: false,\n        value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n      };\n    }\n  };\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);\n  }\n\n  let iterator = emptyIterator();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighbor(\n      false,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighbor(\n      true,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nfunction attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n\n/**\n * Graphology Adjacency Iteration\n * ===============================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nfunction forEachAdjacency(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n\n/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used by the graph serialization schemes.\n */\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nfunction serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {string} type - The graph's type.\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nfunction serializeEdge(type, key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (type === 'mixed' && data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nfunction validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n    );\n\n  if (!('key' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized node is missing its key.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nfunction validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n    );\n\n  if (!('source' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its source.'\n    );\n\n  if (!('target' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its target.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'\n    );\n}\n\n/* eslint no-nested-ternary: 0 */\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are consistent\n      if (edgeData.source.key !== source || edgeData.target.key !== target) {\n        // If source or target inconsistent\n        if (\n          !undirected ||\n          edgeData.source.key !== target ||\n          edgeData.target.key !== source\n        ) {\n          // If directed, or source/target aren't flipped\n          throw new UsageGraphError(\n            `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n          );\n        }\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Internal method used to drop an edge.\n *\n * @param  {Graph}    graph    - Target graph.\n * @param  {EdgeData} edgeData - Data of the edge to drop.\n */\nfunction dropEdgeFromData(graph, edgeData) {\n  // Dropping the edge from the register\n  graph._edges.delete(edgeData.key);\n\n  // Updating related degrees\n  const {source: sourceData, target: targetData, attributes} = edgeData;\n\n  const undirected = edgeData.undirected;\n\n  const isSelfLoop = sourceData === targetData;\n\n  if (undirected) {\n    sourceData.undirectedDegree--;\n    targetData.undirectedDegree--;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops--;\n      graph._undirectedSelfLoopCount--;\n    }\n  } else {\n    sourceData.outDegree--;\n    targetData.inDegree--;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops--;\n      graph._directedSelfLoopCount--;\n    }\n  }\n\n  // Clearing index\n  if (graph.multi) edgeData.detachMulti();\n  else edgeData.detach();\n\n  if (undirected) graph._undirectedSize--;\n  else graph._directedSize--;\n\n  // Emitting\n  graph.emit('edgeDropped', {\n    key: edgeData.key,\n    attributes,\n    source: sourceData.key,\n    target: targetData.key,\n    undirected\n  });\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nclass Graph extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = instancePrefix + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.out.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.undirected.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return (\n        (typeof nodeData.out !== 'undefined' &&\n          nodeData.out.hasOwnProperty(target)) ||\n        (typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected.hasOwnProperty(target))\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's inbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's outbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's inbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's outbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n      loops += nodeData.directedLoops * 2;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    let edgeData;\n\n    // Removing attached edges\n    // NOTE: we could be faster here, but this is such a pain to maintain\n    if (this.type !== 'undirected') {\n      for (const neighbor in nodeData.out) {\n        edgeData = nodeData.out[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n\n      for (const neighbor in nodeData.in) {\n        edgeData = nodeData.in[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (this.type !== 'directed') {\n      for (const neighbor in nodeData.undirected) {\n        edgeData = nodeData.undirected[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0];\n      const target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single directed edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropDirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const edgeData = getMatchingEdge(this, source, target, 'directed');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropDirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single undirected edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropUndirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    const edgeData = getMatchingEdge(this, source, target, 'undirected');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropUndirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    // Clearing structure index\n    const iterator = this._nodes.values();\n\n    let step;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      step.value.clear();\n    }\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    return Array.from(this._nodes.keys());\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const step = iterator.next();\n        if (step.done) return step;\n        const data = step.value;\n        return {\n          value: {node: data.key, attributes: data.attributes},\n          done: false\n        };\n      }\n    };\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(this.type, key, data);\n    });\n\n    return {\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      },\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance directly\n    if (data instanceof Graph) {\n      // Nodes\n      data.forEachNode((n, a) => {\n        if (merge) this.mergeNode(n, a);\n        else this.addNode(n, a);\n      });\n\n      // Edges\n      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {\n        if (merge) {\n          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);\n          else this.mergeDirectedEdgeWithKey(e, s, t, a);\n        } else {\n          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);\n          else this.addDirectedEdgeWithKey(e, s, t, a);\n        }\n      });\n\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list, node, edge;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        node = list[i];\n\n        // Validating\n        validateSerializedNode(node);\n\n        // Adding the node\n        const {key, attributes} = node;\n\n        if (merge) this.mergeNode(key, attributes);\n        else this.addNode(key, attributes);\n      }\n    }\n\n    if (data.edges) {\n      let undirectedByDefault = false;\n\n      if (this.type === 'undirected') {\n        undirectedByDefault = true;\n      }\n\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        edge = list[i];\n\n        // Validating\n        validateSerializedEdge(edge);\n\n        // Adding the edge\n        const {\n          source,\n          target,\n          attributes,\n          undirected = undirectedByDefault\n        } = edge;\n\n        let method;\n\n        if ('key' in edge) {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdgeWithKey\n              : this.mergeDirectedEdgeWithKey\n            : undirected\n            ? this.addUndirectedEdgeWithKey\n            : this.addDirectedEdgeWithKey;\n\n          method.call(this, edge.key, source, target, attributes);\n        } else {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdge\n              : this.mergeDirectedEdge\n            : undirected\n            ? this.addUndirectedEdge\n            : this.addDirectedEdge;\n\n          method.call(this, source, target, attributes);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @param  {object} options - Upgrade options.\n   * @return {Graph}          - The copy.\n   */\n  copy(options) {\n    options = options || {};\n\n    if (\n      typeof options.type === 'string' &&\n      options.type !== this.type &&\n      options.type !== 'mixed'\n    )\n      throw new UsageGraphError(\n        `Graph.copy: cannot create an incompatible copy from \"${this.type}\" type to \"${options.type}\" because this would mean losing information about the current graph.`\n      );\n\n    if (\n      typeof options.multi === 'boolean' &&\n      options.multi !== this.multi &&\n      options.multi !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'\n      );\n\n    if (\n      typeof options.allowSelfLoops === 'boolean' &&\n      options.allowSelfLoops !== this.allowSelfLoops &&\n      options.allowSelfLoops !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'\n      );\n\n    const graph = this.emptyCopy(options);\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n\n/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\n/**\n * Graphology ESM Endoint\n * =======================\n *\n * Endpoint for ESM modules consumers.\n */\n\n\n//# sourceMappingURL=graphology.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS9kaXN0L2dyYXBob2xvZ3kubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU8sd0JBQXdCLFdBQVc7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFdBQVcsaUNBQWlDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFB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QUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksY0FBYztBQUMxQixZQUFZLGNBQWM7QUFDMUIsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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OztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOEJBQThCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQ0FBZ0M7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLHVCQUF1QjtBQUNyQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBMO0FBQzFMIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGh5ZW9uXFxEZXNrdG9wXFxmcm9udGVuZC1oaWRkZW5ub2RlXFxub2RlX21vZHVsZXNcXGdyYXBob2xvZ3lcXGRpc3RcXGdyYXBob2xvZ3kubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbi8qKlxuICogR3JhcGhvbG9neSBVdGlsaXRpZXNcbiAqID09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIENvbGxlY3Rpb24gb2YgaGVscGZ1bCBmdW5jdGlvbnMgdXNlZCBieSB0aGUgaW1wbGVtZW50YXRpb24uXG4gKi9cblxuLyoqXG4gKiBPYmplY3QuYXNzaWduLWxpa2UgcG9seWZpbGwuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXQgICAgICAgLSBGaXJzdCBvYmplY3QuXG4gKiBAcGFyYW0gIHtvYmplY3R9IFsuLi5vYmplY3RzXSAtIE9iamVjdHMgdG8gbWVyZ2UuXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGFzc2lnblBvbHlmaWxsKCkge1xuICBjb25zdCB0YXJnZXQgPSBhcmd1bWVudHNbMF07XG5cbiAgZm9yIChsZXQgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKCFhcmd1bWVudHNbaV0pIGNvbnRpbnVlO1xuXG4gICAgZm9yIChjb25zdCBrIGluIGFyZ3VtZW50c1tpXSkgdGFyZ2V0W2tdID0gYXJndW1lbnRzW2ldW2tdO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubGV0IGFzc2lnbiA9IGFzc2lnblBvbHlmaWxsO1xuXG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gPT09ICdmdW5jdGlvbicpIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBmaXJzdCBtYXRjaGluZyBlZGdlIGZvciBnaXZlbiBwYXRoLlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjaGVjayB0aGUgZXhpc3RlbmNlIG9mIHNvdXJjZSAmIHRhcmdldC4gVGhpc1xuICogbXVzdCBiZSBwZXJmb3JtZWQgYnkgdGhlIGNhbGxlci5cbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gIGdyYXBoICAtIFRhcmdldCBncmFwaC5cbiAqIEBwYXJhbSAge2FueX0gICAgc291cmNlIC0gU291cmNlIG5vZGUuXG4gKiBAcGFyYW0gIHthbnl9ICAgIHRhcmdldCAtIFRhcmdldCBub2RlLlxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlICAgLSBUeXBlIG9mIHRoZSBlZGdlIChtaXhlZCwgZGlyZWN0ZWQgb3IgdW5kaXJlY3RlZCkuXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hpbmdFZGdlKGdyYXBoLCBzb3VyY2UsIHRhcmdldCwgdHlwZSkge1xuICBjb25zdCBzb3VyY2VEYXRhID0gZ3JhcGguX25vZGVzLmdldChzb3VyY2UpO1xuXG4gIGxldCBlZGdlID0gbnVsbDtcblxuICBpZiAoIXNvdXJjZURhdGEpIHJldHVybiBlZGdlO1xuXG4gIGlmICh0eXBlID09PSAnbWl4ZWQnKSB7XG4gICAgZWRnZSA9XG4gICAgICAoc291cmNlRGF0YS5vdXQgJiYgc291cmNlRGF0YS5vdXRbdGFyZ2V0XSkgfHxcbiAgICAgIChzb3VyY2VEYXRhLnVuZGlyZWN0ZWQgJiYgc291cmNlRGF0YS51bmRpcmVjdGVkW3RhcmdldF0pO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdkaXJlY3RlZCcpIHtcbiAgICBlZGdlID0gc291cmNlRGF0YS5vdXQgJiYgc291cmNlRGF0YS5vdXRbdGFyZ2V0XTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc291cmNlRGF0YS51bmRpcmVjdGVkICYmIHNvdXJjZURhdGEudW5kaXJlY3RlZFt0YXJnZXRdO1xuICB9XG5cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge21peGVkfSAgIHZhbHVlIC0gVGFyZ2V0IHZhbHVlLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAvLyBOT1RFOiBhcyBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2dyYXBob2xvZ3kvZ3JhcGhvbG9neS9pc3N1ZXMvMTQ5XG4gIC8vIHRoaXMgZnVuY3Rpb24gaGFzIGJlZW4gbG9vc2VuZWQgbm90IHRvIHJlamVjdCBvYmplY3QgaW5zdGFuY2VzXG4gIC8vIGNvbWluZyBmcm9tIG90aGVyIEphdmFTY3JpcHQgY29udGV4dHMuIEl0IGhhcyBhbHNvIGJlZW4gY2hvc2VuXG4gIC8vIG5vdCB0byBpbXByb3ZlIGl0IHRvIGF2b2lkIG9idmlvdXMgZmFsc2UgcG9zaXRpdmVzIGFuZCBhdm9pZFxuICAvLyB0YWtpbmcgYSBwZXJmb3JtYW5jZSBoaXQuIFBlb3BsZSBzaG91bGQgcmVhbGx5IHVzZSBUeXBlU2NyaXB0XG4gIC8vIGlmIHRoZXkgd2FudCB0byBhdm9pZCBmZWVkaW5nIHN1YnRseSBpcnJlbHZhbnQgYXR0cmlidXRlIG9iamVjdHMuXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgZW1wdHkuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgbyAtIFRhcmdldCBPYmplY3QuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KG8pIHtcbiAgbGV0IGs7XG5cbiAgZm9yIChrIGluIG8pIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgXCJwcml2YXRlXCIgcHJvcGVydHkgZm9yIHRoZSBnaXZlbiBtZW1iZXIgbmFtZSBieSBjb25jZWFsaW5nIGl0XG4gKiB1c2luZyB0aGUgYGVudW1lcmFibGVgIG9wdGlvbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGFyZ2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgLSBNZW1iZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcHJpdmF0ZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWVcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlYWQtb25seSBwcm9wZXJ0eSBmb3IgdGhlIGdpdmVuIG1lbWJlciBuYW1lICYgdGhlIGdpdmVuIGdldHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gICB0YXJnZXQgLSBUYXJnZXQgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZSAgIC0gTWVtYmVyIG5hbWUuXG4gKiBAcGFyYW0ge21peGVkfSAgICB2YWx1ZSAgLSBUaGUgYXR0YWNoZWQgZ2V0dGVyIG9yIGZpeGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiByZWFkT25seVByb3BlcnR5KHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgY29uc3QgZGVzY3JpcHRvciA9IHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9O1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZXNjcmlwdG9yLmdldCA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gZmFsc2U7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBjb25zdGl0dXRlIHZhbGlkIGhpbnRzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBoaW50cyAtIFRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSGludHMoaGludHMpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGhpbnRzKSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChoaW50cy5hdHRyaWJ1dGVzICYmICFBcnJheS5pc0FycmF5KGhpbnRzLmF0dHJpYnV0ZXMpKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGdlbmVyYXRpbmcgaW5jcmVtZW50YWwgaWRzIGZvciBlZGdlcy5cbiAqXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gaW5jcmVtZW50YWxJZFN0YXJ0aW5nRnJvbVJhbmRvbUJ5dGUoKSB7XG4gIGxldCBpID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSAmIDB4ZmY7XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICByZXR1cm4gaSsrO1xuICB9O1xufVxuXG4vKipcbiAqIENoYWlucyBtdWx0aXBsZSBpdGVyYXRvcnMgaW50byBhIHNpbmdsZSBpdGVyYXRvci5cbiAqXG4gKiBAcGFyYW0gey4uLkl0ZXJhdG9yfSBpdGVyYWJsZXNcbiAqIEByZXR1cm5zIHtJdGVyYXRvcn1cbiAqL1xuZnVuY3Rpb24gY2hhaW4oKSB7XG4gIGNvbnN0IGl0ZXJhYmxlcyA9IGFyZ3VtZW50cztcbiAgbGV0IGN1cnJlbnQgPSBudWxsO1xuICBsZXQgaSA9IC0xO1xuXG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG5leHQoKSB7XG4gICAgICBsZXQgc3RlcCA9IG51bGw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgaWYgKGkgPj0gaXRlcmFibGVzLmxlbmd0aCkgcmV0dXJuIHtkb25lOiB0cnVlfTtcbiAgICAgICAgICBjdXJyZW50ID0gaXRlcmFibGVzW2ldW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwID0gY3VycmVudC5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICAgIHJldHVybiBzdGVwO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlJdGVyYXRvcigpIHtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIHJldHVybiB7ZG9uZTogdHJ1ZX07XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEdyYXBob2xvZ3kgQ3VzdG9tIEVycm9yc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIERlZmluaW5nIGN1c3RvbSBlcnJvcnMgZm9yIGVhc2Ugb2YgdXNlICYgZWFzeSB1bml0IHRlc3RzIGFjcm9zc1xuICogaW1wbGVtZW50YXRpb25zIChub3JtYWxpemVkIHR5cG9sb2d5IHJhdGhlciB0aGFuIHJlbHlpbmcgb24gZXJyb3JcbiAqIG1lc3NhZ2VzIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGNvcnJlY3QgZXJyb3Igd2FzIGZvdW5kKS5cbiAqL1xuY2xhc3MgR3JhcGhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uYW1lID0gJ0dyYXBoRXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbn1cblxuY2xhc3MgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IgZXh0ZW5kcyBHcmFwaEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcic7XG5cbiAgICAvLyBUaGlzIGlzIFY4IHNwZWNpZmljIHRvIGVuaGFuY2Ugc3RhY2sgcmVhZGFiaWxpdHlcbiAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKVxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxuICAgICAgKTtcbiAgfVxufVxuXG5jbGFzcyBOb3RGb3VuZEdyYXBoRXJyb3IgZXh0ZW5kcyBHcmFwaEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdOb3RGb3VuZEdyYXBoRXJyb3InO1xuXG4gICAgLy8gVGhpcyBpcyBWOCBzcGVjaWZpYyB0byBlbmhhbmNlIHN0YWNrIHJlYWRhYmlsaXR5XG4gICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE5vdEZvdW5kR3JhcGhFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IpO1xuICB9XG59XG5cbmNsYXNzIFVzYWdlR3JhcGhFcnJvciBleHRlbmRzIEdyYXBoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1VzYWdlR3JhcGhFcnJvcic7XG5cbiAgICAvLyBUaGlzIGlzIFY4IHNwZWNpZmljIHRvIGVuaGFuY2Ugc3RhY2sgcmVhZGFiaWxpdHlcbiAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKVxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVXNhZ2VHcmFwaEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBHcmFwaG9sb2d5IEludGVybmFsIERhdGEgQ2xhc3Nlc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogSW50ZXJuYWwgY2xhc3NlcyBob3BlZnVsbHkgcmVkdWNlZCB0byBzdHJ1Y3RzIGJ5IGVuZ2luZXMgJiBzdG9yaW5nXG4gKiBuZWNlc3NhcnkgaW5mb3JtYXRpb24gZm9yIG5vZGVzICYgZWRnZXMuXG4gKlxuICogTm90ZSB0aGF0IHRob3NlIGNsYXNzZXMgZG9uJ3QgcmVseSBvbiB0aGUgYGNsYXNzYCBrZXl3b3JkIHRvIGF2b2lkIHNvbWVcbiAqIGNydWZ0IGludHJvZHVjZWQgYnkgbW9zdCBvZiBFUzIwMTUgdHJhbnNwaWxlcnMuXG4gKi9cblxuLyoqXG4gKiBNaXhlZE5vZGVEYXRhIGNsYXNzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gTm9kZSdzIGF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIE1peGVkTm9kZURhdGEoa2V5LCBhdHRyaWJ1dGVzKSB7XG4gIC8vIEF0dHJpYnV0ZXNcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgdGhpcy5jbGVhcigpO1xufVxuXG5NaXhlZE5vZGVEYXRhLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRGVncmVlc1xuICB0aGlzLmluRGVncmVlID0gMDtcbiAgdGhpcy5vdXREZWdyZWUgPSAwO1xuICB0aGlzLnVuZGlyZWN0ZWREZWdyZWUgPSAwO1xuICB0aGlzLnVuZGlyZWN0ZWRMb29wcyA9IDA7XG4gIHRoaXMuZGlyZWN0ZWRMb29wcyA9IDA7XG5cbiAgLy8gSW5kaWNlc1xuICB0aGlzLmluID0ge307XG4gIHRoaXMub3V0ID0ge307XG4gIHRoaXMudW5kaXJlY3RlZCA9IHt9O1xufTtcblxuLyoqXG4gKiBEaXJlY3RlZE5vZGVEYXRhIGNsYXNzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gTm9kZSdzIGF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIERpcmVjdGVkTm9kZURhdGEoa2V5LCBhdHRyaWJ1dGVzKSB7XG4gIC8vIEF0dHJpYnV0ZXNcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgdGhpcy5jbGVhcigpO1xufVxuXG5EaXJlY3RlZE5vZGVEYXRhLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRGVncmVlc1xuICB0aGlzLmluRGVncmVlID0gMDtcbiAgdGhpcy5vdXREZWdyZWUgPSAwO1xuICB0aGlzLmRpcmVjdGVkTG9vcHMgPSAwO1xuXG4gIC8vIEluZGljZXNcbiAgdGhpcy5pbiA9IHt9O1xuICB0aGlzLm91dCA9IHt9O1xufTtcblxuLyoqXG4gKiBVbmRpcmVjdGVkTm9kZURhdGEgY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBOb2RlJ3MgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gVW5kaXJlY3RlZE5vZGVEYXRhKGtleSwgYXR0cmlidXRlcykge1xuICAvLyBBdHRyaWJ1dGVzXG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gIHRoaXMuY2xlYXIoKTtcbn1cblxuVW5kaXJlY3RlZE5vZGVEYXRhLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRGVncmVlc1xuICB0aGlzLnVuZGlyZWN0ZWREZWdyZWUgPSAwO1xuICB0aGlzLnVuZGlyZWN0ZWRMb29wcyA9IDA7XG5cbiAgLy8gSW5kaWNlc1xuICB0aGlzLnVuZGlyZWN0ZWQgPSB7fTtcbn07XG5cbi8qKlxuICogRWRnZURhdGEgY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVuZGlyZWN0ZWQgICAtIFdoZXRoZXIgdGhlIGVkZ2UgaXMgdW5kaXJlY3RlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgc3RyaW5nICAgICAgIC0gVGhlIGVkZ2UncyBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30gIHNvdXJjZSAgICAgICAtIFNvdXJjZSBvZiB0aGUgZWRnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgdGFyZ2V0ICAgICAgIC0gVGFyZ2V0IG9mIHRoZSBlZGdlLlxuICogQHBhcmFtIHtvYmplY3R9ICBhdHRyaWJ1dGVzICAgLSBFZGdlJ3MgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gRWRnZURhdGEodW5kaXJlY3RlZCwga2V5LCBzb3VyY2UsIHRhcmdldCwgYXR0cmlidXRlcykge1xuICAvLyBBdHRyaWJ1dGVzXG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICB0aGlzLnVuZGlyZWN0ZWQgPSB1bmRpcmVjdGVkO1xuXG4gIC8vIEV4dHJlbWl0aWVzXG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbn1cblxuRWRnZURhdGEucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG91dEtleSA9ICdvdXQnO1xuICBsZXQgaW5LZXkgPSAnaW4nO1xuXG4gIGlmICh0aGlzLnVuZGlyZWN0ZWQpIG91dEtleSA9IGluS2V5ID0gJ3VuZGlyZWN0ZWQnO1xuXG4gIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLmtleTtcbiAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQua2V5O1xuXG4gIC8vIEhhbmRsaW5nIHNvdXJjZVxuICB0aGlzLnNvdXJjZVtvdXRLZXldW3RhcmdldF0gPSB0aGlzO1xuXG4gIGlmICh0aGlzLnVuZGlyZWN0ZWQgJiYgc291cmNlID09PSB0YXJnZXQpIHJldHVybjtcblxuICAvLyBIYW5kbGluZyB0YXJnZXRcbiAgdGhpcy50YXJnZXRbaW5LZXldW3NvdXJjZV0gPSB0aGlzO1xufTtcblxuRWRnZURhdGEucHJvdG90eXBlLmF0dGFjaE11bHRpID0gZnVuY3Rpb24gKCkge1xuICBsZXQgb3V0S2V5ID0gJ291dCc7XG4gIGxldCBpbktleSA9ICdpbic7XG5cbiAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2Uua2V5O1xuICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldC5rZXk7XG5cbiAgaWYgKHRoaXMudW5kaXJlY3RlZCkgb3V0S2V5ID0gaW5LZXkgPSAndW5kaXJlY3RlZCc7XG5cbiAgLy8gSGFuZGxpbmcgc291cmNlXG4gIGNvbnN0IGFkaiA9IHRoaXMuc291cmNlW291dEtleV07XG4gIGNvbnN0IGhlYWQgPSBhZGpbdGFyZ2V0XTtcblxuICBpZiAodHlwZW9mIGhlYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYWRqW3RhcmdldF0gPSB0aGlzO1xuXG4gICAgLy8gU2VsZi1sb29wIG9wdGltaXphdGlvblxuICAgIGlmICghKHRoaXMudW5kaXJlY3RlZCAmJiBzb3VyY2UgPT09IHRhcmdldCkpIHtcbiAgICAgIC8vIEhhbmRsaW5nIHRhcmdldFxuICAgICAgdGhpcy50YXJnZXRbaW5LZXldW3NvdXJjZV0gPSB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFByZXBlbmRpbmcgdG8gZG91Ymx5LWxpbmtlZCBsaXN0XG4gIGhlYWQucHJldmlvdXMgPSB0aGlzO1xuICB0aGlzLm5leHQgPSBoZWFkO1xuXG4gIC8vIFBvaW50aW5nIHRvIG5ldyBoZWFkXG4gIC8vIE5PVEU6IHVzZSBtdXRhdGluZyBzd2FwIGxhdGVyIHRvIGF2b2lkIGxvb2t1cD9cbiAgYWRqW3RhcmdldF0gPSB0aGlzO1xuICB0aGlzLnRhcmdldFtpbktleV1bc291cmNlXSA9IHRoaXM7XG59O1xuXG5FZGdlRGF0YS5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS5rZXk7XG4gIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0LmtleTtcblxuICBsZXQgb3V0S2V5ID0gJ291dCc7XG4gIGxldCBpbktleSA9ICdpbic7XG5cbiAgaWYgKHRoaXMudW5kaXJlY3RlZCkgb3V0S2V5ID0gaW5LZXkgPSAndW5kaXJlY3RlZCc7XG5cbiAgZGVsZXRlIHRoaXMuc291cmNlW291dEtleV1bdGFyZ2V0XTtcblxuICAvLyBOby1vcCBkZWxldGUgaW4gY2FzZSBvZiB1bmRpcmVjdGVkIHNlbGYtbG9vcFxuICBkZWxldGUgdGhpcy50YXJnZXRbaW5LZXldW3NvdXJjZV07XG59O1xuXG5FZGdlRGF0YS5wcm90b3R5cGUuZGV0YWNoTXVsdGkgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLmtleTtcbiAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQua2V5O1xuXG4gIGxldCBvdXRLZXkgPSAnb3V0JztcbiAgbGV0IGluS2V5ID0gJ2luJztcblxuICBpZiAodGhpcy51bmRpcmVjdGVkKSBvdXRLZXkgPSBpbktleSA9ICd1bmRpcmVjdGVkJztcblxuICAvLyBEZWxldGluZyBmcm9tIGRvdWJseS1saW5rZWQgbGlzdFxuICBpZiAodGhpcy5wcmV2aW91cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgYXJlIGRlYWxpbmcgd2l0aCB0aGUgaGVhZFxuXG4gICAgLy8gU2hvdWxkIHdlIGRlbGV0ZSB0aGUgYWRqYWNlbmN5IGVudHJ5IGJlY2F1c2UgaXQgaXMgbm93IGVtcHR5P1xuICAgIGlmICh0aGlzLm5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIHRoaXMuc291cmNlW291dEtleV1bdGFyZ2V0XTtcblxuICAgICAgLy8gTm8tb3AgZGVsZXRlIGluIGNhc2Ugb2YgdW5kaXJlY3RlZCBzZWxmLWxvb3BcbiAgICAgIGRlbGV0ZSB0aGlzLnRhcmdldFtpbktleV1bc291cmNlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGV0YWNoaW5nXG4gICAgICB0aGlzLm5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIE5PVEU6IGNvdWxkIGF2b2lkIHRoZSBsb29rdXBzIGJ5IGNyZWF0aW5nIGEgIy5iZWNvbWUgbXV0YXRpbmcgbWV0aG9kXG4gICAgICB0aGlzLnNvdXJjZVtvdXRLZXldW3RhcmdldF0gPSB0aGlzLm5leHQ7XG5cbiAgICAgIC8vIE5vLW9wIGRlbGV0ZSBpbiBjYXNlIG9mIHVuZGlyZWN0ZWQgc2VsZi1sb29wXG4gICAgICB0aGlzLnRhcmdldFtpbktleV1bc291cmNlXSA9IHRoaXMubmV4dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgYXJlIGRlYWxpbmcgd2l0aCBhbm90aGVyIGxpc3Qgbm9kZVxuICAgIHRoaXMucHJldmlvdXMubmV4dCA9IHRoaXMubmV4dDtcblxuICAgIC8vIElmIG5vdCBsYXN0XG4gICAgaWYgKHRoaXMubmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm5leHQucHJldmlvdXMgPSB0aGlzLnByZXZpb3VzO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBHcmFwaG9sb2d5IE5vZGUgQXR0cmlidXRlcyBtZXRob2RzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmNvbnN0IE5PREUgPSAwO1xuY29uc3QgU09VUkNFID0gMTtcbmNvbnN0IFRBUkdFVCA9IDI7XG5jb25zdCBPUFBPU0lURSA9IDM7XG5cbmZ1bmN0aW9uIGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICBncmFwaCxcbiAgbWV0aG9kLFxuICBtb2RlLFxuICBub2RlT3JFZGdlLFxuICBuYW1lT3JFZGdlLFxuICBhZGQxLFxuICBhZGQyXG4pIHtcbiAgbGV0IG5vZGVEYXRhLCBlZGdlRGF0YSwgYXJnMSwgYXJnMjtcblxuICBub2RlT3JFZGdlID0gJycgKyBub2RlT3JFZGdlO1xuXG4gIGlmIChtb2RlID09PSBOT0RFKSB7XG4gICAgbm9kZURhdGEgPSBncmFwaC5fbm9kZXMuZ2V0KG5vZGVPckVkZ2UpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZU9yRWRnZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgYXJnMSA9IG5hbWVPckVkZ2U7XG4gICAgYXJnMiA9IGFkZDE7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gT1BQT1NJVEUpIHtcbiAgICBuYW1lT3JFZGdlID0gJycgKyBuYW1lT3JFZGdlO1xuXG4gICAgZWRnZURhdGEgPSBncmFwaC5fZWRnZXMuZ2V0KG5hbWVPckVkZ2UpO1xuXG4gICAgaWYgKCFlZGdlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bmFtZU9yRWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgY29uc3Qgc291cmNlID0gZWRnZURhdGEuc291cmNlLmtleTtcbiAgICBjb25zdCB0YXJnZXQgPSBlZGdlRGF0YS50YXJnZXQua2V5O1xuXG4gICAgaWYgKG5vZGVPckVkZ2UgPT09IHNvdXJjZSkge1xuICAgICAgbm9kZURhdGEgPSBlZGdlRGF0YS50YXJnZXQ7XG4gICAgfSBlbHNlIGlmIChub2RlT3JFZGdlID09PSB0YXJnZXQpIHtcbiAgICAgIG5vZGVEYXRhID0gZWRnZURhdGEuc291cmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiB0aGUgXCIke25vZGVPckVkZ2V9XCIgbm9kZSBpcyBub3QgYXR0YWNoZWQgdG8gdGhlIFwiJHtuYW1lT3JFZGdlfVwiIGVkZ2UgKCR7c291cmNlfSwgJHt0YXJnZXR9KS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGFyZzEgPSBhZGQxO1xuICAgIGFyZzIgPSBhZGQyO1xuICB9IGVsc2Uge1xuICAgIGVkZ2VEYXRhID0gZ3JhcGguX2VkZ2VzLmdldChub2RlT3JFZGdlKTtcblxuICAgIGlmICghZWRnZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGVPckVkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChtb2RlID09PSBTT1VSQ0UpIHtcbiAgICAgIG5vZGVEYXRhID0gZWRnZURhdGEuc291cmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlRGF0YSA9IGVkZ2VEYXRhLnRhcmdldDtcbiAgICB9XG5cbiAgICBhcmcxID0gbmFtZU9yRWRnZTtcbiAgICBhcmcyID0gYWRkMTtcbiAgfVxuXG4gIHJldHVybiBbbm9kZURhdGEsIGFyZzEsIGFyZzJdO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlR2V0dGVyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSwgYWRkMSkge1xuICAgIGNvbnN0IFtkYXRhLCBuYW1lXSA9IGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICAgICAgdGhpcyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG1vZGUsXG4gICAgICBub2RlT3JFZGdlLFxuICAgICAgbmFtZU9yRWRnZSxcbiAgICAgIGFkZDFcbiAgICApO1xuXG4gICAgcmV0dXJuIGRhdGEuYXR0cmlidXRlc1tuYW1lXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZXNHZXR0ZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlKSB7XG4gICAgY29uc3QgW2RhdGFdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlXG4gICAgKTtcblxuICAgIHJldHVybiBkYXRhLmF0dHJpYnV0ZXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVDaGVja2VyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSwgYWRkMSkge1xuICAgIGNvbnN0IFtkYXRhLCBuYW1lXSA9IGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICAgICAgdGhpcyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG1vZGUsXG4gICAgICBub2RlT3JFZGdlLFxuICAgICAgbmFtZU9yRWRnZSxcbiAgICAgIGFkZDFcbiAgICApO1xuXG4gICAgcmV0dXJuIGRhdGEuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZVNldHRlcihDbGFzcywgbWV0aG9kLCBtb2RlKSB7XG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5vZGVPckVkZ2UsIG5hbWVPckVkZ2UsIGFkZDEsIGFkZDIpIHtcbiAgICBjb25zdCBbZGF0YSwgbmFtZSwgdmFsdWVdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMSxcbiAgICAgIGFkZDJcbiAgICApO1xuXG4gICAgZGF0YS5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnbm9kZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVVcGRhdGVyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSwgYWRkMSwgYWRkMikge1xuICAgIGNvbnN0IFtkYXRhLCBuYW1lLCB1cGRhdGVyXSA9IGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICAgICAgdGhpcyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG1vZGUsXG4gICAgICBub2RlT3JFZGdlLFxuICAgICAgbmFtZU9yRWRnZSxcbiAgICAgIGFkZDEsXG4gICAgICBhZGQyXG4gICAgKTtcblxuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogdXBkYXRlciBzaG91bGQgYmUgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGRhdGEuYXR0cmlidXRlcztcbiAgICBjb25zdCB2YWx1ZSA9IHVwZGF0ZXIoYXR0cmlidXRlc1tuYW1lXSk7XG5cbiAgICBhdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnbm9kZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVSZW1vdmVyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSwgYWRkMSkge1xuICAgIGNvbnN0IFtkYXRhLCBuYW1lXSA9IGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICAgICAgdGhpcyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG1vZGUsXG4gICAgICBub2RlT3JFZGdlLFxuICAgICAgbmFtZU9yRWRnZSxcbiAgICAgIGFkZDFcbiAgICApO1xuXG4gICAgZGVsZXRlIGRhdGEuYXR0cmlidXRlc1tuYW1lXTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZXNSZXBsYWNlcihDbGFzcywgbWV0aG9kLCBtb2RlKSB7XG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5vZGVPckVkZ2UsIG5hbWVPckVkZ2UsIGFkZDEpIHtcbiAgICBjb25zdCBbZGF0YSwgYXR0cmlidXRlc10gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2UsXG4gICAgICBhZGQxXG4gICAgKTtcblxuICAgIGlmICghaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogcHJvdmlkZWQgYXR0cmlidXRlcyBhcmUgbm90IGEgcGxhaW4gb2JqZWN0LmBcbiAgICAgICk7XG5cbiAgICBkYXRhLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAncmVwbGFjZScsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlc01lcmdlcihDbGFzcywgbWV0aG9kLCBtb2RlKSB7XG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5vZGVPckVkZ2UsIG5hbWVPckVkZ2UsIGFkZDEpIHtcbiAgICBjb25zdCBbZGF0YSwgYXR0cmlidXRlc10gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2UsXG4gICAgICBhZGQxXG4gICAgKTtcblxuICAgIGlmICghaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogcHJvdmlkZWQgYXR0cmlidXRlcyBhcmUgbm90IGEgcGxhaW4gb2JqZWN0LmBcbiAgICAgICk7XG5cbiAgICBhc3NpZ24oZGF0YS5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ21lcmdlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgIGRhdGE6IGF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxKSB7XG4gICAgY29uc3QgW2RhdGEsIHVwZGF0ZXJdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMVxuICAgICk7XG5cbiAgICBpZiAodHlwZW9mIHVwZGF0ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHByb3ZpZGVkIHVwZGF0ZXIgaXMgbm90IGEgZnVuY3Rpb24uYFxuICAgICAgKTtcblxuICAgIGRhdGEuYXR0cmlidXRlcyA9IHVwZGF0ZXIoZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3VwZGF0ZScsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIExpc3Qgb2YgbWV0aG9kcyB0byBhdHRhY2guXG4gKi9cbmNvbnN0IE5PREVfQVRUUklCVVRFU19NRVRIT0RTID0gW1xuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgZ2V0JHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVHZXR0ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYGdldCR7ZWxlbWVudH1BdHRyaWJ1dGVzYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZXNHZXR0ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYGhhcyR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlQ2hlY2tlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgc2V0JHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVTZXR0ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHVwZGF0ZSR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlVXBkYXRlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgcmVtb3ZlJHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVSZW1vdmVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGByZXBsYWNlJHtlbGVtZW50fUF0dHJpYnV0ZXNgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlc1JlcGxhY2VyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBtZXJnZSR7ZWxlbWVudH1BdHRyaWJ1dGVzYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZXNNZXJnZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHVwZGF0ZSR7ZWxlbWVudH1BdHRyaWJ1dGVzYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVyXG4gIH1cbl07XG5cbi8qKlxuICogQXR0YWNoIGV2ZXJ5IGF0dHJpYnV0ZXMtcmVsYXRlZCBtZXRob2RzIHRvIGEgR3JhcGggY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gR3JhcGggLSBUYXJnZXQgY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVzTWV0aG9kcyhHcmFwaCkge1xuICBOT0RFX0FUVFJJQlVURVNfTUVUSE9EUy5mb3JFYWNoKGZ1bmN0aW9uICh7bmFtZSwgYXR0YWNoZXJ9KSB7XG4gICAgLy8gRm9yIG5vZGVzXG4gICAgYXR0YWNoZXIoR3JhcGgsIG5hbWUoJ05vZGUnKSwgTk9ERSk7XG5cbiAgICAvLyBGb3Igc291cmNlc1xuICAgIGF0dGFjaGVyKEdyYXBoLCBuYW1lKCdTb3VyY2UnKSwgU09VUkNFKTtcblxuICAgIC8vIEZvciB0YXJnZXRzXG4gICAgYXR0YWNoZXIoR3JhcGgsIG5hbWUoJ1RhcmdldCcpLCBUQVJHRVQpO1xuXG4gICAgLy8gRm9yIG9wcG9zaXRlc1xuICAgIGF0dGFjaGVyKEdyYXBoLCBuYW1lKCdPcHBvc2l0ZScpLCBPUFBPU0lURSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdyYXBob2xvZ3kgRWRnZSBBdHRyaWJ1dGVzIG1ldGhvZHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyoqXG4gKiBBdHRhY2ggYW4gYXR0cmlidXRlIGdldHRlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVHZXR0ZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogR2V0IHRoZSBkZXNpcmVkIGF0dHJpYnV0ZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgKG5vZGUgb3IgZWRnZSkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgZWxlbWVudCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKlxuICAgKiBBcml0eSAzIChvbmx5IGZvciBlZGdlcyk6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAtIFNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7bWl4ZWR9ICAgICAgICAgIC0gVGhlIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gJycgKyBuYW1lO1xuXG4gICAgICBuYW1lID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICBkYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIiR7c291cmNlfVwiIC0gXCIke3RhcmdldH1cIikuYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ21peGVkJylcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuYFxuICAgICAgICApO1xuXG4gICAgICBlbGVtZW50ID0gJycgKyBlbGVtZW50O1xuICAgICAgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlbGVtZW50KTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWxlbWVudH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEuYXR0cmlidXRlc1tuYW1lXTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggYW4gYXR0cmlidXRlcyBnZXR0ZXIgbWV0aG9kIG9udG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbWV0aG9kICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgIC0gVHlwZSBvZiB0aGUgZWRnZSB0byBmaW5kLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlc0dldHRlcihDbGFzcywgbWV0aG9kLCB0eXBlKSB7XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYWxsIHRoZSB0YXJnZXQgZWxlbWVudCdzIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgZWxlbWVudCAtIFRhcmdldCBlbGVtZW50LlxuICAgKlxuICAgKiBBcml0eSAzIChvbmx5IGZvciBlZGdlcyk6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAtIFNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAtIFRoZSBlbGVtZW50J3MgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudCxcbiAgICAgICAgdGFyZ2V0ID0gJycgKyBhcmd1bWVudHNbMV07XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5hdHRyaWJ1dGVzO1xuICB9O1xufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGUgY2hlY2tlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAtIE1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgdHlwZSAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVDaGVja2VyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkZXNpcmVkIGF0dHJpYnV0ZSBpcyBzZXQgZm9yIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIGVsZW1lbnQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdG9vIG1hbnkgYXJndW1lbnRzIGFyZSBwcm92aWRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHtcbiAgICBsZXQgZGF0YTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciAke3RoaXMudHlwZX0gZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuYFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSAnJyArIG5hbWU7XG5cbiAgICAgIG5hbWUgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGUgc2V0dGVyIG1ldGhvZCBvbnRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbWV0aG9kICAgICAgICAtIE1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgdHlwZSAgICAgICAgICAtIFR5cGUgb2YgdGhlIGVkZ2UgdG8gZmluZC5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZVNldHRlcihDbGFzcywgbWV0aG9kLCB0eXBlKSB7XG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlc2lyZWQgYXR0cmlidXRlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCAobm9kZSBvciBlZGdlKS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICBlbGVtZW50IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqIEBwYXJhbSAge21peGVkfSAgdmFsdWUgICAtIE5ldyBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKiBAcGFyYW0gIHttaXhlZH0gIHZhbHVlICAgLSBOZXcgYXR0cmlidXRlIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgLSBSZXR1cm5zIGl0c2VsZiBmb3IgY2hhaW5pbmcuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdG9vIG1hbnkgYXJndW1lbnRzIGFyZSBwcm92aWRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gJycgKyBuYW1lO1xuXG4gICAgICBuYW1lID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFsdWUgPSBhcmd1bWVudHNbM107XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBkYXRhLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdlZGdlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3NldCcsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggYW4gYXR0cmlidXRlIHVwZGF0ZXIgbWV0aG9kIG9udG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAgIC0gVHlwZSBvZiB0aGUgZWRnZSB0byBmaW5kLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlVXBkYXRlcihDbGFzcywgbWV0aG9kLCB0eXBlKSB7XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRlc2lyZWQgYXR0cmlidXRlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCAobm9kZSBvciBlZGdlKSB1c2luZ1xuICAgKiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgICBlbGVtZW50IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBuYW1lICAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IHVwZGF0ZXIgLSBVcGRhdGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBBcml0eSAzIChvbmx5IGZvciBlZGdlcyk6XG4gICAqIEBwYXJhbSAge2FueX0gICAgICBzb3VyY2UgIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgIC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBuYW1lICAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IHVwZGF0ZXIgLSBVcGRhdGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgICAtIFJldHVybnMgaXRzZWxmIGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSwgdXBkYXRlcikge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudDtcbiAgICAgIGNvbnN0IHRhcmdldCA9ICcnICsgbmFtZTtcblxuICAgICAgbmFtZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHVwZGF0ZXIgPSBhcmd1bWVudHNbM107XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHVwZGF0ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHVwZGF0ZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24uYFxuICAgICAgKTtcblxuICAgIGRhdGEuYXR0cmlidXRlc1tuYW1lXSA9IHVwZGF0ZXIoZGF0YS5hdHRyaWJ1dGVzW25hbWVdKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdlZGdlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3NldCcsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggYW4gYXR0cmlidXRlIHJlbW92ZXIgbWV0aG9kIG9udG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAgIC0gVHlwZSBvZiB0aGUgZWRnZSB0byBmaW5kLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlUmVtb3ZlcihDbGFzcywgbWV0aG9kLCB0eXBlKSB7XG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGRlc2lyZWQgYXR0cmlidXRlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCAobm9kZSBvciBlZGdlKS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICBlbGVtZW50IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgLSBSZXR1cm5zIGl0c2VsZiBmb3IgY2hhaW5pbmcuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdG9vIG1hbnkgYXJndW1lbnRzIGFyZSBwcm92aWRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHtcbiAgICBsZXQgZGF0YTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciAke3RoaXMudHlwZX0gZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuYFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSAnJyArIG5hbWU7XG5cbiAgICAgIG5hbWUgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBkZWxldGUgZGF0YS5hdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2VkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAncmVtb3ZlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGUgcmVwbGFjZXIgbWV0aG9kIG9udG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAgIC0gVHlwZSBvZiB0aGUgZWRnZSB0byBmaW5kLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlc1JlcGxhY2VyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIGVsZW1lbnQgICAgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gTmV3IGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlICAgICAtIFNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgICAgIC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIGF0dHJpYnV0ZXMgLSBOZXcgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgICAgICAtIFJldHVybnMgaXRzZWxmIGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudCxcbiAgICAgICAgdGFyZ2V0ID0gJycgKyBhdHRyaWJ1dGVzO1xuXG4gICAgICBhdHRyaWJ1dGVzID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICBkYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIiR7c291cmNlfVwiIC0gXCIke3RhcmdldH1cIikuYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ21peGVkJylcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuYFxuICAgICAgICApO1xuXG4gICAgICBlbGVtZW50ID0gJycgKyBlbGVtZW50O1xuICAgICAgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlbGVtZW50KTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWxlbWVudH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuYFxuICAgICAgKTtcblxuICAgIGRhdGEuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdyZXBsYWNlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZSBtZXJnZXIgbWV0aG9kIG9udG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAgIC0gVHlwZSBvZiB0aGUgZWRnZSB0byBmaW5kLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlc01lcmdlcihDbGFzcywgbWV0aG9kLCB0eXBlKSB7XG4gIC8qKlxuICAgKiBNZXJnZSB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgKG5vZGUgb3IgZWRnZSkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgZWxlbWVudCAgICAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzIHRvIG1lcmdlLlxuICAgKlxuICAgKiBBcml0eSAzIChvbmx5IGZvciBlZGdlcyk6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAgICAgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0ICAgICAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBhdHRyaWJ1dGVzIC0gQXR0cmlidXRlcyB0byBtZXJnZS5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgICAgICAtIFJldHVybnMgaXRzZWxmIGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudCxcbiAgICAgICAgdGFyZ2V0ID0gJycgKyBhdHRyaWJ1dGVzO1xuXG4gICAgICBhdHRyaWJ1dGVzID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICBkYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIiR7c291cmNlfVwiIC0gXCIke3RhcmdldH1cIikuYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ21peGVkJylcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuYFxuICAgICAgICApO1xuXG4gICAgICBlbGVtZW50ID0gJycgKyBlbGVtZW50O1xuICAgICAgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlbGVtZW50KTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWxlbWVudH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuYFxuICAgICAgKTtcblxuICAgIGFzc2lnbihkYXRhLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2VkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAnbWVyZ2UnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgZGF0YTogYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZSB1cGRhdGVyIG1ldGhvZCBvbnRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbWV0aG9kICAgICAgICAtIE1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgdHlwZSAgICAgICAgICAtIFR5cGUgb2YgdGhlIGVkZ2UgdG8gZmluZC5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYXR0cmlidXRlcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAobm9kZSBvciBlZGdlKS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIGVsZW1lbnQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IHVwZGF0ZXIgLSBVcGRhdGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBBcml0eSAzIChvbmx5IGZvciBlZGdlcyk6XG4gICAqIEBwYXJhbSAge2FueX0gICAgICBzb3VyY2UgIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgIC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSB1cGRhdGVyIC0gVXBkYXRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgICAgLSBSZXR1cm5zIGl0c2VsZiBmb3IgY2hhaW5pbmcuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdG9vIG1hbnkgYXJndW1lbnRzIGFyZSBwcm92aWRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQsIHVwZGF0ZXIpIHtcbiAgICBsZXQgZGF0YTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciAke3RoaXMudHlwZX0gZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuYFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGVsZW1lbnQsXG4gICAgICAgIHRhcmdldCA9ICcnICsgdXBkYXRlcjtcblxuICAgICAgdXBkYXRlciA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogcHJvdmlkZWQgdXBkYXRlciBpcyBub3QgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuXG4gICAgZGF0YS5hdHRyaWJ1dGVzID0gdXBkYXRlcihkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2VkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAndXBkYXRlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbi8qKlxuICogTGlzdCBvZiBtZXRob2RzIHRvIGF0dGFjaC5cbiAqL1xuY29uc3QgRURHRV9BVFRSSUJVVEVTX01FVEhPRFMgPSBbXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBnZXQke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZUdldHRlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgZ2V0JHtlbGVtZW50fUF0dHJpYnV0ZXNgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlc0dldHRlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgaGFzJHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVDaGVja2VyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBzZXQke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZVNldHRlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgdXBkYXRlJHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVVcGRhdGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGByZW1vdmUke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZVJlbW92ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHJlcGxhY2Uke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVzUmVwbGFjZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYG1lcmdlJHtlbGVtZW50fUF0dHJpYnV0ZXNgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlc01lcmdlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgdXBkYXRlJHtlbGVtZW50fUF0dHJpYnV0ZXNgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZXJcbiAgfVxuXTtcblxuLyoqXG4gKiBBdHRhY2ggZXZlcnkgYXR0cmlidXRlcy1yZWxhdGVkIG1ldGhvZHMgdG8gYSBHcmFwaCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBHcmFwaCAtIFRhcmdldCBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZXNNZXRob2RzKEdyYXBoKSB7XG4gIEVER0VfQVRUUklCVVRFU19NRVRIT0RTLmZvckVhY2goZnVuY3Rpb24gKHtuYW1lLCBhdHRhY2hlcn0pIHtcbiAgICAvLyBGb3IgZWRnZXNcbiAgICBhdHRhY2hlcihHcmFwaCwgbmFtZSgnRWRnZScpLCAnbWl4ZWQnKTtcblxuICAgIC8vIEZvciBkaXJlY3RlZCBlZGdlc1xuICAgIGF0dGFjaGVyKEdyYXBoLCBuYW1lKCdEaXJlY3RlZEVkZ2UnKSwgJ2RpcmVjdGVkJyk7XG5cbiAgICAvLyBGb3IgdW5kaXJlY3RlZCBlZGdlc1xuICAgIGF0dGFjaGVyKEdyYXBoLCBuYW1lKCdVbmRpcmVjdGVkRWRnZScpLCAndW5kaXJlY3RlZCcpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHcmFwaG9sb2d5IEVkZ2UgSXRlcmF0aW9uXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEF0dGFjaGluZyBzb21lIG1ldGhvZHMgdG8gdGhlIEdyYXBoIGNsYXNzIHRvIGJlIGFibGUgdG8gaXRlcmF0ZSBvdmVyIGFcbiAqIGdyYXBoJ3MgZWRnZXMuXG4gKi9cblxuLyoqXG4gKiBEZWZpbml0aW9ucy5cbiAqL1xuY29uc3QgRURHRVNfSVRFUkFUSU9OID0gW1xuICB7XG4gICAgbmFtZTogJ2VkZ2VzJyxcbiAgICB0eXBlOiAnbWl4ZWQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnaW5FZGdlcycsXG4gICAgdHlwZTogJ2RpcmVjdGVkJyxcbiAgICBkaXJlY3Rpb246ICdpbidcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdvdXRFZGdlcycsXG4gICAgdHlwZTogJ2RpcmVjdGVkJyxcbiAgICBkaXJlY3Rpb246ICdvdXQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnaW5ib3VuZEVkZ2VzJyxcbiAgICB0eXBlOiAnbWl4ZWQnLFxuICAgIGRpcmVjdGlvbjogJ2luJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ291dGJvdW5kRWRnZXMnLFxuICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgZGlyZWN0aW9uOiAnb3V0J1xuICB9LFxuICB7XG4gICAgbmFtZTogJ2RpcmVjdGVkRWRnZXMnLFxuICAgIHR5cGU6ICdkaXJlY3RlZCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICd1bmRpcmVjdGVkRWRnZXMnLFxuICAgIHR5cGU6ICd1bmRpcmVjdGVkJ1xuICB9XG5dO1xuXG4vKipcbiAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGVkZ2VzIGZyb20gdGhlIGdpdmVuIG9iamVjdCB0byBtYXRjaCBvbmUgb2YgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gICBvYmplY3QgICAtIFRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hTaW1wbGUoYnJlYWthYmxlLCBvYmplY3QsIGNhbGxiYWNrLCBhdm9pZCkge1xuICBsZXQgc2hvdWxkQnJlYWsgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IGsgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGsgPT09IGF2b2lkKSBjb250aW51ZTtcblxuICAgIGNvbnN0IGVkZ2VEYXRhID0gb2JqZWN0W2tdO1xuXG4gICAgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhcbiAgICAgIGVkZ2VEYXRhLmtleSxcbiAgICAgIGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBlZGdlRGF0YS5zb3VyY2Uua2V5LFxuICAgICAgZWRnZURhdGEudGFyZ2V0LmtleSxcbiAgICAgIGVkZ2VEYXRhLnNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgZWRnZURhdGEudGFyZ2V0LmF0dHJpYnV0ZXMsXG4gICAgICBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgKTtcblxuICAgIGlmIChicmVha2FibGUgJiYgc2hvdWxkQnJlYWspIHJldHVybiBlZGdlRGF0YS5rZXk7XG4gIH1cblxuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hNdWx0aShicmVha2FibGUsIG9iamVjdCwgY2FsbGJhY2ssIGF2b2lkKSB7XG4gIGxldCBlZGdlRGF0YSwgc291cmNlLCB0YXJnZXQ7XG5cbiAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG5cbiAgZm9yIChjb25zdCBrIGluIG9iamVjdCkge1xuICAgIGlmIChrID09PSBhdm9pZCkgY29udGludWU7XG5cbiAgICBlZGdlRGF0YSA9IG9iamVjdFtrXTtcblxuICAgIGRvIHtcbiAgICAgIHNvdXJjZSA9IGVkZ2VEYXRhLnNvdXJjZTtcbiAgICAgIHRhcmdldCA9IGVkZ2VEYXRhLnRhcmdldDtcblxuICAgICAgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhcbiAgICAgICAgZWRnZURhdGEua2V5LFxuICAgICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICBzb3VyY2Uua2V5LFxuICAgICAgICB0YXJnZXQua2V5LFxuICAgICAgICBzb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgICAgdGFyZ2V0LmF0dHJpYnV0ZXMsXG4gICAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICAgICk7XG5cbiAgICAgIGlmIChicmVha2FibGUgJiYgc2hvdWxkQnJlYWspIHJldHVybiBlZGdlRGF0YS5rZXk7XG5cbiAgICAgIGVkZ2VEYXRhID0gZWRnZURhdGEubmV4dDtcbiAgICB9IHdoaWxlIChlZGdlRGF0YSAhPT0gdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb3ZlciBlZGdlcyBmcm9tIHRoZSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgIG9iamVjdCAtIFRhcmdldCBvYmplY3QuXG4gKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3Iob2JqZWN0LCBhdm9pZCkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgY29uc3QgbCA9IGtleXMubGVuZ3RoO1xuXG4gIGxldCBlZGdlRGF0YTtcbiAgbGV0IGkgPSAwO1xuXG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG5leHQoKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICghZWRnZURhdGEpIHtcbiAgICAgICAgICBpZiAoaSA+PSBsKSByZXR1cm4ge2RvbmU6IHRydWV9O1xuXG4gICAgICAgICAgY29uc3QgayA9IGtleXNbaSsrXTtcblxuICAgICAgICAgIGlmIChrID09PSBhdm9pZCkge1xuICAgICAgICAgICAgZWRnZURhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlZGdlRGF0YSA9IG9iamVjdFtrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGdlRGF0YSA9IGVkZ2VEYXRhLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKCFlZGdlRGF0YSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGVkZ2U6IGVkZ2VEYXRhLmtleSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHNvdXJjZTogZWRnZURhdGEuc291cmNlLmtleSxcbiAgICAgICAgICB0YXJnZXQ6IGVkZ2VEYXRhLnRhcmdldC5rZXksXG4gICAgICAgICAgc291cmNlQXR0cmlidXRlczogZWRnZURhdGEuc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgdGFyZ2V0QXR0cmlidXRlczogZWRnZURhdGEudGFyZ2V0LmF0dHJpYnV0ZXMsXG4gICAgICAgICAgdW5kaXJlY3RlZDogZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciB0aGUgZWdkZXMgZnJvbSB0aGUgb2JqZWN0IGF0IGdpdmVuIGtleSB0byBtYXRjaFxuICogb25lIG9mIHRoZW0uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9ICAgb2JqZWN0ICAgLSBUYXJnZXQgb2JqZWN0LlxuICogQHBhcmFtIHttaXhlZH0gICAgayAgICAgICAgLSBOZWlnaGJvciBrZXkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEZvcktleVNpbXBsZShicmVha2FibGUsIG9iamVjdCwgaywgY2FsbGJhY2spIHtcbiAgY29uc3QgZWRnZURhdGEgPSBvYmplY3Rba107XG5cbiAgaWYgKCFlZGdlRGF0YSkgcmV0dXJuO1xuXG4gIGNvbnN0IHNvdXJjZURhdGEgPSBlZGdlRGF0YS5zb3VyY2U7XG4gIGNvbnN0IHRhcmdldERhdGEgPSBlZGdlRGF0YS50YXJnZXQ7XG5cbiAgaWYgKFxuICAgIGNhbGxiYWNrKFxuICAgICAgZWRnZURhdGEua2V5LFxuICAgICAgZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgIHNvdXJjZURhdGEua2V5LFxuICAgICAgdGFyZ2V0RGF0YS5rZXksXG4gICAgICBzb3VyY2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICB0YXJnZXREYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgKSAmJlxuICAgIGJyZWFrYWJsZVxuICApXG4gICAgcmV0dXJuIGVkZ2VEYXRhLmtleTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaEZvcktleU11bHRpKGJyZWFrYWJsZSwgb2JqZWN0LCBrLCBjYWxsYmFjaykge1xuICBsZXQgZWRnZURhdGEgPSBvYmplY3Rba107XG5cbiAgaWYgKCFlZGdlRGF0YSkgcmV0dXJuO1xuXG4gIGxldCBzaG91bGRCcmVhayA9IGZhbHNlO1xuXG4gIGRvIHtcbiAgICBzaG91bGRCcmVhayA9IGNhbGxiYWNrKFxuICAgICAgZWRnZURhdGEua2V5LFxuICAgICAgZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgIGVkZ2VEYXRhLnNvdXJjZS5rZXksXG4gICAgICBlZGdlRGF0YS50YXJnZXQua2V5LFxuICAgICAgZWRnZURhdGEuc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICBlZGdlRGF0YS50YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICApO1xuXG4gICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIGVkZ2VEYXRhLmtleTtcblxuICAgIGVkZ2VEYXRhID0gZWRnZURhdGEubmV4dDtcbiAgfSB3aGlsZSAoZWRnZURhdGEgIT09IHVuZGVmaW5lZCk7XG5cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBpdGVyYXRvciBvdmVyIHRoZSBlZ2RlcyBmcm9tIHRoZSBvYmplY3QgYXQgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gICBvYmplY3QgICAtIFRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0gIHttaXhlZH0gICAgayAgICAgICAgLSBOZWlnaGJvciBrZXkuXG4gKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3JGb3JLZXkob2JqZWN0LCBrKSB7XG4gIGxldCBlZGdlRGF0YSA9IG9iamVjdFtrXTtcblxuICBpZiAoZWRnZURhdGEubmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBpZiAoIWVkZ2VEYXRhKSByZXR1cm4ge2RvbmU6IHRydWV9O1xuXG4gICAgICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgICAgIGVkZ2U6IGVkZ2VEYXRhLmtleSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHNvdXJjZTogZWRnZURhdGEuc291cmNlLmtleSxcbiAgICAgICAgICB0YXJnZXQ6IGVkZ2VEYXRhLnRhcmdldC5rZXksXG4gICAgICAgICAgc291cmNlQXR0cmlidXRlczogZWRnZURhdGEuc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgdGFyZ2V0QXR0cmlidXRlczogZWRnZURhdGEudGFyZ2V0LmF0dHJpYnV0ZXMsXG4gICAgICAgICAgdW5kaXJlY3RlZDogZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICAgICB9O1xuXG4gICAgICAgIGVkZ2VEYXRhID0gZWRnZURhdGEubmV4dDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGxldCBkb25lID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG5leHQoKSB7XG4gICAgICBpZiAoZG9uZSA9PT0gdHJ1ZSkgcmV0dXJuIHtkb25lOiB0cnVlfTtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgZWRnZTogZWRnZURhdGEua2V5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgc291cmNlOiBlZGdlRGF0YS5zb3VyY2Uua2V5LFxuICAgICAgICAgIHRhcmdldDogZWRnZURhdGEudGFyZ2V0LmtleSxcbiAgICAgICAgICBzb3VyY2VBdHRyaWJ1dGVzOiBlZGdlRGF0YS5zb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgICAgICB0YXJnZXRBdHRyaWJ1dGVzOiBlZGdlRGF0YS50YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgICAgICB1bmRpcmVjdGVkOiBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGNyZWF0aW5nIGFuIGFycmF5IG9mIGVkZ2VzIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICBncmFwaCAtIFRhcmdldCBHcmFwaCBpbnN0YW5jZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gIHR5cGUgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIC0gQXJyYXkgb2YgZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VBcnJheShncmFwaCwgdHlwZSkge1xuICBpZiAoZ3JhcGguc2l6ZSA9PT0gMCkgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlID09PSAnbWl4ZWQnIHx8IHR5cGUgPT09IGdyYXBoLnR5cGUpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShncmFwaC5fZWRnZXMua2V5cygpKTtcbiAgfVxuXG4gIGNvbnN0IHNpemUgPVxuICAgIHR5cGUgPT09ICd1bmRpcmVjdGVkJyA/IGdyYXBoLnVuZGlyZWN0ZWRTaXplIDogZ3JhcGguZGlyZWN0ZWRTaXplO1xuXG4gIGNvbnN0IGxpc3QgPSBuZXcgQXJyYXkoc2l6ZSksXG4gICAgbWFzayA9IHR5cGUgPT09ICd1bmRpcmVjdGVkJztcblxuICBjb25zdCBpdGVyYXRvciA9IGdyYXBoLl9lZGdlcy52YWx1ZXMoKTtcblxuICBsZXQgaSA9IDA7XG4gIGxldCBzdGVwLCBkYXRhO1xuXG4gIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgZGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICBpZiAoZGF0YS51bmRpcmVjdGVkID09PSBtYXNrKSBsaXN0W2krK10gPSBkYXRhLmtleTtcbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGEgZ3JhcGgncyBlZGdlcyB1c2luZyBhIGNhbGxiYWNrIHRvIG1hdGNoIG9uZSBvZlxuICogdGhlbS5cbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICAgZ3JhcGggICAgLSBUYXJnZXQgR3JhcGggaW5zdGFuY2UuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEVkZ2UoYnJlYWthYmxlLCBncmFwaCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKGdyYXBoLnNpemUgPT09IDApIHJldHVybjtcblxuICBjb25zdCBzaG91bGRGaWx0ZXIgPSB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IGdyYXBoLnR5cGU7XG4gIGNvbnN0IG1hc2sgPSB0eXBlID09PSAndW5kaXJlY3RlZCc7XG5cbiAgbGV0IHN0ZXAsIGRhdGE7XG4gIGxldCBzaG91bGRCcmVhayA9IGZhbHNlO1xuICBjb25zdCBpdGVyYXRvciA9IGdyYXBoLl9lZGdlcy52YWx1ZXMoKTtcblxuICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgIGRhdGEgPSBzdGVwLnZhbHVlO1xuXG4gICAgaWYgKHNob3VsZEZpbHRlciAmJiBkYXRhLnVuZGlyZWN0ZWQgIT09IG1hc2spIGNvbnRpbnVlO1xuXG4gICAgY29uc3Qge2tleSwgYXR0cmlidXRlcywgc291cmNlLCB0YXJnZXR9ID0gZGF0YTtcblxuICAgIHNob3VsZEJyZWFrID0gY2FsbGJhY2soXG4gICAgICBrZXksXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgc291cmNlLmtleSxcbiAgICAgIHRhcmdldC5rZXksXG4gICAgICBzb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgIHRhcmdldC5hdHRyaWJ1dGVzLFxuICAgICAgZGF0YS51bmRpcmVjdGVkXG4gICAgKTtcblxuICAgIGlmIChicmVha2FibGUgJiYgc2hvdWxkQnJlYWspIHJldHVybiBrZXk7XG4gIH1cblxuICByZXR1cm47XG59XG5cbi8qKlxuICogRnVuY3Rpb24gY3JlYXRpbmcgYW4gaXRlcmF0b3Igb2YgZWRnZXMgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgICBncmFwaCAtIFRhcmdldCBHcmFwaCBpbnN0YW5jZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUl0ZXJhdG9yKGdyYXBoLCB0eXBlKSB7XG4gIGlmIChncmFwaC5zaXplID09PSAwKSByZXR1cm4gZW1wdHlJdGVyYXRvcigpO1xuXG4gIGNvbnN0IHNob3VsZEZpbHRlciA9IHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gZ3JhcGgudHlwZTtcbiAgY29uc3QgbWFzayA9IHR5cGUgPT09ICd1bmRpcmVjdGVkJztcblxuICBjb25zdCBpdGVyYXRvciA9IGdyYXBoLl9lZGdlcy52YWx1ZXMoKTtcblxuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgbGV0IHN0ZXAsIGRhdGE7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkgcmV0dXJuIHN0ZXA7XG5cbiAgICAgICAgZGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICAgICAgaWYgKHNob3VsZEZpbHRlciAmJiBkYXRhLnVuZGlyZWN0ZWQgIT09IG1hc2spIGNvbnRpbnVlO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgICAgZWRnZTogZGF0YS5rZXksXG4gICAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgc291cmNlOiBkYXRhLnNvdXJjZS5rZXksXG4gICAgICAgIHRhcmdldDogZGF0YS50YXJnZXQua2V5LFxuICAgICAgICBzb3VyY2VBdHRyaWJ1dGVzOiBkYXRhLnNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgICB0YXJnZXRBdHRyaWJ1dGVzOiBkYXRhLnRhcmdldC5hdHRyaWJ1dGVzLFxuICAgICAgICB1bmRpcmVjdGVkOiBkYXRhLnVuZGlyZWN0ZWRcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7dmFsdWUsIGRvbmU6IGZhbHNlfTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgYSBub2RlJ3MgZWRnZXMgdXNpbmcgYSBjYWxsYmFjayB0byBtYXRjaCBvbmUgb2YgdGhlbS5cbiAqXG4gKiBAcGFyYW0gIHtib29sZWFufSAgbXVsdGkgICAgIC0gV2hldGhlciB0aGUgZ3JhcGggaXMgbXVsdGkgb3Igbm90LlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgICAgICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgZGlyZWN0aW9uIC0gSW4gb3Igb3V0P1xuICogQHBhcmFtICB7YW55fSAgICAgIG5vZGVEYXRhICAtIFRhcmdldCBub2RlJ3MgZGF0YS5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAgLSBGdW5jdGlvbiB0byBjYWxsLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoRWRnZUZvck5vZGUoXG4gIGJyZWFrYWJsZSxcbiAgbXVsdGksXG4gIHR5cGUsXG4gIGRpcmVjdGlvbixcbiAgbm9kZURhdGEsXG4gIGNhbGxiYWNrXG4pIHtcbiAgY29uc3QgZm4gPSBtdWx0aSA/IGZvckVhY2hNdWx0aSA6IGZvckVhY2hTaW1wbGU7XG5cbiAgbGV0IGZvdW5kO1xuXG4gIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnb3V0Jykge1xuICAgICAgZm91bmQgPSBmbihicmVha2FibGUsIG5vZGVEYXRhLmluLCBjYWxsYmFjayk7XG5cbiAgICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ2luJykge1xuICAgICAgZm91bmQgPSBmbihcbiAgICAgICAgYnJlYWthYmxlLFxuICAgICAgICBub2RlRGF0YS5vdXQsXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAhZGlyZWN0aW9uID8gbm9kZURhdGEua2V5IDogdW5kZWZpbmVkXG4gICAgICApO1xuXG4gICAgICBpZiAoYnJlYWthYmxlICYmIGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICBmb3VuZCA9IGZuKGJyZWFrYWJsZSwgbm9kZURhdGEudW5kaXJlY3RlZCwgY2FsbGJhY2spO1xuXG4gICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICB9XG5cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGNyZWF0aW5nIGFuIGFycmF5IG9mIGVkZ2VzIGZvciB0aGUgZ2l2ZW4gdHlwZSAmIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSAge2Jvb2xlYW59IG11bHRpICAgICAtIFdoZXRoZXIgdGhlIGdyYXBoIGlzIG11bHRpIG9yIG5vdC5cbiAqIEBwYXJhbSAge3N0cmluZ30gIHR5cGUgICAgICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBkaXJlY3Rpb24gLSBJbiBvciBvdXQ/XG4gKiBAcGFyYW0gIHthbnl9ICAgICBub2RlRGF0YSAgLSBUYXJnZXQgbm9kZSdzIGRhdGEuXG4gKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgLSBBcnJheSBvZiBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUFycmF5Rm9yTm9kZShtdWx0aSwgdHlwZSwgZGlyZWN0aW9uLCBub2RlRGF0YSkge1xuICBjb25zdCBlZGdlcyA9IFtdOyAvLyBUT0RPOiBwb3NzaWJpbGl0eSB0byBrbm93IHNpemUgYmVmb3JlaGFuZCBvciBmYWN0b3JpemUgd2l0aCBtYXBcblxuICBmb3JFYWNoRWRnZUZvck5vZGUoZmFsc2UsIG11bHRpLCB0eXBlLCBkaXJlY3Rpb24sIG5vZGVEYXRhLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZWRnZXMucHVzaChrZXkpO1xuICB9KTtcblxuICByZXR1cm4gZWRnZXM7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgYSBub2RlJ3MgZWRnZXMgdXNpbmcgYSBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICBkaXJlY3Rpb24gLSBJbiBvciBvdXQ/XG4gKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZURhdGEgIC0gVGFyZ2V0IG5vZGUncyBkYXRhLlxuICogQHJldHVybiB7SXRlcmF0b3J9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VJdGVyYXRvckZvck5vZGUodHlwZSwgZGlyZWN0aW9uLCBub2RlRGF0YSkge1xuICBsZXQgaXRlcmF0b3IgPSBlbXB0eUl0ZXJhdG9yKCk7XG5cbiAgaWYgKHR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgIGlmIChkaXJlY3Rpb24gIT09ICdvdXQnICYmIHR5cGVvZiBub2RlRGF0YS5pbiAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICBpdGVyYXRvciA9IGNoYWluKGl0ZXJhdG9yLCBjcmVhdGVJdGVyYXRvcihub2RlRGF0YS5pbikpO1xuICAgIGlmIChkaXJlY3Rpb24gIT09ICdpbicgJiYgdHlwZW9mIG5vZGVEYXRhLm91dCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICBpdGVyYXRvciA9IGNoYWluKFxuICAgICAgICBpdGVyYXRvcixcbiAgICAgICAgY3JlYXRlSXRlcmF0b3Iobm9kZURhdGEub3V0LCAhZGlyZWN0aW9uID8gbm9kZURhdGEua2V5IDogdW5kZWZpbmVkKVxuICAgICAgKTtcbiAgfVxuXG4gIGlmICh0eXBlICE9PSAnZGlyZWN0ZWQnICYmIHR5cGVvZiBub2RlRGF0YS51bmRpcmVjdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgIGl0ZXJhdG9yID0gY2hhaW4oaXRlcmF0b3IsIGNyZWF0ZUl0ZXJhdG9yKG5vZGVEYXRhLnVuZGlyZWN0ZWQpKTtcbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvcjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBlZGdlcyBmb3IgdGhlIGdpdmVuIHBhdGggdXNpbmcgYSBjYWxsYmFjayB0byBtYXRjaFxuICogb25lIG9mIHRoZW0uXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgICAgICAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gIG11bHRpICAgICAgLSBXaGV0aGVyIHRoZSBncmFwaCBpcyBtdWx0aS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICBkaXJlY3Rpb24gIC0gSW4gb3Igb3V0P1xuICogQHBhcmFtICB7Tm9kZURhdGF9IHNvdXJjZURhdGEgLSBTb3VyY2Ugbm9kZSdzIGRhdGEuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdGFyZ2V0ICAgICAtIFRhcmdldCBub2RlLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrICAgLSBGdW5jdGlvbiB0byBjYWxsLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoRWRnZUZvclBhdGgoXG4gIGJyZWFrYWJsZSxcbiAgdHlwZSxcbiAgbXVsdGksXG4gIGRpcmVjdGlvbixcbiAgc291cmNlRGF0YSxcbiAgdGFyZ2V0LFxuICBjYWxsYmFja1xuKSB7XG4gIGNvbnN0IGZuID0gbXVsdGkgPyBmb3JFYWNoRm9yS2V5TXVsdGkgOiBmb3JFYWNoRm9yS2V5U2ltcGxlO1xuXG4gIGxldCBmb3VuZDtcblxuICBpZiAodHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VEYXRhLmluICE9PSAndW5kZWZpbmVkJyAmJiBkaXJlY3Rpb24gIT09ICdvdXQnKSB7XG4gICAgICBmb3VuZCA9IGZuKGJyZWFrYWJsZSwgc291cmNlRGF0YS5pbiwgdGFyZ2V0LCBjYWxsYmFjayk7XG5cbiAgICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygc291cmNlRGF0YS5vdXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBkaXJlY3Rpb24gIT09ICdpbicgJiZcbiAgICAgIChkaXJlY3Rpb24gfHwgc291cmNlRGF0YS5rZXkgIT09IHRhcmdldClcbiAgICApIHtcbiAgICAgIGZvdW5kID0gZm4oYnJlYWthYmxlLCBzb3VyY2VEYXRhLm91dCwgdGFyZ2V0LCBjYWxsYmFjayk7XG5cbiAgICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlRGF0YS51bmRpcmVjdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZm91bmQgPSBmbihicmVha2FibGUsIHNvdXJjZURhdGEudW5kaXJlY3RlZCwgdGFyZ2V0LCBjYWxsYmFjayk7XG5cbiAgICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm47XG59XG5cbi8qKlxuICogRnVuY3Rpb24gY3JlYXRpbmcgYW4gYXJyYXkgb2YgZWRnZXMgZm9yIHRoZSBnaXZlbiBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlICAgICAgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSAge2Jvb2xlYW59ICBtdWx0aSAgICAgIC0gV2hldGhlciB0aGUgZ3JhcGggaXMgbXVsdGkuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgZGlyZWN0aW9uICAtIEluIG9yIG91dD9cbiAqIEBwYXJhbSAge05vZGVEYXRhfSBzb3VyY2VEYXRhIC0gU291cmNlIG5vZGUncyBkYXRhLlxuICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgICAgLSBUYXJnZXQgbm9kZS5cbiAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIC0gQXJyYXkgb2YgZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VBcnJheUZvclBhdGgodHlwZSwgbXVsdGksIGRpcmVjdGlvbiwgc291cmNlRGF0YSwgdGFyZ2V0KSB7XG4gIGNvbnN0IGVkZ2VzID0gW107IC8vIFRPRE86IHBvc3NpYmlsaXR5IHRvIGtub3cgc2l6ZSBiZWZvcmVoYW5kIG9yIGZhY3Rvcml6ZSB3aXRoIG1hcFxuXG4gIGZvckVhY2hFZGdlRm9yUGF0aChcbiAgICBmYWxzZSxcbiAgICB0eXBlLFxuICAgIG11bHRpLFxuICAgIGRpcmVjdGlvbixcbiAgICBzb3VyY2VEYXRhLFxuICAgIHRhcmdldCxcbiAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBlZGdlcy5wdXNoKGtleSk7XG4gICAgfVxuICApO1xuXG4gIHJldHVybiBlZGdlcztcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb3ZlciBlZGdlcyBmb3IgdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgICAgICAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGRpcmVjdGlvbiAgLSBJbiBvciBvdXQ/XG4gKiBAcGFyYW0gIHtOb2RlRGF0YX0gc291cmNlRGF0YSAtIFNvdXJjZSBub2RlJ3MgZGF0YS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICB0YXJnZXQgICAgIC0gVGFyZ2V0IG5vZGUuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgICAtIEZ1bmN0aW9uIHRvIGNhbGwuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VJdGVyYXRvckZvclBhdGgodHlwZSwgZGlyZWN0aW9uLCBzb3VyY2VEYXRhLCB0YXJnZXQpIHtcbiAgbGV0IGl0ZXJhdG9yID0gZW1wdHlJdGVyYXRvcigpO1xuXG4gIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygc291cmNlRGF0YS5pbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGRpcmVjdGlvbiAhPT0gJ291dCcgJiZcbiAgICAgIHRhcmdldCBpbiBzb3VyY2VEYXRhLmluXG4gICAgKVxuICAgICAgaXRlcmF0b3IgPSBjaGFpbihpdGVyYXRvciwgY3JlYXRlSXRlcmF0b3JGb3JLZXkoc291cmNlRGF0YS5pbiwgdGFyZ2V0KSk7XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygc291cmNlRGF0YS5vdXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBkaXJlY3Rpb24gIT09ICdpbicgJiZcbiAgICAgIHRhcmdldCBpbiBzb3VyY2VEYXRhLm91dCAmJlxuICAgICAgKGRpcmVjdGlvbiB8fCBzb3VyY2VEYXRhLmtleSAhPT0gdGFyZ2V0KVxuICAgIClcbiAgICAgIGl0ZXJhdG9yID0gY2hhaW4oaXRlcmF0b3IsIGNyZWF0ZUl0ZXJhdG9yRm9yS2V5KHNvdXJjZURhdGEub3V0LCB0YXJnZXQpKTtcbiAgfVxuXG4gIGlmICh0eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHNvdXJjZURhdGEudW5kaXJlY3RlZCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHRhcmdldCBpbiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRcbiAgICApXG4gICAgICBpdGVyYXRvciA9IGNoYWluKFxuICAgICAgICBpdGVyYXRvcixcbiAgICAgICAgY3JlYXRlSXRlcmF0b3JGb3JLZXkoc291cmNlRGF0YS51bmRpcmVjdGVkLCB0YXJnZXQpXG4gICAgICApO1xuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGFjaGluZyBhbiBlZGdlIGFycmF5IGNyZWF0b3IgbWV0aG9kIHRvIHRoZSBHcmFwaCBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUFycmF5Q3JlYXRvcihDbGFzcywgZGVzY3JpcHRpb24pIHtcbiAgY29uc3Qge25hbWUsIHR5cGUsIGRpcmVjdGlvbn0gPSBkZXNjcmlwdGlvbjtcblxuICAvKipcbiAgICogRnVuY3Rpb24gcmV0dXJuaW5nIGFuIGFycmF5IG9mIGNlcnRhaW4gZWRnZXMuXG4gICAqXG4gICAqIEFyaXR5IDA6IFJldHVybiBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKlxuICAgKiBBcml0eSAxOiBSZXR1cm4gYWxsIG9mIGEgbm9kZSdzIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgbm9kZSAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqXG4gICAqIEFyaXR5IDI6IFJldHVybiB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgc291cmNlIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICB0YXJnZXQgLSBUYXJnZXQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7YXJyYXl8bnVtYmVyfSAtIFRoZSBlZGdlcyBvciB0aGUgbnVtYmVyIG9mIGVkZ2VzLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoc291cmNlLCB0YXJnZXQpIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICByZXR1cm4gW107XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjcmVhdGVFZGdlQXJyYXkodGhpcywgdHlwZSk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG5cbiAgICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICh0eXBlb2Ygbm9kZURhdGEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke25hbWV9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIGEgbm9kZSdzIGVkZ2VzXG4gICAgICByZXR1cm4gY3JlYXRlRWRnZUFycmF5Rm9yTm9kZShcbiAgICAgICAgdGhpcy5tdWx0aSxcbiAgICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgbm9kZURhdGFcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICAgIGNvbnN0IHNvdXJjZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKCFzb3VyY2VEYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke25hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgaWYgKCF0aGlzLl9ub2Rlcy5oYXModGFyZ2V0KSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtuYW1lfTogIGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7dGFyZ2V0fVwiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIHRoZSBlZGdlcyBiZXR3ZWVuIHNvdXJjZSAmIHRhcmdldFxuICAgICAgcmV0dXJuIGNyZWF0ZUVkZ2VBcnJheUZvclBhdGgoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRoaXMubXVsdGksXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgc291cmNlRGF0YSxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiB0b28gbWFueSBhcmd1bWVudHMgKGV4cGVjdGluZyAwLCAxIG9yIDIgYW5kIGdvdCAke2FyZ3VtZW50cy5sZW5ndGh9KS5gXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYSBlZGdlIGNhbGxiYWNrIGl0ZXJhdG9yIG1ldGhvZCB0byB0aGUgR3JhcGggcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtvYmplY3R9ICAgZGVzY3JpcHRpb24gLSBNZXRob2QgZGVzY3JpcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEZvckVhY2hFZGdlKENsYXNzLCBkZXNjcmlwdGlvbikge1xuICBjb25zdCB7bmFtZSwgdHlwZSwgZGlyZWN0aW9ufSA9IGRlc2NyaXB0aW9uO1xuXG4gIGNvbnN0IGZvckVhY2hOYW1lID0gJ2ZvckVhY2gnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxLCAtMSk7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIGJ5IGFwcGx5aW5nIHRoZSBnaXZlblxuICAgKiBjYWxsYmFjay5cbiAgICpcbiAgICogQXJpdHkgMTogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMjogSXRlcmF0ZSBvdmVyIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMzogSXRlcmF0ZSBvdmVyIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBzb3VyY2UgICAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVtmb3JFYWNoTmFtZV0gPSBmdW5jdGlvbiAoc291cmNlLCB0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodHlwZSAhPT0gJ21peGVkJyAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKSByZXR1cm47XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY2FsbGJhY2sgPSBzb3VyY2U7XG4gICAgICByZXR1cm4gZm9yRWFjaEVkZ2UoZmFsc2UsIHRoaXMsIHR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICBjYWxsYmFjayA9IHRhcmdldDtcblxuICAgICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlRGF0YSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7Zm9yRWFjaE5hbWV9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIGEgbm9kZSdzIGVkZ2VzXG4gICAgICAvLyBUT0RPOiBtYXliZSBhdHRhY2ggdGhlIHN1YiBtZXRob2QgdG8gdGhlIGluc3RhbmNlIGR5bmFtaWNhbGx5P1xuICAgICAgcmV0dXJuIGZvckVhY2hFZGdlRm9yTm9kZShcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMubXVsdGksXG4gICAgICAgIHR5cGUgPT09ICdtaXhlZCcgPyB0aGlzLnR5cGUgOiB0eXBlLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIG5vZGVEYXRhLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZURhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7Zm9yRWFjaE5hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgaWYgKCF0aGlzLl9ub2Rlcy5oYXModGFyZ2V0KSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtmb3JFYWNoTmFtZX06ICBjb3VsZCBub3QgZmluZCB0aGUgXCIke3RhcmdldH1cIiB0YXJnZXQgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciB0aGUgZWRnZXMgYmV0d2VlbiBzb3VyY2UgJiB0YXJnZXRcbiAgICAgIHJldHVybiBmb3JFYWNoRWRnZUZvclBhdGgoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGlzLm11bHRpLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHNvdXJjZURhdGEsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7Zm9yRWFjaE5hbWV9OiB0b28gbWFueSBhcmd1bWVudHMgKGV4cGVjdGluZyAxLCAyIG9yIDMgYW5kIGdvdCAke2FyZ3VtZW50cy5sZW5ndGh9KS5gXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gbWFwcGluZyB0aGUgZ3JhcGgncyByZWxldmFudCBlZGdlcyBieSBhcHBseWluZyB0aGUgZ2l2ZW5cbiAgICogY2FsbGJhY2suXG4gICAqXG4gICAqIEFyaXR5IDE6IE1hcCBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDI6IE1hcCBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDM6IE1hcCB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBtYXBOYW1lID0gJ21hcCcgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVttYXBOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG5cbiAgICBsZXQgcmVzdWx0O1xuXG4gICAgLy8gV2Uga25vdyB0aGUgcmVzdWx0IGxlbmd0aCBiZWZvcmVoYW5kXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgaWYgKHR5cGUgIT09ICdkaXJlY3RlZCcpIGxlbmd0aCArPSB0aGlzLnVuZGlyZWN0ZWRTaXplO1xuICAgICAgaWYgKHR5cGUgIT09ICd1bmRpcmVjdGVkJykgbGVuZ3RoICs9IHRoaXMuZGlyZWN0ZWRTaXplO1xuXG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICBhcmdzLnB1c2goKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpID0+IHtcbiAgICAgICAgcmVzdWx0W2krK10gPSBjYWxsYmFjayhlLCBlYSwgcywgdCwgc2EsIHRhLCB1KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFdlIGRvbid0IGtub3cgdGhlIHJlc3VsdCBsZW5ndGggYmVmb3JlaGFuZFxuICAgIC8vIFRPRE86IHdlIGNhbiBpbiBzb21lIGluc3RhbmNlcyBvZiBzaW1wbGUgZ3JhcGhzLCBrbm93aW5nIGRlZ3JlZVxuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGFyZ3MucHVzaCgoZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkgPT4ge1xuICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjayhlLCBlYSwgcywgdCwgc2EsIHRhLCB1KSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzW2ZvckVhY2hOYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGZpbHRlcmluZyB0aGUgZ3JhcGgncyByZWxldmFudCBlZGdlcyB1c2luZyB0aGUgcHJvdmlkZWQgcHJlZGljYXRlXG4gICAqIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBBcml0eSAxOiBGaWx0ZXIgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIFByZWRpY2F0ZSB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDI6IEZpbHRlciBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIFByZWRpY2F0ZSB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDM6IEZpbHRlciB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAgIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIFByZWRpY2F0ZSB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3QgZmlsdGVyTmFtZSA9ICdmaWx0ZXInICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcblxuICBDbGFzcy5wcm90b3R5cGVbZmlsdGVyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICBhcmdzLnB1c2goKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpID0+IHtcbiAgICAgIGlmIChjYWxsYmFjayhlLCBlYSwgcywgdCwgc2EsIHRhLCB1KSkgcmVzdWx0LnB1c2goZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzW2ZvckVhY2hOYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHJlZHVjaW5nIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIHVzaW5nIHRoZSBwcm92aWRlZCBhY2N1bXVsYXRvclxuICAgKiBmdW5jdGlvbi5cbiAgICpcbiAgICogQXJpdHkgMTogUmVkdWNlIGFsbCB0aGUgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBhY2N1bXVsYXRvciAgLSBBY2N1bXVsYXRvciB0byB1c2UuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBpbml0aWFsVmFsdWUgLSBJbml0aWFsIHZhbHVlLlxuICAgKlxuICAgKiBBcml0eSAyOiBSZWR1Y2UgYWxsIG9mIGEgbm9kZSdzIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBhY2N1bXVsYXRvciAgLSBBY2N1bXVsYXRvciB0byB1c2UuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBpbml0aWFsVmFsdWUgLSBJbml0aWFsIHZhbHVlLlxuICAgKlxuICAgKiBBcml0eSAzOiBSZWR1Y2UgdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgICAgICAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBhY2N1bXVsYXRvciAgLSBBY2N1bXVsYXRvciB0byB1c2UuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBpbml0aWFsVmFsdWUgLSBJbml0aWFsIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IHJlZHVjZU5hbWUgPSAncmVkdWNlJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG5cbiAgQ2xhc3MucHJvdG90eXBlW3JlZHVjZU5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGlmIChhcmdzLmxlbmd0aCA8IDIgfHwgYXJncy5sZW5ndGggPiA0KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke3JlZHVjZU5hbWV9OiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKGV4cGVjdGluZyAyLCAzIG9yIDQgYW5kIGdvdCAke2FyZ3MubGVuZ3RofSkuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDJdICE9PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke3JlZHVjZU5hbWV9OiBtaXNzaW5nIGluaXRpYWwgdmFsdWUuIFlvdSBtdXN0IHByb3ZpZGUgaXQgYmVjYXVzZSB0aGUgY2FsbGJhY2sgdGFrZXMgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBhbmQgd2UgY2Fubm90IGluZmVyIHRoZSBpbml0aWFsIHZhbHVlIGZyb20gdGhlIGZpcnN0IGl0ZXJhdGlvbiwgYXMgeW91IGNvdWxkIHdpdGggYSBzaW1wbGUgYXJyYXkuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgY2FsbGJhY2s7XG4gICAgbGV0IGluaXRpYWxWYWx1ZTtcblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgY2FsbGJhY2sgPSBhcmdzWzBdO1xuICAgICAgaW5pdGlhbFZhbHVlID0gYXJnc1sxXTtcbiAgICAgIGFyZ3MgPSBbXTtcbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICBjYWxsYmFjayA9IGFyZ3NbMV07XG4gICAgICBpbml0aWFsVmFsdWUgPSBhcmdzWzJdO1xuICAgICAgYXJncyA9IFthcmdzWzBdXTtcbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICBjYWxsYmFjayA9IGFyZ3NbMl07XG4gICAgICBpbml0aWFsVmFsdWUgPSBhcmdzWzNdO1xuICAgICAgYXJncyA9IFthcmdzWzBdLCBhcmdzWzFdXTtcbiAgICB9XG5cbiAgICBsZXQgYWNjdW11bGF0b3IgPSBpbml0aWFsVmFsdWU7XG5cbiAgICBhcmdzLnB1c2goKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpID0+IHtcbiAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpO1xuICAgIH0pO1xuXG4gICAgdGhpc1tmb3JFYWNoTmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGEgYnJlYWthYmxlIGVkZ2UgY2FsbGJhY2sgaXRlcmF0b3IgbWV0aG9kIHRvIHRoZSBHcmFwaFxuICogcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtvYmplY3R9ICAgZGVzY3JpcHRpb24gLSBNZXRob2QgZGVzY3JpcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEZpbmRFZGdlKENsYXNzLCBkZXNjcmlwdGlvbikge1xuICBjb25zdCB7bmFtZSwgdHlwZSwgZGlyZWN0aW9ufSA9IGRlc2NyaXB0aW9uO1xuXG4gIGNvbnN0IGZpbmRFZGdlTmFtZSA9ICdmaW5kJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSwgLTEpO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciB0aGUgZ3JhcGgncyByZWxldmFudCBlZGdlcyBpbiBvcmRlciB0byBtYXRjaFxuICAgKiBvbmUgb2YgdGhlbSB1c2luZyB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBBcml0eSAxOiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAyOiBJdGVyYXRlIG92ZXIgYWxsIG9mIGEgbm9kZSdzIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAzOiBJdGVyYXRlIG92ZXIgdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW2ZpbmRFZGdlTmFtZV0gPSBmdW5jdGlvbiAoc291cmNlLCB0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodHlwZSAhPT0gJ21peGVkJyAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNhbGxiYWNrID0gc291cmNlO1xuICAgICAgcmV0dXJuIGZvckVhY2hFZGdlKHRydWUsIHRoaXMsIHR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICBjYWxsYmFjayA9IHRhcmdldDtcblxuICAgICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlRGF0YSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7ZmluZEVkZ2VOYW1lfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciBhIG5vZGUncyBlZGdlc1xuICAgICAgLy8gVE9ETzogbWF5YmUgYXR0YWNoIHRoZSBzdWIgbWV0aG9kIHRvIHRoZSBpbnN0YW5jZSBkeW5hbWljYWxseT9cbiAgICAgIHJldHVybiBmb3JFYWNoRWRnZUZvck5vZGUoXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRoaXMubXVsdGksXG4gICAgICAgIHR5cGUgPT09ICdtaXhlZCcgPyB0aGlzLnR5cGUgOiB0eXBlLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIG5vZGVEYXRhLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZURhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7ZmluZEVkZ2VOYW1lfTogIGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIGlmICghdGhpcy5fbm9kZXMuaGFzKHRhcmdldCkpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7ZmluZEVkZ2VOYW1lfTogIGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7dGFyZ2V0fVwiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIHRoZSBlZGdlcyBiZXR3ZWVuIHNvdXJjZSAmIHRhcmdldFxuICAgICAgcmV0dXJuIGZvckVhY2hFZGdlRm9yUGF0aChcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy5tdWx0aSxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBzb3VyY2VEYXRhLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke2ZpbmRFZGdlTmFtZX06IHRvbyBtYW55IGFyZ3VtZW50cyAoZXhwZWN0aW5nIDEsIDIgb3IgMyBhbmQgZ290ICR7YXJndW1lbnRzLmxlbmd0aH0pLmBcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciB0aGUgZ3JhcGgncyByZWxldmFudCBlZGdlcyBpbiBvcmRlciB0byBhc3NlcnRcbiAgICogd2hldGhlciBhbnkgb25lIG9mIHRoZW0gbWF0Y2hlcyB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBBcml0eSAxOiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAyOiBJdGVyYXRlIG92ZXIgYWxsIG9mIGEgbm9kZSdzIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAzOiBJdGVyYXRlIG92ZXIgdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3Qgc29tZU5hbWUgPSAnc29tZScgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEsIC0xKTtcblxuICBDbGFzcy5wcm90b3R5cGVbc29tZU5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcblxuICAgIGFyZ3MucHVzaCgoZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZm91bmQgPSB0aGlzW2ZpbmRFZGdlTmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICBpZiAoZm91bmQpIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciB0aGUgZ3JhcGgncyByZWxldmFudCBlZGdlcyBpbiBvcmRlciB0byBhc3NlcnRcbiAgICogd2hldGhlciBhbGwgb2YgdGhlbSBtYXRjaGUgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQXJpdHkgMTogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMjogSXRlcmF0ZSBvdmVyIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMzogSXRlcmF0ZSBvdmVyIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBzb3VyY2UgICAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IGV2ZXJ5TmFtZSA9ICdldmVyeScgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEsIC0xKTtcblxuICBDbGFzcy5wcm90b3R5cGVbZXZlcnlOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG5cbiAgICBhcmdzLnB1c2goKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpID0+IHtcbiAgICAgIHJldHVybiAhY2FsbGJhY2soZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBmb3VuZCA9IHRoaXNbZmluZEVkZ2VOYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIGlmIChmb3VuZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGFuIGVkZ2UgaXRlcmF0b3IgbWV0aG9kIHRvIHRoZSBHcmFwaCBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUl0ZXJhdG9yQ3JlYXRvcihDbGFzcywgZGVzY3JpcHRpb24pIHtcbiAgY29uc3Qge25hbWU6IG9yaWdpbmFsTmFtZSwgdHlwZSwgZGlyZWN0aW9ufSA9IGRlc2NyaXB0aW9uO1xuXG4gIGNvbnN0IG5hbWUgPSBvcmlnaW5hbE5hbWUuc2xpY2UoMCwgLTEpICsgJ0VudHJpZXMnO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb3ZlciB0aGUgZ3JhcGgncyBlZGdlcy5cbiAgICpcbiAgICogQXJpdHkgMDogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgZWRnZXMuXG4gICAqXG4gICAqIEFyaXR5IDE6IEl0ZXJhdGUgb3ZlciBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICBub2RlICAgLSBUYXJnZXQgbm9kZS5cbiAgICpcbiAgICogQXJpdHkgMjogSXRlcmF0ZSBvdmVyIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICBzb3VyY2UgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgIHRhcmdldCAtIFRhcmdldCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHthcnJheXxudW1iZXJ9IC0gVGhlIGVkZ2VzIG9yIHRoZSBudW1iZXIgb2YgZWRnZXMuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRhcmdldCkge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHR5cGUgIT09ICdtaXhlZCcgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHJldHVybiBlbXB0eUl0ZXJhdG9yKCk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjcmVhdGVFZGdlSXRlcmF0b3IodGhpcywgdHlwZSk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG5cbiAgICAgIGNvbnN0IHNvdXJjZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKCFzb3VyY2VEYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke25hbWV9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIGEgbm9kZSdzIGVkZ2VzXG4gICAgICByZXR1cm4gY3JlYXRlRWRnZUl0ZXJhdG9yRm9yTm9kZSh0eXBlLCBkaXJlY3Rpb24sIHNvdXJjZURhdGEpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICghc291cmNlRGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtuYW1lfTogIGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIGlmICghdGhpcy5fbm9kZXMuaGFzKHRhcmdldCkpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bmFtZX06ICBjb3VsZCBub3QgZmluZCB0aGUgXCIke3RhcmdldH1cIiB0YXJnZXQgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciB0aGUgZWRnZXMgYmV0d2VlbiBzb3VyY2UgJiB0YXJnZXRcbiAgICAgIHJldHVybiBjcmVhdGVFZGdlSXRlcmF0b3JGb3JQYXRoKHR5cGUsIGRpcmVjdGlvbiwgc291cmNlRGF0YSwgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogdG9vIG1hbnkgYXJndW1lbnRzIChleHBlY3RpbmcgMCwgMSBvciAyIGFuZCBnb3QgJHthcmd1bWVudHMubGVuZ3RofSkuYFxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGV2ZXJ5IGVkZ2UgaXRlcmF0aW9uIG1ldGhvZCB0byB0aGUgR3JhcGggY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gR3JhcGggLSBHcmFwaCBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUl0ZXJhdGlvbk1ldGhvZHMoR3JhcGgpIHtcbiAgRURHRVNfSVRFUkFUSU9OLmZvckVhY2goZGVzY3JpcHRpb24gPT4ge1xuICAgIGF0dGFjaEVkZ2VBcnJheUNyZWF0b3IoR3JhcGgsIGRlc2NyaXB0aW9uKTtcbiAgICBhdHRhY2hGb3JFYWNoRWRnZShHcmFwaCwgZGVzY3JpcHRpb24pO1xuICAgIGF0dGFjaEZpbmRFZGdlKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gICAgYXR0YWNoRWRnZUl0ZXJhdG9yQ3JlYXRvcihHcmFwaCwgZGVzY3JpcHRpb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHcmFwaG9sb2d5IE5laWdoYm9yIEl0ZXJhdGlvblxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQXR0YWNoaW5nIHNvbWUgbWV0aG9kcyB0byB0aGUgR3JhcGggY2xhc3MgdG8gYmUgYWJsZSB0byBpdGVyYXRlIG92ZXJcbiAqIG5laWdoYm9ycy5cbiAqL1xuXG4vKipcbiAqIERlZmluaXRpb25zLlxuICovXG5jb25zdCBORUlHSEJPUlNfSVRFUkFUSU9OID0gW1xuICB7XG4gICAgbmFtZTogJ25laWdoYm9ycycsXG4gICAgdHlwZTogJ21peGVkJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ2luTmVpZ2hib3JzJyxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnLFxuICAgIGRpcmVjdGlvbjogJ2luJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ291dE5laWdoYm9ycycsXG4gICAgdHlwZTogJ2RpcmVjdGVkJyxcbiAgICBkaXJlY3Rpb246ICdvdXQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnaW5ib3VuZE5laWdoYm9ycycsXG4gICAgdHlwZTogJ21peGVkJyxcbiAgICBkaXJlY3Rpb246ICdpbidcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdvdXRib3VuZE5laWdoYm9ycycsXG4gICAgdHlwZTogJ21peGVkJyxcbiAgICBkaXJlY3Rpb246ICdvdXQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnZGlyZWN0ZWROZWlnaGJvcnMnLFxuICAgIHR5cGU6ICdkaXJlY3RlZCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICd1bmRpcmVjdGVkTmVpZ2hib3JzJyxcbiAgICB0eXBlOiAndW5kaXJlY3RlZCdcbiAgfVxuXTtcblxuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5mdW5jdGlvbiBDb21wb3NpdGVTZXRXcmFwcGVyKCkge1xuICB0aGlzLkEgPSBudWxsO1xuICB0aGlzLkIgPSBudWxsO1xufVxuXG5Db21wb3NpdGVTZXRXcmFwcGVyLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHNldCkge1xuICBpZiAodGhpcy5BID09PSBudWxsKSB0aGlzLkEgPSBzZXQ7XG4gIGVsc2UgaWYgKHRoaXMuQiA9PT0gbnVsbCkgdGhpcy5CID0gc2V0O1xufTtcblxuQ29tcG9zaXRlU2V0V3JhcHBlci5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAodGhpcy5BICE9PSBudWxsICYmIGtleSBpbiB0aGlzLkEpIHJldHVybiB0cnVlO1xuICBpZiAodGhpcy5CICE9PSBudWxsICYmIGtleSBpbiB0aGlzLkIpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIHRoZSBnaXZlbiBub2RlJ3MgcmVsZXZhbnQgbmVpZ2hib3JzIHRvIG1hdGNoXG4gKiBvbmUgb2YgdGhlbSB1c2luZyBhIHByZWRpY2F0ZWQgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgICAgICAtIFR5cGUgb2YgbmVpZ2hib3JzLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGRpcmVjdGlvbiAtIERpcmVjdGlvbi5cbiAqIEBwYXJhbSAge2FueX0gICAgICBub2RlRGF0YSAgLSBUYXJnZXQgbm9kZSdzIGRhdGEuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoSW5PYmplY3RPbmNlKGJyZWFrYWJsZSwgdmlzaXRlZCwgbm9kZURhdGEsIG9iamVjdCwgY2FsbGJhY2spIHtcbiAgZm9yIChjb25zdCBrIGluIG9iamVjdCkge1xuICAgIGNvbnN0IGVkZ2VEYXRhID0gb2JqZWN0W2tdO1xuXG4gICAgY29uc3Qgc291cmNlRGF0YSA9IGVkZ2VEYXRhLnNvdXJjZTtcbiAgICBjb25zdCB0YXJnZXREYXRhID0gZWRnZURhdGEudGFyZ2V0O1xuXG4gICAgY29uc3QgbmVpZ2hib3JEYXRhID0gc291cmNlRGF0YSA9PT0gbm9kZURhdGEgPyB0YXJnZXREYXRhIDogc291cmNlRGF0YTtcblxuICAgIGlmICh2aXNpdGVkICYmIHZpc2l0ZWQuaGFzKG5laWdoYm9yRGF0YS5rZXkpKSBjb250aW51ZTtcblxuICAgIGNvbnN0IHNob3VsZEJyZWFrID0gY2FsbGJhY2sobmVpZ2hib3JEYXRhLmtleSwgbmVpZ2hib3JEYXRhLmF0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIG5laWdoYm9yRGF0YS5rZXk7XG4gIH1cblxuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hOZWlnaGJvcihicmVha2FibGUsIHR5cGUsIGRpcmVjdGlvbiwgbm9kZURhdGEsIGNhbGxiYWNrKSB7XG4gIC8vIElmIHdlIHdhbnQgb25seSB1bmRpcmVjdGVkIG9yIGluIG9yIG91dCwgd2UgY2FuIHJvbGwgc29tZSBvcHRpbWl6YXRpb25zXG4gIGlmICh0eXBlICE9PSAnbWl4ZWQnKSB7XG4gICAgaWYgKHR5cGUgPT09ICd1bmRpcmVjdGVkJylcbiAgICAgIHJldHVybiBmb3JFYWNoSW5PYmplY3RPbmNlKFxuICAgICAgICBicmVha2FibGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5vZGVEYXRhLFxuICAgICAgICBub2RlRGF0YS51bmRpcmVjdGVkLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcblxuICAgIGlmICh0eXBlb2YgZGlyZWN0aW9uID09PSAnc3RyaW5nJylcbiAgICAgIHJldHVybiBmb3JFYWNoSW5PYmplY3RPbmNlKFxuICAgICAgICBicmVha2FibGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5vZGVEYXRhLFxuICAgICAgICBub2RlRGF0YVtkaXJlY3Rpb25dLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgfVxuXG4gIC8vIEVsc2Ugd2UgbmVlZCB0byBrZWVwIGEgc2V0IG9mIG5laWdoYm9ycyBub3QgdG8gcmV0dXJuIGR1cGxpY2F0ZXNcbiAgLy8gV2UgY2hlYXQgYnkgcXVlcnlpbmcgdGhlIG90aGVyIGFkamFjZW5jaWVzXG4gIGNvbnN0IHZpc2l0ZWQgPSBuZXcgQ29tcG9zaXRlU2V0V3JhcHBlcigpO1xuXG4gIGxldCBmb3VuZDtcblxuICBpZiAodHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ291dCcpIHtcbiAgICAgIGZvdW5kID0gZm9yRWFjaEluT2JqZWN0T25jZShcbiAgICAgICAgYnJlYWthYmxlLFxuICAgICAgICBudWxsLFxuICAgICAgICBub2RlRGF0YSxcbiAgICAgICAgbm9kZURhdGEuaW4sXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuXG4gICAgICBpZiAoYnJlYWthYmxlICYmIGZvdW5kKSByZXR1cm4gZm91bmQ7XG5cbiAgICAgIHZpc2l0ZWQud3JhcChub2RlRGF0YS5pbik7XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gIT09ICdpbicpIHtcbiAgICAgIGZvdW5kID0gZm9yRWFjaEluT2JqZWN0T25jZShcbiAgICAgICAgYnJlYWthYmxlLFxuICAgICAgICB2aXNpdGVkLFxuICAgICAgICBub2RlRGF0YSxcbiAgICAgICAgbm9kZURhdGEub3V0LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuXG4gICAgICB2aXNpdGVkLndyYXAobm9kZURhdGEub3V0KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgIGZvdW5kID0gZm9yRWFjaEluT2JqZWN0T25jZShcbiAgICAgIGJyZWFrYWJsZSxcbiAgICAgIHZpc2l0ZWQsXG4gICAgICBub2RlRGF0YSxcbiAgICAgIG5vZGVEYXRhLnVuZGlyZWN0ZWQsXG4gICAgICBjYWxsYmFja1xuICAgICk7XG5cbiAgICBpZiAoYnJlYWthYmxlICYmIGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gIH1cblxuICByZXR1cm47XG59XG5cbi8qKlxuICogRnVuY3Rpb24gY3JlYXRpbmcgYW4gYXJyYXkgb2YgcmVsZXZhbnQgbmVpZ2hib3JzIGZvciB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgIHR5cGUgICAgICAtIFR5cGUgb2YgbmVpZ2hib3JzLlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICBkaXJlY3Rpb24gLSBEaXJlY3Rpb24uXG4gKiBAcGFyYW0gIHthbnl9ICAgICAgICAgIG5vZGVEYXRhICAtIFRhcmdldCBub2RlJ3MgZGF0YS5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgICAgIC0gVGhlIGxpc3Qgb2YgbmVpZ2hib3JzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOZWlnaGJvckFycmF5Rm9yTm9kZSh0eXBlLCBkaXJlY3Rpb24sIG5vZGVEYXRhKSB7XG4gIC8vIElmIHdlIHdhbnQgb25seSB1bmRpcmVjdGVkIG9yIGluIG9yIG91dCwgd2UgY2FuIHJvbGwgc29tZSBvcHRpbWl6YXRpb25zXG4gIGlmICh0eXBlICE9PSAnbWl4ZWQnKSB7XG4gICAgaWYgKHR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIE9iamVjdC5rZXlzKG5vZGVEYXRhLnVuZGlyZWN0ZWQpO1xuXG4gICAgaWYgKHR5cGVvZiBkaXJlY3Rpb24gPT09ICdzdHJpbmcnKSByZXR1cm4gT2JqZWN0LmtleXMobm9kZURhdGFbZGlyZWN0aW9uXSk7XG4gIH1cblxuICBjb25zdCBuZWlnaGJvcnMgPSBbXTtcblxuICBmb3JFYWNoTmVpZ2hib3IoZmFsc2UsIHR5cGUsIGRpcmVjdGlvbiwgbm9kZURhdGEsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBuZWlnaGJvcnMucHVzaChrZXkpO1xuICB9KTtcblxuICByZXR1cm4gbmVpZ2hib3JzO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBpdGVyYXRvciBvdmVyIHRoZSBnaXZlbiBub2RlJ3MgcmVsZXZhbnQgbmVpZ2hib3JzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlICAgICAgLSBUeXBlIG9mIG5laWdoYm9ycy5cbiAqIEBwYXJhbSAge3N0cmluZ30gICBkaXJlY3Rpb24gLSBEaXJlY3Rpb24uXG4gKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZURhdGEgIC0gVGFyZ2V0IG5vZGUncyBkYXRhLlxuICogQHJldHVybiB7SXRlcmF0b3J9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZHVwZWRPYmplY3RJdGVyYXRvcih2aXNpdGVkLCBub2RlRGF0YSwgb2JqZWN0KSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBjb25zdCBsID0ga2V5cy5sZW5ndGg7XG5cbiAgbGV0IGkgPSAwO1xuXG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG5leHQoKSB7XG4gICAgICBsZXQgbmVpZ2hib3JEYXRhID0gbnVsbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAoaSA+PSBsKSB7XG4gICAgICAgICAgaWYgKHZpc2l0ZWQpIHZpc2l0ZWQud3JhcChvYmplY3QpO1xuICAgICAgICAgIHJldHVybiB7ZG9uZTogdHJ1ZX07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlZGdlRGF0YSA9IG9iamVjdFtrZXlzW2krK11dO1xuXG4gICAgICAgIGNvbnN0IHNvdXJjZURhdGEgPSBlZGdlRGF0YS5zb3VyY2U7XG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSBlZGdlRGF0YS50YXJnZXQ7XG5cbiAgICAgICAgbmVpZ2hib3JEYXRhID0gc291cmNlRGF0YSA9PT0gbm9kZURhdGEgPyB0YXJnZXREYXRhIDogc291cmNlRGF0YTtcblxuICAgICAgICBpZiAodmlzaXRlZCAmJiB2aXNpdGVkLmhhcyhuZWlnaGJvckRhdGEua2V5KSkge1xuICAgICAgICAgIG5laWdoYm9yRGF0YSA9IG51bGw7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG5laWdoYm9yRGF0YSA9PT0gbnVsbCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZToge25laWdoYm9yOiBuZWlnaGJvckRhdGEua2V5LCBhdHRyaWJ1dGVzOiBuZWlnaGJvckRhdGEuYXR0cmlidXRlc31cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOZWlnaGJvckl0ZXJhdG9yKHR5cGUsIGRpcmVjdGlvbiwgbm9kZURhdGEpIHtcbiAgLy8gSWYgd2Ugd2FudCBvbmx5IHVuZGlyZWN0ZWQgb3IgaW4gb3Igb3V0LCB3ZSBjYW4gcm9sbCBzb21lIG9wdGltaXphdGlvbnNcbiAgaWYgKHR5cGUgIT09ICdtaXhlZCcpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKVxuICAgICAgcmV0dXJuIGNyZWF0ZURlZHVwZWRPYmplY3RJdGVyYXRvcihudWxsLCBub2RlRGF0YSwgbm9kZURhdGEudW5kaXJlY3RlZCk7XG5cbiAgICBpZiAodHlwZW9mIGRpcmVjdGlvbiA9PT0gJ3N0cmluZycpXG4gICAgICByZXR1cm4gY3JlYXRlRGVkdXBlZE9iamVjdEl0ZXJhdG9yKG51bGwsIG5vZGVEYXRhLCBub2RlRGF0YVtkaXJlY3Rpb25dKTtcbiAgfVxuXG4gIGxldCBpdGVyYXRvciA9IGVtcHR5SXRlcmF0b3IoKTtcblxuICAvLyBFbHNlIHdlIG5lZWQgdG8ga2VlcCBhIHNldCBvZiBuZWlnaGJvcnMgbm90IHRvIHJldHVybiBkdXBsaWNhdGVzXG4gIC8vIFdlIGNoZWF0IGJ5IHF1ZXJ5aW5nIHRoZSBvdGhlciBhZGphY2VuY2llc1xuICBjb25zdCB2aXNpdGVkID0gbmV3IENvbXBvc2l0ZVNldFdyYXBwZXIoKTtcblxuICBpZiAodHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ291dCcpIHtcbiAgICAgIGl0ZXJhdG9yID0gY2hhaW4oXG4gICAgICAgIGl0ZXJhdG9yLFxuICAgICAgICBjcmVhdGVEZWR1cGVkT2JqZWN0SXRlcmF0b3IodmlzaXRlZCwgbm9kZURhdGEsIG5vZGVEYXRhLmluKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ2luJykge1xuICAgICAgaXRlcmF0b3IgPSBjaGFpbihcbiAgICAgICAgaXRlcmF0b3IsXG4gICAgICAgIGNyZWF0ZURlZHVwZWRPYmplY3RJdGVyYXRvcih2aXNpdGVkLCBub2RlRGF0YSwgbm9kZURhdGEub3V0KVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgIGl0ZXJhdG9yID0gY2hhaW4oXG4gICAgICBpdGVyYXRvcixcbiAgICAgIGNyZWF0ZURlZHVwZWRPYmplY3RJdGVyYXRvcih2aXNpdGVkLCBub2RlRGF0YSwgbm9kZURhdGEudW5kaXJlY3RlZClcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGFjaGluZyBhIG5laWdoYm9ycyBhcnJheSBjcmVhdG9yIG1ldGhvZCB0byB0aGUgR3JhcGggcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtvYmplY3R9ICAgZGVzY3JpcHRpb24gLSBNZXRob2QgZGVzY3JpcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaE5laWdoYm9yQXJyYXlDcmVhdG9yKENsYXNzLCBkZXNjcmlwdGlvbikge1xuICBjb25zdCB7bmFtZSwgdHlwZSwgZGlyZWN0aW9ufSA9IGRlc2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgY2VydGFpbiBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICBub2RlICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHJldHVybiB7YXJyYXl9IC0gVGhlIG5laWdoYm9ycyBvZiBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgbm9kZSBpcyBub3QgZm91bmQgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICByZXR1cm4gW107XG5cbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIG5vZGVEYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke25hbWV9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIC8vIEhlcmUsIHdlIHdhbnQgdG8gaXRlcmF0ZSBvdmVyIGEgbm9kZSdzIHJlbGV2YW50IG5laWdoYm9yc1xuICAgIHJldHVybiBjcmVhdGVOZWlnaGJvckFycmF5Rm9yTm9kZShcbiAgICAgIHR5cGUgPT09ICdtaXhlZCcgPyB0aGlzLnR5cGUgOiB0eXBlLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgbm9kZURhdGFcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGFjaGluZyBhIG5laWdoYm9ycyBjYWxsYmFjayBpdGVyYXRvciBtZXRob2QgdG8gdGhlIEdyYXBoIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc2NyaXB0aW9uIC0gTWV0aG9kIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBhdHRhY2hGb3JFYWNoTmVpZ2hib3IoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgY29uc3QgZm9yRWFjaE5hbWUgPSAnZm9yRWFjaCcgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEsIC0xKTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgYWxsIHRoZSByZWxldmFudCBuZWlnaGJvcnMgdXNpbmcgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbZm9yRWFjaE5hbWVdID0gZnVuY3Rpb24gKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodHlwZSAhPT0gJ21peGVkJyAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKSByZXR1cm47XG5cbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIG5vZGVEYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke2ZvckVhY2hOYW1lfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICAvLyBIZXJlLCB3ZSB3YW50IHRvIGl0ZXJhdGUgb3ZlciBhIG5vZGUncyByZWxldmFudCBuZWlnaGJvcnNcbiAgICBmb3JFYWNoTmVpZ2hib3IoXG4gICAgICBmYWxzZSxcbiAgICAgIHR5cGUgPT09ICdtaXhlZCcgPyB0aGlzLnR5cGUgOiB0eXBlLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgbm9kZURhdGEsXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIG1hcHBpbmcgdGhlIHJlbGV2YW50IG5laWdoYm9ycyB1c2luZyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBtYXBOYW1lID0gJ21hcCcgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVttYXBOYW1lXSA9IGZ1bmN0aW9uIChub2RlLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IG9wdGltaXplIHdoZW4gc2l6ZSBpcyBrbm93biBiZWZvcmVoYW5kXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB0aGlzW2ZvckVhY2hOYW1lXShub2RlLCAobiwgYSkgPT4ge1xuICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2sobiwgYSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gZmlsdGVyaW5nIHRoZSByZWxldmFudCBuZWlnaGJvcnMgdXNpbmcgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3QgZmlsdGVyTmFtZSA9ICdmaWx0ZXInICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcblxuICBDbGFzcy5wcm90b3R5cGVbZmlsdGVyTmFtZV0gPSBmdW5jdGlvbiAobm9kZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIHRoaXNbZm9yRWFjaE5hbWVdKG5vZGUsIChuLCBhKSA9PiB7XG4gICAgICBpZiAoY2FsbGJhY2sobiwgYSkpIHJlc3VsdC5wdXNoKG4pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gcmVkdWNpbmcgdGhlIHJlbGV2YW50IG5laWdoYm9ycyB1c2luZyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCByZWR1Y2VOYW1lID0gJ3JlZHVjZScgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVtyZWR1Y2VOYW1lXSA9IGZ1bmN0aW9uIChub2RlLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHtyZWR1Y2VOYW1lfTogbWlzc2luZyBpbml0aWFsIHZhbHVlLiBZb3UgbXVzdCBwcm92aWRlIGl0IGJlY2F1c2UgdGhlIGNhbGxiYWNrIHRha2VzIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgYW5kIHdlIGNhbm5vdCBpbmZlciB0aGUgaW5pdGlhbCB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBpdGVyYXRpb24sIGFzIHlvdSBjb3VsZCB3aXRoIGEgc2ltcGxlIGFycmF5LmBcbiAgICAgICk7XG5cbiAgICBsZXQgYWNjdW11bGF0b3IgPSBpbml0aWFsVmFsdWU7XG5cbiAgICB0aGlzW2ZvckVhY2hOYW1lXShub2RlLCAobiwgYSkgPT4ge1xuICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFjayhhY2N1bXVsYXRvciwgbiwgYSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGEgYnJlYWthYmxlIG5laWdoYm9ycyBjYWxsYmFjayBpdGVyYXRvciBtZXRob2QgdG8gdGhlXG4gKiBHcmFwaCBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRmluZE5laWdoYm9yKENsYXNzLCBkZXNjcmlwdGlvbikge1xuICBjb25zdCB7bmFtZSwgdHlwZSwgZGlyZWN0aW9ufSA9IGRlc2NyaXB0aW9uO1xuXG4gIGNvbnN0IGNhcGl0YWxpemVkU2luZ3VsYXIgPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEsIC0xKTtcblxuICBjb25zdCBmaW5kTmFtZSA9ICdmaW5kJyArIGNhcGl0YWxpemVkU2luZ3VsYXI7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzIHVzaW5nIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW2ZpbmROYW1lXSA9IGZ1bmN0aW9uIChub2RlLCBjYWxsYmFjaykge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHR5cGUgIT09ICdtaXhlZCcgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSkgcmV0dXJuO1xuXG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBub2RlRGF0YSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHtmaW5kTmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgLy8gSGVyZSwgd2Ugd2FudCB0byBpdGVyYXRlIG92ZXIgYSBub2RlJ3MgcmVsZXZhbnQgbmVpZ2hib3JzXG4gICAgcmV0dXJuIGZvckVhY2hOZWlnaGJvcihcbiAgICAgIHRydWUsXG4gICAgICB0eXBlID09PSAnbWl4ZWQnID8gdGhpcy50eXBlIDogdHlwZSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgY2FsbGJhY2tcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhbGwgdGhlIHJlbGV2YW50IG5laWdoYm9ycyB0byBmaW5kIGlmIGFueSBvZiB0aGVtXG4gICAqIG1hdGNoZXMgdGhlIGdpdmVuIHByZWRpY2F0ZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3Qgc29tZU5hbWUgPSAnc29tZScgKyBjYXBpdGFsaXplZFNpbmd1bGFyO1xuXG4gIENsYXNzLnByb3RvdHlwZVtzb21lTmFtZV0gPSBmdW5jdGlvbiAobm9kZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBmb3VuZCA9IHRoaXNbZmluZE5hbWVdKG5vZGUsIGNhbGxiYWNrKTtcblxuICAgIGlmIChmb3VuZCkgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzIHRvIGZpbmQgaWYgYWxsIG9mIHRoZW1cbiAgICogbWF0Y2hlIHRoZSBnaXZlbiBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IGV2ZXJ5TmFtZSA9ICdldmVyeScgKyBjYXBpdGFsaXplZFNpbmd1bGFyO1xuXG4gIENsYXNzLnByb3RvdHlwZVtldmVyeU5hbWVdID0gZnVuY3Rpb24gKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZm91bmQgPSB0aGlzW2ZpbmROYW1lXShub2RlLCAobiwgYSkgPT4ge1xuICAgICAgcmV0dXJuICFjYWxsYmFjayhuLCBhKTtcbiAgICB9KTtcblxuICAgIGlmIChmb3VuZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGEgbmVpZ2hib3JzIGNhbGxiYWNrIGl0ZXJhdG9yIG1ldGhvZCB0byB0aGUgR3JhcGggcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtvYmplY3R9ICAgZGVzY3JpcHRpb24gLSBNZXRob2QgZGVzY3JpcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaE5laWdoYm9ySXRlcmF0b3JDcmVhdG9yKENsYXNzLCBkZXNjcmlwdGlvbikge1xuICBjb25zdCB7bmFtZSwgdHlwZSwgZGlyZWN0aW9ufSA9IGRlc2NyaXB0aW9uO1xuXG4gIGNvbnN0IGl0ZXJhdG9yTmFtZSA9IG5hbWUuc2xpY2UoMCwgLTEpICsgJ0VudHJpZXMnO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb3ZlciBhbGwgdGhlIHJlbGV2YW50IG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbaXRlcmF0b3JOYW1lXSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodHlwZSAhPT0gJ21peGVkJyAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgcmV0dXJuIGVtcHR5SXRlcmF0b3IoKTtcblxuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICh0eXBlb2Ygbm9kZURhdGEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7aXRlcmF0b3JOYW1lfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICAvLyBIZXJlLCB3ZSB3YW50IHRvIGl0ZXJhdGUgb3ZlciBhIG5vZGUncyByZWxldmFudCBuZWlnaGJvcnNcbiAgICByZXR1cm4gY3JlYXRlTmVpZ2hib3JJdGVyYXRvcihcbiAgICAgIHR5cGUgPT09ICdtaXhlZCcgPyB0aGlzLnR5cGUgOiB0eXBlLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgbm9kZURhdGFcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGFjaGluZyBldmVyeSBuZWlnaGJvciBpdGVyYXRpb24gbWV0aG9kIHRvIHRoZSBHcmFwaCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBHcmFwaCAtIEdyYXBoIGNsYXNzLlxuICovXG5mdW5jdGlvbiBhdHRhY2hOZWlnaGJvckl0ZXJhdGlvbk1ldGhvZHMoR3JhcGgpIHtcbiAgTkVJR0hCT1JTX0lURVJBVElPTi5mb3JFYWNoKGRlc2NyaXB0aW9uID0+IHtcbiAgICBhdHRhY2hOZWlnaGJvckFycmF5Q3JlYXRvcihHcmFwaCwgZGVzY3JpcHRpb24pO1xuICAgIGF0dGFjaEZvckVhY2hOZWlnaGJvcihHcmFwaCwgZGVzY3JpcHRpb24pO1xuICAgIGF0dGFjaEZpbmROZWlnaGJvcihHcmFwaCwgZGVzY3JpcHRpb24pO1xuICAgIGF0dGFjaE5laWdoYm9ySXRlcmF0b3JDcmVhdG9yKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdyYXBob2xvZ3kgQWRqYWNlbmN5IEl0ZXJhdGlvblxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEF0dGFjaGluZyBzb21lIG1ldGhvZHMgdG8gdGhlIEdyYXBoIGNsYXNzIHRvIGJlIGFibGUgdG8gaXRlcmF0ZSBvdmVyIGFcbiAqIGdyYXBoJ3MgYWRqYWNlbmN5LlxuICovXG5cbi8qKlxuICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgYSBzaW1wbGUgZ3JhcGgncyBhZGphY2VuY3kgdXNpbmcgYSBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICBicmVha2FibGUgICAgICAgICAtIENhbiB3ZSBicmVhaz9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gIGFzc3ltZXRyaWMgICAgICAgIC0gV2hldGhlciB0byBlbWl0IHVuZGlyZWN0ZWQgZWRnZXMgb25seSBvbmNlLlxuICogQHBhcmFtIHtib29sZWFufSAgZGlzY29ubmVjdGVkTm9kZXMgLSBXaGV0aGVyIHRvIGVtaXQgZGlzY29ubmVjdGVkIG5vZGVzLlxuICogQHBhcmFtIHtHcmFwaH0gICAgZ3JhcGggICAgICAgICAgICAgLSBUYXJnZXQgR3JhcGggaW5zdGFuY2UuXG4gKiBAcGFyYW0ge2NhbGxiYWNrfSBmdW5jdGlvbiAgICAgICAgICAtIEl0ZXJhdGlvbiBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEFkamFjZW5jeShcbiAgYnJlYWthYmxlLFxuICBhc3N5bWV0cmljLFxuICBkaXNjb25uZWN0ZWROb2RlcyxcbiAgZ3JhcGgsXG4gIGNhbGxiYWNrXG4pIHtcbiAgY29uc3QgaXRlcmF0b3IgPSBncmFwaC5fbm9kZXMudmFsdWVzKCk7XG5cbiAgY29uc3QgdHlwZSA9IGdyYXBoLnR5cGU7XG5cbiAgbGV0IHN0ZXAsIHNvdXJjZURhdGEsIG5laWdoYm9yLCBhZGosIGVkZ2VEYXRhLCB0YXJnZXREYXRhLCBzaG91bGRCcmVhaztcblxuICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgIGxldCBoYXNFZGdlcyA9IGZhbHNlO1xuXG4gICAgc291cmNlRGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICBpZiAodHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBhZGogPSBzb3VyY2VEYXRhLm91dDtcblxuICAgICAgZm9yIChuZWlnaGJvciBpbiBhZGopIHtcbiAgICAgICAgZWRnZURhdGEgPSBhZGpbbmVpZ2hib3JdO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0YXJnZXREYXRhID0gZWRnZURhdGEudGFyZ2V0O1xuXG4gICAgICAgICAgaGFzRWRnZXMgPSB0cnVlO1xuICAgICAgICAgIHNob3VsZEJyZWFrID0gY2FsbGJhY2soXG4gICAgICAgICAgICBzb3VyY2VEYXRhLmtleSxcbiAgICAgICAgICAgIHRhcmdldERhdGEua2V5LFxuICAgICAgICAgICAgc291cmNlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgdGFyZ2V0RGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgZWRnZURhdGEua2V5LFxuICAgICAgICAgICAgZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIGVkZ2VEYXRhO1xuXG4gICAgICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChlZGdlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGFkaiA9IHNvdXJjZURhdGEudW5kaXJlY3RlZDtcblxuICAgICAgZm9yIChuZWlnaGJvciBpbiBhZGopIHtcbiAgICAgICAgaWYgKGFzc3ltZXRyaWMgJiYgc291cmNlRGF0YS5rZXkgPiBuZWlnaGJvcikgY29udGludWU7XG5cbiAgICAgICAgZWRnZURhdGEgPSBhZGpbbmVpZ2hib3JdO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0YXJnZXREYXRhID0gZWRnZURhdGEudGFyZ2V0O1xuXG4gICAgICAgICAgaWYgKHRhcmdldERhdGEua2V5ICE9PSBuZWlnaGJvcikgdGFyZ2V0RGF0YSA9IGVkZ2VEYXRhLnNvdXJjZTtcblxuICAgICAgICAgIGhhc0VkZ2VzID0gdHJ1ZTtcbiAgICAgICAgICBzaG91bGRCcmVhayA9IGNhbGxiYWNrKFxuICAgICAgICAgICAgc291cmNlRGF0YS5rZXksXG4gICAgICAgICAgICB0YXJnZXREYXRhLmtleSxcbiAgICAgICAgICAgIHNvdXJjZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIHRhcmdldERhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGVkZ2VEYXRhLmtleSxcbiAgICAgICAgICAgIGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChicmVha2FibGUgJiYgc2hvdWxkQnJlYWspIHJldHVybiBlZGdlRGF0YTtcblxuICAgICAgICAgIGVkZ2VEYXRhID0gZWRnZURhdGEubmV4dDtcbiAgICAgICAgfSB3aGlsZSAoZWRnZURhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXNjb25uZWN0ZWROb2RlcyAmJiAhaGFzRWRnZXMpIHtcbiAgICAgIHNob3VsZEJyZWFrID0gY2FsbGJhY2soXG4gICAgICAgIHNvdXJjZURhdGEua2V5LFxuICAgICAgICBudWxsLFxuICAgICAgICBzb3VyY2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG5cbiAgICAgIGlmIChicmVha2FibGUgJiYgc2hvdWxkQnJlYWspIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBHcmFwaG9sb2d5IFNlcmlhbGl6YXRpb24gVXRpbGl0aWVzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIENvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHVzZWQgYnkgdGhlIGdyYXBoIHNlcmlhbGl6YXRpb24gc2NoZW1lcy5cbiAqL1xuXG4vKipcbiAqIEZvcm1hdHMgaW50ZXJuYWwgbm9kZSBkYXRhIGludG8gYSBzZXJpYWxpemVkIG5vZGUuXG4gKlxuICogQHBhcmFtICB7YW55fSAgICBrZXkgIC0gVGhlIG5vZGUncyBrZXkuXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRhdGEgLSBJbnRlcm5hbCBub2RlJ3MgZGF0YS5cbiAqIEByZXR1cm4ge2FycmF5fSAgICAgICAtIFRoZSBzZXJpYWxpemVkIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGUoa2V5LCBkYXRhKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSB7a2V5fTtcblxuICBpZiAoIWlzRW1wdHkoZGF0YS5hdHRyaWJ1dGVzKSlcbiAgICBzZXJpYWxpemVkLmF0dHJpYnV0ZXMgPSBhc3NpZ24oe30sIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8qKlxuICogRm9ybWF0cyBpbnRlcm5hbCBlZGdlIGRhdGEgaW50byBhIHNlcmlhbGl6ZWQgZWRnZS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgLSBUaGUgZ3JhcGgncyB0eXBlLlxuICogQHBhcmFtICB7YW55fSAgICBrZXkgIC0gVGhlIGVkZ2UncyBrZXkuXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRhdGEgLSBJbnRlcm5hbCBlZGdlJ3MgZGF0YS5cbiAqIEByZXR1cm4ge2FycmF5fSAgICAgICAtIFRoZSBzZXJpYWxpemVkIGVkZ2UuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVkZ2UodHlwZSwga2V5LCBkYXRhKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAga2V5LFxuICAgIHNvdXJjZTogZGF0YS5zb3VyY2Uua2V5LFxuICAgIHRhcmdldDogZGF0YS50YXJnZXQua2V5XG4gIH07XG5cbiAgaWYgKCFpc0VtcHR5KGRhdGEuYXR0cmlidXRlcykpXG4gICAgc2VyaWFsaXplZC5hdHRyaWJ1dGVzID0gYXNzaWduKHt9LCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIGlmICh0eXBlID09PSAnbWl4ZWQnICYmIGRhdGEudW5kaXJlY3RlZCkgc2VyaWFsaXplZC51bmRpcmVjdGVkID0gdHJ1ZTtcblxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzZXJpYWxpemVkIG5vZGUuXG4gKlxuICogQHBhcmFtICB7bWl4ZWR9IHZhbHVlIC0gVGFyZ2V0IHZhbHVlLlxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2VyaWFsaXplZE5vZGUodmFsdWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAnR3JhcGguaW1wb3J0OiBpbnZhbGlkIHNlcmlhbGl6ZWQgbm9kZS4gQSBzZXJpYWxpemVkIG5vZGUgc2hvdWxkIGJlIGEgcGxhaW4gb2JqZWN0IHdpdGggYXQgbGVhc3QgYSBcImtleVwiIHByb3BlcnR5LidcbiAgICApO1xuXG4gIGlmICghKCdrZXknIGluIHZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAnR3JhcGguaW1wb3J0OiBzZXJpYWxpemVkIG5vZGUgaXMgbWlzc2luZyBpdHMga2V5LidcbiAgICApO1xuXG4gIGlmIChcbiAgICAnYXR0cmlidXRlcycgaW4gdmFsdWUgJiZcbiAgICAoIWlzUGxhaW5PYmplY3QodmFsdWUuYXR0cmlidXRlcykgfHwgdmFsdWUuYXR0cmlidXRlcyA9PT0gbnVsbClcbiAgKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgYXR0cmlidXRlcy4gQXR0cmlidXRlcyBzaG91bGQgYmUgYSBwbGFpbiBvYmplY3QsIG51bGwgb3Igb21pdHRlZC4nXG4gICAgKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzZXJpYWxpemVkIGVkZ2UuXG4gKlxuICogQHBhcmFtICB7bWl4ZWR9IHZhbHVlIC0gVGFyZ2V0IHZhbHVlLlxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2VyaWFsaXplZEVkZ2UodmFsdWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAnR3JhcGguaW1wb3J0OiBpbnZhbGlkIHNlcmlhbGl6ZWQgZWRnZS4gQSBzZXJpYWxpemVkIGVkZ2Ugc2hvdWxkIGJlIGEgcGxhaW4gb2JqZWN0IHdpdGggYXQgbGVhc3QgYSBcInNvdXJjZVwiICYgXCJ0YXJnZXRcIiBwcm9wZXJ0eS4nXG4gICAgKTtcblxuICBpZiAoISgnc291cmNlJyBpbiB2YWx1ZSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgJ0dyYXBoLmltcG9ydDogc2VyaWFsaXplZCBlZGdlIGlzIG1pc3NpbmcgaXRzIHNvdXJjZS4nXG4gICAgKTtcblxuICBpZiAoISgndGFyZ2V0JyBpbiB2YWx1ZSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgJ0dyYXBoLmltcG9ydDogc2VyaWFsaXplZCBlZGdlIGlzIG1pc3NpbmcgaXRzIHRhcmdldC4nXG4gICAgKTtcblxuICBpZiAoXG4gICAgJ2F0dHJpYnV0ZXMnIGluIHZhbHVlICYmXG4gICAgKCFpc1BsYWluT2JqZWN0KHZhbHVlLmF0dHJpYnV0ZXMpIHx8IHZhbHVlLmF0dHJpYnV0ZXMgPT09IG51bGwpXG4gIClcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAnR3JhcGguaW1wb3J0OiBpbnZhbGlkIGF0dHJpYnV0ZXMuIEF0dHJpYnV0ZXMgc2hvdWxkIGJlIGEgcGxhaW4gb2JqZWN0LCBudWxsIG9yIG9taXR0ZWQuJ1xuICAgICk7XG5cbiAgaWYgKCd1bmRpcmVjdGVkJyBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudW5kaXJlY3RlZCAhPT0gJ2Jvb2xlYW4nKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgdW5kaXJlY3RlZG5lc3MgaW5mb3JtYXRpb24uIFVuZGlyZWN0ZWQgc2hvdWxkIGJlIGJvb2xlYW4gb3Igb21pdHRlZC4nXG4gICAgKTtcbn1cblxuLyogZXNsaW50IG5vLW5lc3RlZC10ZXJuYXJ5OiAwICovXG5cbi8qKlxuICogQ29uc3RhbnRzLlxuICovXG5jb25zdCBJTlNUQU5DRV9JRCA9IGluY3JlbWVudGFsSWRTdGFydGluZ0Zyb21SYW5kb21CeXRlKCk7XG5cbi8qKlxuICogRW51bXMuXG4gKi9cbmNvbnN0IFRZUEVTID0gbmV3IFNldChbJ2RpcmVjdGVkJywgJ3VuZGlyZWN0ZWQnLCAnbWl4ZWQnXSk7XG5cbmNvbnN0IEVNSVRURVJfUFJPUFMgPSBuZXcgU2V0KFtcbiAgJ2RvbWFpbicsXG4gICdfZXZlbnRzJyxcbiAgJ19ldmVudHNDb3VudCcsXG4gICdfbWF4TGlzdGVuZXJzJ1xuXSk7XG5cbmNvbnN0IEVER0VfQUREX01FVEhPRFMgPSBbXG4gIHtcbiAgICBuYW1lOiB2ZXJiID0+IGAke3ZlcmJ9RWRnZWAsXG4gICAgZ2VuZXJhdGVLZXk6IHRydWVcbiAgfSxcbiAge1xuICAgIG5hbWU6IHZlcmIgPT4gYCR7dmVyYn1EaXJlY3RlZEVkZ2VgLFxuICAgIGdlbmVyYXRlS2V5OiB0cnVlLFxuICAgIHR5cGU6ICdkaXJlY3RlZCdcbiAgfSxcbiAge1xuICAgIG5hbWU6IHZlcmIgPT4gYCR7dmVyYn1VbmRpcmVjdGVkRWRnZWAsXG4gICAgZ2VuZXJhdGVLZXk6IHRydWUsXG4gICAgdHlwZTogJ3VuZGlyZWN0ZWQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiB2ZXJiID0+IGAke3ZlcmJ9RWRnZVdpdGhLZXlgXG4gIH0sXG4gIHtcbiAgICBuYW1lOiB2ZXJiID0+IGAke3ZlcmJ9RGlyZWN0ZWRFZGdlV2l0aEtleWAsXG4gICAgdHlwZTogJ2RpcmVjdGVkJ1xuICB9LFxuICB7XG4gICAgbmFtZTogdmVyYiA9PiBgJHt2ZXJifVVuZGlyZWN0ZWRFZGdlV2l0aEtleWAsXG4gICAgdHlwZTogJ3VuZGlyZWN0ZWQnXG4gIH1cbl07XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zLlxuICovXG5jb25zdCBERUZBVUxUUyA9IHtcbiAgYWxsb3dTZWxmTG9vcHM6IHRydWUsXG4gIG11bHRpOiBmYWxzZSxcbiAgdHlwZTogJ21peGVkJ1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBmdW5jdGlvbnMgdXNlZCBieSB0aGUgR3JhcGggY2xhc3MgZm9yIHZhcmlvdXMgbWV0aG9kcy5cbiAqL1xuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCB1c2VkIHRvIGFkZCBhIG5vZGUgdG8gdGhlIGdpdmVuIGdyYXBoXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgZ3JhcGggICAgICAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgICAgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gKiBAcGFyYW0gIHtvYmplY3R9ICBbYXR0cmlidXRlc10gICAgLSBPcHRpb25hbCBhdHRyaWJ1dGVzLlxuICogQHJldHVybiB7Tm9kZURhdGF9ICAgICAgICAgICAgICAgIC0gQ3JlYXRlZCBub2RlIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGFkZE5vZGUoZ3JhcGgsIG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgaWYgKGF0dHJpYnV0ZXMgJiYgIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLmFkZE5vZGU6IGludmFsaWQgYXR0cmlidXRlcy4gRXhwZWN0aW5nIGFuIG9iamVjdCBidXQgZ290IFwiJHthdHRyaWJ1dGVzfVwiYFxuICAgICk7XG5cbiAgLy8gU3RyaW5nIGNvZXJjaW9uXG4gIG5vZGUgPSAnJyArIG5vZGU7XG4gIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmIChncmFwaC5fbm9kZXMuaGFzKG5vZGUpKVxuICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguYWRkTm9kZTogdGhlIFwiJHtub2RlfVwiIG5vZGUgYWxyZWFkeSBleGlzdCBpbiB0aGUgZ3JhcGguYFxuICAgICk7XG5cbiAgY29uc3QgZGF0YSA9IG5ldyBncmFwaC5Ob2RlRGF0YUNsYXNzKG5vZGUsIGF0dHJpYnV0ZXMpO1xuXG4gIC8vIEFkZGluZyB0aGUgbm9kZSB0byBpbnRlcm5hbCByZWdpc3RlclxuICBncmFwaC5fbm9kZXMuc2V0KG5vZGUsIGRhdGEpO1xuXG4gIC8vIEVtaXR0aW5nXG4gIGdyYXBoLmVtaXQoJ25vZGVBZGRlZCcsIHtcbiAgICBrZXk6IG5vZGUsXG4gICAgYXR0cmlidXRlc1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBTYW1lIGFzIHRoZSBhYm92ZSBidXQgd2l0aG91dCBzYW5pdHkgY2hlY2tzIGJlY2F1c2Ugd2UgY2FsbCB0aGlzIGluIGNvbnRleHRzXG4gKiB3aGVyZSBuZWNlc3NhcnkgY2hlY2tzIHdlcmUgYWxyZWFkeSBkb25lLlxuICovXG5mdW5jdGlvbiB1bnNhZmVBZGROb2RlKGdyYXBoLCBub2RlLCBhdHRyaWJ1dGVzKSB7XG4gIGNvbnN0IGRhdGEgPSBuZXcgZ3JhcGguTm9kZURhdGFDbGFzcyhub2RlLCBhdHRyaWJ1dGVzKTtcblxuICBncmFwaC5fbm9kZXMuc2V0KG5vZGUsIGRhdGEpO1xuXG4gIGdyYXBoLmVtaXQoJ25vZGVBZGRlZCcsIHtcbiAgICBrZXk6IG5vZGUsXG4gICAgYXR0cmlidXRlc1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBtZXRob2QgdXNlZCB0byBhZGQgYW4gYXJiaXRyYXJ5IGVkZ2UgdG8gdGhlIGdpdmVuIGdyYXBoLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgIGdyYXBoICAgICAgICAgICAtIFRhcmdldCBncmFwaC5cbiAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICAgICAgICAgICAtIE5hbWUgb2YgdGhlIGNoaWxkIG1ldGhvZCBmb3IgZXJyb3JzLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gbXVzdEdlbmVyYXRlS2V5IC0gU2hvdWxkIHRoZSBncmFwaCBnZW5lcmF0ZSBhbiBpZD9cbiAqIEBwYXJhbSAge2Jvb2xlYW59IHVuZGlyZWN0ZWQgICAgICAtIFdoZXRoZXIgdGhlIGVkZ2UgaXMgdW5kaXJlY3RlZC5cbiAqIEBwYXJhbSAge2FueX0gICAgIGVkZ2UgICAgICAgICAgICAtIFRoZSBlZGdlJ3Mga2V5LlxuICogQHBhcmFtICB7YW55fSAgICAgc291cmNlICAgICAgICAgIC0gVGhlIHNvdXJjZSBub2RlLlxuICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0ICAgICAgICAgIC0gVGhlIHRhcmdldCBub2RlLlxuICogQHBhcmFtICB7b2JqZWN0fSAgW2F0dHJpYnV0ZXNdICAgIC0gT3B0aW9uYWwgYXR0cmlidXRlcy5cbiAqIEByZXR1cm4ge2FueX0gICAgICAgICAgICAgICAgICAgICAtIFRoZSBlZGdlLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGdyYXBoIGlzIG9mIHRoZSB3cm9uZyB0eXBlLlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBhcmUgbm90IGFuIG9iamVjdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgc291cmNlIG9yIHRhcmdldCBkb2Vzbid0IGV4aXN0LlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBhZGRFZGdlKFxuICBncmFwaCxcbiAgbmFtZSxcbiAgbXVzdEdlbmVyYXRlS2V5LFxuICB1bmRpcmVjdGVkLFxuICBlZGdlLFxuICBzb3VyY2UsXG4gIHRhcmdldCxcbiAgYXR0cmlidXRlc1xuKSB7XG4gIC8vIENoZWNraW5nIHZhbGlkaXR5IG9mIG9wZXJhdGlvblxuICBpZiAoIXVuZGlyZWN0ZWQgJiYgZ3JhcGgudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKVxuICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogeW91IGNhbm5vdCBhZGQgYSBkaXJlY3RlZCBlZGdlIHRvIGFuIHVuZGlyZWN0ZWQgZ3JhcGguIFVzZSB0aGUgIy5hZGRFZGdlIG9yICMuYWRkVW5kaXJlY3RlZEVkZ2UgaW5zdGVhZC5gXG4gICAgKTtcblxuICBpZiAodW5kaXJlY3RlZCAmJiBncmFwaC50eXBlID09PSAnZGlyZWN0ZWQnKVxuICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogeW91IGNhbm5vdCBhZGQgYW4gdW5kaXJlY3RlZCBlZGdlIHRvIGEgZGlyZWN0ZWQgZ3JhcGguIFVzZSB0aGUgIy5hZGRFZGdlIG9yICMuYWRkRGlyZWN0ZWRFZGdlIGluc3RlYWQuYFxuICAgICk7XG5cbiAgaWYgKGF0dHJpYnV0ZXMgJiYgIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IGludmFsaWQgYXR0cmlidXRlcy4gRXhwZWN0aW5nIGFuIG9iamVjdCBidXQgZ290IFwiJHthdHRyaWJ1dGVzfVwiYFxuICAgICk7XG5cbiAgLy8gQ29lcmNpb24gb2Ygc291cmNlICYgdGFyZ2V0OlxuICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG4gIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICghZ3JhcGguYWxsb3dTZWxmTG9vcHMgJiYgc291cmNlID09PSB0YXJnZXQpXG4gICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiBzb3VyY2UgJiB0YXJnZXQgYXJlIHRoZSBzYW1lIChcIiR7c291cmNlfVwiKSwgdGh1cyBjcmVhdGluZyBhIGxvb3AgZXhwbGljaXRseSBmb3JiaWRkZW4gYnkgdGhpcyBncmFwaCAnYWxsb3dTZWxmTG9vcHMnIG9wdGlvbiBzZXQgdG8gZmFsc2UuYFxuICAgICk7XG5cbiAgY29uc3Qgc291cmNlRGF0YSA9IGdyYXBoLl9ub2Rlcy5nZXQoc291cmNlKSxcbiAgICB0YXJnZXREYXRhID0gZ3JhcGguX25vZGVzLmdldCh0YXJnZXQpO1xuXG4gIGlmICghc291cmNlRGF0YSlcbiAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHNvdXJjZSBub2RlIFwiJHtzb3VyY2V9XCIgbm90IGZvdW5kLmBcbiAgICApO1xuXG4gIGlmICghdGFyZ2V0RGF0YSlcbiAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHRhcmdldCBub2RlIFwiJHt0YXJnZXR9XCIgbm90IGZvdW5kLmBcbiAgICApO1xuXG4gIC8vIE11c3QgdGhlIGdyYXBoIGdlbmVyYXRlIGFuIGlkIGZvciB0aGlzIGVkZ2U/XG4gIGNvbnN0IGV2ZW50RGF0YSA9IHtcbiAgICBrZXk6IG51bGwsXG4gICAgdW5kaXJlY3RlZCxcbiAgICBzb3VyY2UsXG4gICAgdGFyZ2V0LFxuICAgIGF0dHJpYnV0ZXNcbiAgfTtcblxuICBpZiAobXVzdEdlbmVyYXRlS2V5KSB7XG4gICAgLy8gTk9URTogaW4gdGhpcyBjYXNlIHdlIGNhbiBndWFyYW50ZWUgdGhhdCB0aGUga2V5IGRvZXMgbm90IGFscmVhZHlcbiAgICAvLyBleGlzdCBhbmQgaXMgYWxyZWFkeSBjb3JyZWN0bHkgY2FzdGVkIGFzIGEgc3RyaW5nXG4gICAgZWRnZSA9IGdyYXBoLl9lZGdlS2V5R2VuZXJhdG9yKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29lcmNpb24gb2YgZWRnZSBrZXlcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgLy8gSGVyZSwgd2UgaGF2ZSBhIGtleSBjb2xsaXNpb25cbiAgICBpZiAoZ3JhcGguX2VkZ2VzLmhhcyhlZGdlKSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke25hbWV9OiB0aGUgXCIke2VkZ2V9XCIgZWRnZSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcbiAgfVxuXG4gIC8vIEhlcmUsIHdlIG1pZ2h0IGhhdmUgYSBzb3VyY2UgLyB0YXJnZXQgY29sbGlzaW9uXG4gIGlmIChcbiAgICAhZ3JhcGgubXVsdGkgJiZcbiAgICAodW5kaXJlY3RlZFxuICAgICAgPyB0eXBlb2Ygc291cmNlRGF0YS51bmRpcmVjdGVkW3RhcmdldF0gIT09ICd1bmRlZmluZWQnXG4gICAgICA6IHR5cGVvZiBzb3VyY2VEYXRhLm91dFt0YXJnZXRdICE9PSAndW5kZWZpbmVkJylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiBhbiBlZGdlIGxpbmtpbmcgXCIke3NvdXJjZX1cIiB0byBcIiR7dGFyZ2V0fVwiIGFscmVhZHkgZXhpc3RzLiBJZiB5b3UgcmVhbGx5IHdhbnQgdG8gYWRkIG11bHRpcGxlIGVkZ2VzIGxpbmtpbmcgdGhvc2Ugbm9kZXMsIHlvdSBzaG91bGQgY3JlYXRlIGEgbXVsdGkgZ3JhcGggYnkgdXNpbmcgdGhlICdtdWx0aScgb3B0aW9uLmBcbiAgICApO1xuICB9XG5cbiAgLy8gU3RvcmluZyBzb21lIGRhdGFcbiAgY29uc3QgZWRnZURhdGEgPSBuZXcgRWRnZURhdGEoXG4gICAgdW5kaXJlY3RlZCxcbiAgICBlZGdlLFxuICAgIHNvdXJjZURhdGEsXG4gICAgdGFyZ2V0RGF0YSxcbiAgICBhdHRyaWJ1dGVzXG4gICk7XG5cbiAgLy8gQWRkaW5nIHRoZSBlZGdlIHRvIHRoZSBpbnRlcm5hbCByZWdpc3RlclxuICBncmFwaC5fZWRnZXMuc2V0KGVkZ2UsIGVkZ2VEYXRhKTtcblxuICAvLyBJbmNyZW1lbnRpbmcgbm9kZSBkZWdyZWUgY291bnRlcnNcbiAgY29uc3QgaXNTZWxmTG9vcCA9IHNvdXJjZSA9PT0gdGFyZ2V0O1xuXG4gIGlmICh1bmRpcmVjdGVkKSB7XG4gICAgc291cmNlRGF0YS51bmRpcmVjdGVkRGVncmVlKys7XG4gICAgdGFyZ2V0RGF0YS51bmRpcmVjdGVkRGVncmVlKys7XG5cbiAgICBpZiAoaXNTZWxmTG9vcCkge1xuICAgICAgc291cmNlRGF0YS51bmRpcmVjdGVkTG9vcHMrKztcbiAgICAgIGdyYXBoLl91bmRpcmVjdGVkU2VsZkxvb3BDb3VudCsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzb3VyY2VEYXRhLm91dERlZ3JlZSsrO1xuICAgIHRhcmdldERhdGEuaW5EZWdyZWUrKztcblxuICAgIGlmIChpc1NlbGZMb29wKSB7XG4gICAgICBzb3VyY2VEYXRhLmRpcmVjdGVkTG9vcHMrKztcbiAgICAgIGdyYXBoLl9kaXJlY3RlZFNlbGZMb29wQ291bnQrKztcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGluZyByZWxldmFudCBpbmRleFxuICBpZiAoZ3JhcGgubXVsdGkpIGVkZ2VEYXRhLmF0dGFjaE11bHRpKCk7XG4gIGVsc2UgZWRnZURhdGEuYXR0YWNoKCk7XG5cbiAgaWYgKHVuZGlyZWN0ZWQpIGdyYXBoLl91bmRpcmVjdGVkU2l6ZSsrO1xuICBlbHNlIGdyYXBoLl9kaXJlY3RlZFNpemUrKztcblxuICAvLyBFbWl0dGluZ1xuICBldmVudERhdGEua2V5ID0gZWRnZTtcblxuICBncmFwaC5lbWl0KCdlZGdlQWRkZWQnLCBldmVudERhdGEpO1xuXG4gIHJldHVybiBlZGdlO1xufVxuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCB1c2VkIHRvIGFkZCBhbiBhcmJpdHJhcnkgZWRnZSB0byB0aGUgZ2l2ZW4gZ3JhcGguXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgZ3JhcGggICAgICAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgICAgICAgICAgIC0gTmFtZSBvZiB0aGUgY2hpbGQgbWV0aG9kIGZvciBlcnJvcnMuXG4gKiBAcGFyYW0gIHtib29sZWFufSBtdXN0R2VuZXJhdGVLZXkgLSBTaG91bGQgdGhlIGdyYXBoIGdlbmVyYXRlIGFuIGlkP1xuICogQHBhcmFtICB7Ym9vbGVhbn0gdW5kaXJlY3RlZCAgICAgIC0gV2hldGhlciB0aGUgZWRnZSBpcyB1bmRpcmVjdGVkLlxuICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAgICAgICAgICAgIC0gVGhlIGVkZ2UncyBrZXkuXG4gKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgICAgICAgICAgLSBUaGUgc291cmNlIG5vZGUuXG4gKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgICAgICAgICAgLSBUaGUgdGFyZ2V0IG5vZGUuXG4gKiBAcGFyYW0gIHtvYmplY3R9ICBbYXR0cmlidXRlc10gICAgLSBPcHRpb25hbCBhdHRyaWJ1dGVzLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gW2FzVXBkYXRlcl0gICAgICAgLSBBcmUgd2UgdXBkYXRpbmcgb3IgbWVyZ2luZz9cbiAqIEByZXR1cm4ge2FueX0gICAgICAgICAgICAgICAgICAgICAtIFRoZSBlZGdlLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGdyYXBoIGlzIG9mIHRoZSB3cm9uZyB0eXBlLlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBhcmUgbm90IGFuIG9iamVjdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgc291cmNlIG9yIHRhcmdldCBkb2Vzbid0IGV4aXN0LlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBtZXJnZUVkZ2UoXG4gIGdyYXBoLFxuICBuYW1lLFxuICBtdXN0R2VuZXJhdGVLZXksXG4gIHVuZGlyZWN0ZWQsXG4gIGVkZ2UsXG4gIHNvdXJjZSxcbiAgdGFyZ2V0LFxuICBhdHRyaWJ1dGVzLFxuICBhc1VwZGF0ZXJcbikge1xuICAvLyBDaGVja2luZyB2YWxpZGl0eSBvZiBvcGVyYXRpb25cbiAgaWYgKCF1bmRpcmVjdGVkICYmIGdyYXBoLnR5cGUgPT09ICd1bmRpcmVjdGVkJylcbiAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHlvdSBjYW5ub3QgbWVyZ2UvdXBkYXRlIGEgZGlyZWN0ZWQgZWRnZSB0byBhbiB1bmRpcmVjdGVkIGdyYXBoLiBVc2UgdGhlICMubWVyZ2VFZGdlLyMudXBkYXRlRWRnZSBvciAjLmFkZFVuZGlyZWN0ZWRFZGdlIGluc3RlYWQuYFxuICAgICk7XG5cbiAgaWYgKHVuZGlyZWN0ZWQgJiYgZ3JhcGgudHlwZSA9PT0gJ2RpcmVjdGVkJylcbiAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHlvdSBjYW5ub3QgbWVyZ2UvdXBkYXRlIGFuIHVuZGlyZWN0ZWQgZWRnZSB0byBhIGRpcmVjdGVkIGdyYXBoLiBVc2UgdGhlICMubWVyZ2VFZGdlLyMudXBkYXRlRWRnZSBvciAjLmFkZERpcmVjdGVkRWRnZSBpbnN0ZWFkLmBcbiAgICApO1xuXG4gIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGFzVXBkYXRlcikge1xuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bmFtZX06IGludmFsaWQgdXBkYXRlciBmdW5jdGlvbi4gRXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiR7YXR0cmlidXRlc31cImBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bmFtZX06IGludmFsaWQgYXR0cmlidXRlcy4gRXhwZWN0aW5nIGFuIG9iamVjdCBidXQgZ290IFwiJHthdHRyaWJ1dGVzfVwiYFxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvZXJjaW9uIG9mIHNvdXJjZSAmIHRhcmdldDpcbiAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gIGxldCB1cGRhdGVyO1xuXG4gIGlmIChhc1VwZGF0ZXIpIHtcbiAgICB1cGRhdGVyID0gYXR0cmlidXRlcztcbiAgICBhdHRyaWJ1dGVzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCFncmFwaC5hbGxvd1NlbGZMb29wcyAmJiBzb3VyY2UgPT09IHRhcmdldClcbiAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHNvdXJjZSAmIHRhcmdldCBhcmUgdGhlIHNhbWUgKFwiJHtzb3VyY2V9XCIpLCB0aHVzIGNyZWF0aW5nIGEgbG9vcCBleHBsaWNpdGx5IGZvcmJpZGRlbiBieSB0aGlzIGdyYXBoICdhbGxvd1NlbGZMb29wcycgb3B0aW9uIHNldCB0byBmYWxzZS5gXG4gICAgKTtcblxuICBsZXQgc291cmNlRGF0YSA9IGdyYXBoLl9ub2Rlcy5nZXQoc291cmNlKTtcbiAgbGV0IHRhcmdldERhdGEgPSBncmFwaC5fbm9kZXMuZ2V0KHRhcmdldCk7XG4gIGxldCBlZGdlRGF0YTtcblxuICAvLyBEbyB3ZSBuZWVkIHRvIGhhbmRsZSBkdXBsaWNhdGU/XG4gIGxldCBhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YTtcblxuICBpZiAoIW11c3RHZW5lcmF0ZUtleSkge1xuICAgIGVkZ2VEYXRhID0gZ3JhcGguX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmIChlZGdlRGF0YSkge1xuICAgICAgLy8gSGVyZSwgd2UgbmVlZCB0byBlbnN1cmUsIGlmIHRoZSB1c2VyIGdhdmUgYSBrZXksIHRoYXQgc291cmNlICYgdGFyZ2V0XG4gICAgICAvLyBhcmUgY29uc2lzdGVudFxuICAgICAgaWYgKGVkZ2VEYXRhLnNvdXJjZS5rZXkgIT09IHNvdXJjZSB8fCBlZGdlRGF0YS50YXJnZXQua2V5ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgLy8gSWYgc291cmNlIG9yIHRhcmdldCBpbmNvbnNpc3RlbnRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF1bmRpcmVjdGVkIHx8XG4gICAgICAgICAgZWRnZURhdGEuc291cmNlLmtleSAhPT0gdGFyZ2V0IHx8XG4gICAgICAgICAgZWRnZURhdGEudGFyZ2V0LmtleSAhPT0gc291cmNlXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIElmIGRpcmVjdGVkLCBvciBzb3VyY2UvdGFyZ2V0IGFyZW4ndCBmbGlwcGVkXG4gICAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICAgIGBHcmFwaC4ke25hbWV9OiBpbmNvbnNpc3RlbmN5IGRldGVjdGVkIHdoZW4gYXR0ZW1wdGluZyB0byBtZXJnZSB0aGUgXCIke2VkZ2V9XCIgZWRnZSB3aXRoIFwiJHtzb3VyY2V9XCIgc291cmNlICYgXCIke3RhcmdldH1cIiB0YXJnZXQgdnMuIChcIiR7ZWRnZURhdGEuc291cmNlLmtleX1cIiwgXCIke2VkZ2VEYXRhLnRhcmdldC5rZXl9XCIpLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhID0gZWRnZURhdGE7XG4gICAgfVxuICB9XG5cbiAgLy8gSGVyZSwgd2UgbWlnaHQgaGF2ZSBhIHNvdXJjZSAvIHRhcmdldCBjb2xsaXNpb25cbiAgaWYgKCFhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YSAmJiAhZ3JhcGgubXVsdGkgJiYgc291cmNlRGF0YSkge1xuICAgIGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhID0gdW5kaXJlY3RlZFxuICAgICAgPyBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRbdGFyZ2V0XVxuICAgICAgOiBzb3VyY2VEYXRhLm91dFt0YXJnZXRdO1xuICB9XG5cbiAgLy8gSGFuZGxpbmcgZHVwbGljYXRlc1xuICBpZiAoYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEpIHtcbiAgICBjb25zdCBpbmZvID0gW2FscmVhZHlFeGlzdGluZ0VkZ2VEYXRhLmtleSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XG5cbiAgICAvLyBXZSBjYW4gc2tpcCB0aGUgYXR0cmlidXRlIG1lcmdpbmcgcGFydCBpZiB0aGUgdXNlciBkaWQgbm90IHByb3ZpZGUgdGhlbVxuICAgIGlmIChhc1VwZGF0ZXIgPyAhdXBkYXRlciA6ICFhdHRyaWJ1dGVzKSByZXR1cm4gaW5mbztcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBhdHRyaWJ1dGVzXG4gICAgaWYgKGFzVXBkYXRlcikge1xuICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhLmF0dHJpYnV0ZXM7XG4gICAgICBhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YS5hdHRyaWJ1dGVzID0gdXBkYXRlcihvbGRBdHRyaWJ1dGVzKTtcblxuICAgICAgZ3JhcGguZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgICB0eXBlOiAncmVwbGFjZScsXG4gICAgICAgIGtleTogYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEua2V5LFxuICAgICAgICBhdHRyaWJ1dGVzOiBhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YS5hdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBNZXJnaW5nIHRoZSBhdHRyaWJ1dGVzXG4gICAgZWxzZSB7XG4gICAgICBhc3NpZ24oYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG5cbiAgICAgIGdyYXBoLmVtaXQoJ2VkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgICAgdHlwZTogJ21lcmdlJyxcbiAgICAgICAga2V5OiBhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YS5rZXksXG4gICAgICAgIGF0dHJpYnV0ZXM6IGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgIGRhdGE6IGF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKGFzVXBkYXRlciAmJiB1cGRhdGVyKSBhdHRyaWJ1dGVzID0gdXBkYXRlcihhdHRyaWJ1dGVzKTtcblxuICAvLyBNdXN0IHRoZSBncmFwaCBnZW5lcmF0ZSBhbiBpZCBmb3IgdGhpcyBlZGdlP1xuICBjb25zdCBldmVudERhdGEgPSB7XG4gICAga2V5OiBudWxsLFxuICAgIHVuZGlyZWN0ZWQsXG4gICAgc291cmNlLFxuICAgIHRhcmdldCxcbiAgICBhdHRyaWJ1dGVzXG4gIH07XG5cbiAgaWYgKG11c3RHZW5lcmF0ZUtleSkge1xuICAgIC8vIE5PVEU6IGluIHRoaXMgY2FzZSB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgdGhlIGtleSBkb2VzIG5vdCBhbHJlYWR5XG4gICAgLy8gZXhpc3QgYW5kIGlzIGFscmVhZHkgY29ycmVjdGx5IGNhc3RlZCBhcyBhIHN0cmluZ1xuICAgIGVkZ2UgPSBncmFwaC5fZWRnZUtleUdlbmVyYXRvcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIENvZXJjaW9uIG9mIGVkZ2Uga2V5XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgIC8vIEhlcmUsIHdlIGhhdmUgYSBrZXkgY29sbGlzaW9uXG4gICAgaWYgKGdyYXBoLl9lZGdlcy5oYXMoZWRnZSkpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHtuYW1lfTogdGhlIFwiJHtlZGdlfVwiIGVkZ2UgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG4gIH1cblxuICBsZXQgc291cmNlV2FzQWRkZWQgPSBmYWxzZTtcbiAgbGV0IHRhcmdldFdhc0FkZGVkID0gZmFsc2U7XG5cbiAgaWYgKCFzb3VyY2VEYXRhKSB7XG4gICAgc291cmNlRGF0YSA9IHVuc2FmZUFkZE5vZGUoZ3JhcGgsIHNvdXJjZSwge30pO1xuICAgIHNvdXJjZVdhc0FkZGVkID0gdHJ1ZTtcblxuICAgIGlmIChzb3VyY2UgPT09IHRhcmdldCkge1xuICAgICAgdGFyZ2V0RGF0YSA9IHNvdXJjZURhdGE7XG4gICAgICB0YXJnZXRXYXNBZGRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICghdGFyZ2V0RGF0YSkge1xuICAgIHRhcmdldERhdGEgPSB1bnNhZmVBZGROb2RlKGdyYXBoLCB0YXJnZXQsIHt9KTtcbiAgICB0YXJnZXRXYXNBZGRlZCA9IHRydWU7XG4gIH1cblxuICAvLyBTdG9yaW5nIHNvbWUgZGF0YVxuICBlZGdlRGF0YSA9IG5ldyBFZGdlRGF0YSh1bmRpcmVjdGVkLCBlZGdlLCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBhdHRyaWJ1dGVzKTtcblxuICAvLyBBZGRpbmcgdGhlIGVkZ2UgdG8gdGhlIGludGVybmFsIHJlZ2lzdGVyXG4gIGdyYXBoLl9lZGdlcy5zZXQoZWRnZSwgZWRnZURhdGEpO1xuXG4gIC8vIEluY3JlbWVudGluZyBub2RlIGRlZ3JlZSBjb3VudGVyc1xuICBjb25zdCBpc1NlbGZMb29wID0gc291cmNlID09PSB0YXJnZXQ7XG5cbiAgaWYgKHVuZGlyZWN0ZWQpIHtcbiAgICBzb3VyY2VEYXRhLnVuZGlyZWN0ZWREZWdyZWUrKztcbiAgICB0YXJnZXREYXRhLnVuZGlyZWN0ZWREZWdyZWUrKztcblxuICAgIGlmIChpc1NlbGZMb29wKSB7XG4gICAgICBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRMb29wcysrO1xuICAgICAgZ3JhcGguX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50Kys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNvdXJjZURhdGEub3V0RGVncmVlKys7XG4gICAgdGFyZ2V0RGF0YS5pbkRlZ3JlZSsrO1xuXG4gICAgaWYgKGlzU2VsZkxvb3ApIHtcbiAgICAgIHNvdXJjZURhdGEuZGlyZWN0ZWRMb29wcysrO1xuICAgICAgZ3JhcGguX2RpcmVjdGVkU2VsZkxvb3BDb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0aW5nIHJlbGV2YW50IGluZGV4XG4gIGlmIChncmFwaC5tdWx0aSkgZWRnZURhdGEuYXR0YWNoTXVsdGkoKTtcbiAgZWxzZSBlZGdlRGF0YS5hdHRhY2goKTtcblxuICBpZiAodW5kaXJlY3RlZCkgZ3JhcGguX3VuZGlyZWN0ZWRTaXplKys7XG4gIGVsc2UgZ3JhcGguX2RpcmVjdGVkU2l6ZSsrO1xuXG4gIC8vIEVtaXR0aW5nXG4gIGV2ZW50RGF0YS5rZXkgPSBlZGdlO1xuXG4gIGdyYXBoLmVtaXQoJ2VkZ2VBZGRlZCcsIGV2ZW50RGF0YSk7XG5cbiAgcmV0dXJuIFtlZGdlLCB0cnVlLCBzb3VyY2VXYXNBZGRlZCwgdGFyZ2V0V2FzQWRkZWRdO1xufVxuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCB1c2VkIHRvIGRyb3AgYW4gZWRnZS5cbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICAgZ3JhcGggICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHtFZGdlRGF0YX0gZWRnZURhdGEgLSBEYXRhIG9mIHRoZSBlZGdlIHRvIGRyb3AuXG4gKi9cbmZ1bmN0aW9uIGRyb3BFZGdlRnJvbURhdGEoZ3JhcGgsIGVkZ2VEYXRhKSB7XG4gIC8vIERyb3BwaW5nIHRoZSBlZGdlIGZyb20gdGhlIHJlZ2lzdGVyXG4gIGdyYXBoLl9lZGdlcy5kZWxldGUoZWRnZURhdGEua2V5KTtcblxuICAvLyBVcGRhdGluZyByZWxhdGVkIGRlZ3JlZXNcbiAgY29uc3Qge3NvdXJjZTogc291cmNlRGF0YSwgdGFyZ2V0OiB0YXJnZXREYXRhLCBhdHRyaWJ1dGVzfSA9IGVkZ2VEYXRhO1xuXG4gIGNvbnN0IHVuZGlyZWN0ZWQgPSBlZGdlRGF0YS51bmRpcmVjdGVkO1xuXG4gIGNvbnN0IGlzU2VsZkxvb3AgPSBzb3VyY2VEYXRhID09PSB0YXJnZXREYXRhO1xuXG4gIGlmICh1bmRpcmVjdGVkKSB7XG4gICAgc291cmNlRGF0YS51bmRpcmVjdGVkRGVncmVlLS07XG4gICAgdGFyZ2V0RGF0YS51bmRpcmVjdGVkRGVncmVlLS07XG5cbiAgICBpZiAoaXNTZWxmTG9vcCkge1xuICAgICAgc291cmNlRGF0YS51bmRpcmVjdGVkTG9vcHMtLTtcbiAgICAgIGdyYXBoLl91bmRpcmVjdGVkU2VsZkxvb3BDb3VudC0tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzb3VyY2VEYXRhLm91dERlZ3JlZS0tO1xuICAgIHRhcmdldERhdGEuaW5EZWdyZWUtLTtcblxuICAgIGlmIChpc1NlbGZMb29wKSB7XG4gICAgICBzb3VyY2VEYXRhLmRpcmVjdGVkTG9vcHMtLTtcbiAgICAgIGdyYXBoLl9kaXJlY3RlZFNlbGZMb29wQ291bnQtLTtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhcmluZyBpbmRleFxuICBpZiAoZ3JhcGgubXVsdGkpIGVkZ2VEYXRhLmRldGFjaE11bHRpKCk7XG4gIGVsc2UgZWRnZURhdGEuZGV0YWNoKCk7XG5cbiAgaWYgKHVuZGlyZWN0ZWQpIGdyYXBoLl91bmRpcmVjdGVkU2l6ZS0tO1xuICBlbHNlIGdyYXBoLl9kaXJlY3RlZFNpemUtLTtcblxuICAvLyBFbWl0dGluZ1xuICBncmFwaC5lbWl0KCdlZGdlRHJvcHBlZCcsIHtcbiAgICBrZXk6IGVkZ2VEYXRhLmtleSxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIHNvdXJjZTogc291cmNlRGF0YS5rZXksXG4gICAgdGFyZ2V0OiB0YXJnZXREYXRhLmtleSxcbiAgICB1bmRpcmVjdGVkXG4gIH0pO1xufVxuXG4vKipcbiAqIEdyYXBoIGNsYXNzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gIHtvYmplY3R9ICBbb3B0aW9uc10gLSBPcHRpb25zOlxuICogQHBhcmFtICB7Ym9vbGVhbn0gICBbYWxsb3dTZWxmTG9vcHNdIC0gQWxsb3cgc2VsZiBsb29wcz9cbiAqIEBwYXJhbSAge3N0cmluZ30gICAgW3R5cGVdICAgICAgICAgICAtIFR5cGUgb2YgdGhlIGdyYXBoLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gICBbbWFwXSAgICAgICAgICAgIC0gQWxsb3cgcmVmZXJlbmNlcyBhcyBrZXlzP1xuICogQHBhcmFtICB7Ym9vbGVhbn0gICBbbXVsdGldICAgICAgICAgIC0gQWxsb3cgcGFyYWxsZWwgZWRnZXM/XG4gKlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgYXJndW1lbnRzIGFyZSBub3QgdmFsaWQuXG4gKi9cbmNsYXNzIEdyYXBoIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvLy0tIFNvbHZpbmcgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIERFRkFVTFRTLCBvcHRpb25zKTtcblxuICAgIC8vIEVuZm9yY2luZyBvcHRpb25zIHZhbGlkaXR5XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLm11bHRpICE9PSAnYm9vbGVhbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5jb25zdHJ1Y3RvcjogaW52YWxpZCAnbXVsdGknIG9wdGlvbi4gRXhwZWN0aW5nIGEgYm9vbGVhbiBidXQgZ290IFwiJHtvcHRpb25zLm11bHRpfVwiLmBcbiAgICAgICk7XG5cbiAgICBpZiAoIVRZUEVTLmhhcyhvcHRpb25zLnR5cGUpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguY29uc3RydWN0b3I6IGludmFsaWQgJ3R5cGUnIG9wdGlvbi4gU2hvdWxkIGJlIG9uZSBvZiBcIm1peGVkXCIsIFwiZGlyZWN0ZWRcIiBvciBcInVuZGlyZWN0ZWRcIiBidXQgZ290IFwiJHtvcHRpb25zLnR5cGV9XCIuYFxuICAgICAgKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvd1NlbGZMb29wcyAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguY29uc3RydWN0b3I6IGludmFsaWQgJ2FsbG93U2VsZkxvb3BzJyBvcHRpb24uIEV4cGVjdGluZyBhIGJvb2xlYW4gYnV0IGdvdCBcIiR7b3B0aW9ucy5hbGxvd1NlbGZMb29wc31cIi5gXG4gICAgICApO1xuXG4gICAgLy8tLSBQcml2YXRlIHByb3BlcnRpZXNcblxuICAgIC8vIFV0aWxpdGllc1xuICAgIGNvbnN0IE5vZGVEYXRhQ2xhc3MgPVxuICAgICAgb3B0aW9ucy50eXBlID09PSAnbWl4ZWQnXG4gICAgICAgID8gTWl4ZWROb2RlRGF0YVxuICAgICAgICA6IG9wdGlvbnMudHlwZSA9PT0gJ2RpcmVjdGVkJ1xuICAgICAgICA/IERpcmVjdGVkTm9kZURhdGFcbiAgICAgICAgOiBVbmRpcmVjdGVkTm9kZURhdGE7XG5cbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ05vZGVEYXRhQ2xhc3MnLCBOb2RlRGF0YUNsYXNzKTtcblxuICAgIC8vIEludGVybmFsIGVkZ2Uga2V5IGdlbmVyYXRvclxuXG4gICAgLy8gTk9URTogdGhpcyBpbnRlcm5hbCBnZW5lcmF0b3IgcHJvZHVjZSBrZXlzIHRoYXQgYXJlIHN0cmluZ3NcbiAgICAvLyBjb21wb3NlZCBvZiBhIHdlaXJkIHByZWZpeCwgYW4gaW5jcmVtZW50YWwgaW5zdGFuY2UgaWQgc3RhcnRpbmcgZnJvbVxuICAgIC8vIGEgcmFuZG9tIGJ5dGUgYW5kIGZpbmFsbHkgYW4gaW50ZXJuYWwgaW5zdGFuY2UgaW5jcmVtZW50YWwgaWQuXG4gICAgLy8gQWxsIHRoaXMgdG8gYXZvaWQgaW50cmEtZnJhbWUgYW5kIGNyb3NzLWZyYW1lIGFkdmVyc2FyaWFsIGlucHV0c1xuICAgIC8vIHRoYXQgY2FuIGZvcmNlIGEgc2luZ2xlICMuYWRkRWRnZSBjYWxsIHRvIGRlZ2VuZXJhdGUgaW50byBhIE8obilcbiAgICAvLyBhdmFpbGFibGUga2V5IHNlYXJjaCBsb29wLlxuXG4gICAgLy8gSXQgYWxzbyBlbnN1cmVzIHRoYXQgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZWRnZSBrZXlzIGFyZSB1bmxpa2VseVxuICAgIC8vIHRvIHByb2R1Y2UgY29sbGlzaW9ucyB3aXRoIGFyYml0cmFyeSBrZXlzIGdpdmVuIGJ5IHVzZXJzLlxuICAgIGNvbnN0IGluc3RhbmNlUHJlZml4ID0gJ2dlaWRfJyArIElOU1RBTkNFX0lEKCkgKyAnXyc7XG4gICAgbGV0IGVkZ2VJZCA9IDA7XG5cbiAgICBjb25zdCBlZGdlS2V5R2VuZXJhdG9yID0gKCkgPT4ge1xuICAgICAgbGV0IGF2YWlsYWJsZUVkZ2VLZXk7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgYXZhaWxhYmxlRWRnZUtleSA9IGluc3RhbmNlUHJlZml4ICsgZWRnZUlkKys7XG4gICAgICB9IHdoaWxlICh0aGlzLl9lZGdlcy5oYXMoYXZhaWxhYmxlRWRnZUtleSkpO1xuXG4gICAgICByZXR1cm4gYXZhaWxhYmxlRWRnZUtleTtcbiAgICB9O1xuXG4gICAgLy8gSW5kZXhlc1xuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnX2F0dHJpYnV0ZXMnLCB7fSk7XG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfbm9kZXMnLCBuZXcgTWFwKCkpO1xuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnX2VkZ2VzJywgbmV3IE1hcCgpKTtcbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ19kaXJlY3RlZFNpemUnLCAwKTtcbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ191bmRpcmVjdGVkU2l6ZScsIDApO1xuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnX2RpcmVjdGVkU2VsZkxvb3BDb3VudCcsIDApO1xuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50JywgMCk7XG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfZWRnZUtleUdlbmVyYXRvcicsIGVkZ2VLZXlHZW5lcmF0b3IpO1xuXG4gICAgLy8gT3B0aW9uc1xuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnX29wdGlvbnMnLCBvcHRpb25zKTtcblxuICAgIC8vIEVtaXR0ZXIgcHJvcGVydGllc1xuICAgIEVNSVRURVJfUFJPUFMuZm9yRWFjaChwcm9wID0+IHByaXZhdGVQcm9wZXJ0eSh0aGlzLCBwcm9wLCB0aGlzW3Byb3BdKSk7XG5cbiAgICAvLy0tIFByb3BlcnRpZXMgcmVhZGVyc1xuICAgIHJlYWRPbmx5UHJvcGVydHkodGhpcywgJ29yZGVyJywgKCkgPT4gdGhpcy5fbm9kZXMuc2l6ZSk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eSh0aGlzLCAnc2l6ZScsICgpID0+IHRoaXMuX2VkZ2VzLnNpemUpO1xuICAgIHJlYWRPbmx5UHJvcGVydHkodGhpcywgJ2RpcmVjdGVkU2l6ZScsICgpID0+IHRoaXMuX2RpcmVjdGVkU2l6ZSk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eSh0aGlzLCAndW5kaXJlY3RlZFNpemUnLCAoKSA9PiB0aGlzLl91bmRpcmVjdGVkU2l6ZSk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICAnc2VsZkxvb3BDb3VudCcsXG4gICAgICAoKSA9PiB0aGlzLl9kaXJlY3RlZFNlbGZMb29wQ291bnQgKyB0aGlzLl91bmRpcmVjdGVkU2VsZkxvb3BDb3VudFxuICAgICk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICAnZGlyZWN0ZWRTZWxmTG9vcENvdW50JyxcbiAgICAgICgpID0+IHRoaXMuX2RpcmVjdGVkU2VsZkxvb3BDb3VudFxuICAgICk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICAndW5kaXJlY3RlZFNlbGZMb29wQ291bnQnLFxuICAgICAgKCkgPT4gdGhpcy5fdW5kaXJlY3RlZFNlbGZMb29wQ291bnRcbiAgICApO1xuICAgIHJlYWRPbmx5UHJvcGVydHkodGhpcywgJ211bHRpJywgdGhpcy5fb3B0aW9ucy5tdWx0aSk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHRoaXMuX29wdGlvbnMudHlwZSk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eSh0aGlzLCAnYWxsb3dTZWxmTG9vcHMnLCB0aGlzLl9vcHRpb25zLmFsbG93U2VsZkxvb3BzKTtcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICdpbXBsZW1lbnRhdGlvbicsICgpID0+ICdncmFwaG9sb2d5Jyk7XG4gIH1cblxuICBfcmVzZXRJbnN0YW5jZUNvdW50ZXJzKCkge1xuICAgIHRoaXMuX2RpcmVjdGVkU2l6ZSA9IDA7XG4gICAgdGhpcy5fdW5kaXJlY3RlZFNpemUgPSAwO1xuICAgIHRoaXMuX2RpcmVjdGVkU2VsZkxvb3BDb3VudCA9IDA7XG4gICAgdGhpcy5fdW5kaXJlY3RlZFNlbGZMb29wQ291bnQgPSAwO1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFJlYWRcbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUgaXMgZm91bmQgaW4gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuaGFzKCcnICsgbm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHRoZSBnaXZlbiBkaXJlY3RlZCBlZGdlIGlzIGZvdW5kIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQXJpdHkgMTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgLSBUaGUgZWRnZSdzIHNvdXJjZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0IC0gVGhlIGVkZ2UncyB0YXJnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGFyZ3VtZW50cyBhcmUgaW52YWxpZC5cbiAgICovXG4gIGhhc0RpcmVjdGVkRWRnZShzb3VyY2UsIHRhcmdldCkge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgZWRnZSA9ICcnICsgc291cmNlO1xuXG4gICAgICBjb25zdCBlZGdlRGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgICAgcmV0dXJuICEhZWRnZURhdGEgJiYgIWVkZ2VEYXRhLnVuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgICAvLyBJZiB0aGUgbm9kZSBzb3VyY2Ugb3IgdGhlIHRhcmdldCBpcyBub3QgaW4gdGhlIGdyYXBoIHdlIGJyZWFrXG4gICAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAoIW5vZGVEYXRhKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIElzIHRoZXJlIGEgZGlyZWN0ZWQgZWRnZSBwb2ludGluZyB0b3dhcmQgdGFyZ2V0P1xuICAgICAgcmV0dXJuIG5vZGVEYXRhLm91dC5oYXNPd25Qcm9wZXJ0eSh0YXJnZXQpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC5oYXNEaXJlY3RlZEVkZ2U6IGludmFsaWQgYXJpdHkgKCR7YXJndW1lbnRzLmxlbmd0aH0sIGluc3RlYWQgb2YgMSBvciAyKS4gWW91IGNhbiBlaXRoZXIgYXNrIGZvciBhbiBlZGdlIGlkIG9yIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIGVkZ2UgYmV0d2VlbiBhIHNvdXJjZSAmIGEgdGFyZ2V0LmBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdW5kaXJlY3RlZCBlZGdlIGlzIGZvdW5kIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQXJpdHkgMTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgLSBUaGUgZWRnZSdzIHNvdXJjZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0IC0gVGhlIGVkZ2UncyB0YXJnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGFyZ3VtZW50cyBhcmUgaW52YWxpZC5cbiAgICovXG4gIGhhc1VuZGlyZWN0ZWRFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodGhpcy50eXBlID09PSAnZGlyZWN0ZWQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgZWRnZSA9ICcnICsgc291cmNlO1xuXG4gICAgICBjb25zdCBlZGdlRGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgICAgcmV0dXJuICEhZWRnZURhdGEgJiYgZWRnZURhdGEudW5kaXJlY3RlZDtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICAgIC8vIElmIHRoZSBub2RlIHNvdXJjZSBvciB0aGUgdGFyZ2V0IGlzIG5vdCBpbiB0aGUgZ3JhcGggd2UgYnJlYWtcbiAgICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICghbm9kZURhdGEpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gSXMgdGhlcmUgYSBkaXJlY3RlZCBlZGdlIHBvaW50aW5nIHRvd2FyZCB0YXJnZXQ/XG4gICAgICByZXR1cm4gbm9kZURhdGEudW5kaXJlY3RlZC5oYXNPd25Qcm9wZXJ0eSh0YXJnZXQpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC5oYXNEaXJlY3RlZEVkZ2U6IGludmFsaWQgYXJpdHkgKCR7YXJndW1lbnRzLmxlbmd0aH0sIGluc3RlYWQgb2YgMSBvciAyKS4gWW91IGNhbiBlaXRoZXIgYXNrIGZvciBhbiBlZGdlIGlkIG9yIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIGVkZ2UgYmV0d2VlbiBhIHNvdXJjZSAmIGEgdGFyZ2V0LmBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gZWRnZSBpcyBmb3VuZCBpbiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEFyaXR5IDE6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlIC0gVGhlIGVkZ2UncyBzb3VyY2UuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAtIFRoZSBlZGdlJ3MgdGFyZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBhcmd1bWVudHMgYXJlIGludmFsaWQuXG4gICAqL1xuICBoYXNFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGVkZ2UgPSAnJyArIHNvdXJjZTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2VkZ2VzLmhhcyhlZGdlKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICAgIC8vIElmIHRoZSBub2RlIHNvdXJjZSBvciB0aGUgdGFyZ2V0IGlzIG5vdCBpbiB0aGUgZ3JhcGggd2UgYnJlYWtcbiAgICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICghbm9kZURhdGEpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gSXMgdGhlcmUgYSBkaXJlY3RlZCBlZGdlIHBvaW50aW5nIHRvd2FyZCB0YXJnZXQ/XG4gICAgICByZXR1cm4gKFxuICAgICAgICAodHlwZW9mIG5vZGVEYXRhLm91dCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICBub2RlRGF0YS5vdXQuaGFzT3duUHJvcGVydHkodGFyZ2V0KSkgfHxcbiAgICAgICAgKHR5cGVvZiBub2RlRGF0YS51bmRpcmVjdGVkICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgIG5vZGVEYXRhLnVuZGlyZWN0ZWQuaGFzT3duUHJvcGVydHkodGFyZ2V0KSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLmhhc0VkZ2U6IGludmFsaWQgYXJpdHkgKCR7YXJndW1lbnRzLmxlbmd0aH0sIGluc3RlYWQgb2YgMSBvciAyKS4gWW91IGNhbiBlaXRoZXIgYXNrIGZvciBhbiBlZGdlIGlkIG9yIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIGVkZ2UgYmV0d2VlbiBhIHNvdXJjZSAmIGEgdGFyZ2V0LmBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGVkZ2UgbWF0Y2hpbmcgc291cmNlICYgdGFyZ2V0IGluIGEgZGlyZWN0ZWQgZmFzaGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSBzb3VyY2UgLSBUaGUgZWRnZSdzIHNvdXJjZS5cbiAgICogQHBhcmFtICB7YW55fSB0YXJnZXQgLSBUaGUgZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHJldHVybiB7YW55fHVuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ3JhcGggaXMgbXVsdGkuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgc291cmNlIG9yIHRhcmdldCBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZGlyZWN0ZWRFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm47XG5cbiAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmRpcmVjdGVkRWRnZTogdGhpcyBtZXRob2QgaXMgaXJyZWxldmFudCB3aXRoIG11bHRpZ3JhcGhzIHNpbmNlIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0LiBTZWUgIy5kaXJlY3RlZEVkZ2VzIGluc3RlYWQuJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IHNvdXJjZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgIGlmICghc291cmNlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKCF0aGlzLl9ub2Rlcy5oYXModGFyZ2V0KSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7dGFyZ2V0fVwiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgY29uc3QgZWRnZURhdGEgPSAoc291cmNlRGF0YS5vdXQgJiYgc291cmNlRGF0YS5vdXRbdGFyZ2V0XSkgfHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKGVkZ2VEYXRhKSByZXR1cm4gZWRnZURhdGEua2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGVkZ2UgbWF0Y2hpbmcgc291cmNlICYgdGFyZ2V0IGluIGEgdW5kaXJlY3RlZCBmYXNoaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9IHNvdXJjZSAtIFRoZSBlZGdlJ3Mgc291cmNlLlxuICAgKiBAcGFyYW0gIHthbnl9IHRhcmdldCAtIFRoZSBlZGdlJ3MgdGFyZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl8dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBncmFwaCBpcyBtdWx0aS5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICB1bmRpcmVjdGVkRWRnZShzb3VyY2UsIHRhcmdldCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09ICdkaXJlY3RlZCcpIHJldHVybjtcblxuICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgudW5kaXJlY3RlZEVkZ2U6IHRoaXMgbWV0aG9kIGlzIGlycmVsZXZhbnQgd2l0aCBtdWx0aWdyYXBocyBzaW5jZSB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZSBlZGdlcyBiZXR3ZWVuIHNvdXJjZSAmIHRhcmdldC4gU2VlICMudW5kaXJlY3RlZEVkZ2VzIGluc3RlYWQuJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IHNvdXJjZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgIGlmICghc291cmNlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC51bmRpcmVjdGVkRWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyh0YXJnZXQpKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLnVuZGlyZWN0ZWRFZGdlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3RhcmdldH1cIiB0YXJnZXQgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGNvbnN0IGVkZ2VEYXRhID1cbiAgICAgIChzb3VyY2VEYXRhLnVuZGlyZWN0ZWQgJiYgc291cmNlRGF0YS51bmRpcmVjdGVkW3RhcmdldF0pIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChlZGdlRGF0YSkgcmV0dXJuIGVkZ2VEYXRhLmtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBlZGdlIG1hdGNoaW5nIHNvdXJjZSAmIHRhcmdldCBpbiBhIG1peGVkIGZhc2hpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gc291cmNlIC0gVGhlIGVkZ2UncyBzb3VyY2UuXG4gICAqIEBwYXJhbSAge2FueX0gdGFyZ2V0IC0gVGhlIGVkZ2UncyB0YXJnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge2FueXx1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGdyYXBoIGlzIG11bHRpLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHNvdXJjZSBvciB0YXJnZXQgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGVkZ2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5lZGdlOiB0aGlzIG1ldGhvZCBpcyBpcnJlbGV2YW50IHdpdGggbXVsdGlncmFwaHMgc2luY2UgdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgZWRnZXMgYmV0d2VlbiBzb3VyY2UgJiB0YXJnZXQuIFNlZSAjLmVkZ2VzIGluc3RlYWQuJ1xuICAgICAgKTtcblxuICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgaWYgKCFzb3VyY2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKCF0aGlzLl9ub2Rlcy5oYXModGFyZ2V0KSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5lZGdlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3RhcmdldH1cIiB0YXJnZXQgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGNvbnN0IGVkZ2VEYXRhID1cbiAgICAgIChzb3VyY2VEYXRhLm91dCAmJiBzb3VyY2VEYXRhLm91dFt0YXJnZXRdKSB8fFxuICAgICAgKHNvdXJjZURhdGEudW5kaXJlY3RlZCAmJiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRbdGFyZ2V0XSkgfHxcbiAgICAgIHVuZGVmaW5lZDtcblxuICAgIGlmIChlZGdlRGF0YSkgcmV0dXJuIGVkZ2VEYXRhLmtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdHdvIG5vZGVzIGFyZSBkaXJlY3RlZCBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5laWdoYm9yIC0gVGhlIG5laWdoYm9yJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGFyZURpcmVjdGVkTmVpZ2hib3JzKG5vZGUsIG5laWdoYm9yKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBuZWlnaGJvciA9ICcnICsgbmVpZ2hib3I7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguYXJlRGlyZWN0ZWROZWlnaGJvcnM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gbmVpZ2hib3IgaW4gbm9kZURhdGEuaW4gfHwgbmVpZ2hib3IgaW4gbm9kZURhdGEub3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0d28gbm9kZXMgYXJlIG91dCBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5laWdoYm9yIC0gVGhlIG5laWdoYm9yJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGFyZU91dE5laWdoYm9ycyhub2RlLCBuZWlnaGJvcikge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG4gICAgbmVpZ2hib3IgPSAnJyArIG5laWdoYm9yO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmFyZU91dE5laWdoYm9yczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBuZWlnaGJvciBpbiBub2RlRGF0YS5vdXQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHR3byBub2RlcyBhcmUgaW4gbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBuZWlnaGJvciAtIFRoZSBuZWlnaGJvcidzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBhcmVJbk5laWdoYm9ycyhub2RlLCBuZWlnaGJvcikge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG4gICAgbmVpZ2hib3IgPSAnJyArIG5laWdoYm9yO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmFyZUluTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIG5laWdoYm9yIGluIG5vZGVEYXRhLmluO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0d28gbm9kZXMgYXJlIHVuZGlyZWN0ZWQgbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBuZWlnaGJvciAtIFRoZSBuZWlnaGJvcidzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBhcmVVbmRpcmVjdGVkTmVpZ2hib3JzKG5vZGUsIG5laWdoYm9yKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBuZWlnaGJvciA9ICcnICsgbmVpZ2hib3I7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguYXJlVW5kaXJlY3RlZE5laWdoYm9yczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAnZGlyZWN0ZWQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gbmVpZ2hib3IgaW4gbm9kZURhdGEudW5kaXJlY3RlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdHdvIG5vZGVzIGFyZSBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5laWdoYm9yIC0gVGhlIG5laWdoYm9yJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGFyZU5laWdoYm9ycyhub2RlLCBuZWlnaGJvcikge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG4gICAgbmVpZ2hib3IgPSAnJyArIG5laWdoYm9yO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmFyZU5laWdoYm9yczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGlmIChuZWlnaGJvciBpbiBub2RlRGF0YS5pbiB8fCBuZWlnaGJvciBpbiBub2RlRGF0YS5vdXQpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGlmIChuZWlnaGJvciBpbiBub2RlRGF0YS51bmRpcmVjdGVkKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHR3byBub2RlcyBhcmUgaW5ib3VuZCBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5laWdoYm9yIC0gVGhlIG5laWdoYm9yJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGFyZUluYm91bmROZWlnaGJvcnMobm9kZSwgbmVpZ2hib3IpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIG5laWdoYm9yID0gJycgKyBuZWlnaGJvcjtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5hcmVJbmJvdW5kTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgaWYgKG5laWdoYm9yIGluIG5vZGVEYXRhLmluKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBpZiAobmVpZ2hib3IgaW4gbm9kZURhdGEudW5kaXJlY3RlZCkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0d28gbm9kZXMgYXJlIG91dGJvdW5kIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbmVpZ2hib3IgLSBUaGUgbmVpZ2hib3IncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgYXJlT3V0Ym91bmROZWlnaGJvcnMobm9kZSwgbmVpZ2hib3IpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIG5laWdoYm9yID0gJycgKyBuZWlnaGJvcjtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5hcmVPdXRib3VuZE5laWdoYm9yczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGlmIChuZWlnaGJvciBpbiBub2RlRGF0YS5vdXQpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGlmIChuZWlnaGJvciBpbiBub2RlRGF0YS51bmRpcmVjdGVkKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgaW5EZWdyZWUobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguaW5EZWdyZWU6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gMDtcblxuICAgIHJldHVybiBub2RlRGF0YS5pbkRlZ3JlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3Mgb3V0IGRlZ3JlZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgb3V0RGVncmVlKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLm91dERlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIG5vZGVEYXRhLm91dERlZ3JlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgZGlyZWN0ZWQgZGVncmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBkaXJlY3RlZERlZ3JlZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kaXJlY3RlZERlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIG5vZGVEYXRhLmluRGVncmVlICsgbm9kZURhdGEub3V0RGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyB1bmRpcmVjdGVkIGRlZ3JlZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgdW5kaXJlY3RlZERlZ3JlZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC51bmRpcmVjdGVkRGVncmVlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICdkaXJlY3RlZCcpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIG5vZGVEYXRhLnVuZGlyZWN0ZWREZWdyZWU7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIGluYm91bmQgZGVncmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluYm91bmQgZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGluYm91bmREZWdyZWUobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguaW5ib3VuZERlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBsZXQgZGVncmVlID0gMDtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS51bmRpcmVjdGVkRGVncmVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLmluRGVncmVlO1xuICAgIH1cblxuICAgIHJldHVybiBkZWdyZWU7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIG91dGJvdW5kIGRlZ3JlZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBvdXRib3VuZCBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgb3V0Ym91bmREZWdyZWUobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgub3V0Ym91bmREZWdyZWU6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgbGV0IGRlZ3JlZSA9IDA7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS5vdXREZWdyZWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZ3JlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgZGlyZWN0ZWQgZGVncmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBkZWdyZWUobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZGVncmVlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGxldCBkZWdyZWUgPSAwO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWREZWdyZWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEuaW5EZWdyZWUgKyBub2RlRGF0YS5vdXREZWdyZWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZ3JlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgaW4gZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgaW5EZWdyZWVXaXRob3V0U2VsZkxvb3BzKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmluRGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIG5vZGVEYXRhLmluRGVncmVlIC0gbm9kZURhdGEuZGlyZWN0ZWRMb29wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3Mgb3V0IGRlZ3JlZSB3aXRob3V0IGNvbnNpZGVyaW5nIHNlbGYgbG9vcHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW4gZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIG91dERlZ3JlZVdpdGhvdXRTZWxmTG9vcHMobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgub3V0RGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIG5vZGVEYXRhLm91dERlZ3JlZSAtIG5vZGVEYXRhLmRpcmVjdGVkTG9vcHM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIGRpcmVjdGVkIGRlZ3JlZSB3aXRob3V0IGNvbnNpZGVyaW5nIHNlbGYgbG9vcHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW4gZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGRpcmVjdGVkRGVncmVlV2l0aG91dFNlbGZMb29wcyhub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kaXJlY3RlZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gMDtcblxuICAgIHJldHVybiBub2RlRGF0YS5pbkRlZ3JlZSArIG5vZGVEYXRhLm91dERlZ3JlZSAtIG5vZGVEYXRhLmRpcmVjdGVkTG9vcHMgKiAyO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyB1bmRpcmVjdGVkIGRlZ3JlZSB3aXRob3V0IGNvbnNpZGVyaW5nIHNlbGYgbG9vcHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW4gZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIHVuZGlyZWN0ZWREZWdyZWVXaXRob3V0U2VsZkxvb3BzKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLnVuZGlyZWN0ZWREZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICdkaXJlY3RlZCcpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIG5vZGVEYXRhLnVuZGlyZWN0ZWREZWdyZWUgLSBub2RlRGF0YS51bmRpcmVjdGVkTG9vcHMgKiAyO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBpbmJvdW5kIGRlZ3JlZSB3aXRob3V0IGNvbnNpZGVyaW5nIHNlbGYgbG9vcHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW5ib3VuZCBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgaW5ib3VuZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHMobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguaW5ib3VuZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgbGV0IGRlZ3JlZSA9IDA7XG4gICAgbGV0IGxvb3BzID0gMDtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS51bmRpcmVjdGVkRGVncmVlO1xuICAgICAgbG9vcHMgKz0gbm9kZURhdGEudW5kaXJlY3RlZExvb3BzICogMjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS5pbkRlZ3JlZTtcbiAgICAgIGxvb3BzICs9IG5vZGVEYXRhLmRpcmVjdGVkTG9vcHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZ3JlZSAtIGxvb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBvdXRib3VuZCBkZWdyZWUgd2l0aG91dCBjb25zaWRlcmluZyBzZWxmIGxvb3BzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIG91dGJvdW5kIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBvdXRib3VuZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHMobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgub3V0Ym91bmREZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGxldCBkZWdyZWUgPSAwO1xuICAgIGxldCBsb29wcyA9IDA7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZTtcbiAgICAgIGxvb3BzICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWRMb29wcyAqIDI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEub3V0RGVncmVlO1xuICAgICAgbG9vcHMgKz0gbm9kZURhdGEuZGlyZWN0ZWRMb29wcztcbiAgICB9XG5cbiAgICByZXR1cm4gZGVncmVlIC0gbG9vcHM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIGRpcmVjdGVkIGRlZ3JlZSB3aXRob3V0IGNvbnNpZGVyaW5nIHNlbGYgbG9vcHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGRlZ3JlZVdpdGhvdXRTZWxmTG9vcHMobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBsZXQgZGVncmVlID0gMDtcbiAgICBsZXQgbG9vcHMgPSAwO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWREZWdyZWU7XG4gICAgICBsb29wcyArPSBub2RlRGF0YS51bmRpcmVjdGVkTG9vcHMgKiAyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLmluRGVncmVlICsgbm9kZURhdGEub3V0RGVncmVlO1xuICAgICAgbG9vcHMgKz0gbm9kZURhdGEuZGlyZWN0ZWRMb29wcyAqIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZ3JlZSAtIGxvb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIGVkZ2UncyBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHthbnl9ICAgICAgLSBUaGUgZWRnZSdzIHNvdXJjZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBzb3VyY2UoZWRnZSkge1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKCFkYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLnNvdXJjZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICByZXR1cm4gZGF0YS5zb3VyY2Uua2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIGVkZ2UncyB0YXJnZXQuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHthbnl9ICAgICAgLSBUaGUgZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICB0YXJnZXQoZWRnZSkge1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKCFkYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLnRhcmdldDogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICByZXR1cm4gZGF0YS50YXJnZXQua2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIGVkZ2UncyBleHRyZW1pdGllcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgIGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgLSBUaGUgZWRnZSdzIGV4dHJlbWl0aWVzLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGV4dHJlbWl0aWVzKGVkZ2UpIHtcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgY29uc3QgZWRnZURhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoIWVkZ2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmV4dHJlbWl0aWVzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIHJldHVybiBbZWRnZURhdGEuc291cmNlLmtleSwgZWRnZURhdGEudGFyZ2V0LmtleV07XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBub2RlICYgYW4gZWRnZSwgcmV0dXJucyB0aGUgb3RoZXIgZXh0cmVtaXR5IG9mIHRoZSBlZGdlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHthbnl9ICAgICAgICAtIFRoZSByZWxhdGVkIG5vZGUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgaXNuJ3QgaW4gdGhlIGdyYXBoIG9yIGlmIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICBlZGdlICYgbm9kZSBhcmUgbm90IHJlbGF0ZWQuXG4gICAqL1xuICBvcHBvc2l0ZShub2RlLCBlZGdlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmICghZGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5vcHBvc2l0ZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBjb25zdCBzb3VyY2UgPSBkYXRhLnNvdXJjZS5rZXk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZGF0YS50YXJnZXQua2V5O1xuXG4gICAgaWYgKG5vZGUgPT09IHNvdXJjZSkgcmV0dXJuIHRhcmdldDtcbiAgICBpZiAobm9kZSA9PT0gdGFyZ2V0KSByZXR1cm4gc291cmNlO1xuXG4gICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC5vcHBvc2l0ZTogdGhlIFwiJHtub2RlfVwiIG5vZGUgaXMgbm90IGF0dGFjaGVkIHRvIHRoZSBcIiR7ZWRnZX1cIiBlZGdlICgke3NvdXJjZX0sICR7dGFyZ2V0fSkuYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBlZGdlIGhhcyB0aGUgZ2l2ZW4gbm9kZSBhcyBleHRyZW1pdHkuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgIC0gVGhlIHJlbGF0ZWQgbm9kZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBlaXRoZXIgdGhlIG5vZGUgb3IgdGhlIGVkZ2UgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgaGFzRXh0cmVtaXR5KGVkZ2UsIG5vZGUpIHtcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKCFkYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmhhc0V4dHJlbWl0eTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICByZXR1cm4gZGF0YS5zb3VyY2Uua2V5ID09PSBub2RlIHx8IGRhdGEudGFyZ2V0LmtleSA9PT0gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdGhlIGdpdmVuIGVkZ2UgaXMgdW5kaXJlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGlzVW5kaXJlY3RlZChlZGdlKSB7XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoIWRhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguaXNVbmRpcmVjdGVkOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIHJldHVybiBkYXRhLnVuZGlyZWN0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHRoZSBnaXZlbiBlZGdlIGlzIGRpcmVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgaXNEaXJlY3RlZChlZGdlKSB7XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoIWRhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguaXNEaXJlY3RlZDogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICByZXR1cm4gIWRhdGEudW5kaXJlY3RlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdGhlIGdpdmVuIGVkZ2UgaXMgYSBzZWxmIGxvb3AuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBpc1NlbGZMb29wKGVkZ2UpIHtcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmICghZGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pc1NlbGZMb29wOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIHJldHVybiBkYXRhLnNvdXJjZSA9PT0gZGF0YS50YXJnZXQ7XG4gIH1cblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogTXV0YXRpb25cbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byBhZGQgYSBub2RlIHRvIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICBub2RlICAgICAgICAgLSBUaGUgbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBbYXR0cmlidXRlc10gLSBPcHRpb25hbCBhdHRyaWJ1dGVzLlxuICAgKiBAcmV0dXJuIHthbnl9ICAgICAgICAgICAgICAgICAtIFRoZSBub2RlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBnaXZlbiBub2RlIGFscmVhZHkgZXhpc3QuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbiBvYmplY3QuXG4gICAqL1xuICBhZGROb2RlKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IGFkZE5vZGUodGhpcywgbm9kZSwgYXR0cmlidXRlcyk7XG5cbiAgICByZXR1cm4gbm9kZURhdGEua2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIG1lcmdlIGEgbm9kZSBpbnRvIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICBub2RlICAgICAgICAgLSBUaGUgbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBbYXR0cmlidXRlc10gLSBPcHRpb25hbCBhdHRyaWJ1dGVzLlxuICAgKiBAcmV0dXJuIHthbnl9ICAgICAgICAgICAgICAgICAtIFRoZSBub2RlLlxuICAgKi9cbiAgbWVyZ2VOb2RlKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoYXR0cmlidXRlcyAmJiAhaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLm1lcmdlTm9kZTogaW52YWxpZCBhdHRyaWJ1dGVzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIke2F0dHJpYnV0ZXN9XCJgXG4gICAgICApO1xuXG4gICAgLy8gU3RyaW5nIGNvZXJjaW9uXG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcblxuICAgIC8vIElmIHRoZSBub2RlIGFscmVhZHkgZXhpc3RzLCB3ZSBtZXJnZSB0aGUgYXR0cmlidXRlc1xuICAgIGxldCBkYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGFzc2lnbihkYXRhLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgICAgIHRoaXMuZW1pdCgnbm9kZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgICAgIHR5cGU6ICdtZXJnZScsXG4gICAgICAgICAga2V5OiBub2RlLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICBkYXRhOiBhdHRyaWJ1dGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtub2RlLCBmYWxzZV07XG4gICAgfVxuXG4gICAgZGF0YSA9IG5ldyB0aGlzLk5vZGVEYXRhQ2xhc3Mobm9kZSwgYXR0cmlidXRlcyk7XG5cbiAgICAvLyBBZGRpbmcgdGhlIG5vZGUgdG8gaW50ZXJuYWwgcmVnaXN0ZXJcbiAgICB0aGlzLl9ub2Rlcy5zZXQobm9kZSwgZGF0YSk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnbm9kZUFkZGVkJywge1xuICAgICAga2V5OiBub2RlLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtub2RlLCB0cnVlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byBhZGQgYSBub2RlIGlmIGl0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBncmFwaCBvciBlbHNlIHRvXG4gICAqIHVwZGF0ZSBpdHMgYXR0cmlidXRlcyB1c2luZyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgIC0gVGhlIG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBbdXBkYXRlcl0gLSBPcHRpb25hbCB1cGRhdGVyIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHthbnl9ICAgICAgICAgICAgICAgIC0gVGhlIG5vZGUuXG4gICAqL1xuICB1cGRhdGVOb2RlKG5vZGUsIHVwZGF0ZXIpIHtcbiAgICBpZiAodXBkYXRlciAmJiB0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLnVwZGF0ZU5vZGU6IGludmFsaWQgdXBkYXRlciBmdW5jdGlvbi4gRXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiR7dXBkYXRlcn1cImBcbiAgICAgICk7XG5cbiAgICAvLyBTdHJpbmcgY29lcmNpb25cbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgLy8gSWYgdGhlIG5vZGUgYWxyZWFkeSBleGlzdHMsIHdlIHVwZGF0ZSB0aGUgYXR0cmlidXRlc1xuICAgIGxldCBkYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh1cGRhdGVyKSB7XG4gICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBkYXRhLmF0dHJpYnV0ZXM7XG4gICAgICAgIGRhdGEuYXR0cmlidXRlcyA9IHVwZGF0ZXIob2xkQXR0cmlidXRlcyk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdub2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICAgICAgdHlwZTogJ3JlcGxhY2UnLFxuICAgICAgICAgIGtleTogbm9kZSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW25vZGUsIGZhbHNlXTtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gdXBkYXRlciA/IHVwZGF0ZXIoe30pIDoge307XG5cbiAgICBkYXRhID0gbmV3IHRoaXMuTm9kZURhdGFDbGFzcyhub2RlLCBhdHRyaWJ1dGVzKTtcblxuICAgIC8vIEFkZGluZyB0aGUgbm9kZSB0byBpbnRlcm5hbCByZWdpc3RlclxuICAgIHRoaXMuX25vZGVzLnNldChub2RlLCBkYXRhKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlQWRkZWQnLCB7XG4gICAgICBrZXk6IG5vZGUsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gW25vZGUsIHRydWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGRyb3AgYSBzaW5nbGUgbm9kZSAmIGFsbCBpdHMgYXR0YWNoZWQgZWRnZXMgZnJvbSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgbm9kZSAtIFRoZSBub2RlLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZHJvcE5vZGUobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZHJvcE5vZGU6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgbGV0IGVkZ2VEYXRhO1xuXG4gICAgLy8gUmVtb3ZpbmcgYXR0YWNoZWQgZWRnZXNcbiAgICAvLyBOT1RFOiB3ZSBjb3VsZCBiZSBmYXN0ZXIgaGVyZSwgYnV0IHRoaXMgaXMgc3VjaCBhIHBhaW4gdG8gbWFpbnRhaW5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGZvciAoY29uc3QgbmVpZ2hib3IgaW4gbm9kZURhdGEub3V0KSB7XG4gICAgICAgIGVkZ2VEYXRhID0gbm9kZURhdGEub3V0W25laWdoYm9yXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgZHJvcEVkZ2VGcm9tRGF0YSh0aGlzLCBlZGdlRGF0YSk7XG4gICAgICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChlZGdlRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgbmVpZ2hib3IgaW4gbm9kZURhdGEuaW4pIHtcbiAgICAgICAgZWRnZURhdGEgPSBub2RlRGF0YS5pbltuZWlnaGJvcl07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGRyb3BFZGdlRnJvbURhdGEodGhpcywgZWRnZURhdGEpO1xuICAgICAgICAgIGVkZ2VEYXRhID0gZWRnZURhdGEubmV4dDtcbiAgICAgICAgfSB3aGlsZSAoZWRnZURhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGZvciAoY29uc3QgbmVpZ2hib3IgaW4gbm9kZURhdGEudW5kaXJlY3RlZCkge1xuICAgICAgICBlZGdlRGF0YSA9IG5vZGVEYXRhLnVuZGlyZWN0ZWRbbmVpZ2hib3JdO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBkcm9wRWRnZUZyb21EYXRhKHRoaXMsIGVkZ2VEYXRhKTtcbiAgICAgICAgICBlZGdlRGF0YSA9IGVkZ2VEYXRhLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKGVkZ2VEYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEcm9wcGluZyB0aGUgbm9kZSBmcm9tIHRoZSByZWdpc3RlclxuICAgIHRoaXMuX25vZGVzLmRlbGV0ZShub2RlKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlRHJvcHBlZCcsIHtcbiAgICAgIGtleTogbm9kZSxcbiAgICAgIGF0dHJpYnV0ZXM6IG5vZGVEYXRhLmF0dHJpYnV0ZXNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byBkcm9wIGEgc2luZ2xlIGVkZ2UgZnJvbSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEFyaXR5IDE6XG4gICAqIEBwYXJhbSAge2FueX0gICAgZWRnZSAtIFRoZSBlZGdlLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIHNvdXJjZSAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIHRhcmdldCAtIFRhcmdldCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZHJvcEVkZ2UoZWRnZSkge1xuICAgIGxldCBlZGdlRGF0YTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBhcmd1bWVudHNbMF07XG4gICAgICBjb25zdCB0YXJnZXQgPSAnJyArIGFyZ3VtZW50c1sxXTtcblxuICAgICAgZWRnZURhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHRoaXMudHlwZSk7XG5cbiAgICAgIGlmICghZWRnZURhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLmRyb3BFZGdlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiAtPiBcIiR7dGFyZ2V0fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgICAgZWRnZURhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICAgIGlmICghZWRnZURhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLmRyb3BFZGdlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGRyb3BFZGdlRnJvbURhdGEodGhpcywgZWRnZURhdGEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gZHJvcCBhIHNpbmdsZSBkaXJlY3RlZCBlZGdlIGZyb20gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIHNvdXJjZSAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIHRhcmdldCAtIFRhcmdldCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZHJvcERpcmVjdGVkRWRnZShzb3VyY2UsIHRhcmdldCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMilcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5kcm9wRGlyZWN0ZWRFZGdlOiBpdCBkb2VzIG5vdCBtYWtlIHNlbnNlIHRvIHRyeSBhbmQgZHJvcCBhIGRpcmVjdGVkIGVkZ2UgYnkga2V5LiBXaGF0IGlmIHRoZSBlZGdlIHdpdGggdGhpcyBrZXkgaXMgdW5kaXJlY3RlZD8gVXNlICMuZHJvcEVkZ2UgZm9yIHRoaXMgcHVycG9zZSBpbnN0ZWFkLidcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5kcm9wRGlyZWN0ZWRFZGdlOiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gZHJvcHBpbmcgYW4gZWRnZSBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgdG8gZGVsZXRlIGFzIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIG9uZXMuJ1xuICAgICAgKTtcblxuICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgY29uc3QgZWRnZURhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsICdkaXJlY3RlZCcpO1xuXG4gICAgaWYgKCFlZGdlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kcm9wRGlyZWN0ZWRFZGdlOiBjb3VsZCBub3QgZmluZCBhIFwiJHtzb3VyY2V9XCIgLT4gXCIke3RhcmdldH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgZHJvcEVkZ2VGcm9tRGF0YSh0aGlzLCBlZGdlRGF0YSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byBkcm9wIGEgc2luZ2xlIHVuZGlyZWN0ZWQgZWRnZSBmcm9tIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICBzb3VyY2UgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICB0YXJnZXQgLSBUYXJnZXQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGRyb3BVbmRpcmVjdGVkRWRnZShzb3VyY2UsIHRhcmdldCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMilcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5kcm9wVW5kaXJlY3RlZEVkZ2U6IGl0IGRvZXMgbm90IG1ha2Ugc2Vuc2UgdG8gZHJvcCBhIGRpcmVjdGVkIGVkZ2UgYnkga2V5LiBXaGF0IGlmIHRoZSBlZGdlIHdpdGggdGhpcyBrZXkgaXMgdW5kaXJlY3RlZD8gVXNlICMuZHJvcEVkZ2UgZm9yIHRoaXMgcHVycG9zZSBpbnN0ZWFkLidcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5kcm9wVW5kaXJlY3RlZEVkZ2U6IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBkcm9wcGluZyBhbiBlZGdlIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCB0byBkZWxldGUgYXMgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgb25lcy4nXG4gICAgICApO1xuXG4gICAgY29uc3QgZWRnZURhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsICd1bmRpcmVjdGVkJyk7XG5cbiAgICBpZiAoIWVkZ2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRyb3BVbmRpcmVjdGVkRWRnZTogY291bGQgbm90IGZpbmQgYSBcIiR7c291cmNlfVwiIC0+IFwiJHt0YXJnZXR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGRyb3BFZGdlRnJvbURhdGEodGhpcywgZWRnZURhdGEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gcmVtb3ZlIGV2ZXJ5IGVkZ2UgJiBldmVyeSBub2RlIGZyb20gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIC8vIENsZWFyaW5nIGVkZ2VzXG4gICAgdGhpcy5fZWRnZXMuY2xlYXIoKTtcblxuICAgIC8vIENsZWFyaW5nIG5vZGVzXG4gICAgdGhpcy5fbm9kZXMuY2xlYXIoKTtcblxuICAgIC8vIFJlc2V0IGNvdW50ZXJzXG4gICAgdGhpcy5fcmVzZXRJbnN0YW5jZUNvdW50ZXJzKCk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnY2xlYXJlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIHJlbW92ZSBldmVyeSBlZGdlIGZyb20gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICovXG4gIGNsZWFyRWRnZXMoKSB7XG4gICAgLy8gQ2xlYXJpbmcgc3RydWN0dXJlIGluZGV4XG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIHN0ZXAudmFsdWUuY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhcmluZyBlZGdlc1xuICAgIHRoaXMuX2VkZ2VzLmNsZWFyKCk7XG5cbiAgICAvLyBSZXNldCBjb3VudGVyc1xuICAgIHRoaXMuX3Jlc2V0SW5zdGFuY2VDb3VudGVycygpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2VkZ2VzQ2xlYXJlZCcpO1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEF0dHJpYnV0ZXMtcmVsYXRlZCBtZXRob2RzXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZGVzaXJlZCBncmFwaCdzIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdyYXBoJ3MgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdGhlIGdyYXBoIGhhcyB0aGUgZGVzaXJlZCBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNBdHRyaWJ1dGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBzZXR0aW5nIGEgdmFsdWUgZm9yIHRoZSBkZXNpcmVkIGdyYXBoJ3MgYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lICAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdmFsdWUgLSBWYWx1ZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqL1xuICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnYXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICB0eXBlOiAnc2V0JyxcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2F0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNpbmcgYSBmdW5jdGlvbiB0byB1cGRhdGUgdGhlIGRlc2lyZWQgZ3JhcGgncyBhdHRyaWJ1dGUncyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWUgICAgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSB1cGRhdGVyIC0gRnVuY3Rpb24gdXNlIHRvIHVwZGF0ZSB0aGUgYXR0cmlidXRlJ3MgdmFsdWUuXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKi9cbiAgdXBkYXRlQXR0cmlidXRlKG5hbWUsIHVwZGF0ZXIpIHtcbiAgICBpZiAodHlwZW9mIHVwZGF0ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC51cGRhdGVBdHRyaWJ1dGU6IHVwZGF0ZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24uJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fYXR0cmlidXRlc1tuYW1lXTtcblxuICAgIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gPSB1cGRhdGVyKHZhbHVlKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdhdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgYXR0cmlidXRlczogdGhpcy5fYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZW1vdmluZyB0aGUgZGVzaXJlZCBncmFwaCdzIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2F0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLl9hdHRyaWJ1dGVzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJlcGxhY2luZyB0aGUgZ3JhcGgncyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBOZXcgYXR0cmlidXRlcy5cbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgZ2l2ZW4gYXR0cmlidXRlcyBhcmUgbm90IGEgcGxhaW4gb2JqZWN0LlxuICAgKi9cbiAgcmVwbGFjZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnJlcGxhY2VBdHRyaWJ1dGVzOiBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuJ1xuICAgICAgKTtcblxuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2F0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgdHlwZTogJ3JlcGxhY2UnLFxuICAgICAgYXR0cmlidXRlczogdGhpcy5fYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIG1lcmdpbmcgdGhlIGdyYXBoJ3MgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gQXR0cmlidXRlcyB0byBtZXJnZS5cbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgZ2l2ZW4gYXR0cmlidXRlcyBhcmUgbm90IGEgcGxhaW4gb2JqZWN0LlxuICAgKi9cbiAgbWVyZ2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5tZXJnZUF0dHJpYnV0ZXM6IHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC4nXG4gICAgICApO1xuXG4gICAgYXNzaWduKHRoaXMuX2F0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2F0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgdHlwZTogJ21lcmdlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2F0dHJpYnV0ZXMsXG4gICAgICBkYXRhOiBhdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXBkYXRpbmcgdGhlIGdyYXBoJ3MgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IHVwZGF0ZXIgLSBGdW5jdGlvbiB1c2VkIHRvIHVwZGF0ZSB0aGUgYXR0cmlidXRlcy5cbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgZ2l2ZW4gdXBkYXRlciBpcyBub3QgYSBmdW5jdGlvbi5cbiAgICovXG4gIHVwZGF0ZUF0dHJpYnV0ZXModXBkYXRlcikge1xuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnVwZGF0ZUF0dHJpYnV0ZXM6IHByb3ZpZGVkIHVwZGF0ZXIgaXMgbm90IGEgZnVuY3Rpb24uJ1xuICAgICAgKTtcblxuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSB1cGRhdGVyKHRoaXMuX2F0dHJpYnV0ZXMpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2F0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgdHlwZTogJ3VwZGF0ZScsXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLl9hdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byB1cGRhdGUgZWFjaCBub2RlJ3MgYXR0cmlidXRlcyB1c2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259ICB1cGRhdGVyIC0gVXBkYXRlciBmdW5jdGlvbiB0byB1c2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICBbaGludHNdIC0gT3B0aW9uYWwgaGludHMuXG4gICAqL1xuICB1cGRhdGVFYWNoTm9kZUF0dHJpYnV0ZXModXBkYXRlciwgaGludHMpIHtcbiAgICBpZiAodHlwZW9mIHVwZGF0ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC51cGRhdGVFYWNoTm9kZUF0dHJpYnV0ZXM6IGV4cGVjdGluZyBhbiB1cGRhdGVyIGZ1bmN0aW9uLidcbiAgICAgICk7XG5cbiAgICBpZiAoaGludHMgJiYgIXZhbGlkYXRlSGludHMoaGludHMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgudXBkYXRlRWFjaE5vZGVBdHRyaWJ1dGVzOiBpbnZhbGlkIGhpbnRzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGhhdmluZyB0aGUgZm9sbG93aW5nIHNoYXBlOiB7YXR0cmlidXRlcz86IFtzdHJpbmddfSdcbiAgICAgICk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX25vZGVzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIG5vZGVEYXRhO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIG5vZGVEYXRhID0gc3RlcC52YWx1ZTtcbiAgICAgIG5vZGVEYXRhLmF0dHJpYnV0ZXMgPSB1cGRhdGVyKG5vZGVEYXRhLmtleSwgbm9kZURhdGEuYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdlYWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgaGludHM6IGhpbnRzID8gaGludHMgOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gdXBkYXRlIGVhY2ggZWRnZSdzIGF0dHJpYnV0ZXMgdXNpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSAgdXBkYXRlciAtIFVwZGF0ZXIgZnVuY3Rpb24gdG8gdXNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgW2hpbnRzXSAtIE9wdGlvbmFsIGhpbnRzLlxuICAgKi9cbiAgdXBkYXRlRWFjaEVkZ2VBdHRyaWJ1dGVzKHVwZGF0ZXIsIGhpbnRzKSB7XG4gICAgaWYgKHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgudXBkYXRlRWFjaEVkZ2VBdHRyaWJ1dGVzOiBleHBlY3RpbmcgYW4gdXBkYXRlciBmdW5jdGlvbi4nXG4gICAgICApO1xuXG4gICAgaWYgKGhpbnRzICYmICF2YWxpZGF0ZUhpbnRzKGhpbnRzKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnVwZGF0ZUVhY2hFZGdlQXR0cmlidXRlczogaW52YWxpZCBoaW50cy4gRXhwZWN0aW5nIGFuIG9iamVjdCBoYXZpbmcgdGhlIGZvbGxvd2luZyBzaGFwZToge2F0dHJpYnV0ZXM/OiBbc3RyaW5nXX0nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9lZGdlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBlZGdlRGF0YSwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBlZGdlRGF0YSA9IHN0ZXAudmFsdWU7XG4gICAgICBzb3VyY2VEYXRhID0gZWRnZURhdGEuc291cmNlO1xuICAgICAgdGFyZ2V0RGF0YSA9IGVkZ2VEYXRhLnRhcmdldDtcblxuICAgICAgZWRnZURhdGEuYXR0cmlidXRlcyA9IHVwZGF0ZXIoXG4gICAgICAgIGVkZ2VEYXRhLmtleSxcbiAgICAgICAgZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgc291cmNlRGF0YS5rZXksXG4gICAgICAgIHRhcmdldERhdGEua2V5LFxuICAgICAgICBzb3VyY2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgIHRhcmdldERhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2VhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBoaW50czogaGludHMgPyBoaW50cyA6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBJdGVyYXRpb24tcmVsYXRlZCBtZXRob2RzXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogTWV0aG9kIGl0ZXJhdGluZyBvdmVyIHRoZSBncmFwaCdzIGFkamFjZW5jeSB1c2luZyB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqL1xuICBmb3JFYWNoQWRqYWNlbmN5RW50cnkoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZm9yRWFjaEFkamFjZW5jeUVudHJ5OiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgZm9yRWFjaEFkamFjZW5jeShmYWxzZSwgZmFsc2UsIGZhbHNlLCB0aGlzLCBjYWxsYmFjayk7XG4gIH1cbiAgZm9yRWFjaEFkamFjZW5jeUVudHJ5V2l0aE9ycGhhbnMoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZm9yRWFjaEFkamFjZW5jeUVudHJ5V2l0aE9ycGhhbnM6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBmb3JFYWNoQWRqYWNlbmN5KGZhbHNlLCBmYWxzZSwgdHJ1ZSwgdGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBpdGVyYXRpbmcgb3ZlciB0aGUgZ3JhcGgncyBhc3N5bWV0cmljIGFkamFjZW5jeSB1c2luZyB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqL1xuICBmb3JFYWNoQXNzeW1ldHJpY0FkamFjZW5jeUVudHJ5KGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmZvckVhY2hBc3N5bWV0cmljQWRqYWNlbmN5RW50cnk6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBmb3JFYWNoQWRqYWNlbmN5KGZhbHNlLCB0cnVlLCBmYWxzZSwgdGhpcywgY2FsbGJhY2spO1xuICB9XG4gIGZvckVhY2hBc3N5bWV0cmljQWRqYWNlbmN5RW50cnlXaXRoT3JwaGFucyhjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5mb3JFYWNoQXNzeW1ldHJpY0FkamFjZW5jeUVudHJ5V2l0aE9ycGhhbnM6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBmb3JFYWNoQWRqYWNlbmN5KGZhbHNlLCB0cnVlLCB0cnVlLCB0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgbGlzdCBvZiB0aGUgZ3JhcGgncyBub2Rlcy5cbiAgICpcbiAgICogQHJldHVybiB7YXJyYXl9IC0gVGhlIG5vZGVzLlxuICAgKi9cbiAgbm9kZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fbm9kZXMua2V5cygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgaXRlcmF0aW5nIG92ZXIgdGhlIGdyYXBoJ3Mgbm9kZXMgdXNpbmcgdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gIGNhbGxiYWNrIC0gQ2FsbGJhY2sgKGtleSwgYXR0cmlidXRlcywgaW5kZXgpLlxuICAgKi9cbiAgZm9yRWFjaE5vZGUoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZm9yRWFjaE5vZGU6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX25vZGVzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIG5vZGVEYXRhO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIG5vZGVEYXRhID0gc3RlcC52YWx1ZTtcbiAgICAgIGNhbGxiYWNrKG5vZGVEYXRhLmtleSwgbm9kZURhdGEuYXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBpdGVyYXRpbmcgYXR0ZW1wdGluZyB0byBmaW5kIGEgbm9kZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcHJlZGljYXRlXG4gICAqIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gIGNhbGxiYWNrIC0gQ2FsbGJhY2sgKGtleSwgYXR0cmlidXRlcykuXG4gICAqL1xuICBmaW5kTm9kZShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5maW5kTm9kZTogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgbm9kZURhdGE7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgbm9kZURhdGEgPSBzdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoY2FsbGJhY2sobm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKSkgcmV0dXJuIG5vZGVEYXRhLmtleTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIG1hcHBpbmcgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoa2V5LCBhdHRyaWJ1dGVzKS5cbiAgICovXG4gIG1hcE5vZGVzKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLm1hcE5vZGU6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX25vZGVzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIG5vZGVEYXRhO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMub3JkZXIpO1xuICAgIGxldCBpID0gMDtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG4gICAgICByZXN1bHRbaSsrXSA9IGNhbGxiYWNrKG5vZGVEYXRhLmtleSwgbm9kZURhdGEuYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgc29tZSBub2RlIHZlcmlmeSB0aGUgZ2l2ZW4gcHJlZGljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gIGNhbGxiYWNrIC0gQ2FsbGJhY2sgKGtleSwgYXR0cmlidXRlcykuXG4gICAqL1xuICBzb21lTm9kZShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5zb21lTm9kZTogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgbm9kZURhdGE7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgbm9kZURhdGEgPSBzdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoY2FsbGJhY2sobm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciBhbGwgbm9kZSB2ZXJpZnkgdGhlIGdpdmVuIHByZWRpY2F0ZS5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIChrZXksIGF0dHJpYnV0ZXMpLlxuICAgKi9cbiAgZXZlcnlOb2RlKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmV2ZXJ5Tm9kZTogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgbm9kZURhdGE7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgbm9kZURhdGEgPSBzdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIWNhbGxiYWNrKG5vZGVEYXRhLmtleSwgbm9kZURhdGEuYXR0cmlidXRlcykpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZmlsdGVyaW5nIG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gIGNhbGxiYWNrIC0gQ2FsbGJhY2sgKGtleSwgYXR0cmlidXRlcykuXG4gICAqL1xuICBmaWx0ZXJOb2RlcyhjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5maWx0ZXJOb2RlczogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgbm9kZURhdGE7XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICAgIGlmIChjYWxsYmFjayhub2RlRGF0YS5rZXksIG5vZGVEYXRhLmF0dHJpYnV0ZXMpKVxuICAgICAgICByZXN1bHQucHVzaChub2RlRGF0YS5rZXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJlZHVjaW5nIG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gIGNhbGxiYWNrIC0gQ2FsbGJhY2sgKGFjY3VtdWxhdG9yLCBrZXksIGF0dHJpYnV0ZXMpLlxuICAgKi9cbiAgcmVkdWNlTm9kZXMoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5yZWR1Y2VOb2RlczogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMilcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnJlZHVjZU5vZGVzOiBtaXNzaW5nIGluaXRpYWwgdmFsdWUuIFlvdSBtdXN0IHByb3ZpZGUgaXQgYmVjYXVzZSB0aGUgY2FsbGJhY2sgdGFrZXMgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBhbmQgd2UgY2Fubm90IGluZmVyIHRoZSBpbml0aWFsIHZhbHVlIGZyb20gdGhlIGZpcnN0IGl0ZXJhdGlvbiwgYXMgeW91IGNvdWxkIHdpdGggYSBzaW1wbGUgYXJyYXkuJ1xuICAgICAgKTtcblxuICAgIGxldCBhY2N1bXVsYXRvciA9IGluaXRpYWxWYWx1ZTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgbm9kZURhdGE7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgbm9kZURhdGEgPSBzdGVwLnZhbHVlO1xuICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFjayhhY2N1bXVsYXRvciwgbm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyBhbiBpdGVyYXRvciBvdmVyIHRoZSBncmFwaCdzIG5vZGUgZW50cmllcy5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmF0b3J9XG4gICAqL1xuICBub2RlRW50cmllcygpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX25vZGVzLnZhbHVlcygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSByZXR1cm4gc3RlcDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHtub2RlOiBkYXRhLmtleSwgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzfSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogU2VyaWFsaXphdGlvblxuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGV4cG9ydCB0aGUgd2hvbGUgZ3JhcGguXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgc2VyaWFsaXplZCBncmFwaC5cbiAgICovXG4gIGV4cG9ydCgpIHtcbiAgICBjb25zdCBub2RlcyA9IG5ldyBBcnJheSh0aGlzLl9ub2Rlcy5zaXplKTtcblxuICAgIGxldCBpID0gMDtcblxuICAgIHRoaXMuX25vZGVzLmZvckVhY2goKGRhdGEsIGtleSkgPT4ge1xuICAgICAgbm9kZXNbaSsrXSA9IHNlcmlhbGl6ZU5vZGUoa2V5LCBkYXRhKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGVkZ2VzID0gbmV3IEFycmF5KHRoaXMuX2VkZ2VzLnNpemUpO1xuXG4gICAgaSA9IDA7XG5cbiAgICB0aGlzLl9lZGdlcy5mb3JFYWNoKChkYXRhLCBrZXkpID0+IHtcbiAgICAgIGVkZ2VzW2krK10gPSBzZXJpYWxpemVFZGdlKHRoaXMudHlwZSwga2V5LCBkYXRhKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgbXVsdGk6IHRoaXMubXVsdGksXG4gICAgICAgIGFsbG93U2VsZkxvb3BzOiB0aGlzLmFsbG93U2VsZkxvb3BzXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczogdGhpcy5nZXRBdHRyaWJ1dGVzKCksXG4gICAgICBub2RlcyxcbiAgICAgIGVkZ2VzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byBpbXBvcnQgYSBzZXJpYWxpemVkIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R8R3JhcGh9IGRhdGEgIC0gVGhlIHNlcmlhbGl6ZWQgZ3JhcGguXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgbWVyZ2UgLSBXaGV0aGVyIHRvIG1lcmdlIGRhdGEuXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAgICAgLSBSZXR1cm5zIGl0c2VsZiBmb3IgY2hhaW5pbmcuXG4gICAqL1xuICBpbXBvcnQoZGF0YSwgbWVyZ2UgPSBmYWxzZSkge1xuICAgIC8vIEltcG9ydGluZyBhIEdyYXBoIGluc3RhbmNlIGRpcmVjdGx5XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBHcmFwaCkge1xuICAgICAgLy8gTm9kZXNcbiAgICAgIGRhdGEuZm9yRWFjaE5vZGUoKG4sIGEpID0+IHtcbiAgICAgICAgaWYgKG1lcmdlKSB0aGlzLm1lcmdlTm9kZShuLCBhKTtcbiAgICAgICAgZWxzZSB0aGlzLmFkZE5vZGUobiwgYSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRWRnZXNcbiAgICAgIGRhdGEuZm9yRWFjaEVkZ2UoKGUsIGEsIHMsIHQsIF9zYSwgX3RhLCB1KSA9PiB7XG4gICAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICAgIGlmICh1KSB0aGlzLm1lcmdlVW5kaXJlY3RlZEVkZ2VXaXRoS2V5KGUsIHMsIHQsIGEpO1xuICAgICAgICAgIGVsc2UgdGhpcy5tZXJnZURpcmVjdGVkRWRnZVdpdGhLZXkoZSwgcywgdCwgYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHUpIHRoaXMuYWRkVW5kaXJlY3RlZEVkZ2VXaXRoS2V5KGUsIHMsIHQsIGEpO1xuICAgICAgICAgIGVsc2UgdGhpcy5hZGREaXJlY3RlZEVkZ2VXaXRoS2V5KGUsIHMsIHQsIGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gSW1wb3J0aW5nIGEgc2VyaWFsaXplZCBncmFwaFxuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmltcG9ydDogaW52YWxpZCBhcmd1bWVudC4gRXhwZWN0aW5nIGEgc2VyaWFsaXplZCBncmFwaCBvciwgYWx0ZXJuYXRpdmVseSwgYSBHcmFwaCBpbnN0YW5jZS4nXG4gICAgICApO1xuXG4gICAgaWYgKGRhdGEuYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEuYXR0cmlidXRlcykpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgICAnR3JhcGguaW1wb3J0OiBpbnZhbGlkIGF0dHJpYnV0ZXMuIEV4cGVjdGluZyBhIHBsYWluIG9iamVjdC4nXG4gICAgICAgICk7XG5cbiAgICAgIGlmIChtZXJnZSkgdGhpcy5tZXJnZUF0dHJpYnV0ZXMoZGF0YS5hdHRyaWJ1dGVzKTtcbiAgICAgIGVsc2UgdGhpcy5yZXBsYWNlQXR0cmlidXRlcyhkYXRhLmF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIGxldCBpLCBsLCBsaXN0LCBub2RlLCBlZGdlO1xuXG4gICAgaWYgKGRhdGEubm9kZXMpIHtcbiAgICAgIGxpc3QgPSBkYXRhLm5vZGVzO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgICAnR3JhcGguaW1wb3J0OiBpbnZhbGlkIG5vZGVzLiBFeHBlY3RpbmcgYW4gYXJyYXkuJ1xuICAgICAgICApO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IGxpc3RbaV07XG5cbiAgICAgICAgLy8gVmFsaWRhdGluZ1xuICAgICAgICB2YWxpZGF0ZVNlcmlhbGl6ZWROb2RlKG5vZGUpO1xuXG4gICAgICAgIC8vIEFkZGluZyB0aGUgbm9kZVxuICAgICAgICBjb25zdCB7a2V5LCBhdHRyaWJ1dGVzfSA9IG5vZGU7XG5cbiAgICAgICAgaWYgKG1lcmdlKSB0aGlzLm1lcmdlTm9kZShrZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgICBlbHNlIHRoaXMuYWRkTm9kZShrZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLmVkZ2VzKSB7XG4gICAgICBsZXQgdW5kaXJlY3RlZEJ5RGVmYXVsdCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgICAgdW5kaXJlY3RlZEJ5RGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGxpc3QgPSBkYXRhLmVkZ2VzO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgICAnR3JhcGguaW1wb3J0OiBpbnZhbGlkIGVkZ2VzLiBFeHBlY3RpbmcgYW4gYXJyYXkuJ1xuICAgICAgICApO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgZWRnZSA9IGxpc3RbaV07XG5cbiAgICAgICAgLy8gVmFsaWRhdGluZ1xuICAgICAgICB2YWxpZGF0ZVNlcmlhbGl6ZWRFZGdlKGVkZ2UpO1xuXG4gICAgICAgIC8vIEFkZGluZyB0aGUgZWRnZVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgIHVuZGlyZWN0ZWQgPSB1bmRpcmVjdGVkQnlEZWZhdWx0XG4gICAgICAgIH0gPSBlZGdlO1xuXG4gICAgICAgIGxldCBtZXRob2Q7XG5cbiAgICAgICAgaWYgKCdrZXknIGluIGVkZ2UpIHtcbiAgICAgICAgICBtZXRob2QgPSBtZXJnZVxuICAgICAgICAgICAgPyB1bmRpcmVjdGVkXG4gICAgICAgICAgICAgID8gdGhpcy5tZXJnZVVuZGlyZWN0ZWRFZGdlV2l0aEtleVxuICAgICAgICAgICAgICA6IHRoaXMubWVyZ2VEaXJlY3RlZEVkZ2VXaXRoS2V5XG4gICAgICAgICAgICA6IHVuZGlyZWN0ZWRcbiAgICAgICAgICAgID8gdGhpcy5hZGRVbmRpcmVjdGVkRWRnZVdpdGhLZXlcbiAgICAgICAgICAgIDogdGhpcy5hZGREaXJlY3RlZEVkZ2VXaXRoS2V5O1xuXG4gICAgICAgICAgbWV0aG9kLmNhbGwodGhpcywgZWRnZS5rZXksIHNvdXJjZSwgdGFyZ2V0LCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXRob2QgPSBtZXJnZVxuICAgICAgICAgICAgPyB1bmRpcmVjdGVkXG4gICAgICAgICAgICAgID8gdGhpcy5tZXJnZVVuZGlyZWN0ZWRFZGdlXG4gICAgICAgICAgICAgIDogdGhpcy5tZXJnZURpcmVjdGVkRWRnZVxuICAgICAgICAgICAgOiB1bmRpcmVjdGVkXG4gICAgICAgICAgICA/IHRoaXMuYWRkVW5kaXJlY3RlZEVkZ2VcbiAgICAgICAgICAgIDogdGhpcy5hZGREaXJlY3RlZEVkZ2U7XG5cbiAgICAgICAgICBtZXRob2QuY2FsbCh0aGlzLCBzb3VyY2UsIHRhcmdldCwgYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBVdGlsc1xuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgYSBudWxsIGNvcHkgb2YgdGhlIGdyYXBoLCBpLmUuIGEgZ3JhcGggd2l0aG91dCBub2Rlc1xuICAgKiAmIGVkZ2VzIGJ1dCB3aXRoIHRoZSBleGFjdCBzYW1lIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gbWVyZ2Ugd2l0aCB0aGUgY3VycmVudCBvbmVzLlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgLSBUaGUgbnVsbCBjb3B5LlxuICAgKi9cbiAgbnVsbENvcHkob3B0aW9ucykge1xuICAgIGNvbnN0IGdyYXBoID0gbmV3IEdyYXBoKGFzc2lnbih7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucykpO1xuICAgIGdyYXBoLnJlcGxhY2VBdHRyaWJ1dGVzKGFzc2lnbih7fSwgdGhpcy5nZXRBdHRyaWJ1dGVzKCkpKTtcbiAgICByZXR1cm4gZ3JhcGg7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyBhbiBlbXB0eSBjb3B5IG9mIHRoZSBncmFwaCwgaS5lLiBhIGdyYXBoIHdpdGhvdXQgZWRnZXMgYnV0XG4gICAqIHdpdGggdGhlIGV4YWN0IHNhbWUgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBtZXJnZSB3aXRoIHRoZSBjdXJyZW50IG9uZXMuXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAtIFRoZSBlbXB0eSBjb3B5LlxuICAgKi9cbiAgZW1wdHlDb3B5KG9wdGlvbnMpIHtcbiAgICBjb25zdCBncmFwaCA9IHRoaXMubnVsbENvcHkob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKChub2RlRGF0YSwga2V5KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gYXNzaWduKHt9LCBub2RlRGF0YS5hdHRyaWJ1dGVzKTtcblxuICAgICAgLy8gTk9URTogbm8gbmVlZCB0byBlbWl0IGV2ZW50cyBzaW5jZSB1c2VyIGNhbm5vdCBhY2Nlc3MgdGhlIGluc3RhbmNlIHlldFxuICAgICAgbm9kZURhdGEgPSBuZXcgZ3JhcGguTm9kZURhdGFDbGFzcyhrZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgZ3JhcGguX25vZGVzLnNldChrZXksIG5vZGVEYXRhKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBncmFwaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIGFuIGV4YWN0IGNvcHkgb2YgdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgLSBVcGdyYWRlIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAtIFRoZSBjb3B5LlxuICAgKi9cbiAgY29weShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgICAgb3B0aW9ucy50eXBlICE9PSB0aGlzLnR5cGUgJiZcbiAgICAgIG9wdGlvbnMudHlwZSAhPT0gJ21peGVkJ1xuICAgIClcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5jb3B5OiBjYW5ub3QgY3JlYXRlIGFuIGluY29tcGF0aWJsZSBjb3B5IGZyb20gXCIke3RoaXMudHlwZX1cIiB0eXBlIHRvIFwiJHtvcHRpb25zLnR5cGV9XCIgYmVjYXVzZSB0aGlzIHdvdWxkIG1lYW4gbG9zaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5tdWx0aSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICBvcHRpb25zLm11bHRpICE9PSB0aGlzLm11bHRpICYmXG4gICAgICBvcHRpb25zLm11bHRpICE9PSB0cnVlXG4gICAgKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmNvcHk6IGNhbm5vdCBjcmVhdGUgYW4gaW5jb21wYXRpYmxlIGNvcHkgYnkgZG93bmdyYWRpbmcgYSBtdWx0aSBncmFwaCB0byBhIHNpbXBsZSBvbmUgYmVjYXVzZSB0aGlzIHdvdWxkIG1lYW4gbG9zaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGdyYXBoLidcbiAgICAgICk7XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5hbGxvd1NlbGZMb29wcyA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICBvcHRpb25zLmFsbG93U2VsZkxvb3BzICE9PSB0aGlzLmFsbG93U2VsZkxvb3BzICYmXG4gICAgICBvcHRpb25zLmFsbG93U2VsZkxvb3BzICE9PSB0cnVlXG4gICAgKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmNvcHk6IGNhbm5vdCBjcmVhdGUgYW4gaW5jb21wYXRpYmxlIGNvcHkgZnJvbSBhIGdyYXBoIGFsbG93aW5nIHNlbGYgbG9vcHMgdG8gb25lIHRoYXQgZG9lcyBub3QgYmVjYXVzZSB0aGlzIHdvdWxkIG1lYW4gbG9zaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGdyYXBoLidcbiAgICAgICk7XG5cbiAgICBjb25zdCBncmFwaCA9IHRoaXMuZW1wdHlDb3B5KG9wdGlvbnMpO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9lZGdlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBlZGdlRGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBlZGdlRGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICAgIC8vIE5PVEU6IG5vIG5lZWQgdG8gZW1pdCBldmVudHMgc2luY2UgdXNlciBjYW5ub3QgYWNjZXNzIHRoZSBpbnN0YW5jZSB5ZXRcbiAgICAgIGFkZEVkZ2UoXG4gICAgICAgIGdyYXBoLFxuICAgICAgICAnY29weScsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBlZGdlRGF0YS51bmRpcmVjdGVkLFxuICAgICAgICBlZGdlRGF0YS5rZXksXG4gICAgICAgIGVkZ2VEYXRhLnNvdXJjZS5rZXksXG4gICAgICAgIGVkZ2VEYXRhLnRhcmdldC5rZXksXG4gICAgICAgIGFzc2lnbih7fSwgZWRnZURhdGEuYXR0cmlidXRlcylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEtub3duIG1ldGhvZHNcbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCBieSBKYXZhU2NyaXB0IHRvIHBlcmZvcm0gSlNPTiBzZXJpYWxpemF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIHNlcmlhbGl6ZWQgZ3JhcGguXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwb3J0KCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyBbb2JqZWN0IEdyYXBoXS5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCBHcmFwaF0nO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIGludGVybmFsbHkgYnkgbm9kZSdzIGNvbnNvbGUgdG8gZGlzcGxheSBhIGN1c3RvbSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBGb3JtYXR0ZWQgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncmFwaC5cbiAgICovXG4gIGluc3BlY3QoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB7fTtcbiAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKChkYXRhLCBrZXkpID0+IHtcbiAgICAgIG5vZGVzW2tleV0gPSBkYXRhLmF0dHJpYnV0ZXM7XG4gICAgfSk7XG5cbiAgICBjb25zdCBlZGdlcyA9IHt9LFxuICAgICAgbXVsdGlJbmRleCA9IHt9O1xuXG4gICAgdGhpcy5fZWRnZXMuZm9yRWFjaCgoZGF0YSwga2V5KSA9PiB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBkYXRhLnVuZGlyZWN0ZWQgPyAnLS0nIDogJy0+JztcblxuICAgICAgbGV0IGxhYmVsID0gJyc7XG5cbiAgICAgIGxldCBzb3VyY2UgPSBkYXRhLnNvdXJjZS5rZXk7XG4gICAgICBsZXQgdGFyZ2V0ID0gZGF0YS50YXJnZXQua2V5O1xuICAgICAgbGV0IHRtcDtcblxuICAgICAgaWYgKGRhdGEudW5kaXJlY3RlZCAmJiBzb3VyY2UgPiB0YXJnZXQpIHtcbiAgICAgICAgdG1wID0gc291cmNlO1xuICAgICAgICBzb3VyY2UgPSB0YXJnZXQ7XG4gICAgICAgIHRhcmdldCA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVzYyA9IGAoJHtzb3VyY2V9KSR7ZGlyZWN0aW9ufSgke3RhcmdldH0pYDtcblxuICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aCgnZ2VpZF8nKSkge1xuICAgICAgICBsYWJlbCArPSBgWyR7a2V5fV06IGA7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtdWx0aUluZGV4W2Rlc2NdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG11bHRpSW5kZXhbZGVzY10gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG11bHRpSW5kZXhbZGVzY10rKztcbiAgICAgICAgfVxuXG4gICAgICAgIGxhYmVsICs9IGAke211bHRpSW5kZXhbZGVzY119LiBgO1xuICAgICAgfVxuXG4gICAgICBsYWJlbCArPSBkZXNjO1xuXG4gICAgICBlZGdlc1tsYWJlbF0gPSBkYXRhLmF0dHJpYnV0ZXM7XG4gICAgfSk7XG5cbiAgICBjb25zdCBkdW1teSA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBrIGluIHRoaXMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5oYXNPd25Qcm9wZXJ0eShrKSAmJlxuICAgICAgICAhRU1JVFRFUl9QUk9QUy5oYXMoaykgJiZcbiAgICAgICAgdHlwZW9mIHRoaXNba10gIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIGsgIT09ICdzeW1ib2wnXG4gICAgICApXG4gICAgICAgIGR1bW15W2tdID0gdGhpc1trXTtcbiAgICB9XG5cbiAgICBkdW1teS5hdHRyaWJ1dGVzID0gdGhpcy5fYXR0cmlidXRlcztcbiAgICBkdW1teS5ub2RlcyA9IG5vZGVzO1xuICAgIGR1bW15LmVkZ2VzID0gZWRnZXM7XG5cbiAgICBwcml2YXRlUHJvcGVydHkoZHVtbXksICdjb25zdHJ1Y3RvcicsIHRoaXMuY29uc3RydWN0b3IpO1xuXG4gICAgcmV0dXJuIGR1bW15O1xuICB9XG59XG5cbi8qKlxuICogQXR0YWNoaW5nIG1ldGhvZHMgdG8gdGhlIHByb3RvdHlwZS5cbiAqXG4gKiBIZXJlLCB3ZSBhcmUgYXR0YWNoaW5nIGEgd2lkZSB2YXJpZXR5IG9mIG1ldGhvZHMgdG8gdGhlIEdyYXBoIGNsYXNzJ1xuICogcHJvdG90eXBlIHdoZW4gdGhvc2UgYXJlIHZlcnkgbnVtZXJvdXMgYW5kIHdoZW4gdGhlaXIgY3JlYXRpb24gaXNcbiAqIGFic3RyYWN0ZWQuXG4gKi9cblxuLyoqXG4gKiBBdHRhY2hpbmcgY3VzdG9tIGluc3BlY3QgbWV0aG9kIGZvciBub2RlID49IDEwLlxuICovXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcpXG4gIEdyYXBoLnByb3RvdHlwZVtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9XG4gICAgR3JhcGgucHJvdG90eXBlLmluc3BlY3Q7XG5cbi8qKlxuICogUmVsYXRlZCB0byBlZGdlIGFkZGl0aW9uLlxuICovXG5FREdFX0FERF9NRVRIT0RTLmZvckVhY2gobWV0aG9kID0+IHtcbiAgWydhZGQnLCAnbWVyZ2UnLCAndXBkYXRlJ10uZm9yRWFjaCh2ZXJiID0+IHtcbiAgICBjb25zdCBuYW1lID0gbWV0aG9kLm5hbWUodmVyYik7XG4gICAgY29uc3QgZm4gPSB2ZXJiID09PSAnYWRkJyA/IGFkZEVkZ2UgOiBtZXJnZUVkZ2U7XG5cbiAgICBpZiAobWV0aG9kLmdlbmVyYXRlS2V5KSB7XG4gICAgICBHcmFwaC5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoc291cmNlLCB0YXJnZXQsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGZuKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIChtZXRob2QudHlwZSB8fCB0aGlzLnR5cGUpID09PSAndW5kaXJlY3RlZCcsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgdmVyYiA9PT0gJ3VwZGF0ZSdcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIEdyYXBoLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChlZGdlLCBzb3VyY2UsIHRhcmdldCwgYXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gZm4oXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIChtZXRob2QudHlwZSB8fCB0aGlzLnR5cGUpID09PSAndW5kaXJlY3RlZCcsXG4gICAgICAgICAgZWRnZSxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgdmVyYiA9PT0gJ3VwZGF0ZSdcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn0pO1xuXG4vKipcbiAqIEF0dHJpYnV0ZXMtcmVsYXRlZC5cbiAqL1xuYXR0YWNoTm9kZUF0dHJpYnV0ZXNNZXRob2RzKEdyYXBoKTtcbmF0dGFjaEVkZ2VBdHRyaWJ1dGVzTWV0aG9kcyhHcmFwaCk7XG5cbi8qKlxuICogRWRnZSBpdGVyYXRpb24tcmVsYXRlZC5cbiAqL1xuYXR0YWNoRWRnZUl0ZXJhdGlvbk1ldGhvZHMoR3JhcGgpO1xuXG4vKipcbiAqIE5laWdoYm9yIGl0ZXJhdGlvbi1yZWxhdGVkLlxuICovXG5hdHRhY2hOZWlnaGJvckl0ZXJhdGlvbk1ldGhvZHMoR3JhcGgpO1xuXG4vKipcbiAqIEdyYXBob2xvZ3kgSGVscGVyIENsYXNzZXNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQnVpbGRpbmcgc29tZSBoaWdoZXItb3JkZXIgY2xhc3NlcyBpbnN0YW50aWF0aW5nIHRoZSBncmFwaCB3aXRoXG4gKiBwcmVkZWZpbml0ZSBvcHRpb25zLlxuICovXG5cbi8qKlxuICogQWx0ZXJuYXRpdmUgY29uc3RydWN0b3JzLlxuICovXG5jbGFzcyBEaXJlY3RlZEdyYXBoIGV4dGVuZHMgR3JhcGgge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3QgZmluYWxPcHRpb25zID0gYXNzaWduKHt0eXBlOiAnZGlyZWN0ZWQnfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ211bHRpJyBpbiBmaW5hbE9wdGlvbnMgJiYgZmluYWxPcHRpb25zLm11bHRpICE9PSBmYWxzZSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0RpcmVjdGVkR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IGluZGljYXRpb24gdGhhdCB0aGUgZ3JhcGggc2hvdWxkIGJlIG11bHRpIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIGlmIChmaW5hbE9wdGlvbnMudHlwZSAhPT0gJ2RpcmVjdGVkJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0RpcmVjdGVkR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IFwiJyArXG4gICAgICAgICAgZmluYWxPcHRpb25zLnR5cGUgK1xuICAgICAgICAgICdcIiB0eXBlIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIHN1cGVyKGZpbmFsT3B0aW9ucyk7XG4gIH1cbn1cbmNsYXNzIFVuZGlyZWN0ZWRHcmFwaCBleHRlbmRzIEdyYXBoIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IGFzc2lnbih7dHlwZTogJ3VuZGlyZWN0ZWQnfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ211bHRpJyBpbiBmaW5hbE9wdGlvbnMgJiYgZmluYWxPcHRpb25zLm11bHRpICE9PSBmYWxzZSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ1VuZGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgaW5kaWNhdGlvbiB0aGF0IHRoZSBncmFwaCBzaG91bGQgYmUgbXVsdGkgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgaWYgKGZpbmFsT3B0aW9ucy50eXBlICE9PSAndW5kaXJlY3RlZCcpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdVbmRpcmVjdGVkR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IFwiJyArXG4gICAgICAgICAgZmluYWxPcHRpb25zLnR5cGUgK1xuICAgICAgICAgICdcIiB0eXBlIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIHN1cGVyKGZpbmFsT3B0aW9ucyk7XG4gIH1cbn1cbmNsYXNzIE11bHRpR3JhcGggZXh0ZW5kcyBHcmFwaCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBhc3NpZ24oe211bHRpOiB0cnVlfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ211bHRpJyBpbiBmaW5hbE9wdGlvbnMgJiYgZmluYWxPcHRpb25zLm11bHRpICE9PSB0cnVlKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnTXVsdGlHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgaW5kaWNhdGlvbiB0aGF0IHRoZSBncmFwaCBzaG91bGQgYmUgc2ltcGxlIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIHN1cGVyKGZpbmFsT3B0aW9ucyk7XG4gIH1cbn1cbmNsYXNzIE11bHRpRGlyZWN0ZWRHcmFwaCBleHRlbmRzIEdyYXBoIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IGFzc2lnbih7dHlwZTogJ2RpcmVjdGVkJywgbXVsdGk6IHRydWV9LCBvcHRpb25zKTtcblxuICAgIGlmICgnbXVsdGknIGluIGZpbmFsT3B0aW9ucyAmJiBmaW5hbE9wdGlvbnMubXVsdGkgIT09IHRydWUpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdNdWx0aURpcmVjdGVkR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IGluZGljYXRpb24gdGhhdCB0aGUgZ3JhcGggc2hvdWxkIGJlIHNpbXBsZSBpbiBnaXZlbiBvcHRpb25zISdcbiAgICAgICk7XG5cbiAgICBpZiAoZmluYWxPcHRpb25zLnR5cGUgIT09ICdkaXJlY3RlZCcpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdNdWx0aURpcmVjdGVkR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IFwiJyArXG4gICAgICAgICAgZmluYWxPcHRpb25zLnR5cGUgK1xuICAgICAgICAgICdcIiB0eXBlIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIHN1cGVyKGZpbmFsT3B0aW9ucyk7XG4gIH1cbn1cbmNsYXNzIE11bHRpVW5kaXJlY3RlZEdyYXBoIGV4dGVuZHMgR3JhcGgge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3QgZmluYWxPcHRpb25zID0gYXNzaWduKHt0eXBlOiAndW5kaXJlY3RlZCcsIG11bHRpOiB0cnVlfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ211bHRpJyBpbiBmaW5hbE9wdGlvbnMgJiYgZmluYWxPcHRpb25zLm11bHRpICE9PSB0cnVlKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnTXVsdGlVbmRpcmVjdGVkR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IGluZGljYXRpb24gdGhhdCB0aGUgZ3JhcGggc2hvdWxkIGJlIHNpbXBsZSBpbiBnaXZlbiBvcHRpb25zISdcbiAgICAgICk7XG5cbiAgICBpZiAoZmluYWxPcHRpb25zLnR5cGUgIT09ICd1bmRpcmVjdGVkJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ011bHRpVW5kaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBcIicgK1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy50eXBlICtcbiAgICAgICAgICAnXCIgdHlwZSBpbiBnaXZlbiBvcHRpb25zISdcbiAgICAgICk7XG5cbiAgICBzdXBlcihmaW5hbE9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogQXR0YWNoaW5nIHN0YXRpYyAjLmZyb20gbWV0aG9kIHRvIGVhY2ggb2YgdGhlIGNvbnN0cnVjdG9ycy5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoU3RhdGljRnJvbU1ldGhvZChDbGFzcykge1xuICAvKipcbiAgICogQnVpbGRzIGEgZ3JhcGggZnJvbSBzZXJpYWxpemVkIGRhdGEgb3IgYW5vdGhlciBncmFwaCdzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSAge0dyYXBofFNlcmlhbGl6ZWRHcmFwaH0gZGF0YSAgICAgIC0gSHlkcmF0YXRpb24gZGF0YS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICBbb3B0aW9uc10gLSBPcHRpb25zLlxuICAgKiBAcmV0dXJuIHtDbGFzc31cbiAgICovXG4gIENsYXNzLmZyb20gPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICAgIC8vIE1lcmdpbmcgZ2l2ZW4gb3B0aW9ucyB3aXRoIHNlcmlhbGl6ZWQgb25lc1xuICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IGFzc2lnbih7fSwgZGF0YS5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IENsYXNzKGZpbmFsT3B0aW9ucyk7XG4gICAgaW5zdGFuY2UuaW1wb3J0KGRhdGEpO1xuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuXG5hdHRhY2hTdGF0aWNGcm9tTWV0aG9kKEdyYXBoKTtcbmF0dGFjaFN0YXRpY0Zyb21NZXRob2QoRGlyZWN0ZWRHcmFwaCk7XG5hdHRhY2hTdGF0aWNGcm9tTWV0aG9kKFVuZGlyZWN0ZWRHcmFwaCk7XG5hdHRhY2hTdGF0aWNGcm9tTWV0aG9kKE11bHRpR3JhcGgpO1xuYXR0YWNoU3RhdGljRnJvbU1ldGhvZChNdWx0aURpcmVjdGVkR3JhcGgpO1xuYXR0YWNoU3RhdGljRnJvbU1ldGhvZChNdWx0aVVuZGlyZWN0ZWRHcmFwaCk7XG5cbkdyYXBoLkdyYXBoID0gR3JhcGg7XG5HcmFwaC5EaXJlY3RlZEdyYXBoID0gRGlyZWN0ZWRHcmFwaDtcbkdyYXBoLlVuZGlyZWN0ZWRHcmFwaCA9IFVuZGlyZWN0ZWRHcmFwaDtcbkdyYXBoLk11bHRpR3JhcGggPSBNdWx0aUdyYXBoO1xuR3JhcGguTXVsdGlEaXJlY3RlZEdyYXBoID0gTXVsdGlEaXJlY3RlZEdyYXBoO1xuR3JhcGguTXVsdGlVbmRpcmVjdGVkR3JhcGggPSBNdWx0aVVuZGlyZWN0ZWRHcmFwaDtcblxuR3JhcGguSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IgPSBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcjtcbkdyYXBoLk5vdEZvdW5kR3JhcGhFcnJvciA9IE5vdEZvdW5kR3JhcGhFcnJvcjtcbkdyYXBoLlVzYWdlR3JhcGhFcnJvciA9IFVzYWdlR3JhcGhFcnJvcjtcblxuLyoqXG4gKiBHcmFwaG9sb2d5IEVTTSBFbmRvaW50XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEVuZHBvaW50IGZvciBFU00gbW9kdWxlcyBjb25zdW1lcnMuXG4gKi9cblxuZXhwb3J0IHsgRGlyZWN0ZWRHcmFwaCwgR3JhcGgsIEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yLCBNdWx0aURpcmVjdGVkR3JhcGgsIE11bHRpR3JhcGgsIE11bHRpVW5kaXJlY3RlZEdyYXBoLCBOb3RGb3VuZEdyYXBoRXJyb3IsIFVuZGlyZWN0ZWRHcmFwaCwgVXNhZ2VHcmFwaEVycm9yLCBHcmFwaCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmFwaG9sb2d5Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology/dist/graphology.mjs\n");

/***/ })

};
;