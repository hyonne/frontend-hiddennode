"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sigma";
exports.ids = ["vendor-chunks/sigma"];
exports.modules = {

/***/ "(ssr)/./node_modules/sigma/dist/colors-beb06eb2.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/sigma/dist/colors-beb06eb2.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   H: () => (/* binding */ HTML_COLORS),\n/* harmony export */   _: () => (/* binding */ _slicedToArray),\n/* harmony export */   a: () => (/* binding */ _arrayLikeToArray),\n/* harmony export */   b: () => (/* binding */ _unsupportedIterableToArray),\n/* harmony export */   c: () => (/* binding */ colorToIndex),\n/* harmony export */   d: () => (/* binding */ colorToArray),\n/* harmony export */   e: () => (/* binding */ extractPixel),\n/* harmony export */   f: () => (/* binding */ floatColor),\n/* harmony export */   g: () => (/* binding */ getPixelColor),\n/* harmony export */   i: () => (/* binding */ indexToColor),\n/* harmony export */   p: () => (/* binding */ parseColor),\n/* harmony export */   r: () => (/* binding */ rgbaToFloat)\n/* harmony export */ });\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\n\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\n\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\n\nvar HTML_COLORS = {\n  black: \"#000000\",\n  silver: \"#C0C0C0\",\n  gray: \"#808080\",\n  grey: \"#808080\",\n  white: \"#FFFFFF\",\n  maroon: \"#800000\",\n  red: \"#FF0000\",\n  purple: \"#800080\",\n  fuchsia: \"#FF00FF\",\n  green: \"#008000\",\n  lime: \"#00FF00\",\n  olive: \"#808000\",\n  yellow: \"#FFFF00\",\n  navy: \"#000080\",\n  blue: \"#0000FF\",\n  teal: \"#008080\",\n  aqua: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  mediumblue: \"#0000CD\",\n  darkgreen: \"#006400\",\n  darkcyan: \"#008B8B\",\n  deepskyblue: \"#00BFFF\",\n  darkturquoise: \"#00CED1\",\n  mediumspringgreen: \"#00FA9A\",\n  springgreen: \"#00FF7F\",\n  cyan: \"#00FFFF\",\n  midnightblue: \"#191970\",\n  dodgerblue: \"#1E90FF\",\n  lightseagreen: \"#20B2AA\",\n  forestgreen: \"#228B22\",\n  seagreen: \"#2E8B57\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  limegreen: \"#32CD32\",\n  mediumseagreen: \"#3CB371\",\n  turquoise: \"#40E0D0\",\n  royalblue: \"#4169E1\",\n  steelblue: \"#4682B4\",\n  darkslateblue: \"#483D8B\",\n  mediumturquoise: \"#48D1CC\",\n  indigo: \"#4B0082\",\n  darkolivegreen: \"#556B2F\",\n  cadetblue: \"#5F9EA0\",\n  cornflowerblue: \"#6495ED\",\n  rebeccapurple: \"#663399\",\n  mediumaquamarine: \"#66CDAA\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  slateblue: \"#6A5ACD\",\n  olivedrab: \"#6B8E23\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  mediumslateblue: \"#7B68EE\",\n  lawngreen: \"#7CFC00\",\n  chartreuse: \"#7FFF00\",\n  aquamarine: \"#7FFFD4\",\n  skyblue: \"#87CEEB\",\n  lightskyblue: \"#87CEFA\",\n  blueviolet: \"#8A2BE2\",\n  darkred: \"#8B0000\",\n  darkmagenta: \"#8B008B\",\n  saddlebrown: \"#8B4513\",\n  darkseagreen: \"#8FBC8F\",\n  lightgreen: \"#90EE90\",\n  mediumpurple: \"#9370DB\",\n  darkviolet: \"#9400D3\",\n  palegreen: \"#98FB98\",\n  darkorchid: \"#9932CC\",\n  yellowgreen: \"#9ACD32\",\n  sienna: \"#A0522D\",\n  brown: \"#A52A2A\",\n  darkgray: \"#A9A9A9\",\n  darkgrey: \"#A9A9A9\",\n  lightblue: \"#ADD8E6\",\n  greenyellow: \"#ADFF2F\",\n  paleturquoise: \"#AFEEEE\",\n  lightsteelblue: \"#B0C4DE\",\n  powderblue: \"#B0E0E6\",\n  firebrick: \"#B22222\",\n  darkgoldenrod: \"#B8860B\",\n  mediumorchid: \"#BA55D3\",\n  rosybrown: \"#BC8F8F\",\n  darkkhaki: \"#BDB76B\",\n  mediumvioletred: \"#C71585\",\n  indianred: \"#CD5C5C\",\n  peru: \"#CD853F\",\n  chocolate: \"#D2691E\",\n  tan: \"#D2B48C\",\n  lightgray: \"#D3D3D3\",\n  lightgrey: \"#D3D3D3\",\n  thistle: \"#D8BFD8\",\n  orchid: \"#DA70D6\",\n  goldenrod: \"#DAA520\",\n  palevioletred: \"#DB7093\",\n  crimson: \"#DC143C\",\n  gainsboro: \"#DCDCDC\",\n  plum: \"#DDA0DD\",\n  burlywood: \"#DEB887\",\n  lightcyan: \"#E0FFFF\",\n  lavender: \"#E6E6FA\",\n  darksalmon: \"#E9967A\",\n  violet: \"#EE82EE\",\n  palegoldenrod: \"#EEE8AA\",\n  lightcoral: \"#F08080\",\n  khaki: \"#F0E68C\",\n  aliceblue: \"#F0F8FF\",\n  honeydew: \"#F0FFF0\",\n  azure: \"#F0FFFF\",\n  sandybrown: \"#F4A460\",\n  wheat: \"#F5DEB3\",\n  beige: \"#F5F5DC\",\n  whitesmoke: \"#F5F5F5\",\n  mintcream: \"#F5FFFA\",\n  ghostwhite: \"#F8F8FF\",\n  salmon: \"#FA8072\",\n  antiquewhite: \"#FAEBD7\",\n  linen: \"#FAF0E6\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  oldlace: \"#FDF5E6\",\n  magenta: \"#FF00FF\",\n  deeppink: \"#FF1493\",\n  orangered: \"#FF4500\",\n  tomato: \"#FF6347\",\n  hotpink: \"#FF69B4\",\n  coral: \"#FF7F50\",\n  darkorange: \"#FF8C00\",\n  lightsalmon: \"#FFA07A\",\n  orange: \"#FFA500\",\n  lightpink: \"#FFB6C1\",\n  pink: \"#FFC0CB\",\n  gold: \"#FFD700\",\n  peachpuff: \"#FFDAB9\",\n  navajowhite: \"#FFDEAD\",\n  moccasin: \"#FFE4B5\",\n  bisque: \"#FFE4C4\",\n  mistyrose: \"#FFE4E1\",\n  blanchedalmond: \"#FFEBCD\",\n  papayawhip: \"#FFEFD5\",\n  lavenderblush: \"#FFF0F5\",\n  seashell: \"#FFF5EE\",\n  cornsilk: \"#FFF8DC\",\n  lemonchiffon: \"#FFFACD\",\n  floralwhite: \"#FFFAF0\",\n  snow: \"#FFFAFA\",\n  lightyellow: \"#FFFFE0\",\n  ivory: \"#FFFFF0\"\n};\n\n/**\n * Function extracting the color at the given pixel.\n */\nfunction extractPixel(gl, x, y, array) {\n  var data = array || new Uint8Array(4);\n  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);\n  return data;\n}\n\n/**\n * Memoized function returning a float-encoded color from various string\n * formats describing colors.\n */\nvar INT8 = new Int8Array(4);\nvar INT32 = new Int32Array(INT8.buffer, 0, 1);\nvar FLOAT32 = new Float32Array(INT8.buffer, 0, 1);\nvar RGBA_TEST_REGEX = /^\\s*rgba?\\s*\\(/;\nvar RGBA_EXTRACT_REGEX = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)(?:\\s*,\\s*(.*)?)?\\)\\s*$/;\nfunction parseColor(val) {\n  var r = 0; // byte\n  var g = 0; // byte\n  var b = 0; // byte\n  var a = 1; // float\n\n  // Handling hexadecimal notation\n  if (val[0] === \"#\") {\n    if (val.length === 4) {\n      r = parseInt(val.charAt(1) + val.charAt(1), 16);\n      g = parseInt(val.charAt(2) + val.charAt(2), 16);\n      b = parseInt(val.charAt(3) + val.charAt(3), 16);\n    } else {\n      r = parseInt(val.charAt(1) + val.charAt(2), 16);\n      g = parseInt(val.charAt(3) + val.charAt(4), 16);\n      b = parseInt(val.charAt(5) + val.charAt(6), 16);\n    }\n    if (val.length === 9) {\n      a = parseInt(val.charAt(7) + val.charAt(8), 16) / 255;\n    }\n  }\n\n  // Handling rgb notation\n  else if (RGBA_TEST_REGEX.test(val)) {\n    var match = val.match(RGBA_EXTRACT_REGEX);\n    if (match) {\n      r = +match[1];\n      g = +match[2];\n      b = +match[3];\n      if (match[4]) a = +match[4];\n    }\n  }\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nvar FLOAT_COLOR_CACHE = {};\nfor (var htmlColor in HTML_COLORS) {\n  FLOAT_COLOR_CACHE[htmlColor] = floatColor(HTML_COLORS[htmlColor]);\n  // Replicating cache for hex values for free\n  FLOAT_COLOR_CACHE[HTML_COLORS[htmlColor]] = FLOAT_COLOR_CACHE[htmlColor];\n}\nfunction rgbaToFloat(r, g, b, a, masking) {\n  INT32[0] = a << 24 | b << 16 | g << 8 | r;\n  if (masking) INT32[0] = INT32[0] & 0xfeffffff;\n  return FLOAT32[0];\n}\nfunction floatColor(val) {\n  // The html color names are case-insensitive\n  val = val.toLowerCase();\n\n  // If the color is already computed, we yield it\n  if (typeof FLOAT_COLOR_CACHE[val] !== \"undefined\") return FLOAT_COLOR_CACHE[val];\n  var parsed = parseColor(val);\n  var r = parsed.r,\n    g = parsed.g,\n    b = parsed.b;\n  var a = parsed.a;\n  a = a * 255 | 0;\n  var color = rgbaToFloat(r, g, b, a, true);\n  FLOAT_COLOR_CACHE[val] = color;\n  return color;\n}\nfunction colorToArray(val, masking) {\n  FLOAT32[0] = floatColor(val);\n  var intValue = INT32[0];\n  if (masking) {\n    intValue = intValue | 0x01000000;\n  }\n  var r = intValue & 0xff;\n  var g = intValue >> 8 & 0xff;\n  var b = intValue >> 16 & 0xff;\n  var a = intValue >> 24 & 0xff;\n  return [r, g, b, a];\n}\nvar FLOAT_INDEX_CACHE = {};\nfunction indexToColor(index) {\n  // If the index is already computed, we yield it\n  if (typeof FLOAT_INDEX_CACHE[index] !== \"undefined\") return FLOAT_INDEX_CACHE[index];\n\n  // To address issue #1397, one strategy is to keep encoding 4 bytes colors,\n  // but with alpha hard-set to 1.0 (or 255):\n  var r = (index & 0x00ff0000) >>> 16;\n  var g = (index & 0x0000ff00) >>> 8;\n  var b = index & 0x000000ff;\n  var a = 0x000000ff;\n\n  // The original 4 bytes color encoding was the following:\n  // const r = (index & 0xff000000) >>> 24;\n  // const g = (index & 0x00ff0000) >>> 16;\n  // const b = (index & 0x0000ff00) >>> 8;\n  // const a = index & 0x000000ff;\n\n  var color = rgbaToFloat(r, g, b, a, true);\n  FLOAT_INDEX_CACHE[index] = color;\n  return color;\n}\nfunction colorToIndex(r, g, b, _a) {\n  // As for the function indexToColor, because of #1397 and the \"alpha is always\n  // 1.0\" strategy, we need to fix this function as well:\n  return b + (g << 8) + (r << 16);\n\n  // The original 4 bytes color decoding is the following:\n  // return a + (b << 8) + (g << 16) + (r << 24);\n}\nfunction getPixelColor(gl, frameBuffer, x, y, pixelRatio, downSizingRatio) {\n  var bufferX = Math.floor(x / downSizingRatio * pixelRatio);\n  var bufferY = Math.floor(gl.drawingBufferHeight / downSizingRatio - y / downSizingRatio * pixelRatio);\n  var pixel = new Uint8Array(4);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.readPixels(bufferX, bufferY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n  var _pixel = _slicedToArray(pixel, 4),\n    r = _pixel[0],\n    g = _pixel[1],\n    b = _pixel[2],\n    a = _pixel[3];\n  return [r, g, b, a];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9jb2xvcnMtYmViMDZlYjIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZLGtFQUFrRTtBQUN0RixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrUCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoeWVvblxcRGVza3RvcFxcZnJvbnRlbmQtaGlkZGVubm9kZVxcbm9kZV9tb2R1bGVzXFxzaWdtYVxcZGlzdFxcY29sb3JzLWJlYjA2ZWIyLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7XG4gIHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IHQpIHtcbiAgICB2YXIgZSxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdSxcbiAgICAgIGEgPSBbXSxcbiAgICAgIGYgPSAhMCxcbiAgICAgIG8gPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkge1xuICAgICAgICBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47XG4gICAgICAgIGYgPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gITAsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0LnJldHVybiAmJiAodSA9IHQucmV0dXJuKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICBpZiAocikge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbnZhciBIVE1MX0NPTE9SUyA9IHtcbiAgYmxhY2s6IFwiIzAwMDAwMFwiLFxuICBzaWx2ZXI6IFwiI0MwQzBDMFwiLFxuICBncmF5OiBcIiM4MDgwODBcIixcbiAgZ3JleTogXCIjODA4MDgwXCIsXG4gIHdoaXRlOiBcIiNGRkZGRkZcIixcbiAgbWFyb29uOiBcIiM4MDAwMDBcIixcbiAgcmVkOiBcIiNGRjAwMDBcIixcbiAgcHVycGxlOiBcIiM4MDAwODBcIixcbiAgZnVjaHNpYTogXCIjRkYwMEZGXCIsXG4gIGdyZWVuOiBcIiMwMDgwMDBcIixcbiAgbGltZTogXCIjMDBGRjAwXCIsXG4gIG9saXZlOiBcIiM4MDgwMDBcIixcbiAgeWVsbG93OiBcIiNGRkZGMDBcIixcbiAgbmF2eTogXCIjMDAwMDgwXCIsXG4gIGJsdWU6IFwiIzAwMDBGRlwiLFxuICB0ZWFsOiBcIiMwMDgwODBcIixcbiAgYXF1YTogXCIjMDBGRkZGXCIsXG4gIGRhcmtibHVlOiBcIiMwMDAwOEJcIixcbiAgbWVkaXVtYmx1ZTogXCIjMDAwMENEXCIsXG4gIGRhcmtncmVlbjogXCIjMDA2NDAwXCIsXG4gIGRhcmtjeWFuOiBcIiMwMDhCOEJcIixcbiAgZGVlcHNreWJsdWU6IFwiIzAwQkZGRlwiLFxuICBkYXJrdHVycXVvaXNlOiBcIiMwMENFRDFcIixcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IFwiIzAwRkE5QVwiLFxuICBzcHJpbmdncmVlbjogXCIjMDBGRjdGXCIsXG4gIGN5YW46IFwiIzAwRkZGRlwiLFxuICBtaWRuaWdodGJsdWU6IFwiIzE5MTk3MFwiLFxuICBkb2RnZXJibHVlOiBcIiMxRTkwRkZcIixcbiAgbGlnaHRzZWFncmVlbjogXCIjMjBCMkFBXCIsXG4gIGZvcmVzdGdyZWVuOiBcIiMyMjhCMjJcIixcbiAgc2VhZ3JlZW46IFwiIzJFOEI1N1wiLFxuICBkYXJrc2xhdGVncmF5OiBcIiMyRjRGNEZcIixcbiAgZGFya3NsYXRlZ3JleTogXCIjMkY0RjRGXCIsXG4gIGxpbWVncmVlbjogXCIjMzJDRDMyXCIsXG4gIG1lZGl1bXNlYWdyZWVuOiBcIiMzQ0IzNzFcIixcbiAgdHVycXVvaXNlOiBcIiM0MEUwRDBcIixcbiAgcm95YWxibHVlOiBcIiM0MTY5RTFcIixcbiAgc3RlZWxibHVlOiBcIiM0NjgyQjRcIixcbiAgZGFya3NsYXRlYmx1ZTogXCIjNDgzRDhCXCIsXG4gIG1lZGl1bXR1cnF1b2lzZTogXCIjNDhEMUNDXCIsXG4gIGluZGlnbzogXCIjNEIwMDgyXCIsXG4gIGRhcmtvbGl2ZWdyZWVuOiBcIiM1NTZCMkZcIixcbiAgY2FkZXRibHVlOiBcIiM1RjlFQTBcIixcbiAgY29ybmZsb3dlcmJsdWU6IFwiIzY0OTVFRFwiLFxuICByZWJlY2NhcHVycGxlOiBcIiM2NjMzOTlcIixcbiAgbWVkaXVtYXF1YW1hcmluZTogXCIjNjZDREFBXCIsXG4gIGRpbWdyYXk6IFwiIzY5Njk2OVwiLFxuICBkaW1ncmV5OiBcIiM2OTY5NjlcIixcbiAgc2xhdGVibHVlOiBcIiM2QTVBQ0RcIixcbiAgb2xpdmVkcmFiOiBcIiM2QjhFMjNcIixcbiAgc2xhdGVncmF5OiBcIiM3MDgwOTBcIixcbiAgc2xhdGVncmV5OiBcIiM3MDgwOTBcIixcbiAgbGlnaHRzbGF0ZWdyYXk6IFwiIzc3ODg5OVwiLFxuICBsaWdodHNsYXRlZ3JleTogXCIjNzc4ODk5XCIsXG4gIG1lZGl1bXNsYXRlYmx1ZTogXCIjN0I2OEVFXCIsXG4gIGxhd25ncmVlbjogXCIjN0NGQzAwXCIsXG4gIGNoYXJ0cmV1c2U6IFwiIzdGRkYwMFwiLFxuICBhcXVhbWFyaW5lOiBcIiM3RkZGRDRcIixcbiAgc2t5Ymx1ZTogXCIjODdDRUVCXCIsXG4gIGxpZ2h0c2t5Ymx1ZTogXCIjODdDRUZBXCIsXG4gIGJsdWV2aW9sZXQ6IFwiIzhBMkJFMlwiLFxuICBkYXJrcmVkOiBcIiM4QjAwMDBcIixcbiAgZGFya21hZ2VudGE6IFwiIzhCMDA4QlwiLFxuICBzYWRkbGVicm93bjogXCIjOEI0NTEzXCIsXG4gIGRhcmtzZWFncmVlbjogXCIjOEZCQzhGXCIsXG4gIGxpZ2h0Z3JlZW46IFwiIzkwRUU5MFwiLFxuICBtZWRpdW1wdXJwbGU6IFwiIzkzNzBEQlwiLFxuICBkYXJrdmlvbGV0OiBcIiM5NDAwRDNcIixcbiAgcGFsZWdyZWVuOiBcIiM5OEZCOThcIixcbiAgZGFya29yY2hpZDogXCIjOTkzMkNDXCIsXG4gIHllbGxvd2dyZWVuOiBcIiM5QUNEMzJcIixcbiAgc2llbm5hOiBcIiNBMDUyMkRcIixcbiAgYnJvd246IFwiI0E1MkEyQVwiLFxuICBkYXJrZ3JheTogXCIjQTlBOUE5XCIsXG4gIGRhcmtncmV5OiBcIiNBOUE5QTlcIixcbiAgbGlnaHRibHVlOiBcIiNBREQ4RTZcIixcbiAgZ3JlZW55ZWxsb3c6IFwiI0FERkYyRlwiLFxuICBwYWxldHVycXVvaXNlOiBcIiNBRkVFRUVcIixcbiAgbGlnaHRzdGVlbGJsdWU6IFwiI0IwQzRERVwiLFxuICBwb3dkZXJibHVlOiBcIiNCMEUwRTZcIixcbiAgZmlyZWJyaWNrOiBcIiNCMjIyMjJcIixcbiAgZGFya2dvbGRlbnJvZDogXCIjQjg4NjBCXCIsXG4gIG1lZGl1bW9yY2hpZDogXCIjQkE1NUQzXCIsXG4gIHJvc3licm93bjogXCIjQkM4RjhGXCIsXG4gIGRhcmtraGFraTogXCIjQkRCNzZCXCIsXG4gIG1lZGl1bXZpb2xldHJlZDogXCIjQzcxNTg1XCIsXG4gIGluZGlhbnJlZDogXCIjQ0Q1QzVDXCIsXG4gIHBlcnU6IFwiI0NEODUzRlwiLFxuICBjaG9jb2xhdGU6IFwiI0QyNjkxRVwiLFxuICB0YW46IFwiI0QyQjQ4Q1wiLFxuICBsaWdodGdyYXk6IFwiI0QzRDNEM1wiLFxuICBsaWdodGdyZXk6IFwiI0QzRDNEM1wiLFxuICB0aGlzdGxlOiBcIiNEOEJGRDhcIixcbiAgb3JjaGlkOiBcIiNEQTcwRDZcIixcbiAgZ29sZGVucm9kOiBcIiNEQUE1MjBcIixcbiAgcGFsZXZpb2xldHJlZDogXCIjREI3MDkzXCIsXG4gIGNyaW1zb246IFwiI0RDMTQzQ1wiLFxuICBnYWluc2Jvcm86IFwiI0RDRENEQ1wiLFxuICBwbHVtOiBcIiNEREEwRERcIixcbiAgYnVybHl3b29kOiBcIiNERUI4ODdcIixcbiAgbGlnaHRjeWFuOiBcIiNFMEZGRkZcIixcbiAgbGF2ZW5kZXI6IFwiI0U2RTZGQVwiLFxuICBkYXJrc2FsbW9uOiBcIiNFOTk2N0FcIixcbiAgdmlvbGV0OiBcIiNFRTgyRUVcIixcbiAgcGFsZWdvbGRlbnJvZDogXCIjRUVFOEFBXCIsXG4gIGxpZ2h0Y29yYWw6IFwiI0YwODA4MFwiLFxuICBraGFraTogXCIjRjBFNjhDXCIsXG4gIGFsaWNlYmx1ZTogXCIjRjBGOEZGXCIsXG4gIGhvbmV5ZGV3OiBcIiNGMEZGRjBcIixcbiAgYXp1cmU6IFwiI0YwRkZGRlwiLFxuICBzYW5keWJyb3duOiBcIiNGNEE0NjBcIixcbiAgd2hlYXQ6IFwiI0Y1REVCM1wiLFxuICBiZWlnZTogXCIjRjVGNURDXCIsXG4gIHdoaXRlc21va2U6IFwiI0Y1RjVGNVwiLFxuICBtaW50Y3JlYW06IFwiI0Y1RkZGQVwiLFxuICBnaG9zdHdoaXRlOiBcIiNGOEY4RkZcIixcbiAgc2FsbW9uOiBcIiNGQTgwNzJcIixcbiAgYW50aXF1ZXdoaXRlOiBcIiNGQUVCRDdcIixcbiAgbGluZW46IFwiI0ZBRjBFNlwiLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCIjRkFGQUQyXCIsXG4gIG9sZGxhY2U6IFwiI0ZERjVFNlwiLFxuICBtYWdlbnRhOiBcIiNGRjAwRkZcIixcbiAgZGVlcHBpbms6IFwiI0ZGMTQ5M1wiLFxuICBvcmFuZ2VyZWQ6IFwiI0ZGNDUwMFwiLFxuICB0b21hdG86IFwiI0ZGNjM0N1wiLFxuICBob3RwaW5rOiBcIiNGRjY5QjRcIixcbiAgY29yYWw6IFwiI0ZGN0Y1MFwiLFxuICBkYXJrb3JhbmdlOiBcIiNGRjhDMDBcIixcbiAgbGlnaHRzYWxtb246IFwiI0ZGQTA3QVwiLFxuICBvcmFuZ2U6IFwiI0ZGQTUwMFwiLFxuICBsaWdodHBpbms6IFwiI0ZGQjZDMVwiLFxuICBwaW5rOiBcIiNGRkMwQ0JcIixcbiAgZ29sZDogXCIjRkZENzAwXCIsXG4gIHBlYWNocHVmZjogXCIjRkZEQUI5XCIsXG4gIG5hdmFqb3doaXRlOiBcIiNGRkRFQURcIixcbiAgbW9jY2FzaW46IFwiI0ZGRTRCNVwiLFxuICBiaXNxdWU6IFwiI0ZGRTRDNFwiLFxuICBtaXN0eXJvc2U6IFwiI0ZGRTRFMVwiLFxuICBibGFuY2hlZGFsbW9uZDogXCIjRkZFQkNEXCIsXG4gIHBhcGF5YXdoaXA6IFwiI0ZGRUZENVwiLFxuICBsYXZlbmRlcmJsdXNoOiBcIiNGRkYwRjVcIixcbiAgc2Vhc2hlbGw6IFwiI0ZGRjVFRVwiLFxuICBjb3Juc2lsazogXCIjRkZGOERDXCIsXG4gIGxlbW9uY2hpZmZvbjogXCIjRkZGQUNEXCIsXG4gIGZsb3JhbHdoaXRlOiBcIiNGRkZBRjBcIixcbiAgc25vdzogXCIjRkZGQUZBXCIsXG4gIGxpZ2h0eWVsbG93OiBcIiNGRkZGRTBcIixcbiAgaXZvcnk6IFwiI0ZGRkZGMFwiXG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGV4dHJhY3RpbmcgdGhlIGNvbG9yIGF0IHRoZSBnaXZlbiBwaXhlbC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFBpeGVsKGdsLCB4LCB5LCBhcnJheSkge1xuICB2YXIgZGF0YSA9IGFycmF5IHx8IG5ldyBVaW50OEFycmF5KDQpO1xuICBnbC5yZWFkUGl4ZWxzKHgsIHksIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBNZW1vaXplZCBmdW5jdGlvbiByZXR1cm5pbmcgYSBmbG9hdC1lbmNvZGVkIGNvbG9yIGZyb20gdmFyaW91cyBzdHJpbmdcbiAqIGZvcm1hdHMgZGVzY3JpYmluZyBjb2xvcnMuXG4gKi9cbnZhciBJTlQ4ID0gbmV3IEludDhBcnJheSg0KTtcbnZhciBJTlQzMiA9IG5ldyBJbnQzMkFycmF5KElOVDguYnVmZmVyLCAwLCAxKTtcbnZhciBGTE9BVDMyID0gbmV3IEZsb2F0MzJBcnJheShJTlQ4LmJ1ZmZlciwgMCwgMSk7XG52YXIgUkdCQV9URVNUX1JFR0VYID0gL15cXHMqcmdiYT9cXHMqXFwoLztcbnZhciBSR0JBX0VYVFJBQ1RfUkVHRVggPSAvXlxccypyZ2JhP1xccypcXChcXHMqKFswLTldKilcXHMqLFxccyooWzAtOV0qKVxccyosXFxzKihbMC05XSopKD86XFxzKixcXHMqKC4qKT8pP1xcKVxccyokLztcbmZ1bmN0aW9uIHBhcnNlQ29sb3IodmFsKSB7XG4gIHZhciByID0gMDsgLy8gYnl0ZVxuICB2YXIgZyA9IDA7IC8vIGJ5dGVcbiAgdmFyIGIgPSAwOyAvLyBieXRlXG4gIHZhciBhID0gMTsgLy8gZmxvYXRcblxuICAvLyBIYW5kbGluZyBoZXhhZGVjaW1hbCBub3RhdGlvblxuICBpZiAodmFsWzBdID09PSBcIiNcIikge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSA0KSB7XG4gICAgICByID0gcGFyc2VJbnQodmFsLmNoYXJBdCgxKSArIHZhbC5jaGFyQXQoMSksIDE2KTtcbiAgICAgIGcgPSBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgyKSwgMTYpO1xuICAgICAgYiA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMykgKyB2YWwuY2hhckF0KDMpLCAxNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDEpICsgdmFsLmNoYXJBdCgyKSwgMTYpO1xuICAgICAgZyA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMykgKyB2YWwuY2hhckF0KDQpLCAxNik7XG4gICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCg1KSArIHZhbC5jaGFyQXQoNiksIDE2KTtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDkpIHtcbiAgICAgIGEgPSBwYXJzZUludCh2YWwuY2hhckF0KDcpICsgdmFsLmNoYXJBdCg4KSwgMTYpIC8gMjU1O1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsaW5nIHJnYiBub3RhdGlvblxuICBlbHNlIGlmIChSR0JBX1RFU1RfUkVHRVgudGVzdCh2YWwpKSB7XG4gICAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKFJHQkFfRVhUUkFDVF9SRUdFWCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByID0gK21hdGNoWzFdO1xuICAgICAgZyA9ICttYXRjaFsyXTtcbiAgICAgIGIgPSArbWF0Y2hbM107XG4gICAgICBpZiAobWF0Y2hbNF0pIGEgPSArbWF0Y2hbNF07XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxudmFyIEZMT0FUX0NPTE9SX0NBQ0hFID0ge307XG5mb3IgKHZhciBodG1sQ29sb3IgaW4gSFRNTF9DT0xPUlMpIHtcbiAgRkxPQVRfQ09MT1JfQ0FDSEVbaHRtbENvbG9yXSA9IGZsb2F0Q29sb3IoSFRNTF9DT0xPUlNbaHRtbENvbG9yXSk7XG4gIC8vIFJlcGxpY2F0aW5nIGNhY2hlIGZvciBoZXggdmFsdWVzIGZvciBmcmVlXG4gIEZMT0FUX0NPTE9SX0NBQ0hFW0hUTUxfQ09MT1JTW2h0bWxDb2xvcl1dID0gRkxPQVRfQ09MT1JfQ0FDSEVbaHRtbENvbG9yXTtcbn1cbmZ1bmN0aW9uIHJnYmFUb0Zsb2F0KHIsIGcsIGIsIGEsIG1hc2tpbmcpIHtcbiAgSU5UMzJbMF0gPSBhIDw8IDI0IHwgYiA8PCAxNiB8IGcgPDwgOCB8IHI7XG4gIGlmIChtYXNraW5nKSBJTlQzMlswXSA9IElOVDMyWzBdICYgMHhmZWZmZmZmZjtcbiAgcmV0dXJuIEZMT0FUMzJbMF07XG59XG5mdW5jdGlvbiBmbG9hdENvbG9yKHZhbCkge1xuICAvLyBUaGUgaHRtbCBjb2xvciBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuICB2YWwgPSB2YWwudG9Mb3dlckNhc2UoKTtcblxuICAvLyBJZiB0aGUgY29sb3IgaXMgYWxyZWFkeSBjb21wdXRlZCwgd2UgeWllbGQgaXRcbiAgaWYgKHR5cGVvZiBGTE9BVF9DT0xPUl9DQUNIRVt2YWxdICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gRkxPQVRfQ09MT1JfQ0FDSEVbdmFsXTtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlQ29sb3IodmFsKTtcbiAgdmFyIHIgPSBwYXJzZWQucixcbiAgICBnID0gcGFyc2VkLmcsXG4gICAgYiA9IHBhcnNlZC5iO1xuICB2YXIgYSA9IHBhcnNlZC5hO1xuICBhID0gYSAqIDI1NSB8IDA7XG4gIHZhciBjb2xvciA9IHJnYmFUb0Zsb2F0KHIsIGcsIGIsIGEsIHRydWUpO1xuICBGTE9BVF9DT0xPUl9DQUNIRVt2YWxdID0gY29sb3I7XG4gIHJldHVybiBjb2xvcjtcbn1cbmZ1bmN0aW9uIGNvbG9yVG9BcnJheSh2YWwsIG1hc2tpbmcpIHtcbiAgRkxPQVQzMlswXSA9IGZsb2F0Q29sb3IodmFsKTtcbiAgdmFyIGludFZhbHVlID0gSU5UMzJbMF07XG4gIGlmIChtYXNraW5nKSB7XG4gICAgaW50VmFsdWUgPSBpbnRWYWx1ZSB8IDB4MDEwMDAwMDA7XG4gIH1cbiAgdmFyIHIgPSBpbnRWYWx1ZSAmIDB4ZmY7XG4gIHZhciBnID0gaW50VmFsdWUgPj4gOCAmIDB4ZmY7XG4gIHZhciBiID0gaW50VmFsdWUgPj4gMTYgJiAweGZmO1xuICB2YXIgYSA9IGludFZhbHVlID4+IDI0ICYgMHhmZjtcbiAgcmV0dXJuIFtyLCBnLCBiLCBhXTtcbn1cbnZhciBGTE9BVF9JTkRFWF9DQUNIRSA9IHt9O1xuZnVuY3Rpb24gaW5kZXhUb0NvbG9yKGluZGV4KSB7XG4gIC8vIElmIHRoZSBpbmRleCBpcyBhbHJlYWR5IGNvbXB1dGVkLCB3ZSB5aWVsZCBpdFxuICBpZiAodHlwZW9mIEZMT0FUX0lOREVYX0NBQ0hFW2luZGV4XSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIEZMT0FUX0lOREVYX0NBQ0hFW2luZGV4XTtcblxuICAvLyBUbyBhZGRyZXNzIGlzc3VlICMxMzk3LCBvbmUgc3RyYXRlZ3kgaXMgdG8ga2VlcCBlbmNvZGluZyA0IGJ5dGVzIGNvbG9ycyxcbiAgLy8gYnV0IHdpdGggYWxwaGEgaGFyZC1zZXQgdG8gMS4wIChvciAyNTUpOlxuICB2YXIgciA9IChpbmRleCAmIDB4MDBmZjAwMDApID4+PiAxNjtcbiAgdmFyIGcgPSAoaW5kZXggJiAweDAwMDBmZjAwKSA+Pj4gODtcbiAgdmFyIGIgPSBpbmRleCAmIDB4MDAwMDAwZmY7XG4gIHZhciBhID0gMHgwMDAwMDBmZjtcblxuICAvLyBUaGUgb3JpZ2luYWwgNCBieXRlcyBjb2xvciBlbmNvZGluZyB3YXMgdGhlIGZvbGxvd2luZzpcbiAgLy8gY29uc3QgciA9IChpbmRleCAmIDB4ZmYwMDAwMDApID4+PiAyNDtcbiAgLy8gY29uc3QgZyA9IChpbmRleCAmIDB4MDBmZjAwMDApID4+PiAxNjtcbiAgLy8gY29uc3QgYiA9IChpbmRleCAmIDB4MDAwMGZmMDApID4+PiA4O1xuICAvLyBjb25zdCBhID0gaW5kZXggJiAweDAwMDAwMGZmO1xuXG4gIHZhciBjb2xvciA9IHJnYmFUb0Zsb2F0KHIsIGcsIGIsIGEsIHRydWUpO1xuICBGTE9BVF9JTkRFWF9DQUNIRVtpbmRleF0gPSBjb2xvcjtcbiAgcmV0dXJuIGNvbG9yO1xufVxuZnVuY3Rpb24gY29sb3JUb0luZGV4KHIsIGcsIGIsIF9hKSB7XG4gIC8vIEFzIGZvciB0aGUgZnVuY3Rpb24gaW5kZXhUb0NvbG9yLCBiZWNhdXNlIG9mICMxMzk3IGFuZCB0aGUgXCJhbHBoYSBpcyBhbHdheXNcbiAgLy8gMS4wXCIgc3RyYXRlZ3ksIHdlIG5lZWQgdG8gZml4IHRoaXMgZnVuY3Rpb24gYXMgd2VsbDpcbiAgcmV0dXJuIGIgKyAoZyA8PCA4KSArIChyIDw8IDE2KTtcblxuICAvLyBUaGUgb3JpZ2luYWwgNCBieXRlcyBjb2xvciBkZWNvZGluZyBpcyB0aGUgZm9sbG93aW5nOlxuICAvLyByZXR1cm4gYSArIChiIDw8IDgpICsgKGcgPDwgMTYpICsgKHIgPDwgMjQpO1xufVxuZnVuY3Rpb24gZ2V0UGl4ZWxDb2xvcihnbCwgZnJhbWVCdWZmZXIsIHgsIHksIHBpeGVsUmF0aW8sIGRvd25TaXppbmdSYXRpbykge1xuICB2YXIgYnVmZmVyWCA9IE1hdGguZmxvb3IoeCAvIGRvd25TaXppbmdSYXRpbyAqIHBpeGVsUmF0aW8pO1xuICB2YXIgYnVmZmVyWSA9IE1hdGguZmxvb3IoZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAvIGRvd25TaXppbmdSYXRpbyAtIHkgLyBkb3duU2l6aW5nUmF0aW8gKiBwaXhlbFJhdGlvKTtcbiAgdmFyIHBpeGVsID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICBnbC5yZWFkUGl4ZWxzKGJ1ZmZlclgsIGJ1ZmZlclksIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVsKTtcbiAgdmFyIF9waXhlbCA9IF9zbGljZWRUb0FycmF5KHBpeGVsLCA0KSxcbiAgICByID0gX3BpeGVsWzBdLFxuICAgIGcgPSBfcGl4ZWxbMV0sXG4gICAgYiA9IF9waXhlbFsyXSxcbiAgICBhID0gX3BpeGVsWzNdO1xuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxuXG5leHBvcnQgeyBIVE1MX0NPTE9SUyBhcyBILCBfc2xpY2VkVG9BcnJheSBhcyBfLCBfYXJyYXlMaWtlVG9BcnJheSBhcyBhLCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgYXMgYiwgY29sb3JUb0luZGV4IGFzIGMsIGNvbG9yVG9BcnJheSBhcyBkLCBleHRyYWN0UGl4ZWwgYXMgZSwgZmxvYXRDb2xvciBhcyBmLCBnZXRQaXhlbENvbG9yIGFzIGcsIGluZGV4VG9Db2xvciBhcyBpLCBwYXJzZUNvbG9yIGFzIHAsIHJnYmFUb0Zsb2F0IGFzIHIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/colors-beb06eb2.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/dist/data-11df7124.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/sigma/dist/data-11df7124.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _typeof),\n/* harmony export */   a: () => (/* binding */ assign),\n/* harmony export */   b: () => (/* binding */ assignDeep),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   i: () => (/* binding */ isPlainObject)\n/* harmony export */ });\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\n/**\n * Extends the target array with the given values.\n */\nfunction extend(array, values) {\n  var l2 = values.size;\n  if (l2 === 0) return;\n  var l1 = array.length;\n  array.length += l2;\n  var i = 0;\n  values.forEach(function (value) {\n    array[l1 + i] = value;\n    i++;\n  });\n}\n\n/**\n * Checks whether the given value is a plain object.\n */\nfunction isPlainObject(value) {\n  return _typeof(value) === \"object\" && value !== null && value.constructor === Object;\n}\n\n/**\n * Helper to use `Object.assign` with more than two objects.\n */\nfunction assign(target) {\n  target = target || {};\n  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {\n    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    if (!o) continue;\n    Object.assign(target, o);\n  }\n  return target;\n}\n\n/**\n * Very simple recursive `Object.assign` like function.\n */\nfunction assignDeep(target) {\n  target = target || {};\n  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {\n    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    if (!o) continue;\n    for (var k in o) {\n      if (isPlainObject(o[k])) {\n        target[k] = assignDeep(target[k], o[k]);\n      } else {\n        target[k] = o[k];\n      }\n    }\n  }\n  return target;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9kYXRhLTExZGY3MTI0LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsT0FBTztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxPQUFPO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1RiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoeWVvblxcRGVza3RvcFxcZnJvbnRlbmQtaGlkZGVubm9kZVxcbm9kZV9tb2R1bGVzXFxzaWdtYVxcZGlzdFxcZGF0YS0xMWRmNzEyNC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIHRoZSB0YXJnZXQgYXJyYXkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBleHRlbmQoYXJyYXksIHZhbHVlcykge1xuICB2YXIgbDIgPSB2YWx1ZXMuc2l6ZTtcbiAgaWYgKGwyID09PSAwKSByZXR1cm47XG4gIHZhciBsMSA9IGFycmF5Lmxlbmd0aDtcbiAgYXJyYXkubGVuZ3RoICs9IGwyO1xuICB2YXIgaSA9IDA7XG4gIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFycmF5W2wxICsgaV0gPSB2YWx1ZTtcbiAgICBpKys7XG4gIH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gX3R5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gdXNlIGBPYmplY3QuYXNzaWduYCB3aXRoIG1vcmUgdGhhbiB0d28gb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gMCA6IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIG8gPSBpICsgMSA8IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpICsgMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpICsgMV07XG4gICAgaWYgKCFvKSBjb250aW51ZTtcbiAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgbyk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBWZXJ5IHNpbXBsZSByZWN1cnNpdmUgYE9iamVjdC5hc3NpZ25gIGxpa2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbkRlZXAodGFyZ2V0KSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyAwIDogYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgbyA9IGkgKyAxIDwgMSB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgKyAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2kgKyAxXTtcbiAgICBpZiAoIW8pIGNvbnRpbnVlO1xuICAgIGZvciAodmFyIGsgaW4gbykge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob1trXSkpIHtcbiAgICAgICAgdGFyZ2V0W2tdID0gYXNzaWduRGVlcCh0YXJnZXRba10sIG9ba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tdID0gb1trXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IHsgX3R5cGVvZiBhcyBfLCBhc3NpZ24gYXMgYSwgYXNzaWduRGVlcCBhcyBiLCBleHRlbmQgYXMgZSwgaXNQbGFpbk9iamVjdCBhcyBpIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/data-11df7124.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/dist/index-236c62ad.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/sigma/dist/index-236c62ad.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ AbstractNodeProgram),\n/* harmony export */   D: () => (/* binding */ DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS),\n/* harmony export */   E: () => (/* binding */ EdgeArrowProgram$1),\n/* harmony export */   F: () => (/* binding */ FRAGMENT_SHADER_SOURCE),\n/* harmony export */   N: () => (/* binding */ NodeCircleProgram),\n/* harmony export */   P: () => (/* binding */ Program),\n/* harmony export */   _: () => (/* binding */ _objectSpread2),\n/* harmony export */   a: () => (/* binding */ _defineProperty),\n/* harmony export */   b: () => (/* binding */ drawDiscNodeLabel),\n/* harmony export */   c: () => (/* binding */ drawDiscNodeHover),\n/* harmony export */   d: () => (/* binding */ drawStraightEdgeLabel),\n/* harmony export */   e: () => (/* binding */ EdgeRectangleProgram),\n/* harmony export */   f: () => (/* binding */ NodeProgram),\n/* harmony export */   g: () => (/* binding */ EdgeProgram),\n/* harmony export */   h: () => (/* binding */ createEdgeCompoundProgram),\n/* harmony export */   i: () => (/* binding */ createEdgeArrowHeadProgram),\n/* harmony export */   j: () => (/* binding */ createNodeCompoundProgram),\n/* harmony export */   k: () => (/* binding */ AbstractEdgeProgram),\n/* harmony export */   l: () => (/* binding */ AbstractProgram),\n/* harmony export */   m: () => (/* binding */ EdgeArrowHeadProgram$1),\n/* harmony export */   n: () => (/* binding */ EdgeClampedProgram$1),\n/* harmony export */   o: () => (/* binding */ createEdgeClampedProgram),\n/* harmony export */   p: () => (/* binding */ DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS),\n/* harmony export */   q: () => (/* binding */ createEdgeArrowProgram),\n/* harmony export */   r: () => (/* binding */ getAttributeItemsCount),\n/* harmony export */   s: () => (/* binding */ getAttributesItemsCount),\n/* harmony export */   t: () => (/* binding */ loadVertexShader),\n/* harmony export */   u: () => (/* binding */ loadFragmentShader),\n/* harmony export */   v: () => (/* binding */ loadProgram),\n/* harmony export */   w: () => (/* binding */ killProgram),\n/* harmony export */   x: () => (/* binding */ numberToGLSLFloat)\n/* harmony export */ });\n/* harmony import */ var _inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inherits-d1a1e29b.esm.js */ \"(ssr)/./node_modules/sigma/dist/inherits-d1a1e29b.esm.js\");\n/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ \"(ssr)/./node_modules/sigma/dist/colors-beb06eb2.esm.js\");\n\n\n\nfunction _defineProperty(e, r, t) {\n  return (r = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nfunction _superPropBase(t, o) {\n  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(t)););\n  return t;\n}\n\nfunction _get() {\n  return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {\n    var p = _superPropBase(e, t);\n    if (p) {\n      var n = Object.getOwnPropertyDescriptor(p, t);\n      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n    }\n  }, _get.apply(null, arguments);\n}\n\nfunction _superPropGet(t, o, e, r) {\n  var p = _get((0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(1 & r ? t.prototype : t), o, e);\n  return 2 & r && \"function\" == typeof p ? function (t) {\n    return p.apply(e, t);\n  } : p;\n}\n\nfunction getAttributeItemsCount(attr) {\n  return attr.normalized ? 1 : attr.size;\n}\nfunction getAttributesItemsCount(attrs) {\n  var res = 0;\n  attrs.forEach(function (attr) {\n    return res += getAttributeItemsCount(attr);\n  });\n  return res;\n}\nfunction loadShader(type, gl, source) {\n  var glType = type === \"VERTEX\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;\n\n  // Creating the shader\n  var shader = gl.createShader(glType);\n  if (shader === null) {\n    throw new Error(\"loadShader: error while creating the shader\");\n  }\n\n  // Loading source\n  gl.shaderSource(shader, source);\n\n  // Compiling the shader\n  gl.compileShader(shader);\n\n  // Retrieving compilation status\n  var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  // Throwing if something went awry\n  if (!successfullyCompiled) {\n    var infoLog = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(\"loadShader: error while compiling the shader:\\n\".concat(infoLog, \"\\n\").concat(source));\n  }\n  return shader;\n}\nfunction loadVertexShader(gl, source) {\n  return loadShader(\"VERTEX\", gl, source);\n}\nfunction loadFragmentShader(gl, source) {\n  return loadShader(\"FRAGMENT\", gl, source);\n}\n\n/**\n * Function used to load a program.\n */\nfunction loadProgram(gl, shaders) {\n  var program = gl.createProgram();\n  if (program === null) {\n    throw new Error(\"loadProgram: error while creating the program.\");\n  }\n  var i, l;\n\n  // Attaching the shaders\n  for (i = 0, l = shaders.length; i < l; i++) gl.attachShader(program, shaders[i]);\n  gl.linkProgram(program);\n\n  // Checking status\n  var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!successfullyLinked) {\n    gl.deleteProgram(program);\n    throw new Error(\"loadProgram: error while linking the program.\");\n  }\n  return program;\n}\nfunction killProgram(_ref) {\n  var gl = _ref.gl,\n    buffer = _ref.buffer,\n    program = _ref.program,\n    vertexShader = _ref.vertexShader,\n    fragmentShader = _ref.fragmentShader;\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  gl.deleteProgram(program);\n  gl.deleteBuffer(buffer);\n}\n\n/**\n * Function use to print a float for inserting in a GLSL program.\n */\nfunction numberToGLSLFloat(n) {\n  return n % 1 === 0 ? n.toFixed(1) : n.toString();\n}\n\nvar PICKING_PREFIX = \"#define PICKING_MODE\\n\";\nvar SIZE_FACTOR_PER_ATTRIBUTE_TYPE = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, WebGL2RenderingContext.BOOL, 1), WebGL2RenderingContext.BYTE, 1), WebGL2RenderingContext.UNSIGNED_BYTE, 1), WebGL2RenderingContext.SHORT, 2), WebGL2RenderingContext.UNSIGNED_SHORT, 2), WebGL2RenderingContext.INT, 4), WebGL2RenderingContext.UNSIGNED_INT, 4), WebGL2RenderingContext.FLOAT, 4);\nvar AbstractProgram = /*#__PURE__*/(0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(function AbstractProgram(_gl, _pickGl, _renderer) {\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractProgram);\n});\nvar Program = /*#__PURE__*/function () {\n  function Program(gl, pickingBuffer, renderer) {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, Program);\n    // GLenum\n    _defineProperty(this, \"array\", new Float32Array());\n    _defineProperty(this, \"constantArray\", new Float32Array());\n    _defineProperty(this, \"capacity\", 0);\n    _defineProperty(this, \"verticesCount\", 0);\n    // Reading and caching program definition\n    var def = this.getDefinition();\n    this.VERTICES = def.VERTICES;\n    this.VERTEX_SHADER_SOURCE = def.VERTEX_SHADER_SOURCE;\n    this.FRAGMENT_SHADER_SOURCE = def.FRAGMENT_SHADER_SOURCE;\n    this.UNIFORMS = def.UNIFORMS;\n    this.ATTRIBUTES = def.ATTRIBUTES;\n    this.METHOD = def.METHOD;\n    this.CONSTANT_ATTRIBUTES = \"CONSTANT_ATTRIBUTES\" in def ? def.CONSTANT_ATTRIBUTES : [];\n    this.CONSTANT_DATA = \"CONSTANT_DATA\" in def ? def.CONSTANT_DATA : [];\n    this.isInstanced = \"CONSTANT_ATTRIBUTES\" in def;\n\n    // Computing stride\n    this.ATTRIBUTES_ITEMS_COUNT = getAttributesItemsCount(this.ATTRIBUTES);\n    this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT;\n\n    // Members\n    this.renderer = renderer;\n    this.normalProgram = this.getProgramInfo(\"normal\", gl, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);\n    this.pickProgram = pickingBuffer ? this.getProgramInfo(\"pick\", gl, PICKING_PREFIX + def.VERTEX_SHADER_SOURCE, PICKING_PREFIX + def.FRAGMENT_SHADER_SOURCE, pickingBuffer) : null;\n\n    // For instanced programs:\n    if (this.isInstanced) {\n      var constantAttributesItemsCount = getAttributesItemsCount(this.CONSTANT_ATTRIBUTES);\n      if (this.CONSTANT_DATA.length !== this.VERTICES) throw new Error(\"Program: error while getting constant data (expected \".concat(this.VERTICES, \" items, received \").concat(this.CONSTANT_DATA.length, \" instead)\"));\n      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * constantAttributesItemsCount);\n      for (var i = 0; i < this.CONSTANT_DATA.length; i++) {\n        var vector = this.CONSTANT_DATA[i];\n        if (vector.length !== constantAttributesItemsCount) throw new Error(\"Program: error while getting constant data (one vector has \".concat(vector.length, \" items instead of \").concat(constantAttributesItemsCount, \")\"));\n        for (var j = 0; j < vector.length; j++) this.constantArray[i * constantAttributesItemsCount + j] = vector[j];\n      }\n      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;\n    }\n  }\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(Program, [{\n    key: \"kill\",\n    value: function kill() {\n      killProgram(this.normalProgram);\n      if (this.pickProgram) {\n        killProgram(this.pickProgram);\n        this.pickProgram = null;\n      }\n    }\n  }, {\n    key: \"getProgramInfo\",\n    value: function getProgramInfo(name, gl, vertexShaderSource, fragmentShaderSource, frameBuffer) {\n      var def = this.getDefinition();\n\n      // WebGL buffers\n      var buffer = gl.createBuffer();\n      if (buffer === null) throw new Error(\"Program: error while creating the WebGL buffer.\");\n\n      // Shaders and program\n      var vertexShader = loadVertexShader(gl, vertexShaderSource);\n      var fragmentShader = loadFragmentShader(gl, fragmentShaderSource);\n      var program = loadProgram(gl, [vertexShader, fragmentShader]);\n\n      // Initializing locations\n      var uniformLocations = {};\n      def.UNIFORMS.forEach(function (uniformName) {\n        var location = gl.getUniformLocation(program, uniformName);\n        if (location) uniformLocations[uniformName] = location;\n      });\n      var attributeLocations = {};\n      def.ATTRIBUTES.forEach(function (attr) {\n        attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n      });\n\n      // For instanced programs:\n      var constantBuffer;\n      if (\"CONSTANT_ATTRIBUTES\" in def) {\n        def.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n        });\n        constantBuffer = gl.createBuffer();\n        if (constantBuffer === null) throw new Error(\"Program: error while creating the WebGL constant buffer.\");\n      }\n      return {\n        name: name,\n        program: program,\n        gl: gl,\n        frameBuffer: frameBuffer,\n        buffer: buffer,\n        constantBuffer: constantBuffer || {},\n        uniformLocations: uniformLocations,\n        attributeLocations: attributeLocations,\n        isPicking: name === \"pick\",\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader\n      };\n    }\n  }, {\n    key: \"bindProgram\",\n    value: function bindProgram(program) {\n      var _this = this;\n      var offset = 0;\n      var gl = program.gl,\n        buffer = program.buffer;\n      if (!this.isInstanced) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        offset = 0;\n        this.ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n      } else {\n        // Handle constant data (things that remain unchanged for all items):\n        gl.bindBuffer(gl.ARRAY_BUFFER, program.constantBuffer);\n        offset = 0;\n        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset, false);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.constantArray, gl.STATIC_DRAW);\n\n        // Handle \"instance specific\" data (things that vary for each item):\n        gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);\n        offset = 0;\n        this.ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset, true);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n      }\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n  }, {\n    key: \"unbindProgram\",\n    value: function unbindProgram(program) {\n      var _this2 = this;\n      if (!this.isInstanced) {\n        this.ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program);\n        });\n      } else {\n        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program, false);\n        });\n        this.ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program, true);\n        });\n      }\n    }\n  }, {\n    key: \"bindAttribute\",\n    value: function bindAttribute(attr, program, offset, setDivisor) {\n      var sizeFactor = SIZE_FACTOR_PER_ATTRIBUTE_TYPE[attr.type];\n      if (typeof sizeFactor !== \"number\") throw new Error(\"Program.bind: yet unsupported attribute type \\\"\".concat(attr.type, \"\\\"\"));\n      var location = program.attributeLocations[attr.name];\n      var gl = program.gl;\n      if (location !== -1) {\n        gl.enableVertexAttribArray(location);\n        var stride = !this.isInstanced ? this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT : (setDivisor ? this.ATTRIBUTES_ITEMS_COUNT : getAttributesItemsCount(this.CONSTANT_ATTRIBUTES)) * Float32Array.BYTES_PER_ELEMENT;\n        gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized || false, stride, offset);\n        if (this.isInstanced && setDivisor) {\n          if (gl instanceof WebGL2RenderingContext) {\n            gl.vertexAttribDivisor(location, 1);\n          } else {\n            var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n            if (ext) ext.vertexAttribDivisorANGLE(location, 1);\n          }\n        }\n      }\n      return attr.size * sizeFactor;\n    }\n  }, {\n    key: \"unbindAttribute\",\n    value: function unbindAttribute(attr, program, unsetDivisor) {\n      var location = program.attributeLocations[attr.name];\n      var gl = program.gl;\n      if (location !== -1) {\n        gl.disableVertexAttribArray(location);\n        if (this.isInstanced && unsetDivisor) {\n          if (gl instanceof WebGL2RenderingContext) {\n            gl.vertexAttribDivisor(location, 0);\n          } else {\n            var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n            if (ext) ext.vertexAttribDivisorANGLE(location, 0);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"reallocate\",\n    value: function reallocate(capacity) {\n      // If desired capacity has not changed we do nothing\n      // NOTE: it's possible here to implement more subtle reallocation schemes\n      // when the number of rendered items increase or decrease\n      if (capacity === this.capacity) return;\n      this.capacity = capacity;\n      this.verticesCount = this.VERTICES * capacity;\n      this.array = new Float32Array(!this.isInstanced ? this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT : this.capacity * this.ATTRIBUTES_ITEMS_COUNT);\n    }\n  }, {\n    key: \"hasNothingToRender\",\n    value: function hasNothingToRender() {\n      return this.verticesCount === 0;\n    }\n  }, {\n    key: \"renderProgram\",\n    value: function renderProgram(params, programInfo) {\n      var gl = programInfo.gl,\n        program = programInfo.program;\n\n      // With the current fix for #1397, the alpha blending is enabled for the\n      // picking layer:\n      gl.enable(gl.BLEND);\n\n      // Original code:\n      // if (!isPicking) gl.enable(gl.BLEND);\n      // else gl.disable(gl.BLEND);\n\n      gl.useProgram(program);\n      this.setUniforms(params, programInfo);\n      this.drawWebGL(this.METHOD, programInfo);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      if (this.hasNothingToRender()) return;\n      if (this.pickProgram) {\n        this.pickProgram.gl.viewport(0, 0, params.width * params.pixelRatio / params.downSizingRatio, params.height * params.pixelRatio / params.downSizingRatio);\n        this.bindProgram(this.pickProgram);\n        this.renderProgram(_objectSpread2(_objectSpread2({}, params), {}, {\n          pixelRatio: params.pixelRatio / params.downSizingRatio\n        }), this.pickProgram);\n        this.unbindProgram(this.pickProgram);\n      }\n      this.normalProgram.gl.viewport(0, 0, params.width * params.pixelRatio, params.height * params.pixelRatio);\n      this.bindProgram(this.normalProgram);\n      this.renderProgram(params, this.normalProgram);\n      this.unbindProgram(this.normalProgram);\n    }\n  }, {\n    key: \"drawWebGL\",\n    value: function drawWebGL(method, _ref) {\n      var gl = _ref.gl,\n        frameBuffer = _ref.frameBuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      if (!this.isInstanced) {\n        gl.drawArrays(method, 0, this.verticesCount);\n      } else {\n        if (gl instanceof WebGL2RenderingContext) {\n          gl.drawArraysInstanced(method, 0, this.VERTICES, this.capacity);\n        } else {\n          var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n          if (ext) ext.drawArraysInstancedANGLE(method, 0, this.VERTICES, this.capacity);\n        }\n      }\n    }\n  }]);\n}();\n\nvar AbstractNodeProgram = /*#__PURE__*/function (_AbstractProgram) {\n  function AbstractNodeProgram() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractNodeProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, AbstractNodeProgram, arguments);\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(AbstractNodeProgram, _AbstractProgram);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(AbstractNodeProgram);\n}(AbstractProgram);\nvar NodeProgram = /*#__PURE__*/function (_ref) {\n  function NodeProgram() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, NodeProgram, arguments);\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(NodeProgram, _ref);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeProgram, [{\n    key: \"kill\",\n    value: function kill() {\n      _superPropGet(NodeProgram, \"kill\", this, 3)([]);\n    }\n  }, {\n    key: \"process\",\n    value: function process(nodeIndex, offset, data) {\n      var i = offset * this.STRIDE;\n      // NOTE: dealing with hidden items automatically\n      if (data.hidden) {\n        for (var l = i + this.STRIDE; i < l; i++) {\n          this.array[i] = 0;\n        }\n        return;\n      }\n      return this.processVisibleItem((0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)(nodeIndex), i, data);\n    }\n  }]);\n}(Program);\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional node \"draw label\" function.\n * @param  {function} drawHover - An optional node \"draw hover\" function.\n * @return {function}\n */\nfunction createNodeCompoundProgram(programClasses, drawLabel, drawHover) {\n  return /*#__PURE__*/function () {\n    function NodeCompoundProgram(gl, pickingBuffer, renderer) {\n      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeCompoundProgram);\n      _defineProperty(this, \"drawLabel\", drawLabel);\n      _defineProperty(this, \"drawHover\", drawHover);\n      this.programs = programClasses.map(function (Program) {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeCompoundProgram, [{\n      key: \"reallocate\",\n      value: function reallocate(capacity) {\n        this.programs.forEach(function (program) {\n          return program.reallocate(capacity);\n        });\n      }\n    }, {\n      key: \"process\",\n      value: function process(nodeIndex, offset, data) {\n        this.programs.forEach(function (program) {\n          return program.process(nodeIndex, offset, data);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render(params) {\n        this.programs.forEach(function (program) {\n          return program.render(params);\n        });\n      }\n    }, {\n      key: \"kill\",\n      value: function kill() {\n        this.programs.forEach(function (program) {\n          return program.kill();\n        });\n      }\n    }]);\n  }();\n}\n\nvar AbstractEdgeProgram = /*#__PURE__*/function (_AbstractProgram) {\n  function AbstractEdgeProgram() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractEdgeProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, AbstractEdgeProgram, arguments);\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(AbstractEdgeProgram, _AbstractProgram);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(AbstractEdgeProgram);\n}(AbstractProgram);\nvar EdgeProgram = /*#__PURE__*/function (_ref) {\n  function EdgeProgram() {\n    var _this;\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeProgram);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeProgram, [].concat(args));\n    _defineProperty(_this, \"drawLabel\", undefined);\n    return _this;\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeProgram, _ref);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeProgram, [{\n    key: \"kill\",\n    value: function kill() {\n      _superPropGet(EdgeProgram, \"kill\", this, 3)([]);\n    }\n  }, {\n    key: \"process\",\n    value: function process(edgeIndex, offset, sourceData, targetData, data) {\n      var i = offset * this.STRIDE;\n      // NOTE: dealing with hidden items automatically\n      if (data.hidden || sourceData.hidden || targetData.hidden) {\n        for (var l = i + this.STRIDE; i < l; i++) {\n          this.array[i] = 0;\n        }\n        return;\n      }\n      return this.processVisibleItem((0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)(edgeIndex), i, sourceData, targetData, data);\n    }\n  }]);\n}(Program);\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional edge \"draw label\" function.\n * @return {function}\n */\nfunction createEdgeCompoundProgram(programClasses, drawLabel) {\n  return /*#__PURE__*/function () {\n    function EdgeCompoundProgram(gl, pickingBuffer, renderer) {\n      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeCompoundProgram);\n      _defineProperty(this, \"drawLabel\", drawLabel);\n      this.programs = programClasses.map(function (Program) {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeCompoundProgram, [{\n      key: \"reallocate\",\n      value: function reallocate(capacity) {\n        this.programs.forEach(function (program) {\n          return program.reallocate(capacity);\n        });\n      }\n    }, {\n      key: \"process\",\n      value: function process(edgeIndex, offset, sourceData, targetData, data) {\n        this.programs.forEach(function (program) {\n          return program.process(edgeIndex, offset, sourceData, targetData, data);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render(params) {\n        this.programs.forEach(function (program) {\n          return program.render(params);\n        });\n      }\n    }, {\n      key: \"kill\",\n      value: function kill() {\n        this.programs.forEach(function (program) {\n          return program.kill();\n        });\n      }\n    }]);\n  }();\n}\n\nfunction drawStraightEdgeLabel(context, edgeData, sourceData, targetData, settings) {\n  var size = settings.edgeLabelSize,\n    font = settings.edgeLabelFont,\n    weight = settings.edgeLabelWeight,\n    color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\" : settings.edgeLabelColor.color;\n  var label = edgeData.label;\n  if (!label) return;\n  context.fillStyle = color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n  // Computing positions without considering nodes sizes:\n  var sSize = sourceData.size;\n  var tSize = targetData.size;\n  var sx = sourceData.x;\n  var sy = sourceData.y;\n  var tx = targetData.x;\n  var ty = targetData.y;\n  var cx = (sx + tx) / 2;\n  var cy = (sy + ty) / 2;\n  var dx = tx - sx;\n  var dy = ty - sy;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  if (d < sSize + tSize) return;\n\n  // Adding nodes sizes:\n  sx += dx * sSize / d;\n  sy += dy * sSize / d;\n  tx -= dx * tSize / d;\n  ty -= dy * tSize / d;\n  cx = (sx + tx) / 2;\n  cy = (sy + ty) / 2;\n  dx = tx - sx;\n  dy = ty - sy;\n  d = Math.sqrt(dx * dx + dy * dy);\n\n  // Handling ellipsis\n  var textLength = context.measureText(label).width;\n  if (textLength > d) {\n    var ellipsis = \"\";\n    label = label + ellipsis;\n    textLength = context.measureText(label).width;\n    while (textLength > d && label.length > 1) {\n      label = label.slice(0, -2) + ellipsis;\n      textLength = context.measureText(label).width;\n    }\n    if (label.length < 4) return;\n  }\n  var angle;\n  if (dx > 0) {\n    if (dy > 0) angle = Math.acos(dx / d);else angle = Math.asin(dy / d);\n  } else {\n    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;else angle = Math.asin(dx / d) + Math.PI / 2;\n  }\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);\n  context.restore();\n}\n\nfunction drawDiscNodeLabel(context, data, settings) {\n  if (!data.label) return;\n  var size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight,\n    color = settings.labelColor.attribute ? data[settings.labelColor.attribute] || settings.labelColor.color || \"#000\" : settings.labelColor.color;\n  context.fillStyle = color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}\n\n/**\n * Draw an hovered node.\n * - if there is no label => display a shadow on the node\n * - if the label box is bigger than node size => display a label box that contains the node with a shadow\n * - else node with shadow and the label box\n */\nfunction drawDiscNodeHover(context, data, settings) {\n  var size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n  // Then we draw the label background\n  context.fillStyle = \"#FFF\";\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 8;\n  context.shadowColor = \"#000\";\n  var PADDING = 2;\n  if (typeof data.label === \"string\") {\n    var textWidth = context.measureText(data.label).width,\n      boxWidth = Math.round(textWidth + 5),\n      boxHeight = Math.round(size + 2 * PADDING),\n      radius = Math.max(data.size, size / 2) + PADDING;\n    var angleRadian = Math.asin(boxHeight / 2 / radius);\n    var xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));\n    context.beginPath();\n    context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);\n    context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);\n    context.arc(data.x, data.y, radius, angleRadian, -angleRadian);\n    context.closePath();\n    context.fill();\n  } else {\n    context.beginPath();\n    context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);\n    context.closePath();\n    context.fill();\n  }\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 0;\n\n  // And finally we draw the label\n  drawDiscNodeLabel(context, data, settings);\n}\n\n// language=GLSL\nvar SHADER_SOURCE$6 = /*glsl*/\"\\nprecision highp float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\n\\nuniform float u_correctionRatio;\\n\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float border = u_correctionRatio * 2.0;\\n  float dist = length(v_diffVector) - v_radius + border;\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  if (dist > border)\\n    gl_FragColor = transparent;\\n  else\\n    gl_FragColor = v_color;\\n\\n  #else\\n  float t = 0.0;\\n  if (dist > border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / border;\\n\\n  gl_FragColor = mix(v_color, transparent, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;\n\n// language=GLSL\nvar SHADER_SOURCE$5 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\nattribute float a_size;\\nattribute float a_angle;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\\n  vec2 position = a_position + diffVector;\\n  gl_Position = vec4(\\n    (u_matrix * vec3(position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  v_diffVector = diffVector;\\n  v_radius = size / 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;\n\nvar _WebGLRenderingContex$3 = WebGLRenderingContext,\n  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,\n  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;\nvar UNIFORMS$3 = [\"u_sizeRatio\", \"u_correctionRatio\", \"u_matrix\"];\nvar NodeCircleProgram = /*#__PURE__*/function (_NodeProgram) {\n  function NodeCircleProgram() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeCircleProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, NodeCircleProgram, arguments);\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(NodeCircleProgram, _NodeProgram);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeCircleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS$3,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$3\n        }, {\n          name: \"a_size\",\n          size: 1,\n          type: FLOAT$3\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [{\n          name: \"a_angle\",\n          size: 1,\n          type: FLOAT$3\n        }],\n        CONSTANT_DATA: [[NodeCircleProgram.ANGLE_1], [NodeCircleProgram.ANGLE_2], [NodeCircleProgram.ANGLE_3]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(nodeIndex, startIndex, data) {\n      var array = this.array;\n      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n      array[startIndex++] = data.x;\n      array[startIndex++] = data.y;\n      array[startIndex++] = data.size;\n      array[startIndex++] = color;\n      array[startIndex++] = nodeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_matrix = uniformLocations.u_matrix;\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    }\n  }]);\n}(NodeProgram);\n_defineProperty(NodeCircleProgram, \"ANGLE_1\", 0);\n_defineProperty(NodeCircleProgram, \"ANGLE_2\", 2 * Math.PI / 3);\n_defineProperty(NodeCircleProgram, \"ANGLE_3\", 4 * Math.PI / 3);\n\n// language=GLSL\nvar SHADER_SOURCE$4 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$4;\n\n// language=GLSL\nvar SHADER_SOURCE$3 = /*glsl*/\"\\nattribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_radius;\\nattribute vec3 a_barycentric;\\n\\n#ifdef PICKING_MODE\\nattribute vec4 a_id;\\n#else\\nattribute vec4 a_color;\\n#endif\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\nuniform float u_minEdgeThickness;\\nuniform float u_lengthToThicknessRatio;\\nuniform float u_widenessToThicknessRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  float normalLength = length(a_normal);\\n  vec2 unitNormal = a_normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl and\\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\\n  // happening:\\n  float pixelsThickness = max(normalLength / u_sizeRatio, minThickness);\\n  float webGLThickness = pixelsThickness * u_correctionRatio;\\n  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n  float webGLArrowHeadThickness = webGLThickness * u_widenessToThicknessRatio;\\n\\n  float da = a_barycentric.x;\\n  float db = a_barycentric.y;\\n  float dc = a_barycentric.z;\\n\\n  vec2 delta = vec2(\\n      da * (webGLNodeRadius * unitNormal.y)\\n    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadThickness * unitNormal.x)\\n    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadThickness * unitNormal.x),\\n\\n      da * (-webGLNodeRadius * unitNormal.x)\\n    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadThickness * unitNormal.y)\\n    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadThickness * unitNormal.y)\\n  );\\n\\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\\n\\n  gl_Position = vec4(position, 0, 1);\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$3;\n\nvar _WebGLRenderingContex$2 = WebGLRenderingContext,\n  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,\n  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;\nvar UNIFORMS$2 = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_minEdgeThickness\", \"u_lengthToThicknessRatio\", \"u_widenessToThicknessRatio\"];\nvar DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS = {\n  extremity: \"target\",\n  lengthToThicknessRatio: 2.5,\n  widenessToThicknessRatio: 2\n};\nfunction createEdgeArrowHeadProgram(inputOptions) {\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS), inputOptions || {});\n  return /*#__PURE__*/function (_EdgeProgram) {\n    function EdgeArrowHeadProgram() {\n      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeArrowHeadProgram);\n      return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeArrowHeadProgram, arguments);\n    }\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeArrowHeadProgram, _EdgeProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeArrowHeadProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 3,\n          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,\n          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS$2,\n          ATTRIBUTES: [{\n            name: \"a_position\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_normal\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_radius\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }],\n          CONSTANT_ATTRIBUTES: [{\n            name: \"a_barycentric\",\n            size: 3,\n            type: FLOAT$2\n          }],\n          CONSTANT_DATA: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n        if (options.extremity === \"source\") {\n          var _ref = [targetData, sourceData];\n          sourceData = _ref[0];\n          targetData = _ref[1];\n        }\n        var thickness = data.size || 1;\n        var radius = targetData.size || 1;\n        var x1 = sourceData.x;\n        var y1 = sourceData.y;\n        var x2 = targetData.x;\n        var y2 = targetData.y;\n        var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n\n        // Computing normals\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var len = dx * dx + dy * dy;\n        var n1 = 0;\n        var n2 = 0;\n        if (len) {\n          len = 1 / Math.sqrt(len);\n          n1 = -dy * len * thickness;\n          n2 = dx * len * thickness;\n        }\n        var array = this.array;\n        array[startIndex++] = x2;\n        array[startIndex++] = y2;\n        array[startIndex++] = -n1;\n        array[startIndex++] = -n2;\n        array[startIndex++] = radius;\n        array[startIndex++] = color;\n        array[startIndex++] = edgeIndex;\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref2) {\n        var gl = _ref2.gl,\n          uniformLocations = _ref2.uniformLocations;\n        var u_matrix = uniformLocations.u_matrix,\n          u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_correctionRatio = uniformLocations.u_correctionRatio,\n          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,\n          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio,\n          u_widenessToThicknessRatio = uniformLocations.u_widenessToThicknessRatio;\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniform1f(u_correctionRatio, params.correctionRatio);\n        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);\n        gl.uniform1f(u_widenessToThicknessRatio, options.widenessToThicknessRatio);\n      }\n    }]);\n  }(EdgeProgram);\n}\nvar EdgeArrowHeadProgram = createEdgeArrowHeadProgram();\nvar EdgeArrowHeadProgram$1 = EdgeArrowHeadProgram;\n\n// language=GLSL\nvar SHADER_SOURCE$2 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\nvarying float v_feather;\\n\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  // We only handle antialiasing for normal mode:\\n  #ifdef PICKING_MODE\\n  gl_FragColor = v_color;\\n  #else\\n  float dist = length(v_normal) * v_thickness;\\n\\n  float t = smoothstep(\\n    v_thickness - v_feather,\\n    v_thickness,\\n    dist\\n  );\\n\\n  gl_FragColor = mix(v_color, transparent, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$2;\n\n// language=GLSL\nvar SHADER_SOURCE$1 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\nattribute float a_radius;\\nattribute float a_radiusCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_zoomRatio;\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform float u_correctionRatio;\\nuniform float u_minEdgeThickness;\\nuniform float u_lengthToThicknessRatio;\\nuniform float u_feather;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\nvarying float v_feather;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  float radius = a_radius * a_radiusCoef;\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl. Please read it to\\n  // get better comments on what's happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here, we move the point to leave space for the arrow head:\\n  float direction = sign(radius);\\n  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n\\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);\\n\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$1;\n\nvar _WebGLRenderingContex$1 = WebGLRenderingContext,\n  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,\n  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;\nvar UNIFORMS$1 = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_pixelRatio\", \"u_feather\", \"u_minEdgeThickness\", \"u_lengthToThicknessRatio\"];\nvar DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS = {\n  lengthToThicknessRatio: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS.lengthToThicknessRatio\n};\nfunction createEdgeClampedProgram(inputOptions) {\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS), inputOptions || {});\n  return /*#__PURE__*/function (_EdgeProgram) {\n    function EdgeClampedProgram() {\n      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeClampedProgram);\n      return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeClampedProgram, arguments);\n    }\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeClampedProgram, _EdgeProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeClampedProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 6,\n          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,\n          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS$1,\n          ATTRIBUTES: [{\n            name: \"a_positionStart\",\n            size: 2,\n            type: FLOAT$1\n          }, {\n            name: \"a_positionEnd\",\n            size: 2,\n            type: FLOAT$1\n          }, {\n            name: \"a_normal\",\n            size: 2,\n            type: FLOAT$1\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE$1,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE$1,\n            normalized: true\n          }, {\n            name: \"a_radius\",\n            size: 1,\n            type: FLOAT$1\n          }],\n          CONSTANT_ATTRIBUTES: [\n          // If 0, then position will be a_positionStart\n          // If 1, then position will be a_positionEnd\n          {\n            name: \"a_positionCoef\",\n            size: 1,\n            type: FLOAT$1\n          }, {\n            name: \"a_normalCoef\",\n            size: 1,\n            type: FLOAT$1\n          }, {\n            name: \"a_radiusCoef\",\n            size: 1,\n            type: FLOAT$1\n          }],\n          CONSTANT_DATA: [[0, 1, 0], [0, -1, 0], [1, 1, 1], [1, 1, 1], [0, -1, 0], [1, -1, -1]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n        var thickness = data.size || 1;\n        var x1 = sourceData.x;\n        var y1 = sourceData.y;\n        var x2 = targetData.x;\n        var y2 = targetData.y;\n        var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n\n        // Computing normals\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var radius = targetData.size || 1;\n        var len = dx * dx + dy * dy;\n        var n1 = 0;\n        var n2 = 0;\n        if (len) {\n          len = 1 / Math.sqrt(len);\n          n1 = -dy * len * thickness;\n          n2 = dx * len * thickness;\n        }\n        var array = this.array;\n        array[startIndex++] = x1;\n        array[startIndex++] = y1;\n        array[startIndex++] = x2;\n        array[startIndex++] = y2;\n        array[startIndex++] = n1;\n        array[startIndex++] = n2;\n        array[startIndex++] = color;\n        array[startIndex++] = edgeIndex;\n        array[startIndex++] = radius;\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref) {\n        var gl = _ref.gl,\n          uniformLocations = _ref.uniformLocations;\n        var u_matrix = uniformLocations.u_matrix,\n          u_zoomRatio = uniformLocations.u_zoomRatio,\n          u_feather = uniformLocations.u_feather,\n          u_pixelRatio = uniformLocations.u_pixelRatio,\n          u_correctionRatio = uniformLocations.u_correctionRatio,\n          u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,\n          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio;\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1f(u_zoomRatio, params.zoomRatio);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniform1f(u_correctionRatio, params.correctionRatio);\n        gl.uniform1f(u_pixelRatio, params.pixelRatio);\n        gl.uniform1f(u_feather, params.antiAliasingFeather);\n        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);\n      }\n    }]);\n  }(EdgeProgram);\n}\nvar EdgeClampedProgram = createEdgeClampedProgram();\nvar EdgeClampedProgram$1 = EdgeClampedProgram;\n\nfunction createEdgeArrowProgram(inputOptions) {\n  return createEdgeCompoundProgram([createEdgeClampedProgram(inputOptions), createEdgeArrowHeadProgram(inputOptions)]);\n}\nvar EdgeArrowProgram = createEdgeArrowProgram();\nvar EdgeArrowProgram$1 = EdgeArrowProgram;\n\n// language=GLSL\nvar SHADER_SOURCE = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_zoomRatio;\\nuniform float u_pixelRatio;\\nuniform float u_correctionRatio;\\nuniform float u_minEdgeThickness;\\nuniform float u_feather;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\nvarying float v_feather;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // We require edges to be at least \\\"minThickness\\\" pixels thick *on screen*\\n  // (so we need to compensate the size ratio):\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n\\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\\n  // referential (in a ([0, 1], [0, 1]) space), using our \\\"magic\\\" correction\\n  // ratio:\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\\n\\n  // For the fragment shader though, we need a thickness that takes the \\\"magic\\\"\\n  // correction ratio into account (as in webGLThickness), but so that the\\n  // antialiasing effect does not depend on the zoom level. So here's yet\\n  // another thickness version:\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE = SHADER_SOURCE;\n\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nvar UNIFORMS = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_pixelRatio\", \"u_feather\", \"u_minEdgeThickness\"];\nvar EdgeRectangleProgram = /*#__PURE__*/function (_EdgeProgram) {\n  function EdgeRectangleProgram() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeRectangleProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeRectangleProgram, arguments);\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeRectangleProgram, _EdgeProgram);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeRectangleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 6,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 2, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_DATA: [[0, 1], [0, -1], [1, 1], [1, 1], [0, -1], [1, -1]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_zoomRatio = uniformLocations.u_zoomRatio,\n        u_feather = uniformLocations.u_feather,\n        u_pixelRatio = uniformLocations.u_pixelRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_minEdgeThickness = uniformLocations.u_minEdgeThickness;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_zoomRatio, params.zoomRatio);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_pixelRatio, params.pixelRatio);\n      gl.uniform1f(u_feather, params.antiAliasingFeather);\n      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n    }\n  }]);\n}(EdgeProgram);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9pbmRleC0yMzZjNjJhZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlLO0FBQ25GOztBQUU5RTtBQUNBLGNBQWMsNERBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxHQUFHLDRDQUE0Qyw0REFBZSxLQUFLO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxlQUFlLDREQUFlO0FBQzlCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVLQUF1SztBQUN2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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRTB6QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoeWVvblxcRGVza3RvcFxcZnJvbnRlbmQtaGlkZGVubm9kZVxcbm9kZV9tb2R1bGVzXFxzaWdtYVxcZGlzdFxcaW5kZXgtMjM2YzYyYWQuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGQgYXMgX3RvUHJvcGVydHlLZXksIGUgYXMgX2dldFByb3RvdHlwZU9mLCBhIGFzIF9jcmVhdGVDbGFzcywgYiBhcyBfY2xhc3NDYWxsQ2hlY2ssIF8gYXMgX2luaGVyaXRzLCBjIGFzIF9jYWxsU3VwZXIgfSBmcm9tICcuL2luaGVyaXRzLWQxYTFlMjliLmVzbS5qcyc7XG5pbXBvcnQgeyBpIGFzIGluZGV4VG9Db2xvciwgZiBhcyBmbG9hdENvbG9yIH0gZnJvbSAnLi9jb2xvcnMtYmViMDZlYjIuZXNtLmpzJztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcbiAgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogZVtyXSA9IHQsIGU7XG59XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKHQsIG8pIHtcbiAgZm9yICg7ICF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIG8pICYmIG51bGwgIT09ICh0ID0gX2dldFByb3RvdHlwZU9mKHQpKTspO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gX2dldCgpIHtcbiAgcmV0dXJuIF9nZXQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuZ2V0ID8gUmVmbGVjdC5nZXQuYmluZCgpIDogZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICB2YXIgcCA9IF9zdXBlclByb3BCYXNlKGUsIHQpO1xuICAgIGlmIChwKSB7XG4gICAgICB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgdCk7XG4gICAgICByZXR1cm4gbi5nZXQgPyBuLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gZSA6IHIpIDogbi52YWx1ZTtcbiAgICB9XG4gIH0sIF9nZXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEdldCh0LCBvLCBlLCByKSB7XG4gIHZhciBwID0gX2dldChfZ2V0UHJvdG90eXBlT2YoMSAmIHIgPyB0LnByb3RvdHlwZSA6IHQpLCBvLCBlKTtcbiAgcmV0dXJuIDIgJiByICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcCA/IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHAuYXBwbHkoZSwgdCk7XG4gIH0gOiBwO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVJdGVtc0NvdW50KGF0dHIpIHtcbiAgcmV0dXJuIGF0dHIubm9ybWFsaXplZCA/IDEgOiBhdHRyLnNpemU7XG59XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzSXRlbXNDb3VudChhdHRycykge1xuICB2YXIgcmVzID0gMDtcbiAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgIHJldHVybiByZXMgKz0gZ2V0QXR0cmlidXRlSXRlbXNDb3VudChhdHRyKTtcbiAgfSk7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBsb2FkU2hhZGVyKHR5cGUsIGdsLCBzb3VyY2UpIHtcbiAgdmFyIGdsVHlwZSA9IHR5cGUgPT09IFwiVkVSVEVYXCIgPyBnbC5WRVJURVhfU0hBREVSIDogZ2wuRlJBR01FTlRfU0hBREVSO1xuXG4gIC8vIENyZWF0aW5nIHRoZSBzaGFkZXJcbiAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbFR5cGUpO1xuICBpZiAoc2hhZGVyID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFNoYWRlcjogZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIHNoYWRlclwiKTtcbiAgfVxuXG4gIC8vIExvYWRpbmcgc291cmNlXG4gIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG5cbiAgLy8gQ29tcGlsaW5nIHRoZSBzaGFkZXJcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gIC8vIFJldHJpZXZpbmcgY29tcGlsYXRpb24gc3RhdHVzXG4gIHZhciBzdWNjZXNzZnVsbHlDb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcblxuICAvLyBUaHJvd2luZyBpZiBzb21ldGhpbmcgd2VudCBhd3J5XG4gIGlmICghc3VjY2Vzc2Z1bGx5Q29tcGlsZWQpIHtcbiAgICB2YXIgaW5mb0xvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2FkU2hhZGVyOiBlcnJvciB3aGlsZSBjb21waWxpbmcgdGhlIHNoYWRlcjpcXG5cIi5jb25jYXQoaW5mb0xvZywgXCJcXG5cIikuY29uY2F0KHNvdXJjZSkpO1xuICB9XG4gIHJldHVybiBzaGFkZXI7XG59XG5mdW5jdGlvbiBsb2FkVmVydGV4U2hhZGVyKGdsLCBzb3VyY2UpIHtcbiAgcmV0dXJuIGxvYWRTaGFkZXIoXCJWRVJURVhcIiwgZ2wsIHNvdXJjZSk7XG59XG5mdW5jdGlvbiBsb2FkRnJhZ21lbnRTaGFkZXIoZ2wsIHNvdXJjZSkge1xuICByZXR1cm4gbG9hZFNoYWRlcihcIkZSQUdNRU5UXCIsIGdsLCBzb3VyY2UpO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gbG9hZCBhIHByb2dyYW0uXG4gKi9cbmZ1bmN0aW9uIGxvYWRQcm9ncmFtKGdsLCBzaGFkZXJzKSB7XG4gIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBpZiAocHJvZ3JhbSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRQcm9ncmFtOiBlcnJvciB3aGlsZSBjcmVhdGluZyB0aGUgcHJvZ3JhbS5cIik7XG4gIH1cbiAgdmFyIGksIGw7XG5cbiAgLy8gQXR0YWNoaW5nIHRoZSBzaGFkZXJzXG4gIGZvciAoaSA9IDAsIGwgPSBzaGFkZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcnNbaV0pO1xuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAvLyBDaGVja2luZyBzdGF0dXNcbiAgdmFyIHN1Y2Nlc3NmdWxseUxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xuICBpZiAoIXN1Y2Nlc3NmdWxseUxpbmtlZCkge1xuICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFByb2dyYW06IGVycm9yIHdoaWxlIGxpbmtpbmcgdGhlIHByb2dyYW0uXCIpO1xuICB9XG4gIHJldHVybiBwcm9ncmFtO1xufVxuZnVuY3Rpb24ga2lsbFByb2dyYW0oX3JlZikge1xuICB2YXIgZ2wgPSBfcmVmLmdsLFxuICAgIGJ1ZmZlciA9IF9yZWYuYnVmZmVyLFxuICAgIHByb2dyYW0gPSBfcmVmLnByb2dyYW0sXG4gICAgdmVydGV4U2hhZGVyID0gX3JlZi52ZXJ0ZXhTaGFkZXIsXG4gICAgZnJhZ21lbnRTaGFkZXIgPSBfcmVmLmZyYWdtZW50U2hhZGVyO1xuICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgZ2wuZGVsZXRlQnVmZmVyKGJ1ZmZlcik7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdXNlIHRvIHByaW50IGEgZmxvYXQgZm9yIGluc2VydGluZyBpbiBhIEdMU0wgcHJvZ3JhbS5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9HTFNMRmxvYXQobikge1xuICByZXR1cm4gbiAlIDEgPT09IDAgPyBuLnRvRml4ZWQoMSkgOiBuLnRvU3RyaW5nKCk7XG59XG5cbnZhciBQSUNLSU5HX1BSRUZJWCA9IFwiI2RlZmluZSBQSUNLSU5HX01PREVcXG5cIjtcbnZhciBTSVpFX0ZBQ1RPUl9QRVJfQVRUUklCVVRFX1RZUEUgPSBfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHt9LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkJPT0wsIDEpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkJZVEUsIDEpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUsIDEpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNIT1JULCAyKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9TSE9SVCwgMiksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuSU5ULCA0KSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9JTlQsIDQpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FULCA0KTtcbnZhciBBYnN0cmFjdFByb2dyYW0gPSAvKiNfX1BVUkVfXyovX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIEFic3RyYWN0UHJvZ3JhbShfZ2wsIF9waWNrR2wsIF9yZW5kZXJlcikge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJzdHJhY3RQcm9ncmFtKTtcbn0pO1xudmFyIFByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9ncmFtKGdsLCBwaWNraW5nQnVmZmVyLCByZW5kZXJlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmFtKTtcbiAgICAvLyBHTGVudW1cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcnJheVwiLCBuZXcgRmxvYXQzMkFycmF5KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnN0YW50QXJyYXlcIiwgbmV3IEZsb2F0MzJBcnJheSgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXBhY2l0eVwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJ0aWNlc0NvdW50XCIsIDApO1xuICAgIC8vIFJlYWRpbmcgYW5kIGNhY2hpbmcgcHJvZ3JhbSBkZWZpbml0aW9uXG4gICAgdmFyIGRlZiA9IHRoaXMuZ2V0RGVmaW5pdGlvbigpO1xuICAgIHRoaXMuVkVSVElDRVMgPSBkZWYuVkVSVElDRVM7XG4gICAgdGhpcy5WRVJURVhfU0hBREVSX1NPVVJDRSA9IGRlZi5WRVJURVhfU0hBREVSX1NPVVJDRTtcbiAgICB0aGlzLkZSQUdNRU5UX1NIQURFUl9TT1VSQ0UgPSBkZWYuRlJBR01FTlRfU0hBREVSX1NPVVJDRTtcbiAgICB0aGlzLlVOSUZPUk1TID0gZGVmLlVOSUZPUk1TO1xuICAgIHRoaXMuQVRUUklCVVRFUyA9IGRlZi5BVFRSSUJVVEVTO1xuICAgIHRoaXMuTUVUSE9EID0gZGVmLk1FVEhPRDtcbiAgICB0aGlzLkNPTlNUQU5UX0FUVFJJQlVURVMgPSBcIkNPTlNUQU5UX0FUVFJJQlVURVNcIiBpbiBkZWYgPyBkZWYuQ09OU1RBTlRfQVRUUklCVVRFUyA6IFtdO1xuICAgIHRoaXMuQ09OU1RBTlRfREFUQSA9IFwiQ09OU1RBTlRfREFUQVwiIGluIGRlZiA/IGRlZi5DT05TVEFOVF9EQVRBIDogW107XG4gICAgdGhpcy5pc0luc3RhbmNlZCA9IFwiQ09OU1RBTlRfQVRUUklCVVRFU1wiIGluIGRlZjtcblxuICAgIC8vIENvbXB1dGluZyBzdHJpZGVcbiAgICB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQgPSBnZXRBdHRyaWJ1dGVzSXRlbXNDb3VudCh0aGlzLkFUVFJJQlVURVMpO1xuICAgIHRoaXMuU1RSSURFID0gdGhpcy5WRVJUSUNFUyAqIHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVDtcblxuICAgIC8vIE1lbWJlcnNcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5ub3JtYWxQcm9ncmFtID0gdGhpcy5nZXRQcm9ncmFtSW5mbyhcIm5vcm1hbFwiLCBnbCwgZGVmLlZFUlRFWF9TSEFERVJfU09VUkNFLCBkZWYuRlJBR01FTlRfU0hBREVSX1NPVVJDRSwgbnVsbCk7XG4gICAgdGhpcy5waWNrUHJvZ3JhbSA9IHBpY2tpbmdCdWZmZXIgPyB0aGlzLmdldFByb2dyYW1JbmZvKFwicGlja1wiLCBnbCwgUElDS0lOR19QUkVGSVggKyBkZWYuVkVSVEVYX1NIQURFUl9TT1VSQ0UsIFBJQ0tJTkdfUFJFRklYICsgZGVmLkZSQUdNRU5UX1NIQURFUl9TT1VSQ0UsIHBpY2tpbmdCdWZmZXIpIDogbnVsbDtcblxuICAgIC8vIEZvciBpbnN0YW5jZWQgcHJvZ3JhbXM6XG4gICAgaWYgKHRoaXMuaXNJbnN0YW5jZWQpIHtcbiAgICAgIHZhciBjb25zdGFudEF0dHJpYnV0ZXNJdGVtc0NvdW50ID0gZ2V0QXR0cmlidXRlc0l0ZW1zQ291bnQodGhpcy5DT05TVEFOVF9BVFRSSUJVVEVTKTtcbiAgICAgIGlmICh0aGlzLkNPTlNUQU5UX0RBVEEubGVuZ3RoICE9PSB0aGlzLlZFUlRJQ0VTKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9ncmFtOiBlcnJvciB3aGlsZSBnZXR0aW5nIGNvbnN0YW50IGRhdGEgKGV4cGVjdGVkIFwiLmNvbmNhdCh0aGlzLlZFUlRJQ0VTLCBcIiBpdGVtcywgcmVjZWl2ZWQgXCIpLmNvbmNhdCh0aGlzLkNPTlNUQU5UX0RBVEEubGVuZ3RoLCBcIiBpbnN0ZWFkKVwiKSk7XG4gICAgICB0aGlzLmNvbnN0YW50QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuQ09OU1RBTlRfREFUQS5sZW5ndGggKiBjb25zdGFudEF0dHJpYnV0ZXNJdGVtc0NvdW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5DT05TVEFOVF9EQVRBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2ZWN0b3IgPSB0aGlzLkNPTlNUQU5UX0RBVEFbaV07XG4gICAgICAgIGlmICh2ZWN0b3IubGVuZ3RoICE9PSBjb25zdGFudEF0dHJpYnV0ZXNJdGVtc0NvdW50KSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9ncmFtOiBlcnJvciB3aGlsZSBnZXR0aW5nIGNvbnN0YW50IGRhdGEgKG9uZSB2ZWN0b3IgaGFzIFwiLmNvbmNhdCh2ZWN0b3IubGVuZ3RoLCBcIiBpdGVtcyBpbnN0ZWFkIG9mIFwiKS5jb25jYXQoY29uc3RhbnRBdHRyaWJ1dGVzSXRlbXNDb3VudCwgXCIpXCIpKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2ZWN0b3IubGVuZ3RoOyBqKyspIHRoaXMuY29uc3RhbnRBcnJheVtpICogY29uc3RhbnRBdHRyaWJ1dGVzSXRlbXNDb3VudCArIGpdID0gdmVjdG9yW2pdO1xuICAgICAgfVxuICAgICAgdGhpcy5TVFJJREUgPSB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUHJvZ3JhbSwgW3tcbiAgICBrZXk6IFwia2lsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAga2lsbFByb2dyYW0odGhpcy5ub3JtYWxQcm9ncmFtKTtcbiAgICAgIGlmICh0aGlzLnBpY2tQcm9ncmFtKSB7XG4gICAgICAgIGtpbGxQcm9ncmFtKHRoaXMucGlja1Byb2dyYW0pO1xuICAgICAgICB0aGlzLnBpY2tQcm9ncmFtID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHJvZ3JhbUluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvZ3JhbUluZm8obmFtZSwgZ2wsIHZlcnRleFNoYWRlclNvdXJjZSwgZnJhZ21lbnRTaGFkZXJTb3VyY2UsIGZyYW1lQnVmZmVyKSB7XG4gICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgIC8vIFdlYkdMIGJ1ZmZlcnNcbiAgICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGlmIChidWZmZXIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIlByb2dyYW06IGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBXZWJHTCBidWZmZXIuXCIpO1xuXG4gICAgICAvLyBTaGFkZXJzIGFuZCBwcm9ncmFtXG4gICAgICB2YXIgdmVydGV4U2hhZGVyID0gbG9hZFZlcnRleFNoYWRlcihnbCwgdmVydGV4U2hhZGVyU291cmNlKTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGxvYWRGcmFnbWVudFNoYWRlcihnbCwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgICAgdmFyIHByb2dyYW0gPSBsb2FkUHJvZ3JhbShnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcblxuICAgICAgLy8gSW5pdGlhbGl6aW5nIGxvY2F0aW9uc1xuICAgICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgICAgIGRlZi5VTklGT1JNUy5mb3JFYWNoKGZ1bmN0aW9uICh1bmlmb3JtTmFtZSkge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgICAgICBpZiAobG9jYXRpb24pIHVuaWZvcm1Mb2NhdGlvbnNbdW5pZm9ybU5hbWVdID0gbG9jYXRpb247XG4gICAgICB9KTtcbiAgICAgIHZhciBhdHRyaWJ1dGVMb2NhdGlvbnMgPSB7fTtcbiAgICAgIGRlZi5BVFRSSUJVVEVTLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgYXR0cmlidXRlTG9jYXRpb25zW2F0dHIubmFtZV0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyLm5hbWUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZvciBpbnN0YW5jZWQgcHJvZ3JhbXM6XG4gICAgICB2YXIgY29uc3RhbnRCdWZmZXI7XG4gICAgICBpZiAoXCJDT05TVEFOVF9BVFRSSUJVVEVTXCIgaW4gZGVmKSB7XG4gICAgICAgIGRlZi5DT05TVEFOVF9BVFRSSUJVVEVTLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVMb2NhdGlvbnNbYXR0ci5uYW1lXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdGFudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBpZiAoY29uc3RhbnRCdWZmZXIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIlByb2dyYW06IGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBXZWJHTCBjb25zdGFudCBidWZmZXIuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgZ2w6IGdsLFxuICAgICAgICBmcmFtZUJ1ZmZlcjogZnJhbWVCdWZmZXIsXG4gICAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgICAgICBjb25zdGFudEJ1ZmZlcjogY29uc3RhbnRCdWZmZXIgfHwge30sXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnM6IHVuaWZvcm1Mb2NhdGlvbnMsXG4gICAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uczogYXR0cmlidXRlTG9jYXRpb25zLFxuICAgICAgICBpc1BpY2tpbmc6IG5hbWUgPT09IFwicGlja1wiLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IHZlcnRleFNoYWRlcixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50U2hhZGVyXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiaW5kUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgZ2wgPSBwcm9ncmFtLmdsLFxuICAgICAgICBidWZmZXIgPSBwcm9ncmFtLmJ1ZmZlcjtcbiAgICAgIGlmICghdGhpcy5pc0luc3RhbmNlZCkge1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0ICs9IF90aGlzLmJpbmRBdHRyaWJ1dGUoYXR0ciwgcHJvZ3JhbSwgb2Zmc2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFycmF5LCBnbC5EWU5BTUlDX0RSQVcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIGNvbnN0YW50IGRhdGEgKHRoaW5ncyB0aGF0IHJlbWFpbiB1bmNoYW5nZWQgZm9yIGFsbCBpdGVtcyk6XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwcm9ncmFtLmNvbnN0YW50QnVmZmVyKTtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5DT05TVEFOVF9BVFRSSUJVVEVTLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0ICs9IF90aGlzLmJpbmRBdHRyaWJ1dGUoYXR0ciwgcHJvZ3JhbSwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5jb25zdGFudEFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgICAgLy8gSGFuZGxlIFwiaW5zdGFuY2Ugc3BlY2lmaWNcIiBkYXRhICh0aGluZ3MgdGhhdCB2YXJ5IGZvciBlYWNoIGl0ZW0pOlxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcHJvZ3JhbS5idWZmZXIpO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLkFUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBvZmZzZXQgKz0gX3RoaXMuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCBvZmZzZXQsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYXJyYXksIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICB9XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuYmluZFByb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5pc0luc3RhbmNlZCkge1xuICAgICAgICB0aGlzLkFUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIudW5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuQ09OU1RBTlRfQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi51bmJpbmRBdHRyaWJ1dGUoYXR0ciwgcHJvZ3JhbSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnVuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmRBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCBvZmZzZXQsIHNldERpdmlzb3IpIHtcbiAgICAgIHZhciBzaXplRmFjdG9yID0gU0laRV9GQUNUT1JfUEVSX0FUVFJJQlVURV9UWVBFW2F0dHIudHlwZV07XG4gICAgICBpZiAodHlwZW9mIHNpemVGYWN0b3IgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcIlByb2dyYW0uYmluZDogeWV0IHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlIFxcXCJcIi5jb25jYXQoYXR0ci50eXBlLCBcIlxcXCJcIikpO1xuICAgICAgdmFyIGxvY2F0aW9uID0gcHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnNbYXR0ci5uYW1lXTtcbiAgICAgIHZhciBnbCA9IHByb2dyYW0uZ2w7XG4gICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgdmFyIHN0cmlkZSA9ICF0aGlzLmlzSW5zdGFuY2VkID8gdGhpcy5BVFRSSUJVVEVTX0lURU1TX0NPVU5UICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UIDogKHNldERpdmlzb3IgPyB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQgOiBnZXRBdHRyaWJ1dGVzSXRlbXNDb3VudCh0aGlzLkNPTlNUQU5UX0FUVFJJQlVURVMpKSAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2NhdGlvbiwgYXR0ci5zaXplLCBhdHRyLnR5cGUsIGF0dHIubm9ybWFsaXplZCB8fCBmYWxzZSwgc3RyaWRlLCBvZmZzZXQpO1xuICAgICAgICBpZiAodGhpcy5pc0luc3RhbmNlZCAmJiBzZXREaXZpc29yKSB7XG4gICAgICAgICAgaWYgKGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihsb2NhdGlvbiwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpO1xuICAgICAgICAgICAgaWYgKGV4dCkgZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShsb2NhdGlvbiwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0ci5zaXplICogc2l6ZUZhY3RvcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kQXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCB1bnNldERpdmlzb3IpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IHByb2dyYW0uYXR0cmlidXRlTG9jYXRpb25zW2F0dHIubmFtZV07XG4gICAgICB2YXIgZ2wgPSBwcm9ncmFtLmdsO1xuICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICBpZiAodGhpcy5pc0luc3RhbmNlZCAmJiB1bnNldERpdmlzb3IpIHtcbiAgICAgICAgICBpZiAoZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGxvY2F0aW9uLCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIik7XG4gICAgICAgICAgICBpZiAoZXh0KSBleHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGxvY2F0aW9uLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhbGxvY2F0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFsbG9jYXRlKGNhcGFjaXR5KSB7XG4gICAgICAvLyBJZiBkZXNpcmVkIGNhcGFjaXR5IGhhcyBub3QgY2hhbmdlZCB3ZSBkbyBub3RoaW5nXG4gICAgICAvLyBOT1RFOiBpdCdzIHBvc3NpYmxlIGhlcmUgdG8gaW1wbGVtZW50IG1vcmUgc3VidGxlIHJlYWxsb2NhdGlvbiBzY2hlbWVzXG4gICAgICAvLyB3aGVuIHRoZSBudW1iZXIgb2YgcmVuZGVyZWQgaXRlbXMgaW5jcmVhc2Ugb3IgZGVjcmVhc2VcbiAgICAgIGlmIChjYXBhY2l0eSA9PT0gdGhpcy5jYXBhY2l0eSkgcmV0dXJuO1xuICAgICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgICAgdGhpcy52ZXJ0aWNlc0NvdW50ID0gdGhpcy5WRVJUSUNFUyAqIGNhcGFjaXR5O1xuICAgICAgdGhpcy5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIXRoaXMuaXNJbnN0YW5jZWQgPyB0aGlzLnZlcnRpY2VzQ291bnQgKiB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQgOiB0aGlzLmNhcGFjaXR5ICogdGhpcy5BVFRSSUJVVEVTX0lURU1TX0NPVU5UKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzTm90aGluZ1RvUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc05vdGhpbmdUb1JlbmRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzQ291bnQgPT09IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclByb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyUHJvZ3JhbShwYXJhbXMsIHByb2dyYW1JbmZvKSB7XG4gICAgICB2YXIgZ2wgPSBwcm9ncmFtSW5mby5nbCxcbiAgICAgICAgcHJvZ3JhbSA9IHByb2dyYW1JbmZvLnByb2dyYW07XG5cbiAgICAgIC8vIFdpdGggdGhlIGN1cnJlbnQgZml4IGZvciAjMTM5NywgdGhlIGFscGhhIGJsZW5kaW5nIGlzIGVuYWJsZWQgZm9yIHRoZVxuICAgICAgLy8gcGlja2luZyBsYXllcjpcbiAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG5cbiAgICAgIC8vIE9yaWdpbmFsIGNvZGU6XG4gICAgICAvLyBpZiAoIWlzUGlja2luZykgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgIC8vIGVsc2UgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICB0aGlzLnNldFVuaWZvcm1zKHBhcmFtcywgcHJvZ3JhbUluZm8pO1xuICAgICAgdGhpcy5kcmF3V2ViR0wodGhpcy5NRVRIT0QsIHByb2dyYW1JbmZvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihwYXJhbXMpIHtcbiAgICAgIGlmICh0aGlzLmhhc05vdGhpbmdUb1JlbmRlcigpKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5waWNrUHJvZ3JhbSkge1xuICAgICAgICB0aGlzLnBpY2tQcm9ncmFtLmdsLnZpZXdwb3J0KDAsIDAsIHBhcmFtcy53aWR0aCAqIHBhcmFtcy5waXhlbFJhdGlvIC8gcGFyYW1zLmRvd25TaXppbmdSYXRpbywgcGFyYW1zLmhlaWdodCAqIHBhcmFtcy5waXhlbFJhdGlvIC8gcGFyYW1zLmRvd25TaXppbmdSYXRpbyk7XG4gICAgICAgIHRoaXMuYmluZFByb2dyYW0odGhpcy5waWNrUHJvZ3JhbSk7XG4gICAgICAgIHRoaXMucmVuZGVyUHJvZ3JhbShfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGFyYW1zKSwge30sIHtcbiAgICAgICAgICBwaXhlbFJhdGlvOiBwYXJhbXMucGl4ZWxSYXRpbyAvIHBhcmFtcy5kb3duU2l6aW5nUmF0aW9cbiAgICAgICAgfSksIHRoaXMucGlja1Byb2dyYW0pO1xuICAgICAgICB0aGlzLnVuYmluZFByb2dyYW0odGhpcy5waWNrUHJvZ3JhbSk7XG4gICAgICB9XG4gICAgICB0aGlzLm5vcm1hbFByb2dyYW0uZ2wudmlld3BvcnQoMCwgMCwgcGFyYW1zLndpZHRoICogcGFyYW1zLnBpeGVsUmF0aW8sIHBhcmFtcy5oZWlnaHQgKiBwYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICB0aGlzLmJpbmRQcm9ncmFtKHRoaXMubm9ybWFsUHJvZ3JhbSk7XG4gICAgICB0aGlzLnJlbmRlclByb2dyYW0ocGFyYW1zLCB0aGlzLm5vcm1hbFByb2dyYW0pO1xuICAgICAgdGhpcy51bmJpbmRQcm9ncmFtKHRoaXMubm9ybWFsUHJvZ3JhbSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdXZWJHTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3V2ViR0wobWV0aG9kLCBfcmVmKSB7XG4gICAgICB2YXIgZ2wgPSBfcmVmLmdsLFxuICAgICAgICBmcmFtZUJ1ZmZlciA9IF9yZWYuZnJhbWVCdWZmZXI7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICAgIGlmICghdGhpcy5pc0luc3RhbmNlZCkge1xuICAgICAgICBnbC5kcmF3QXJyYXlzKG1ldGhvZCwgMCwgdGhpcy52ZXJ0aWNlc0NvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICAgICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKG1ldGhvZCwgMCwgdGhpcy5WRVJUSUNFUywgdGhpcy5jYXBhY2l0eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIik7XG4gICAgICAgICAgaWYgKGV4dCkgZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShtZXRob2QsIDAsIHRoaXMuVkVSVElDRVMsIHRoaXMuY2FwYWNpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBBYnN0cmFjdE5vZGVQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RQcm9ncmFtKSB7XG4gIGZ1bmN0aW9uIEFic3RyYWN0Tm9kZVByb2dyYW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFic3RyYWN0Tm9kZVByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEFic3RyYWN0Tm9kZVByb2dyYW0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKEFic3RyYWN0Tm9kZVByb2dyYW0sIF9BYnN0cmFjdFByb2dyYW0pO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEFic3RyYWN0Tm9kZVByb2dyYW0pO1xufShBYnN0cmFjdFByb2dyYW0pO1xudmFyIE5vZGVQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfcmVmKSB7XG4gIGZ1bmN0aW9uIE5vZGVQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgTm9kZVByb2dyYW0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKE5vZGVQcm9ncmFtLCBfcmVmKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhOb2RlUHJvZ3JhbSwgW3tcbiAgICBrZXk6IFwia2lsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgX3N1cGVyUHJvcEdldChOb2RlUHJvZ3JhbSwgXCJraWxsXCIsIHRoaXMsIDMpKFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKG5vZGVJbmRleCwgb2Zmc2V0LCBkYXRhKSB7XG4gICAgICB2YXIgaSA9IG9mZnNldCAqIHRoaXMuU1RSSURFO1xuICAgICAgLy8gTk9URTogZGVhbGluZyB3aXRoIGhpZGRlbiBpdGVtcyBhdXRvbWF0aWNhbGx5XG4gICAgICBpZiAoZGF0YS5oaWRkZW4pIHtcbiAgICAgICAgZm9yICh2YXIgbCA9IGkgKyB0aGlzLlNUUklERTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuYXJyYXlbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NWaXNpYmxlSXRlbShpbmRleFRvQ29sb3Iobm9kZUluZGV4KSwgaSwgZGF0YSk7XG4gICAgfVxuICB9XSk7XG59KFByb2dyYW0pO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gY29tYmluaW5nIHR3byBvciBtb3JlIHByb2dyYW1zIGludG8gYSBzaW5nbGUgY29tcG91bmQgb25lLlxuICogTm90ZSB0aGF0IHRoaXMgaXMgbW9yZSBhIHF1aWNrICYgZWFzeSB3YXkgdG8gY29tYmluZSBwcm9ncmFtIHRoYW4gYSByZWFsbHlcbiAqIHBlcmZvcm1hbnQgb3B0aW9uLiBNb3JlIHBlcmZvcm1hbnQgcHJvZ3JhbXMgY2FuIGJlIHdyaXR0ZW4gZW50aXJlbHkuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9ICAgIHByb2dyYW1DbGFzc2VzIC0gUHJvZ3JhbSBjbGFzc2VzIHRvIGNvbWJpbmUuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gZHJhd0xhYmVsIC0gQW4gb3B0aW9uYWwgbm9kZSBcImRyYXcgbGFiZWxcIiBmdW5jdGlvbi5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBkcmF3SG92ZXIgLSBBbiBvcHRpb25hbCBub2RlIFwiZHJhdyBob3ZlclwiIGZ1bmN0aW9uLlxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVDb21wb3VuZFByb2dyYW0ocHJvZ3JhbUNsYXNzZXMsIGRyYXdMYWJlbCwgZHJhd0hvdmVyKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGVDb21wb3VuZFByb2dyYW0oZ2wsIHBpY2tpbmdCdWZmZXIsIHJlbmRlcmVyKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUNvbXBvdW5kUHJvZ3JhbSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmF3TGFiZWxcIiwgZHJhd0xhYmVsKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYXdIb3ZlclwiLCBkcmF3SG92ZXIpO1xuICAgICAgdGhpcy5wcm9ncmFtcyA9IHByb2dyYW1DbGFzc2VzLm1hcChmdW5jdGlvbiAoUHJvZ3JhbSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb2dyYW0oZ2wsIHBpY2tpbmdCdWZmZXIsIHJlbmRlcmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKE5vZGVDb21wb3VuZFByb2dyYW0sIFt7XG4gICAgICBrZXk6IFwicmVhbGxvY2F0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWxsb2NhdGUoY2FwYWNpdHkpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ucmVhbGxvY2F0ZShjYXBhY2l0eSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzcyhub2RlSW5kZXgsIG9mZnNldCwgZGF0YSkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5wcm9jZXNzKG5vZGVJbmRleCwgb2Zmc2V0LCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ucmVuZGVyKHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJraWxsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ua2lsbCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbn1cblxudmFyIEFic3RyYWN0RWRnZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdFByb2dyYW0pIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3RFZGdlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJzdHJhY3RFZGdlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgQWJzdHJhY3RFZGdlUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoQWJzdHJhY3RFZGdlUHJvZ3JhbSwgX0Fic3RyYWN0UHJvZ3JhbSk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQWJzdHJhY3RFZGdlUHJvZ3JhbSk7XG59KEFic3RyYWN0UHJvZ3JhbSk7XG52YXIgRWRnZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9yZWYpIHtcbiAgZnVuY3Rpb24gRWRnZVByb2dyYW0oKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlUHJvZ3JhbSk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgRWRnZVByb2dyYW0sIFtdLmNvbmNhdChhcmdzKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImRyYXdMYWJlbFwiLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoRWRnZVByb2dyYW0sIF9yZWYpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVkZ2VQcm9ncmFtLCBbe1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICBfc3VwZXJQcm9wR2V0KEVkZ2VQcm9ncmFtLCBcImtpbGxcIiwgdGhpcywgMykoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3MoZWRnZUluZGV4LCBvZmZzZXQsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpIHtcbiAgICAgIHZhciBpID0gb2Zmc2V0ICogdGhpcy5TVFJJREU7XG4gICAgICAvLyBOT1RFOiBkZWFsaW5nIHdpdGggaGlkZGVuIGl0ZW1zIGF1dG9tYXRpY2FsbHlcbiAgICAgIGlmIChkYXRhLmhpZGRlbiB8fCBzb3VyY2VEYXRhLmhpZGRlbiB8fCB0YXJnZXREYXRhLmhpZGRlbikge1xuICAgICAgICBmb3IgKHZhciBsID0gaSArIHRoaXMuU1RSSURFOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hcnJheVtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Zpc2libGVJdGVtKGluZGV4VG9Db2xvcihlZGdlSW5kZXgpLCBpLCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1dKTtcbn0oUHJvZ3JhbSk7XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBjb21iaW5pbmcgdHdvIG9yIG1vcmUgcHJvZ3JhbXMgaW50byBhIHNpbmdsZSBjb21wb3VuZCBvbmUuXG4gKiBOb3RlIHRoYXQgdGhpcyBpcyBtb3JlIGEgcXVpY2sgJiBlYXN5IHdheSB0byBjb21iaW5lIHByb2dyYW0gdGhhbiBhIHJlYWxseVxuICogcGVyZm9ybWFudCBvcHRpb24uIE1vcmUgcGVyZm9ybWFudCBwcm9ncmFtcyBjYW4gYmUgd3JpdHRlbiBlbnRpcmVseS5cbiAqXG4gKiBAcGFyYW0gIHthcnJheX0gICAgcHJvZ3JhbUNsYXNzZXMgLSBQcm9ncmFtIGNsYXNzZXMgdG8gY29tYmluZS5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBkcmF3TGFiZWwgLSBBbiBvcHRpb25hbCBlZGdlIFwiZHJhdyBsYWJlbFwiIGZ1bmN0aW9uLlxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VDb21wb3VuZFByb2dyYW0ocHJvZ3JhbUNsYXNzZXMsIGRyYXdMYWJlbCkge1xuICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFZGdlQ29tcG91bmRQcm9ncmFtKGdsLCBwaWNraW5nQnVmZmVyLCByZW5kZXJlcikge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VDb21wb3VuZFByb2dyYW0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhd0xhYmVsXCIsIGRyYXdMYWJlbCk7XG4gICAgICB0aGlzLnByb2dyYW1zID0gcHJvZ3JhbUNsYXNzZXMubWFwKGZ1bmN0aW9uIChQcm9ncmFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvZ3JhbShnbCwgcGlja2luZ0J1ZmZlciwgcmVuZGVyZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoRWRnZUNvbXBvdW5kUHJvZ3JhbSwgW3tcbiAgICAgIGtleTogXCJyZWFsbG9jYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVhbGxvY2F0ZShjYXBhY2l0eSkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5yZWFsbG9jYXRlKGNhcGFjaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKGVkZ2VJbmRleCwgb2Zmc2V0LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLnByb2Nlc3MoZWRnZUluZGV4LCBvZmZzZXQsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcmFtcykge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5yZW5kZXIocGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImtpbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5raWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpO1xufVxuXG5mdW5jdGlvbiBkcmF3U3RyYWlnaHRFZGdlTGFiZWwoY29udGV4dCwgZWRnZURhdGEsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIHNldHRpbmdzKSB7XG4gIHZhciBzaXplID0gc2V0dGluZ3MuZWRnZUxhYmVsU2l6ZSxcbiAgICBmb250ID0gc2V0dGluZ3MuZWRnZUxhYmVsRm9udCxcbiAgICB3ZWlnaHQgPSBzZXR0aW5ncy5lZGdlTGFiZWxXZWlnaHQsXG4gICAgY29sb3IgPSBzZXR0aW5ncy5lZGdlTGFiZWxDb2xvci5hdHRyaWJ1dGUgPyBlZGdlRGF0YVtzZXR0aW5ncy5lZGdlTGFiZWxDb2xvci5hdHRyaWJ1dGVdIHx8IHNldHRpbmdzLmVkZ2VMYWJlbENvbG9yLmNvbG9yIHx8IFwiIzAwMFwiIDogc2V0dGluZ3MuZWRnZUxhYmVsQ29sb3IuY29sb3I7XG4gIHZhciBsYWJlbCA9IGVkZ2VEYXRhLmxhYmVsO1xuICBpZiAoIWxhYmVsKSByZXR1cm47XG4gIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gIGNvbnRleHQuZm9udCA9IFwiXCIuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZm9udCk7XG5cbiAgLy8gQ29tcHV0aW5nIHBvc2l0aW9ucyB3aXRob3V0IGNvbnNpZGVyaW5nIG5vZGVzIHNpemVzOlxuICB2YXIgc1NpemUgPSBzb3VyY2VEYXRhLnNpemU7XG4gIHZhciB0U2l6ZSA9IHRhcmdldERhdGEuc2l6ZTtcbiAgdmFyIHN4ID0gc291cmNlRGF0YS54O1xuICB2YXIgc3kgPSBzb3VyY2VEYXRhLnk7XG4gIHZhciB0eCA9IHRhcmdldERhdGEueDtcbiAgdmFyIHR5ID0gdGFyZ2V0RGF0YS55O1xuICB2YXIgY3ggPSAoc3ggKyB0eCkgLyAyO1xuICB2YXIgY3kgPSAoc3kgKyB0eSkgLyAyO1xuICB2YXIgZHggPSB0eCAtIHN4O1xuICB2YXIgZHkgPSB0eSAtIHN5O1xuICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIGlmIChkIDwgc1NpemUgKyB0U2l6ZSkgcmV0dXJuO1xuXG4gIC8vIEFkZGluZyBub2RlcyBzaXplczpcbiAgc3ggKz0gZHggKiBzU2l6ZSAvIGQ7XG4gIHN5ICs9IGR5ICogc1NpemUgLyBkO1xuICB0eCAtPSBkeCAqIHRTaXplIC8gZDtcbiAgdHkgLT0gZHkgKiB0U2l6ZSAvIGQ7XG4gIGN4ID0gKHN4ICsgdHgpIC8gMjtcbiAgY3kgPSAoc3kgKyB0eSkgLyAyO1xuICBkeCA9IHR4IC0gc3g7XG4gIGR5ID0gdHkgLSBzeTtcbiAgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgLy8gSGFuZGxpbmcgZWxsaXBzaXNcbiAgdmFyIHRleHRMZW5ndGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgaWYgKHRleHRMZW5ndGggPiBkKSB7XG4gICAgdmFyIGVsbGlwc2lzID0gXCLigKZcIjtcbiAgICBsYWJlbCA9IGxhYmVsICsgZWxsaXBzaXM7XG4gICAgdGV4dExlbmd0aCA9IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIHdoaWxlICh0ZXh0TGVuZ3RoID4gZCAmJiBsYWJlbC5sZW5ndGggPiAxKSB7XG4gICAgICBsYWJlbCA9IGxhYmVsLnNsaWNlKDAsIC0yKSArIGVsbGlwc2lzO1xuICAgICAgdGV4dExlbmd0aCA9IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIH1cbiAgICBpZiAobGFiZWwubGVuZ3RoIDwgNCkgcmV0dXJuO1xuICB9XG4gIHZhciBhbmdsZTtcbiAgaWYgKGR4ID4gMCkge1xuICAgIGlmIChkeSA+IDApIGFuZ2xlID0gTWF0aC5hY29zKGR4IC8gZCk7ZWxzZSBhbmdsZSA9IE1hdGguYXNpbihkeSAvIGQpO1xuICB9IGVsc2Uge1xuICAgIGlmIChkeSA+IDApIGFuZ2xlID0gTWF0aC5hY29zKGR4IC8gZCkgKyBNYXRoLlBJO2Vsc2UgYW5nbGUgPSBNYXRoLmFzaW4oZHggLyBkKSArIE1hdGguUEkgLyAyO1xuICB9XG4gIGNvbnRleHQuc2F2ZSgpO1xuICBjb250ZXh0LnRyYW5zbGF0ZShjeCwgY3kpO1xuICBjb250ZXh0LnJvdGF0ZShhbmdsZSk7XG4gIGNvbnRleHQuZmlsbFRleHQobGFiZWwsIC10ZXh0TGVuZ3RoIC8gMiwgZWRnZURhdGEuc2l6ZSAvIDIgKyBzaXplKTtcbiAgY29udGV4dC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdEaXNjTm9kZUxhYmVsKGNvbnRleHQsIGRhdGEsIHNldHRpbmdzKSB7XG4gIGlmICghZGF0YS5sYWJlbCkgcmV0dXJuO1xuICB2YXIgc2l6ZSA9IHNldHRpbmdzLmxhYmVsU2l6ZSxcbiAgICBmb250ID0gc2V0dGluZ3MubGFiZWxGb250LFxuICAgIHdlaWdodCA9IHNldHRpbmdzLmxhYmVsV2VpZ2h0LFxuICAgIGNvbG9yID0gc2V0dGluZ3MubGFiZWxDb2xvci5hdHRyaWJ1dGUgPyBkYXRhW3NldHRpbmdzLmxhYmVsQ29sb3IuYXR0cmlidXRlXSB8fCBzZXR0aW5ncy5sYWJlbENvbG9yLmNvbG9yIHx8IFwiIzAwMFwiIDogc2V0dGluZ3MubGFiZWxDb2xvci5jb2xvcjtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgY29udGV4dC5mb250ID0gXCJcIi5jb25jYXQod2VpZ2h0LCBcIiBcIikuY29uY2F0KHNpemUsIFwicHggXCIpLmNvbmNhdChmb250KTtcbiAgY29udGV4dC5maWxsVGV4dChkYXRhLmxhYmVsLCBkYXRhLnggKyBkYXRhLnNpemUgKyAzLCBkYXRhLnkgKyBzaXplIC8gMyk7XG59XG5cbi8qKlxuICogRHJhdyBhbiBob3ZlcmVkIG5vZGUuXG4gKiAtIGlmIHRoZXJlIGlzIG5vIGxhYmVsID0+IGRpc3BsYXkgYSBzaGFkb3cgb24gdGhlIG5vZGVcbiAqIC0gaWYgdGhlIGxhYmVsIGJveCBpcyBiaWdnZXIgdGhhbiBub2RlIHNpemUgPT4gZGlzcGxheSBhIGxhYmVsIGJveCB0aGF0IGNvbnRhaW5zIHRoZSBub2RlIHdpdGggYSBzaGFkb3dcbiAqIC0gZWxzZSBub2RlIHdpdGggc2hhZG93IGFuZCB0aGUgbGFiZWwgYm94XG4gKi9cbmZ1bmN0aW9uIGRyYXdEaXNjTm9kZUhvdmVyKGNvbnRleHQsIGRhdGEsIHNldHRpbmdzKSB7XG4gIHZhciBzaXplID0gc2V0dGluZ3MubGFiZWxTaXplLFxuICAgIGZvbnQgPSBzZXR0aW5ncy5sYWJlbEZvbnQsXG4gICAgd2VpZ2h0ID0gc2V0dGluZ3MubGFiZWxXZWlnaHQ7XG4gIGNvbnRleHQuZm9udCA9IFwiXCIuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZm9udCk7XG5cbiAgLy8gVGhlbiB3ZSBkcmF3IHRoZSBsYWJlbCBiYWNrZ3JvdW5kXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjRkZGXCI7XG4gIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XG4gIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gIGNvbnRleHQuc2hhZG93Qmx1ciA9IDg7XG4gIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcIiMwMDBcIjtcbiAgdmFyIFBBRERJTkcgPSAyO1xuICBpZiAodHlwZW9mIGRhdGEubGFiZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICB2YXIgdGV4dFdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChkYXRhLmxhYmVsKS53aWR0aCxcbiAgICAgIGJveFdpZHRoID0gTWF0aC5yb3VuZCh0ZXh0V2lkdGggKyA1KSxcbiAgICAgIGJveEhlaWdodCA9IE1hdGgucm91bmQoc2l6ZSArIDIgKiBQQURESU5HKSxcbiAgICAgIHJhZGl1cyA9IE1hdGgubWF4KGRhdGEuc2l6ZSwgc2l6ZSAvIDIpICsgUEFERElORztcbiAgICB2YXIgYW5nbGVSYWRpYW4gPSBNYXRoLmFzaW4oYm94SGVpZ2h0IC8gMiAvIHJhZGl1cyk7XG4gICAgdmFyIHhEZWx0YUNvb3JkID0gTWF0aC5zcXJ0KE1hdGguYWJzKE1hdGgucG93KHJhZGl1cywgMikgLSBNYXRoLnBvdyhib3hIZWlnaHQgLyAyLCAyKSkpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oZGF0YS54ICsgeERlbHRhQ29vcmQsIGRhdGEueSArIGJveEhlaWdodCAvIDIpO1xuICAgIGNvbnRleHQubGluZVRvKGRhdGEueCArIHJhZGl1cyArIGJveFdpZHRoLCBkYXRhLnkgKyBib3hIZWlnaHQgLyAyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhkYXRhLnggKyByYWRpdXMgKyBib3hXaWR0aCwgZGF0YS55IC0gYm94SGVpZ2h0IC8gMik7XG4gICAgY29udGV4dC5saW5lVG8oZGF0YS54ICsgeERlbHRhQ29vcmQsIGRhdGEueSAtIGJveEhlaWdodCAvIDIpO1xuICAgIGNvbnRleHQuYXJjKGRhdGEueCwgZGF0YS55LCByYWRpdXMsIGFuZ2xlUmFkaWFuLCAtYW5nbGVSYWRpYW4pO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmFyYyhkYXRhLngsIGRhdGEueSwgZGF0YS5zaXplICsgUEFERElORywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cbiAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcblxuICAvLyBBbmQgZmluYWxseSB3ZSBkcmF3IHRoZSBsYWJlbFxuICBkcmF3RGlzY05vZGVMYWJlbChjb250ZXh0LCBkYXRhLCBzZXR0aW5ncyk7XG59XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFJDYgPSAvKmdsc2wqL1wiXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X2RpZmZWZWN0b3I7XFxudmFyeWluZyBmbG9hdCB2X3JhZGl1cztcXG5cXG51bmlmb3JtIGZsb2F0IHVfY29ycmVjdGlvblJhdGlvO1xcblxcbmNvbnN0IHZlYzQgdHJhbnNwYXJlbnQgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGZsb2F0IGJvcmRlciA9IHVfY29ycmVjdGlvblJhdGlvICogMi4wO1xcbiAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2X2RpZmZWZWN0b3IpIC0gdl9yYWRpdXMgKyBib3JkZXI7XFxuXFxuICAvLyBObyBhbnRpYWxpYXNpbmcgZm9yIHBpY2tpbmcgbW9kZTpcXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIGlmIChkaXN0ID4gYm9yZGVyKVxcbiAgICBnbF9GcmFnQ29sb3IgPSB0cmFuc3BhcmVudDtcXG4gIGVsc2VcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcXG5cXG4gICNlbHNlXFxuICBmbG9hdCB0ID0gMC4wO1xcbiAgaWYgKGRpc3QgPiBib3JkZXIpXFxuICAgIHQgPSAxLjA7XFxuICBlbHNlIGlmIChkaXN0ID4gMC4wKVxcbiAgICB0ID0gZGlzdCAvIGJvcmRlcjtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IG1peCh2X2NvbG9yLCB0cmFuc3BhcmVudCwgdCk7XFxuICAjZW5kaWZcXG59XFxuXCI7XG52YXIgRlJBR01FTlRfU0hBREVSX1NPVVJDRSQyID0gU0hBREVSX1NPVVJDRSQ2O1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQ1ID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3NpemU7XFxuYXR0cmlidXRlIGZsb2F0IGFfYW5nbGU7XFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2NvcnJlY3Rpb25SYXRpbztcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl9kaWZmVmVjdG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9yYWRpdXM7XFxudmFyeWluZyBmbG9hdCB2X2JvcmRlcjtcXG5cXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBmbG9hdCBzaXplID0gYV9zaXplICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbyAqIDQuMDtcXG4gIHZlYzIgZGlmZlZlY3RvciA9IHNpemUgKiB2ZWMyKGNvcyhhX2FuZ2xlKSwgc2luKGFfYW5nbGUpKTtcXG4gIHZlYzIgcG9zaXRpb24gPSBhX3Bvc2l0aW9uICsgZGlmZlZlY3RvcjtcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNChcXG4gICAgKHVfbWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMSkpLnh5LFxcbiAgICAwLFxcbiAgICAxXFxuICApO1xcblxcbiAgdl9kaWZmVmVjdG9yID0gZGlmZlZlY3RvcjtcXG4gIHZfcmFkaXVzID0gc2l6ZSAvIDIuMDtcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG5cXG4gIHZfY29sb3IuYSAqPSBiaWFzO1xcbn1cXG5cIjtcbnZhciBWRVJURVhfU0hBREVSX1NPVVJDRSQzID0gU0hBREVSX1NPVVJDRSQ1O1xuXG52YXIgX1dlYkdMUmVuZGVyaW5nQ29udGV4JDMgPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUkMyA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQzLlVOU0lHTkVEX0JZVEUsXG4gIEZMT0FUJDMgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMy5GTE9BVDtcbnZhciBVTklGT1JNUyQzID0gW1widV9zaXplUmF0aW9cIiwgXCJ1X2NvcnJlY3Rpb25SYXRpb1wiLCBcInVfbWF0cml4XCJdO1xudmFyIE5vZGVDaXJjbGVQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZVByb2dyYW0pIHtcbiAgZnVuY3Rpb24gTm9kZUNpcmNsZVByb2dyYW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVDaXJjbGVQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBOb2RlQ2lyY2xlUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoTm9kZUNpcmNsZVByb2dyYW0sIF9Ob2RlUHJvZ3JhbSk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTm9kZUNpcmNsZVByb2dyYW0sIFt7XG4gICAga2V5OiBcImdldERlZmluaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFZFUlRJQ0VTOiAzLFxuICAgICAgICBWRVJURVhfU0hBREVSX1NPVVJDRTogVkVSVEVYX1NIQURFUl9TT1VSQ0UkMyxcbiAgICAgICAgRlJBR01FTlRfU0hBREVSX1NPVVJDRTogRlJBR01FTlRfU0hBREVSX1NPVVJDRSQyLFxuICAgICAgICBNRVRIT0Q6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsXG4gICAgICAgIFVOSUZPUk1TOiBVTklGT1JNUyQzLFxuICAgICAgICBBVFRSSUJVVEVTOiBbe1xuICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvblwiLFxuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgdHlwZTogRkxPQVQkM1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX3NpemVcIixcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHR5cGU6IEZMT0FUJDNcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9jb2xvclwiLFxuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQzLFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9pZFwiLFxuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQzLFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgfV0sXG4gICAgICAgIENPTlNUQU5UX0FUVFJJQlVURVM6IFt7XG4gICAgICAgICAgbmFtZTogXCJhX2FuZ2xlXCIsXG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICB0eXBlOiBGTE9BVCQzXG4gICAgICAgIH1dLFxuICAgICAgICBDT05TVEFOVF9EQVRBOiBbW05vZGVDaXJjbGVQcm9ncmFtLkFOR0xFXzFdLCBbTm9kZUNpcmNsZVByb2dyYW0uQU5HTEVfMl0sIFtOb2RlQ2lyY2xlUHJvZ3JhbS5BTkdMRV8zXV1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NWaXNpYmxlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlzaWJsZUl0ZW0obm9kZUluZGV4LCBzdGFydEluZGV4LCBkYXRhKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgdmFyIGNvbG9yID0gZmxvYXRDb2xvcihkYXRhLmNvbG9yKTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBkYXRhLng7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZGF0YS55O1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGRhdGEuc2l6ZTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBjb2xvcjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBub2RlSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFVuaWZvcm1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVuaWZvcm1zKHBhcmFtcywgX3JlZikge1xuICAgICAgdmFyIGdsID0gX3JlZi5nbCxcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9ucyA9IF9yZWYudW5pZm9ybUxvY2F0aW9ucztcbiAgICAgIHZhciB1X3NpemVSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9zaXplUmF0aW8sXG4gICAgICAgIHVfY29ycmVjdGlvblJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X2NvcnJlY3Rpb25SYXRpbyxcbiAgICAgICAgdV9tYXRyaXggPSB1bmlmb3JtTG9jYXRpb25zLnVfbWF0cml4O1xuICAgICAgZ2wudW5pZm9ybTFmKHVfY29ycmVjdGlvblJhdGlvLCBwYXJhbXMuY29ycmVjdGlvblJhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm0xZih1X3NpemVSYXRpbywgcGFyYW1zLnNpemVSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVfbWF0cml4LCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgfVxuICB9XSk7XG59KE5vZGVQcm9ncmFtKTtcbl9kZWZpbmVQcm9wZXJ0eShOb2RlQ2lyY2xlUHJvZ3JhbSwgXCJBTkdMRV8xXCIsIDApO1xuX2RlZmluZVByb3BlcnR5KE5vZGVDaXJjbGVQcm9ncmFtLCBcIkFOR0xFXzJcIiwgMiAqIE1hdGguUEkgLyAzKTtcbl9kZWZpbmVQcm9wZXJ0eShOb2RlQ2lyY2xlUHJvZ3JhbSwgXCJBTkdMRV8zXCIsIDQgKiBNYXRoLlBJIC8gMyk7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFJDQgPSAvKmdsc2wqL1wiXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7XFxufVxcblwiO1xudmFyIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UkMSA9IFNIQURFUl9TT1VSQ0UkNDtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UkMyA9IC8qZ2xzbCovXCJcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfbm9ybWFsO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3JhZGl1cztcXG5hdHRyaWJ1dGUgdmVjMyBhX2JhcnljZW50cmljO1xcblxcbiNpZmRlZiBQSUNLSU5HX01PREVcXG5hdHRyaWJ1dGUgdmVjNCBhX2lkO1xcbiNlbHNlXFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG4jZW5kaWZcXG5cXG51bmlmb3JtIG1hdDMgdV9tYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3NpemVSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfY29ycmVjdGlvblJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9taW5FZGdlVGhpY2tuZXNzO1xcbnVuaWZvcm0gZmxvYXQgdV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV93aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW87XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxuY29uc3QgZmxvYXQgYmlhcyA9IDI1NS4wIC8gMjU0LjA7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgbWluVGhpY2tuZXNzID0gdV9taW5FZGdlVGhpY2tuZXNzO1xcblxcbiAgZmxvYXQgbm9ybWFsTGVuZ3RoID0gbGVuZ3RoKGFfbm9ybWFsKTtcXG4gIHZlYzIgdW5pdE5vcm1hbCA9IGFfbm9ybWFsIC8gbm9ybWFsTGVuZ3RoO1xcblxcbiAgLy8gVGhlc2UgZmlyc3QgY29tcHV0YXRpb25zIGFyZSB0YWtlbiBmcm9tIGVkZ2UudmVydC5nbHNsIGFuZFxcbiAgLy8gZWRnZS5jbGFtcGVkLnZlcnQuZ2xzbC4gUGxlYXNlIHJlYWQgaXQgdG8gZ2V0IGJldHRlciBjb21tZW50cyBvbiB3aGF0J3NcXG4gIC8vIGhhcHBlbmluZzpcXG4gIGZsb2F0IHBpeGVsc1RoaWNrbmVzcyA9IG1heChub3JtYWxMZW5ndGggLyB1X3NpemVSYXRpbywgbWluVGhpY2tuZXNzKTtcXG4gIGZsb2F0IHdlYkdMVGhpY2tuZXNzID0gcGl4ZWxzVGhpY2tuZXNzICogdV9jb3JyZWN0aW9uUmF0aW87XFxuICBmbG9hdCB3ZWJHTE5vZGVSYWRpdXMgPSBhX3JhZGl1cyAqIDIuMCAqIHVfY29ycmVjdGlvblJhdGlvIC8gdV9zaXplUmF0aW87XFxuICBmbG9hdCB3ZWJHTEFycm93SGVhZExlbmd0aCA9IHdlYkdMVGhpY2tuZXNzICogdV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvICogMi4wO1xcbiAgZmxvYXQgd2ViR0xBcnJvd0hlYWRUaGlja25lc3MgPSB3ZWJHTFRoaWNrbmVzcyAqIHVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvO1xcblxcbiAgZmxvYXQgZGEgPSBhX2JhcnljZW50cmljLng7XFxuICBmbG9hdCBkYiA9IGFfYmFyeWNlbnRyaWMueTtcXG4gIGZsb2F0IGRjID0gYV9iYXJ5Y2VudHJpYy56O1xcblxcbiAgdmVjMiBkZWx0YSA9IHZlYzIoXFxuICAgICAgZGEgKiAod2ViR0xOb2RlUmFkaXVzICogdW5pdE5vcm1hbC55KVxcbiAgICArIGRiICogKCh3ZWJHTE5vZGVSYWRpdXMgKyB3ZWJHTEFycm93SGVhZExlbmd0aCkgKiB1bml0Tm9ybWFsLnkgKyB3ZWJHTEFycm93SGVhZFRoaWNrbmVzcyAqIHVuaXROb3JtYWwueClcXG4gICAgKyBkYyAqICgod2ViR0xOb2RlUmFkaXVzICsgd2ViR0xBcnJvd0hlYWRMZW5ndGgpICogdW5pdE5vcm1hbC55IC0gd2ViR0xBcnJvd0hlYWRUaGlja25lc3MgKiB1bml0Tm9ybWFsLngpLFxcblxcbiAgICAgIGRhICogKC13ZWJHTE5vZGVSYWRpdXMgKiB1bml0Tm9ybWFsLngpXFxuICAgICsgZGIgKiAoLSh3ZWJHTE5vZGVSYWRpdXMgKyB3ZWJHTEFycm93SGVhZExlbmd0aCkgKiB1bml0Tm9ybWFsLnggKyB3ZWJHTEFycm93SGVhZFRoaWNrbmVzcyAqIHVuaXROb3JtYWwueSlcXG4gICAgKyBkYyAqICgtKHdlYkdMTm9kZVJhZGl1cyArIHdlYkdMQXJyb3dIZWFkTGVuZ3RoKSAqIHVuaXROb3JtYWwueCAtIHdlYkdMQXJyb3dIZWFkVGhpY2tuZXNzICogdW5pdE5vcm1hbC55KVxcbiAgKTtcXG5cXG4gIHZlYzIgcG9zaXRpb24gPSAodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24gKyBkZWx0YSwgMSkpLnh5O1xcblxcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLCAxKTtcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG5cXG4gIHZfY29sb3IuYSAqPSBiaWFzO1xcbn1cXG5cIjtcbnZhciBWRVJURVhfU0hBREVSX1NPVVJDRSQyID0gU0hBREVSX1NPVVJDRSQzO1xuXG52YXIgX1dlYkdMUmVuZGVyaW5nQ29udGV4JDIgPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUkMiA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQyLlVOU0lHTkVEX0JZVEUsXG4gIEZMT0FUJDIgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMi5GTE9BVDtcbnZhciBVTklGT1JNUyQyID0gW1widV9tYXRyaXhcIiwgXCJ1X3NpemVSYXRpb1wiLCBcInVfY29ycmVjdGlvblJhdGlvXCIsIFwidV9taW5FZGdlVGhpY2tuZXNzXCIsIFwidV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvXCIsIFwidV93aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW9cIl07XG52YXIgREVGQVVMVF9FREdFX0FSUk9XX0hFQURfUFJPR1JBTV9PUFRJT05TID0ge1xuICBleHRyZW1pdHk6IFwidGFyZ2V0XCIsXG4gIGxlbmd0aFRvVGhpY2tuZXNzUmF0aW86IDIuNSxcbiAgd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvOiAyXG59O1xuZnVuY3Rpb24gY3JlYXRlRWRnZUFycm93SGVhZFByb2dyYW0oaW5wdXRPcHRpb25zKSB7XG4gIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfRURHRV9BUlJPV19IRUFEX1BST0dSQU1fT1BUSU9OUyksIGlucHV0T3B0aW9ucyB8fCB7fSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FZGdlUHJvZ3JhbSkge1xuICAgIGZ1bmN0aW9uIEVkZ2VBcnJvd0hlYWRQcm9ncmFtKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VBcnJvd0hlYWRQcm9ncmFtKTtcbiAgICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEVkZ2VBcnJvd0hlYWRQcm9ncmFtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfaW5oZXJpdHMoRWRnZUFycm93SGVhZFByb2dyYW0sIF9FZGdlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFZGdlQXJyb3dIZWFkUHJvZ3JhbSwgW3tcbiAgICAgIGtleTogXCJnZXREZWZpbml0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBWRVJUSUNFUzogMyxcbiAgICAgICAgICBWRVJURVhfU0hBREVSX1NPVVJDRTogVkVSVEVYX1NIQURFUl9TT1VSQ0UkMixcbiAgICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDEsXG4gICAgICAgICAgTUVUSE9EOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLFxuICAgICAgICAgIFVOSUZPUk1TOiBVTklGT1JNUyQyLFxuICAgICAgICAgIEFUVFJJQlVURVM6IFt7XG4gICAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25cIixcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQyXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX25vcm1hbFwiLFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfcmFkaXVzXCIsXG4gICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9jb2xvclwiLFxuICAgICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMixcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfaWRcIixcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDIsXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgQ09OU1RBTlRfQVRUUklCVVRFUzogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiYV9iYXJ5Y2VudHJpY1wiLFxuICAgICAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBDT05TVEFOVF9EQVRBOiBbWzEsIDAsIDBdLCBbMCwgMSwgMF0sIFswLCAwLCAxXV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvY2Vzc1Zpc2libGVJdGVtXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1Zpc2libGVJdGVtKGVkZ2VJbmRleCwgc3RhcnRJbmRleCwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSkge1xuICAgICAgICBpZiAob3B0aW9ucy5leHRyZW1pdHkgPT09IFwic291cmNlXCIpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IFt0YXJnZXREYXRhLCBzb3VyY2VEYXRhXTtcbiAgICAgICAgICBzb3VyY2VEYXRhID0gX3JlZlswXTtcbiAgICAgICAgICB0YXJnZXREYXRhID0gX3JlZlsxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpY2tuZXNzID0gZGF0YS5zaXplIHx8IDE7XG4gICAgICAgIHZhciByYWRpdXMgPSB0YXJnZXREYXRhLnNpemUgfHwgMTtcbiAgICAgICAgdmFyIHgxID0gc291cmNlRGF0YS54O1xuICAgICAgICB2YXIgeTEgPSBzb3VyY2VEYXRhLnk7XG4gICAgICAgIHZhciB4MiA9IHRhcmdldERhdGEueDtcbiAgICAgICAgdmFyIHkyID0gdGFyZ2V0RGF0YS55O1xuICAgICAgICB2YXIgY29sb3IgPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuXG4gICAgICAgIC8vIENvbXB1dGluZyBub3JtYWxzXG4gICAgICAgIHZhciBkeCA9IHgyIC0geDE7XG4gICAgICAgIHZhciBkeSA9IHkyIC0geTE7XG4gICAgICAgIHZhciBsZW4gPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgdmFyIG4xID0gMDtcbiAgICAgICAgdmFyIG4yID0gMDtcbiAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgICBuMSA9IC1keSAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgICBuMiA9IGR4ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB4MjtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHkyO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gLW4xO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gLW4yO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gcmFkaXVzO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gY29sb3I7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBlZGdlSW5kZXg7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFVuaWZvcm1zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybXMocGFyYW1zLCBfcmVmMikge1xuICAgICAgICB2YXIgZ2wgPSBfcmVmMi5nbCxcbiAgICAgICAgICB1bmlmb3JtTG9jYXRpb25zID0gX3JlZjIudW5pZm9ybUxvY2F0aW9ucztcbiAgICAgICAgdmFyIHVfbWF0cml4ID0gdW5pZm9ybUxvY2F0aW9ucy51X21hdHJpeCxcbiAgICAgICAgICB1X3NpemVSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9zaXplUmF0aW8sXG4gICAgICAgICAgdV9jb3JyZWN0aW9uUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfY29ycmVjdGlvblJhdGlvLFxuICAgICAgICAgIHVfbWluRWRnZVRoaWNrbmVzcyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9taW5FZGdlVGhpY2tuZXNzLFxuICAgICAgICAgIHVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvLFxuICAgICAgICAgIHVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3dpZGVuZXNzVG9UaGlja25lc3NSYXRpbztcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1X21hdHJpeCwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9zaXplUmF0aW8sIHBhcmFtcy5zaXplUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9jb3JyZWN0aW9uUmF0aW8sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9taW5FZGdlVGhpY2tuZXNzLCBwYXJhbXMubWluRWRnZVRoaWNrbmVzcyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8sIG9wdGlvbnMubGVuZ3RoVG9UaGlja25lc3NSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X3dpZGVuZXNzVG9UaGlja25lc3NSYXRpbywgb3B0aW9ucy53aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW8pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShFZGdlUHJvZ3JhbSk7XG59XG52YXIgRWRnZUFycm93SGVhZFByb2dyYW0gPSBjcmVhdGVFZGdlQXJyb3dIZWFkUHJvZ3JhbSgpO1xudmFyIEVkZ2VBcnJvd0hlYWRQcm9ncmFtJDEgPSBFZGdlQXJyb3dIZWFkUHJvZ3JhbTtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UkMiA9IC8qZ2xzbCovXCJcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X3RoaWNrbmVzcztcXG52YXJ5aW5nIGZsb2F0IHZfZmVhdGhlcjtcXG5cXG5jb25zdCB2ZWM0IHRyYW5zcGFyZW50ID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBXZSBvbmx5IGhhbmRsZSBhbnRpYWxpYXNpbmcgZm9yIG5vcm1hbCBtb2RlOlxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcXG4gICNlbHNlXFxuICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZfbm9ybWFsKSAqIHZfdGhpY2tuZXNzO1xcblxcbiAgZmxvYXQgdCA9IHNtb290aHN0ZXAoXFxuICAgIHZfdGhpY2tuZXNzIC0gdl9mZWF0aGVyLFxcbiAgICB2X3RoaWNrbmVzcyxcXG4gICAgZGlzdFxcbiAgKTtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IG1peCh2X2NvbG9yLCB0cmFuc3BhcmVudCwgdCk7XFxuICAjZW5kaWZcXG59XFxuXCI7XG52YXIgRlJBR01FTlRfU0hBREVSX1NPVVJDRSA9IFNIQURFUl9TT1VSQ0UkMjtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UkMSA9IC8qZ2xzbCovXCJcXG5hdHRyaWJ1dGUgdmVjNCBhX2lkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuYXR0cmlidXRlIHZlYzIgYV9ub3JtYWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfbm9ybWFsQ29lZjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uU3RhcnQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbkVuZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9wb3NpdGlvbkNvZWY7XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFkaXVzO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3JhZGl1c0NvZWY7XFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV96b29tUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X3NpemVSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfcGl4ZWxSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfY29ycmVjdGlvblJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9taW5FZGdlVGhpY2tuZXNzO1xcbnVuaWZvcm0gZmxvYXQgdV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9mZWF0aGVyO1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGZsb2F0IHZfdGhpY2tuZXNzO1xcbnZhcnlpbmcgZmxvYXQgdl9mZWF0aGVyO1xcblxcbmNvbnN0IGZsb2F0IGJpYXMgPSAyNTUuMCAvIDI1NC4wO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGZsb2F0IG1pblRoaWNrbmVzcyA9IHVfbWluRWRnZVRoaWNrbmVzcztcXG5cXG4gIGZsb2F0IHJhZGl1cyA9IGFfcmFkaXVzICogYV9yYWRpdXNDb2VmO1xcbiAgdmVjMiBub3JtYWwgPSBhX25vcm1hbCAqIGFfbm9ybWFsQ29lZjtcXG4gIHZlYzIgcG9zaXRpb24gPSBhX3Bvc2l0aW9uU3RhcnQgKiAoMS4wIC0gYV9wb3NpdGlvbkNvZWYpICsgYV9wb3NpdGlvbkVuZCAqIGFfcG9zaXRpb25Db2VmO1xcblxcbiAgZmxvYXQgbm9ybWFsTGVuZ3RoID0gbGVuZ3RoKG5vcm1hbCk7XFxuICB2ZWMyIHVuaXROb3JtYWwgPSBub3JtYWwgLyBub3JtYWxMZW5ndGg7XFxuXFxuICAvLyBUaGVzZSBmaXJzdCBjb21wdXRhdGlvbnMgYXJlIHRha2VuIGZyb20gZWRnZS52ZXJ0Lmdsc2wuIFBsZWFzZSByZWFkIGl0IHRvXFxuICAvLyBnZXQgYmV0dGVyIGNvbW1lbnRzIG9uIHdoYXQncyBoYXBwZW5pbmc6XFxuICBmbG9hdCBwaXhlbHNUaGlja25lc3MgPSBtYXgobm9ybWFsTGVuZ3RoLCBtaW5UaGlja25lc3MgKiB1X3NpemVSYXRpbyk7XFxuICBmbG9hdCB3ZWJHTFRoaWNrbmVzcyA9IHBpeGVsc1RoaWNrbmVzcyAqIHVfY29ycmVjdGlvblJhdGlvIC8gdV9zaXplUmF0aW87XFxuXFxuICAvLyBIZXJlLCB3ZSBtb3ZlIHRoZSBwb2ludCB0byBsZWF2ZSBzcGFjZSBmb3IgdGhlIGFycm93IGhlYWQ6XFxuICBmbG9hdCBkaXJlY3Rpb24gPSBzaWduKHJhZGl1cyk7XFxuICBmbG9hdCB3ZWJHTE5vZGVSYWRpdXMgPSBkaXJlY3Rpb24gKiByYWRpdXMgKiAyLjAgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfc2l6ZVJhdGlvO1xcbiAgZmxvYXQgd2ViR0xBcnJvd0hlYWRMZW5ndGggPSB3ZWJHTFRoaWNrbmVzcyAqIHVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbyAqIDIuMDtcXG5cXG4gIHZlYzIgY29tcGVuc2F0aW9uVmVjdG9yID0gdmVjMigtZGlyZWN0aW9uICogdW5pdE5vcm1hbC55LCBkaXJlY3Rpb24gKiB1bml0Tm9ybWFsLngpICogKHdlYkdMTm9kZVJhZGl1cyArIHdlYkdMQXJyb3dIZWFkTGVuZ3RoKTtcXG5cXG4gIC8vIEhlcmUgaXMgdGhlIHByb3BlciBwb3NpdGlvbiBvZiB0aGUgdmVydGV4XFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHVfbWF0cml4ICogdmVjMyhwb3NpdGlvbiArIHVuaXROb3JtYWwgKiB3ZWJHTFRoaWNrbmVzcyArIGNvbXBlbnNhdGlvblZlY3RvciwgMSkpLnh5LCAwLCAxKTtcXG5cXG4gIHZfdGhpY2tuZXNzID0gd2ViR0xUaGlja25lc3MgLyB1X3pvb21SYXRpbztcXG5cXG4gIHZfbm9ybWFsID0gdW5pdE5vcm1hbDtcXG5cXG4gIHZfZmVhdGhlciA9IHVfZmVhdGhlciAqIHVfY29ycmVjdGlvblJhdGlvIC8gdV96b29tUmF0aW8gLyB1X3BpeGVsUmF0aW8gKiAyLjA7XFxuXFxuICAjaWZkZWYgUElDS0lOR19NT0RFXFxuICAvLyBGb3IgcGlja2luZyBtb2RlLCB3ZSB1c2UgdGhlIElEIGFzIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2lkO1xcbiAgI2Vsc2VcXG4gIC8vIEZvciBub3JtYWwgbW9kZSwgd2UgdXNlIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuXFxuICB2X2NvbG9yLmEgKj0gYmlhcztcXG59XFxuXCI7XG52YXIgVkVSVEVYX1NIQURFUl9TT1VSQ0UkMSA9IFNIQURFUl9TT1VSQ0UkMTtcblxudmFyIF9XZWJHTFJlbmRlcmluZ0NvbnRleCQxID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBVTlNJR05FRF9CWVRFJDEgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMS5VTlNJR05FRF9CWVRFLFxuICBGTE9BVCQxID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4JDEuRkxPQVQ7XG52YXIgVU5JRk9STVMkMSA9IFtcInVfbWF0cml4XCIsIFwidV96b29tUmF0aW9cIiwgXCJ1X3NpemVSYXRpb1wiLCBcInVfY29ycmVjdGlvblJhdGlvXCIsIFwidV9waXhlbFJhdGlvXCIsIFwidV9mZWF0aGVyXCIsIFwidV9taW5FZGdlVGhpY2tuZXNzXCIsIFwidV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvXCJdO1xudmFyIERFRkFVTFRfRURHRV9DTEFNUEVEX1BST0dSQU1fT1BUSU9OUyA9IHtcbiAgbGVuZ3RoVG9UaGlja25lc3NSYXRpbzogREVGQVVMVF9FREdFX0FSUk9XX0hFQURfUFJPR1JBTV9PUFRJT05TLmxlbmd0aFRvVGhpY2tuZXNzUmF0aW9cbn07XG5mdW5jdGlvbiBjcmVhdGVFZGdlQ2xhbXBlZFByb2dyYW0oaW5wdXRPcHRpb25zKSB7XG4gIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfRURHRV9DTEFNUEVEX1BST0dSQU1fT1BUSU9OUyksIGlucHV0T3B0aW9ucyB8fCB7fSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FZGdlUHJvZ3JhbSkge1xuICAgIGZ1bmN0aW9uIEVkZ2VDbGFtcGVkUHJvZ3JhbSgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlQ2xhbXBlZFByb2dyYW0pO1xuICAgICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgRWRnZUNsYW1wZWRQcm9ncmFtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfaW5oZXJpdHMoRWRnZUNsYW1wZWRQcm9ncmFtLCBfRWRnZVByb2dyYW0pO1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoRWRnZUNsYW1wZWRQcm9ncmFtLCBbe1xuICAgICAga2V5OiBcImdldERlZmluaXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFZFUlRJQ0VTOiA2LFxuICAgICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSQxLFxuICAgICAgICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UsXG4gICAgICAgICAgTUVUSE9EOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLFxuICAgICAgICAgIFVOSUZPUk1TOiBVTklGT1JNUyQxLFxuICAgICAgICAgIEFUVFJJQlVURVM6IFt7XG4gICAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25TdGFydFwiLFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25FbmRcIixcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX25vcm1hbFwiLFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfY29sb3JcIixcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDEsXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX2lkXCIsXG4gICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQxLFxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9yYWRpdXNcIixcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQxXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgQ09OU1RBTlRfQVRUUklCVVRFUzogW1xuICAgICAgICAgIC8vIElmIDAsIHRoZW4gcG9zaXRpb24gd2lsbCBiZSBhX3Bvc2l0aW9uU3RhcnRcbiAgICAgICAgICAvLyBJZiAxLCB0aGVuIHBvc2l0aW9uIHdpbGwgYmUgYV9wb3NpdGlvbkVuZFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvbkNvZWZcIixcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX25vcm1hbENvZWZcIixcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX3JhZGl1c0NvZWZcIixcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQxXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgQ09OU1RBTlRfREFUQTogW1swLCAxLCAwXSwgWzAsIC0xLCAwXSwgWzEsIDEsIDFdLCBbMSwgMSwgMV0sIFswLCAtMSwgMF0sIFsxLCAtMSwgLTFdXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcm9jZXNzVmlzaWJsZUl0ZW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlzaWJsZUl0ZW0oZWRnZUluZGV4LCBzdGFydEluZGV4LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICAgIHZhciB0aGlja25lc3MgPSBkYXRhLnNpemUgfHwgMTtcbiAgICAgICAgdmFyIHgxID0gc291cmNlRGF0YS54O1xuICAgICAgICB2YXIgeTEgPSBzb3VyY2VEYXRhLnk7XG4gICAgICAgIHZhciB4MiA9IHRhcmdldERhdGEueDtcbiAgICAgICAgdmFyIHkyID0gdGFyZ2V0RGF0YS55O1xuICAgICAgICB2YXIgY29sb3IgPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuXG4gICAgICAgIC8vIENvbXB1dGluZyBub3JtYWxzXG4gICAgICAgIHZhciBkeCA9IHgyIC0geDE7XG4gICAgICAgIHZhciBkeSA9IHkyIC0geTE7XG4gICAgICAgIHZhciByYWRpdXMgPSB0YXJnZXREYXRhLnNpemUgfHwgMTtcbiAgICAgICAgdmFyIGxlbiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICB2YXIgbjEgPSAwO1xuICAgICAgICB2YXIgbjIgPSAwO1xuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICAgIG4xID0gLWR5ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgICAgIG4yID0gZHggKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgxO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTE7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB4MjtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHkyO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gbjE7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBuMjtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGNvbG9yO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZWRnZUluZGV4O1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gcmFkaXVzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRVbmlmb3Jtc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVuaWZvcm1zKHBhcmFtcywgX3JlZikge1xuICAgICAgICB2YXIgZ2wgPSBfcmVmLmdsLFxuICAgICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMgPSBfcmVmLnVuaWZvcm1Mb2NhdGlvbnM7XG4gICAgICAgIHZhciB1X21hdHJpeCA9IHVuaWZvcm1Mb2NhdGlvbnMudV9tYXRyaXgsXG4gICAgICAgICAgdV96b29tUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfem9vbVJhdGlvLFxuICAgICAgICAgIHVfZmVhdGhlciA9IHVuaWZvcm1Mb2NhdGlvbnMudV9mZWF0aGVyLFxuICAgICAgICAgIHVfcGl4ZWxSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9waXhlbFJhdGlvLFxuICAgICAgICAgIHVfY29ycmVjdGlvblJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X2NvcnJlY3Rpb25SYXRpbyxcbiAgICAgICAgICB1X3NpemVSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9zaXplUmF0aW8sXG4gICAgICAgICAgdV9taW5FZGdlVGhpY2tuZXNzID0gdW5pZm9ybUxvY2F0aW9ucy51X21pbkVkZ2VUaGlja25lc3MsXG4gICAgICAgICAgdV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW87XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodV9tYXRyaXgsIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfem9vbVJhdGlvLCBwYXJhbXMuem9vbVJhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfc2l6ZVJhdGlvLCBwYXJhbXMuc2l6ZVJhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfY29ycmVjdGlvblJhdGlvLCBwYXJhbXMuY29ycmVjdGlvblJhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfcGl4ZWxSYXRpbywgcGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9mZWF0aGVyLCBwYXJhbXMuYW50aUFsaWFzaW5nRmVhdGhlcik7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X21pbkVkZ2VUaGlja25lc3MsIHBhcmFtcy5taW5FZGdlVGhpY2tuZXNzKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbywgb3B0aW9ucy5sZW5ndGhUb1RoaWNrbmVzc1JhdGlvKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oRWRnZVByb2dyYW0pO1xufVxudmFyIEVkZ2VDbGFtcGVkUHJvZ3JhbSA9IGNyZWF0ZUVkZ2VDbGFtcGVkUHJvZ3JhbSgpO1xudmFyIEVkZ2VDbGFtcGVkUHJvZ3JhbSQxID0gRWRnZUNsYW1wZWRQcm9ncmFtO1xuXG5mdW5jdGlvbiBjcmVhdGVFZGdlQXJyb3dQcm9ncmFtKGlucHV0T3B0aW9ucykge1xuICByZXR1cm4gY3JlYXRlRWRnZUNvbXBvdW5kUHJvZ3JhbShbY3JlYXRlRWRnZUNsYW1wZWRQcm9ncmFtKGlucHV0T3B0aW9ucyksIGNyZWF0ZUVkZ2VBcnJvd0hlYWRQcm9ncmFtKGlucHV0T3B0aW9ucyldKTtcbn1cbnZhciBFZGdlQXJyb3dQcm9ncmFtID0gY3JlYXRlRWRnZUFycm93UHJvZ3JhbSgpO1xudmFyIEVkZ2VBcnJvd1Byb2dyYW0kMSA9IEVkZ2VBcnJvd1Byb2dyYW07XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX25vcm1hbDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9ub3JtYWxDb2VmO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb25TdGFydDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uRW5kO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3Bvc2l0aW9uQ29lZjtcXG5cXG51bmlmb3JtIG1hdDMgdV9tYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3NpemVSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfem9vbVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9waXhlbFJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X21pbkVkZ2VUaGlja25lc3M7XFxudW5pZm9ybSBmbG9hdCB1X2ZlYXRoZXI7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgZmxvYXQgdl90aGlja25lc3M7XFxudmFyeWluZyBmbG9hdCB2X2ZlYXRoZXI7XFxuXFxuY29uc3QgZmxvYXQgYmlhcyA9IDI1NS4wIC8gMjU0LjA7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgbWluVGhpY2tuZXNzID0gdV9taW5FZGdlVGhpY2tuZXNzO1xcblxcbiAgdmVjMiBub3JtYWwgPSBhX25vcm1hbCAqIGFfbm9ybWFsQ29lZjtcXG4gIHZlYzIgcG9zaXRpb24gPSBhX3Bvc2l0aW9uU3RhcnQgKiAoMS4wIC0gYV9wb3NpdGlvbkNvZWYpICsgYV9wb3NpdGlvbkVuZCAqIGFfcG9zaXRpb25Db2VmO1xcblxcbiAgZmxvYXQgbm9ybWFsTGVuZ3RoID0gbGVuZ3RoKG5vcm1hbCk7XFxuICB2ZWMyIHVuaXROb3JtYWwgPSBub3JtYWwgLyBub3JtYWxMZW5ndGg7XFxuXFxuICAvLyBXZSByZXF1aXJlIGVkZ2VzIHRvIGJlIGF0IGxlYXN0IFxcXCJtaW5UaGlja25lc3NcXFwiIHBpeGVscyB0aGljayAqb24gc2NyZWVuKlxcbiAgLy8gKHNvIHdlIG5lZWQgdG8gY29tcGVuc2F0ZSB0aGUgc2l6ZSByYXRpbyk6XFxuICBmbG9hdCBwaXhlbHNUaGlja25lc3MgPSBtYXgobm9ybWFsTGVuZ3RoLCBtaW5UaGlja25lc3MgKiB1X3NpemVSYXRpbyk7XFxuXFxuICAvLyBUaGVuLCB3ZSBuZWVkIHRvIHJldHJpZXZlIHRoZSBub3JtYWxpemVkIHRoaWNrbmVzcyBvZiB0aGUgZWRnZSBpbiB0aGUgV2ViR0xcXG4gIC8vIHJlZmVyZW50aWFsIChpbiBhIChbMCwgMV0sIFswLCAxXSkgc3BhY2UpLCB1c2luZyBvdXIgXFxcIm1hZ2ljXFxcIiBjb3JyZWN0aW9uXFxuICAvLyByYXRpbzpcXG4gIGZsb2F0IHdlYkdMVGhpY2tuZXNzID0gcGl4ZWxzVGhpY2tuZXNzICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG5cXG4gIC8vIEhlcmUgaXMgdGhlIHByb3BlciBwb3NpdGlvbiBvZiB0aGUgdmVydGV4XFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHVfbWF0cml4ICogdmVjMyhwb3NpdGlvbiArIHVuaXROb3JtYWwgKiB3ZWJHTFRoaWNrbmVzcywgMSkpLnh5LCAwLCAxKTtcXG5cXG4gIC8vIEZvciB0aGUgZnJhZ21lbnQgc2hhZGVyIHRob3VnaCwgd2UgbmVlZCBhIHRoaWNrbmVzcyB0aGF0IHRha2VzIHRoZSBcXFwibWFnaWNcXFwiXFxuICAvLyBjb3JyZWN0aW9uIHJhdGlvIGludG8gYWNjb3VudCAoYXMgaW4gd2ViR0xUaGlja25lc3MpLCBidXQgc28gdGhhdCB0aGVcXG4gIC8vIGFudGlhbGlhc2luZyBlZmZlY3QgZG9lcyBub3QgZGVwZW5kIG9uIHRoZSB6b29tIGxldmVsLiBTbyBoZXJlJ3MgeWV0XFxuICAvLyBhbm90aGVyIHRoaWNrbmVzcyB2ZXJzaW9uOlxcbiAgdl90aGlja25lc3MgPSB3ZWJHTFRoaWNrbmVzcyAvIHVfem9vbVJhdGlvO1xcblxcbiAgdl9ub3JtYWwgPSB1bml0Tm9ybWFsO1xcblxcbiAgdl9mZWF0aGVyID0gdV9mZWF0aGVyICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3pvb21SYXRpbyAvIHVfcGl4ZWxSYXRpbyAqIDIuMDtcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG5cXG4gIHZfY29sb3IuYSAqPSBiaWFzO1xcbn1cXG5cIjtcbnZhciBWRVJURVhfU0hBREVSX1NPVVJDRSA9IFNIQURFUl9TT1VSQ0U7XG5cbnZhciBfV2ViR0xSZW5kZXJpbmdDb250ZXggPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXguVU5TSUdORURfQllURSxcbiAgRkxPQVQgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXguRkxPQVQ7XG52YXIgVU5JRk9STVMgPSBbXCJ1X21hdHJpeFwiLCBcInVfem9vbVJhdGlvXCIsIFwidV9zaXplUmF0aW9cIiwgXCJ1X2NvcnJlY3Rpb25SYXRpb1wiLCBcInVfcGl4ZWxSYXRpb1wiLCBcInVfZmVhdGhlclwiLCBcInVfbWluRWRnZVRoaWNrbmVzc1wiXTtcbnZhciBFZGdlUmVjdGFuZ2xlUHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkZ2VQcm9ncmFtKSB7XG4gIGZ1bmN0aW9uIEVkZ2VSZWN0YW5nbGVQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlUmVjdGFuZ2xlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgRWRnZVJlY3RhbmdsZVByb2dyYW0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKEVkZ2VSZWN0YW5nbGVQcm9ncmFtLCBfRWRnZVByb2dyYW0pO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVkZ2VSZWN0YW5nbGVQcm9ncmFtLCBbe1xuICAgIGtleTogXCJnZXREZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBWRVJUSUNFUzogNixcbiAgICAgICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZFUlRFWF9TSEFERVJfU09VUkNFLFxuICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGUkFHTUVOVF9TSEFERVJfU09VUkNFLFxuICAgICAgICBNRVRIT0Q6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsXG4gICAgICAgIFVOSUZPUk1TOiBVTklGT1JNUyxcbiAgICAgICAgQVRUUklCVVRFUzogW3tcbiAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25TdGFydFwiLFxuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvbkVuZFwiLFxuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9ub3JtYWxcIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfY29sb3JcIixcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2lkXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFLFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgfV0sXG4gICAgICAgIENPTlNUQU5UX0FUVFJJQlVURVM6IFtcbiAgICAgICAgLy8gSWYgMCwgdGhlbiBwb3NpdGlvbiB3aWxsIGJlIGFfcG9zaXRpb25TdGFydFxuICAgICAgICAvLyBJZiAyLCB0aGVuIHBvc2l0aW9uIHdpbGwgYmUgYV9wb3NpdGlvbkVuZFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uQ29lZlwiLFxuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9ub3JtYWxDb2VmXCIsXG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICB9XSxcbiAgICAgICAgQ09OU1RBTlRfREFUQTogW1swLCAxXSwgWzAsIC0xXSwgWzEsIDFdLCBbMSwgMV0sIFswLCAtMV0sIFsxLCAtMV1dXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzVmlzaWJsZUl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1Zpc2libGVJdGVtKGVkZ2VJbmRleCwgc3RhcnRJbmRleCwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSkge1xuICAgICAgdmFyIHRoaWNrbmVzcyA9IGRhdGEuc2l6ZSB8fCAxO1xuICAgICAgdmFyIHgxID0gc291cmNlRGF0YS54O1xuICAgICAgdmFyIHkxID0gc291cmNlRGF0YS55O1xuICAgICAgdmFyIHgyID0gdGFyZ2V0RGF0YS54O1xuICAgICAgdmFyIHkyID0gdGFyZ2V0RGF0YS55O1xuICAgICAgdmFyIGNvbG9yID0gZmxvYXRDb2xvcihkYXRhLmNvbG9yKTtcblxuICAgICAgLy8gQ29tcHV0aW5nIG5vcm1hbHNcbiAgICAgIHZhciBkeCA9IHgyIC0geDE7XG4gICAgICB2YXIgZHkgPSB5MiAtIHkxO1xuICAgICAgdmFyIGxlbiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgdmFyIG4xID0gMDtcbiAgICAgIHZhciBuMiA9IDA7XG4gICAgICBpZiAobGVuKSB7XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgbjEgPSAtZHkgKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICAgIG4yID0gZHggKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICB9XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgxO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHkxO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgyO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHkyO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IG4xO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IG4yO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGNvbG9yO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGVkZ2VJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybXMocGFyYW1zLCBfcmVmKSB7XG4gICAgICB2YXIgZ2wgPSBfcmVmLmdsLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zID0gX3JlZi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgdmFyIHVfbWF0cml4ID0gdW5pZm9ybUxvY2F0aW9ucy51X21hdHJpeCxcbiAgICAgICAgdV96b29tUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfem9vbVJhdGlvLFxuICAgICAgICB1X2ZlYXRoZXIgPSB1bmlmb3JtTG9jYXRpb25zLnVfZmVhdGhlcixcbiAgICAgICAgdV9waXhlbFJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3BpeGVsUmF0aW8sXG4gICAgICAgIHVfY29ycmVjdGlvblJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X2NvcnJlY3Rpb25SYXRpbyxcbiAgICAgICAgdV9zaXplUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfc2l6ZVJhdGlvLFxuICAgICAgICB1X21pbkVkZ2VUaGlja25lc3MgPSB1bmlmb3JtTG9jYXRpb25zLnVfbWluRWRnZVRoaWNrbmVzcztcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodV9tYXRyaXgsIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICAgIGdsLnVuaWZvcm0xZih1X3pvb21SYXRpbywgcGFyYW1zLnpvb21SYXRpbyk7XG4gICAgICBnbC51bmlmb3JtMWYodV9zaXplUmF0aW8sIHBhcmFtcy5zaXplUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfY29ycmVjdGlvblJhdGlvLCBwYXJhbXMuY29ycmVjdGlvblJhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm0xZih1X3BpeGVsUmF0aW8sIHBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm0xZih1X2ZlYXRoZXIsIHBhcmFtcy5hbnRpQWxpYXNpbmdGZWF0aGVyKTtcbiAgICAgIGdsLnVuaWZvcm0xZih1X21pbkVkZ2VUaGlja25lc3MsIHBhcmFtcy5taW5FZGdlVGhpY2tuZXNzKTtcbiAgICB9XG4gIH1dKTtcbn0oRWRnZVByb2dyYW0pO1xuXG5leHBvcnQgeyBBYnN0cmFjdE5vZGVQcm9ncmFtIGFzIEEsIERFRkFVTFRfRURHRV9BUlJPV19IRUFEX1BST0dSQU1fT1BUSU9OUyBhcyBELCBFZGdlQXJyb3dQcm9ncmFtJDEgYXMgRSwgRlJBR01FTlRfU0hBREVSX1NPVVJDRSBhcyBGLCBOb2RlQ2lyY2xlUHJvZ3JhbSBhcyBOLCBQcm9ncmFtIGFzIFAsIF9vYmplY3RTcHJlYWQyIGFzIF8sIF9kZWZpbmVQcm9wZXJ0eSBhcyBhLCBkcmF3RGlzY05vZGVMYWJlbCBhcyBiLCBkcmF3RGlzY05vZGVIb3ZlciBhcyBjLCBkcmF3U3RyYWlnaHRFZGdlTGFiZWwgYXMgZCwgRWRnZVJlY3RhbmdsZVByb2dyYW0gYXMgZSwgTm9kZVByb2dyYW0gYXMgZiwgRWRnZVByb2dyYW0gYXMgZywgY3JlYXRlRWRnZUNvbXBvdW5kUHJvZ3JhbSBhcyBoLCBjcmVhdGVFZGdlQXJyb3dIZWFkUHJvZ3JhbSBhcyBpLCBjcmVhdGVOb2RlQ29tcG91bmRQcm9ncmFtIGFzIGosIEFic3RyYWN0RWRnZVByb2dyYW0gYXMgaywgQWJzdHJhY3RQcm9ncmFtIGFzIGwsIEVkZ2VBcnJvd0hlYWRQcm9ncmFtJDEgYXMgbSwgRWRnZUNsYW1wZWRQcm9ncmFtJDEgYXMgbiwgY3JlYXRlRWRnZUNsYW1wZWRQcm9ncmFtIGFzIG8sIERFRkFVTFRfRURHRV9DTEFNUEVEX1BST0dSQU1fT1BUSU9OUyBhcyBwLCBjcmVhdGVFZGdlQXJyb3dQcm9ncmFtIGFzIHEsIGdldEF0dHJpYnV0ZUl0ZW1zQ291bnQgYXMgciwgZ2V0QXR0cmlidXRlc0l0ZW1zQ291bnQgYXMgcywgbG9hZFZlcnRleFNoYWRlciBhcyB0LCBsb2FkRnJhZ21lbnRTaGFkZXIgYXMgdSwgbG9hZFByb2dyYW0gYXMgdiwga2lsbFByb2dyYW0gYXMgdywgbnVtYmVyVG9HTFNMRmxvYXQgYXMgeCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/index-236c62ad.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/dist/inherits-d1a1e29b.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/sigma/dist/inherits-d1a1e29b.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _inherits),\n/* harmony export */   a: () => (/* binding */ _createClass),\n/* harmony export */   b: () => (/* binding */ _classCallCheck),\n/* harmony export */   c: () => (/* binding */ _callSuper),\n/* harmony export */   d: () => (/* binding */ _toPropertyKey),\n/* harmony export */   e: () => (/* binding */ _getPrototypeOf)\n/* harmony export */ });\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\n\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\n\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\n\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\n\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\n\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\n\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9pbmhlcml0cy1kMWExZTI5Yi5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekYsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRStIIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGh5ZW9uXFxEZXNrdG9wXFxmcm9udGVuZC1oaWRkZW5ub2RlXFxub2RlX21vZHVsZXNcXHNpZ21hXFxkaXN0XFxpbmhlcml0cy1kMWExZTI5Yi5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7XG4gIGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikge1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbyA9IHJbdF07XG4gICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGU7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICB9LCBfZ2V0UHJvdG90eXBlT2YodCk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICB9IGNhdGNoICh0KSB7fVxuICByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdDtcbiAgfSkoKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7XG4gIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHtcbiAgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7XG4gIGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7XG59XG5cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkge1xuICByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkge1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDtcbiAgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHModCwgZSkge1xuICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHQsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfVxuICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGUgJiYgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuXG5leHBvcnQgeyBfaW5oZXJpdHMgYXMgXywgX2NyZWF0ZUNsYXNzIGFzIGEsIF9jbGFzc0NhbGxDaGVjayBhcyBiLCBfY2FsbFN1cGVyIGFzIGMsIF90b1Byb3BlcnR5S2V5IGFzIGQsIF9nZXRQcm90b3R5cGVPZiBhcyBlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/inherits-d1a1e29b.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/dist/normalization-be445518.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/sigma/dist/normalization-be445518.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ ANIMATE_DEFAULTS),\n/* harmony export */   a: () => (/* binding */ getMatrixImpact),\n/* harmony export */   b: () => (/* binding */ createElement),\n/* harmony export */   c: () => (/* binding */ createNormalizationFunction),\n/* harmony export */   d: () => (/* binding */ getPixelRatio),\n/* harmony export */   e: () => (/* binding */ easings),\n/* harmony export */   f: () => (/* binding */ multiplyVec2),\n/* harmony export */   g: () => (/* binding */ graphExtent),\n/* harmony export */   h: () => (/* binding */ animateNodes),\n/* harmony export */   i: () => (/* binding */ identity),\n/* harmony export */   j: () => (/* binding */ getCorrectionRatio),\n/* harmony export */   k: () => (/* binding */ quadraticOut),\n/* harmony export */   l: () => (/* binding */ linear),\n/* harmony export */   m: () => (/* binding */ matrixFromCamera),\n/* harmony export */   n: () => (/* binding */ quadraticInOut),\n/* harmony export */   o: () => (/* binding */ cubicIn),\n/* harmony export */   p: () => (/* binding */ cubicOut),\n/* harmony export */   q: () => (/* binding */ quadraticIn),\n/* harmony export */   r: () => (/* binding */ cubicInOut),\n/* harmony export */   s: () => (/* binding */ scale),\n/* harmony export */   t: () => (/* binding */ rotate),\n/* harmony export */   u: () => (/* binding */ translate),\n/* harmony export */   v: () => (/* binding */ validateGraph),\n/* harmony export */   w: () => (/* binding */ multiply),\n/* harmony export */   z: () => (/* binding */ zIndexOrdering)\n/* harmony export */ });\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ \"(ssr)/./node_modules/sigma/dist/colors-beb06eb2.esm.js\");\n\n\n\nvar linear = function linear(k) {\n  return k;\n};\nvar quadraticIn = function quadraticIn(k) {\n  return k * k;\n};\nvar quadraticOut = function quadraticOut(k) {\n  return k * (2 - k);\n};\nvar quadraticInOut = function quadraticInOut(k) {\n  if ((k *= 2) < 1) return 0.5 * k * k;\n  return -0.5 * (--k * (k - 2) - 1);\n};\nvar cubicIn = function cubicIn(k) {\n  return k * k * k;\n};\nvar cubicOut = function cubicOut(k) {\n  return --k * k * k + 1;\n};\nvar cubicInOut = function cubicInOut(k) {\n  if ((k *= 2) < 1) return 0.5 * k * k * k;\n  return 0.5 * ((k -= 2) * k * k + 2);\n};\nvar easings = {\n  linear: linear,\n  quadraticIn: quadraticIn,\n  quadraticOut: quadraticOut,\n  quadraticInOut: quadraticInOut,\n  cubicIn: cubicIn,\n  cubicOut: cubicOut,\n  cubicInOut: cubicInOut\n};\n\n/**\n * Defaults.\n */\n\nvar ANIMATE_DEFAULTS = {\n  easing: \"quadraticInOut\",\n  duration: 150\n};\n\n/**\n * Function used to animate the nodes.\n */\nfunction animateNodes(graph, targets, opts, callback) {\n  var options = Object.assign({}, ANIMATE_DEFAULTS, opts);\n  var easing = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n  var start = Date.now();\n  var startPositions = {};\n  for (var node in targets) {\n    var attrs = targets[node];\n    startPositions[node] = {};\n    for (var _k in attrs) startPositions[node][_k] = graph.getNodeAttribute(node, _k);\n  }\n  var frame = null;\n  var _step = function step() {\n    frame = null;\n    var p = (Date.now() - start) / options.duration;\n    if (p >= 1) {\n      // Animation is done\n      for (var _node in targets) {\n        var _attrs = targets[_node];\n\n        // We use given values to avoid precision issues and for convenience\n        for (var _k2 in _attrs) graph.setNodeAttribute(_node, _k2, _attrs[_k2]);\n      }\n      if (typeof callback === \"function\") callback();\n      return;\n    }\n    p = easing(p);\n    for (var _node2 in targets) {\n      var _attrs2 = targets[_node2];\n      var s = startPositions[_node2];\n      for (var _k3 in _attrs2) graph.setNodeAttribute(_node2, _k3, _attrs2[_k3] * p + s[_k3] * (1 - p));\n    }\n    frame = requestAnimationFrame(_step);\n  };\n  _step();\n  return function () {\n    if (frame) cancelAnimationFrame(frame);\n  };\n}\n\nfunction identity() {\n  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);\n}\n\n// TODO: optimize\nfunction scale(m, x, y) {\n  m[0] = x;\n  m[4] = typeof y === \"number\" ? y : x;\n  return m;\n}\nfunction rotate(m, r) {\n  var s = Math.sin(r),\n    c = Math.cos(r);\n  m[0] = c;\n  m[1] = s;\n  m[3] = -s;\n  m[4] = c;\n  return m;\n}\nfunction translate(m, x, y) {\n  m[6] = x;\n  m[7] = y;\n  return m;\n}\nfunction multiply(a, b) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  var a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  var a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n  var b00 = b[0],\n    b01 = b[1],\n    b02 = b[2];\n  var b10 = b[3],\n    b11 = b[4],\n    b12 = b[5];\n  var b20 = b[6],\n    b21 = b[7],\n    b22 = b[8];\n  a[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  a[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  a[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  a[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  a[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  a[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  a[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  a[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  a[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return a;\n}\nfunction multiplyVec2(a, b) {\n  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var a00 = a[0];\n  var a01 = a[1];\n  var a10 = a[3];\n  var a11 = a[4];\n  var a20 = a[6];\n  var a21 = a[7];\n  var b0 = b.x;\n  var b1 = b.y;\n  return {\n    x: b0 * a00 + b1 * a10 + a20 * z,\n    y: b0 * a01 + b1 * a11 + a21 * z\n  };\n}\n\n/**\n * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This\n * helps to deal with quadtree in particular.\n * But at some point, we need to rescale it so that it takes the best place in the screen, i.e. we always want to see two\n * nodes \"touching\" opposite sides of the graph, with the camera being at its default state.\n *\n * This function determines this ratio.\n */\nfunction getCorrectionRatio(viewportDimensions, graphDimensions) {\n  var viewportRatio = viewportDimensions.height / viewportDimensions.width;\n  var graphRatio = graphDimensions.height / graphDimensions.width;\n\n  // If the stage and the graphs are in different directions (such as the graph being wider that tall while the stage\n  // is taller than wide), we can stop here to have indeed nodes touching opposite sides:\n  if (viewportRatio < 1 && graphRatio > 1 || viewportRatio > 1 && graphRatio < 1) {\n    return 1;\n  }\n\n  // Else, we need to fit the graph inside the stage:\n  // 1. If the graph is \"squarer\" (i.e. with a ratio closer to 1), we need to make the largest sides touch;\n  // 2. If the stage is \"squarer\", we need to make the smallest sides touch.\n  return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));\n}\n\n/**\n * Function returning a matrix from the current state of the camera.\n */\nfunction matrixFromCamera(state, viewportDimensions, graphDimensions, padding, inverse) {\n  // TODO: it's possible to optimize this drastically!\n  var angle = state.angle,\n    ratio = state.ratio,\n    x = state.x,\n    y = state.y;\n  var width = viewportDimensions.width,\n    height = viewportDimensions.height;\n  var matrix = identity();\n  var smallestDimension = Math.min(width, height) - 2 * padding;\n  var correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);\n  if (!inverse) {\n    multiply(matrix, scale(identity(), 2 * (smallestDimension / width) * correctionRatio, 2 * (smallestDimension / height) * correctionRatio));\n    multiply(matrix, rotate(identity(), -angle));\n    multiply(matrix, scale(identity(), 1 / ratio));\n    multiply(matrix, translate(identity(), -x, -y));\n  } else {\n    multiply(matrix, translate(identity(), x, y));\n    multiply(matrix, scale(identity(), ratio));\n    multiply(matrix, rotate(identity(), angle));\n    multiply(matrix, scale(identity(), width / smallestDimension / 2 / correctionRatio, height / smallestDimension / 2 / correctionRatio));\n  }\n  return matrix;\n}\n\n/**\n * All these transformations we apply on the matrix to get it rescale the graph\n * as we want make it very hard to get pixel-perfect distances in WebGL. This\n * function returns a factor that properly cancels the matrix effect on lengths.\n *\n * [jacomyal]\n * To be fully honest, I can't really explain happens here... I notice that the\n * following ratio works (i.e. it correctly compensates the matrix impact on all\n * camera states I could try):\n * > `R = size(V) / size(M * V) / W`\n * as long as `M * V` is in the direction of W (ie. parallel to (Ox)). It works\n * as well with H and a vector that transforms into something parallel to (Oy).\n *\n * Also, note that we use `angle` and not `-angle` (that would seem logical,\n * since we want to anticipate the rotation), because the image is vertically\n * swapped in WebGL.\n */\nfunction getMatrixImpact(matrix, cameraState, viewportDimensions) {\n  var _multiplyVec = multiplyVec2(matrix, {\n      x: Math.cos(cameraState.angle),\n      y: Math.sin(cameraState.angle)\n    }, 0),\n    x = _multiplyVec.x,\n    y = _multiplyVec.y;\n  return 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / viewportDimensions.width;\n}\n\n/**\n * Function returning the graph's node extent in x & y.\n */\nfunction graphExtent(graph) {\n  if (!graph.order) return {\n    x: [0, 1],\n    y: [0, 1]\n  };\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  graph.forEachNode(function (_, attr) {\n    var x = attr.x,\n      y = attr.y;\n    if (x < xMin) xMin = x;\n    if (x > xMax) xMax = x;\n    if (y < yMin) yMin = y;\n    if (y > yMax) yMax = y;\n  });\n  return {\n    x: [xMin, xMax],\n    y: [yMin, yMax]\n  };\n}\n\n/**\n * Check if the graph variable is a valid graph, and if sigma can render it.\n */\nfunction validateGraph(graph) {\n  // check if it's a valid graphology instance\n  if (!graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0___default()(graph)) throw new Error(\"Sigma: invalid graph instance.\");\n\n  // check if nodes have x/y attributes\n  graph.forEachNode(function (key, attributes) {\n    if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {\n      throw new Error(\"Sigma: Coordinates of node \".concat(key, \" are invalid. A node must have a numeric 'x' and 'y' attribute.\"));\n    }\n  });\n}\n\n/**\n * Function used to create DOM elements easily.\n */\nfunction createElement(tag, style, attributes) {\n  var element = document.createElement(tag);\n  if (style) {\n    for (var k in style) {\n      element.style[k] = style[k];\n    }\n  }\n  if (attributes) {\n    for (var _k in attributes) {\n      element.setAttribute(_k, attributes[_k]);\n    }\n  }\n  return element;\n}\n\n/**\n * Function returning the browser's pixel ratio.\n */\nfunction getPixelRatio() {\n  if (typeof window.devicePixelRatio !== \"undefined\") return window.devicePixelRatio;\n  return 1;\n}\n\n/**\n * Function ordering the given elements in reverse z-order so they drawn\n * the correct way.\n */\nfunction zIndexOrdering(_extent, getter, elements) {\n  // If k is > n, we'll use a standard sort\n  return elements.sort(function (a, b) {\n    var zA = getter(a) || 0,\n      zB = getter(b) || 0;\n    if (zA < zB) return -1;\n    if (zA > zB) return 1;\n    return 0;\n  });\n\n  // TODO: counting sort optimization\n}\n\n/**\n * Factory returning a function normalizing the given node's position & size.\n */\n\nfunction createNormalizationFunction(extent) {\n  var _extent$x = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(extent.x, 2),\n    minX = _extent$x[0],\n    maxX = _extent$x[1],\n    _extent$y = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(extent.y, 2),\n    minY = _extent$y[0],\n    maxY = _extent$y[1];\n  var ratio = Math.max(maxX - minX, maxY - minY),\n    dX = (maxX + minX) / 2,\n    dY = (maxY + minY) / 2;\n  if (ratio === 0 || Math.abs(ratio) === Infinity || isNaN(ratio)) ratio = 1;\n  if (isNaN(dX)) dX = 0;\n  if (isNaN(dY)) dY = 0;\n  var fn = function fn(data) {\n    return {\n      x: 0.5 + (data.x - dX) / ratio,\n      y: 0.5 + (data.y - dY) / ratio\n    };\n  };\n\n  // TODO: possibility to apply this in batch over array of indices\n  fn.applyTo = function (data) {\n    data.x = 0.5 + (data.x - dX) / ratio;\n    data.y = 0.5 + (data.y - dY) / ratio;\n  };\n  fn.inverse = function (data) {\n    return {\n      x: dX + ratio * (data.x - 0.5),\n      y: dY + ratio * (data.y - 0.5)\n    };\n  };\n  fn.ratio = ratio;\n  return fn;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9ub3JtYWxpemF0aW9uLWJlNDQ1NTE4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ2U7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdFQUFPOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDBEQUFjO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0ZCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoeWVvblxcRGVza3RvcFxcZnJvbnRlbmQtaGlkZGVubm9kZVxcbm9kZV9tb2R1bGVzXFxzaWdtYVxcZGlzdFxcbm9ybWFsaXphdGlvbi1iZTQ0NTUxOC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlzR3JhcGggZnJvbSAnZ3JhcGhvbG9neS11dGlscy9pcy1ncmFwaCc7XG5pbXBvcnQgeyBfIGFzIF9zbGljZWRUb0FycmF5IH0gZnJvbSAnLi9jb2xvcnMtYmViMDZlYjIuZXNtLmpzJztcblxudmFyIGxpbmVhciA9IGZ1bmN0aW9uIGxpbmVhcihrKSB7XG4gIHJldHVybiBrO1xufTtcbnZhciBxdWFkcmF0aWNJbiA9IGZ1bmN0aW9uIHF1YWRyYXRpY0luKGspIHtcbiAgcmV0dXJuIGsgKiBrO1xufTtcbnZhciBxdWFkcmF0aWNPdXQgPSBmdW5jdGlvbiBxdWFkcmF0aWNPdXQoaykge1xuICByZXR1cm4gayAqICgyIC0gayk7XG59O1xudmFyIHF1YWRyYXRpY0luT3V0ID0gZnVuY3Rpb24gcXVhZHJhdGljSW5PdXQoaykge1xuICBpZiAoKGsgKj0gMikgPCAxKSByZXR1cm4gMC41ICogayAqIGs7XG4gIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbn07XG52YXIgY3ViaWNJbiA9IGZ1bmN0aW9uIGN1YmljSW4oaykge1xuICByZXR1cm4gayAqIGsgKiBrO1xufTtcbnZhciBjdWJpY091dCA9IGZ1bmN0aW9uIGN1YmljT3V0KGspIHtcbiAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbn07XG52YXIgY3ViaWNJbk91dCA9IGZ1bmN0aW9uIGN1YmljSW5PdXQoaykge1xuICBpZiAoKGsgKj0gMikgPCAxKSByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbn07XG52YXIgZWFzaW5ncyA9IHtcbiAgbGluZWFyOiBsaW5lYXIsXG4gIHF1YWRyYXRpY0luOiBxdWFkcmF0aWNJbixcbiAgcXVhZHJhdGljT3V0OiBxdWFkcmF0aWNPdXQsXG4gIHF1YWRyYXRpY0luT3V0OiBxdWFkcmF0aWNJbk91dCxcbiAgY3ViaWNJbjogY3ViaWNJbixcbiAgY3ViaWNPdXQ6IGN1YmljT3V0LFxuICBjdWJpY0luT3V0OiBjdWJpY0luT3V0XG59O1xuXG4vKipcbiAqIERlZmF1bHRzLlxuICovXG5cbnZhciBBTklNQVRFX0RFRkFVTFRTID0ge1xuICBlYXNpbmc6IFwicXVhZHJhdGljSW5PdXRcIixcbiAgZHVyYXRpb246IDE1MFxufTtcblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGFuaW1hdGUgdGhlIG5vZGVzLlxuICovXG5mdW5jdGlvbiBhbmltYXRlTm9kZXMoZ3JhcGgsIHRhcmdldHMsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgQU5JTUFURV9ERUZBVUxUUywgb3B0cyk7XG4gIHZhciBlYXNpbmcgPSB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuZWFzaW5nIDogZWFzaW5nc1tvcHRpb25zLmVhc2luZ107XG4gIHZhciBzdGFydCA9IERhdGUubm93KCk7XG4gIHZhciBzdGFydFBvc2l0aW9ucyA9IHt9O1xuICBmb3IgKHZhciBub2RlIGluIHRhcmdldHMpIHtcbiAgICB2YXIgYXR0cnMgPSB0YXJnZXRzW25vZGVdO1xuICAgIHN0YXJ0UG9zaXRpb25zW25vZGVdID0ge307XG4gICAgZm9yICh2YXIgX2sgaW4gYXR0cnMpIHN0YXJ0UG9zaXRpb25zW25vZGVdW19rXSA9IGdyYXBoLmdldE5vZGVBdHRyaWJ1dGUobm9kZSwgX2spO1xuICB9XG4gIHZhciBmcmFtZSA9IG51bGw7XG4gIHZhciBfc3RlcCA9IGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgZnJhbWUgPSBudWxsO1xuICAgIHZhciBwID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBvcHRpb25zLmR1cmF0aW9uO1xuICAgIGlmIChwID49IDEpIHtcbiAgICAgIC8vIEFuaW1hdGlvbiBpcyBkb25lXG4gICAgICBmb3IgKHZhciBfbm9kZSBpbiB0YXJnZXRzKSB7XG4gICAgICAgIHZhciBfYXR0cnMgPSB0YXJnZXRzW19ub2RlXTtcblxuICAgICAgICAvLyBXZSB1c2UgZ2l2ZW4gdmFsdWVzIHRvIGF2b2lkIHByZWNpc2lvbiBpc3N1ZXMgYW5kIGZvciBjb252ZW5pZW5jZVxuICAgICAgICBmb3IgKHZhciBfazIgaW4gX2F0dHJzKSBncmFwaC5zZXROb2RlQXR0cmlidXRlKF9ub2RlLCBfazIsIF9hdHRyc1tfazJdKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcCA9IGVhc2luZyhwKTtcbiAgICBmb3IgKHZhciBfbm9kZTIgaW4gdGFyZ2V0cykge1xuICAgICAgdmFyIF9hdHRyczIgPSB0YXJnZXRzW19ub2RlMl07XG4gICAgICB2YXIgcyA9IHN0YXJ0UG9zaXRpb25zW19ub2RlMl07XG4gICAgICBmb3IgKHZhciBfazMgaW4gX2F0dHJzMikgZ3JhcGguc2V0Tm9kZUF0dHJpYnV0ZShfbm9kZTIsIF9rMywgX2F0dHJzMltfazNdICogcCArIHNbX2szXSAqICgxIC0gcCkpO1xuICAgIH1cbiAgICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShfc3RlcCk7XG4gIH07XG4gIF9zdGVwKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZyYW1lKSBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KCkge1xuICByZXR1cm4gRmxvYXQzMkFycmF5Lm9mKDEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEpO1xufVxuXG4vLyBUT0RPOiBvcHRpbWl6ZVxuZnVuY3Rpb24gc2NhbGUobSwgeCwgeSkge1xuICBtWzBdID0geDtcbiAgbVs0XSA9IHR5cGVvZiB5ID09PSBcIm51bWJlclwiID8geSA6IHg7XG4gIHJldHVybiBtO1xufVxuZnVuY3Rpb24gcm90YXRlKG0sIHIpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyKSxcbiAgICBjID0gTWF0aC5jb3Mocik7XG4gIG1bMF0gPSBjO1xuICBtWzFdID0gcztcbiAgbVszXSA9IC1zO1xuICBtWzRdID0gYztcbiAgcmV0dXJuIG07XG59XG5mdW5jdGlvbiB0cmFuc2xhdGUobSwgeCwgeSkge1xuICBtWzZdID0geDtcbiAgbVs3XSA9IHk7XG4gIHJldHVybiBtO1xufVxuZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICBhMDEgPSBhWzFdLFxuICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgIGExMSA9IGFbNF0sXG4gICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgYTIxID0gYVs3XSxcbiAgICBhMjIgPSBhWzhdO1xuICB2YXIgYjAwID0gYlswXSxcbiAgICBiMDEgPSBiWzFdLFxuICAgIGIwMiA9IGJbMl07XG4gIHZhciBiMTAgPSBiWzNdLFxuICAgIGIxMSA9IGJbNF0sXG4gICAgYjEyID0gYls1XTtcbiAgdmFyIGIyMCA9IGJbNl0sXG4gICAgYjIxID0gYls3XSxcbiAgICBiMjIgPSBiWzhdO1xuICBhWzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICBhWzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICBhWzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuICBhWzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICBhWzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICBhWzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuICBhWzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICBhWzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICBhWzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5VmVjMihhLCBiKSB7XG4gIHZhciB6ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMTAgPSBhWzNdO1xuICB2YXIgYTExID0gYVs0XTtcbiAgdmFyIGEyMCA9IGFbNl07XG4gIHZhciBhMjEgPSBhWzddO1xuICB2YXIgYjAgPSBiLng7XG4gIHZhciBiMSA9IGIueTtcbiAgcmV0dXJuIHtcbiAgICB4OiBiMCAqIGEwMCArIGIxICogYTEwICsgYTIwICogeixcbiAgICB5OiBiMCAqIGEwMSArIGIxICogYTExICsgYTIxICogelxuICB9O1xufVxuXG4vKipcbiAqIEluIHNpZ21hLCB0aGUgZ3JhcGggaXMgbm9ybWFsaXplZCBpbnRvIGEgWzAsIDFdLCBbMCwgMV0gc3F1YXJlLCBiZWZvcmUgYmVpbmcgZ2l2ZW4gdG8gdGhlIHZhcmlvdXMgcmVuZGVyZXJzLiBUaGlzXG4gKiBoZWxwcyB0byBkZWFsIHdpdGggcXVhZHRyZWUgaW4gcGFydGljdWxhci5cbiAqIEJ1dCBhdCBzb21lIHBvaW50LCB3ZSBuZWVkIHRvIHJlc2NhbGUgaXQgc28gdGhhdCBpdCB0YWtlcyB0aGUgYmVzdCBwbGFjZSBpbiB0aGUgc2NyZWVuLCBpLmUuIHdlIGFsd2F5cyB3YW50IHRvIHNlZSB0d29cbiAqIG5vZGVzIFwidG91Y2hpbmdcIiBvcHBvc2l0ZSBzaWRlcyBvZiB0aGUgZ3JhcGgsIHdpdGggdGhlIGNhbWVyYSBiZWluZyBhdCBpdHMgZGVmYXVsdCBzdGF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgdGhpcyByYXRpby5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29ycmVjdGlvblJhdGlvKHZpZXdwb3J0RGltZW5zaW9ucywgZ3JhcGhEaW1lbnNpb25zKSB7XG4gIHZhciB2aWV3cG9ydFJhdGlvID0gdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCAvIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aDtcbiAgdmFyIGdyYXBoUmF0aW8gPSBncmFwaERpbWVuc2lvbnMuaGVpZ2h0IC8gZ3JhcGhEaW1lbnNpb25zLndpZHRoO1xuXG4gIC8vIElmIHRoZSBzdGFnZSBhbmQgdGhlIGdyYXBocyBhcmUgaW4gZGlmZmVyZW50IGRpcmVjdGlvbnMgKHN1Y2ggYXMgdGhlIGdyYXBoIGJlaW5nIHdpZGVyIHRoYXQgdGFsbCB3aGlsZSB0aGUgc3RhZ2VcbiAgLy8gaXMgdGFsbGVyIHRoYW4gd2lkZSksIHdlIGNhbiBzdG9wIGhlcmUgdG8gaGF2ZSBpbmRlZWQgbm9kZXMgdG91Y2hpbmcgb3Bwb3NpdGUgc2lkZXM6XG4gIGlmICh2aWV3cG9ydFJhdGlvIDwgMSAmJiBncmFwaFJhdGlvID4gMSB8fCB2aWV3cG9ydFJhdGlvID4gMSAmJiBncmFwaFJhdGlvIDwgMSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gRWxzZSwgd2UgbmVlZCB0byBmaXQgdGhlIGdyYXBoIGluc2lkZSB0aGUgc3RhZ2U6XG4gIC8vIDEuIElmIHRoZSBncmFwaCBpcyBcInNxdWFyZXJcIiAoaS5lLiB3aXRoIGEgcmF0aW8gY2xvc2VyIHRvIDEpLCB3ZSBuZWVkIHRvIG1ha2UgdGhlIGxhcmdlc3Qgc2lkZXMgdG91Y2g7XG4gIC8vIDIuIElmIHRoZSBzdGFnZSBpcyBcInNxdWFyZXJcIiwgd2UgbmVlZCB0byBtYWtlIHRoZSBzbWFsbGVzdCBzaWRlcyB0b3VjaC5cbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGdyYXBoUmF0aW8sIDEgLyBncmFwaFJhdGlvKSwgTWF0aC5tYXgoMSAvIHZpZXdwb3J0UmF0aW8sIHZpZXdwb3J0UmF0aW8pKTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgYSBtYXRyaXggZnJvbSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgY2FtZXJhLlxuICovXG5mdW5jdGlvbiBtYXRyaXhGcm9tQ2FtZXJhKHN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMsIGdyYXBoRGltZW5zaW9ucywgcGFkZGluZywgaW52ZXJzZSkge1xuICAvLyBUT0RPOiBpdCdzIHBvc3NpYmxlIHRvIG9wdGltaXplIHRoaXMgZHJhc3RpY2FsbHkhXG4gIHZhciBhbmdsZSA9IHN0YXRlLmFuZ2xlLFxuICAgIHJhdGlvID0gc3RhdGUucmF0aW8sXG4gICAgeCA9IHN0YXRlLngsXG4gICAgeSA9IHN0YXRlLnk7XG4gIHZhciB3aWR0aCA9IHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aCxcbiAgICBoZWlnaHQgPSB2aWV3cG9ydERpbWVuc2lvbnMuaGVpZ2h0O1xuICB2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcbiAgdmFyIHNtYWxsZXN0RGltZW5zaW9uID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLSAyICogcGFkZGluZztcbiAgdmFyIGNvcnJlY3Rpb25SYXRpbyA9IGdldENvcnJlY3Rpb25SYXRpbyh2aWV3cG9ydERpbWVuc2lvbnMsIGdyYXBoRGltZW5zaW9ucyk7XG4gIGlmICghaW52ZXJzZSkge1xuICAgIG11bHRpcGx5KG1hdHJpeCwgc2NhbGUoaWRlbnRpdHkoKSwgMiAqIChzbWFsbGVzdERpbWVuc2lvbiAvIHdpZHRoKSAqIGNvcnJlY3Rpb25SYXRpbywgMiAqIChzbWFsbGVzdERpbWVuc2lvbiAvIGhlaWdodCkgKiBjb3JyZWN0aW9uUmF0aW8pKTtcbiAgICBtdWx0aXBseShtYXRyaXgsIHJvdGF0ZShpZGVudGl0eSgpLCAtYW5nbGUpKTtcbiAgICBtdWx0aXBseShtYXRyaXgsIHNjYWxlKGlkZW50aXR5KCksIDEgLyByYXRpbykpO1xuICAgIG11bHRpcGx5KG1hdHJpeCwgdHJhbnNsYXRlKGlkZW50aXR5KCksIC14LCAteSkpO1xuICB9IGVsc2Uge1xuICAgIG11bHRpcGx5KG1hdHJpeCwgdHJhbnNsYXRlKGlkZW50aXR5KCksIHgsIHkpKTtcbiAgICBtdWx0aXBseShtYXRyaXgsIHNjYWxlKGlkZW50aXR5KCksIHJhdGlvKSk7XG4gICAgbXVsdGlwbHkobWF0cml4LCByb3RhdGUoaWRlbnRpdHkoKSwgYW5nbGUpKTtcbiAgICBtdWx0aXBseShtYXRyaXgsIHNjYWxlKGlkZW50aXR5KCksIHdpZHRoIC8gc21hbGxlc3REaW1lbnNpb24gLyAyIC8gY29ycmVjdGlvblJhdGlvLCBoZWlnaHQgLyBzbWFsbGVzdERpbWVuc2lvbiAvIDIgLyBjb3JyZWN0aW9uUmF0aW8pKTtcbiAgfVxuICByZXR1cm4gbWF0cml4O1xufVxuXG4vKipcbiAqIEFsbCB0aGVzZSB0cmFuc2Zvcm1hdGlvbnMgd2UgYXBwbHkgb24gdGhlIG1hdHJpeCB0byBnZXQgaXQgcmVzY2FsZSB0aGUgZ3JhcGhcbiAqIGFzIHdlIHdhbnQgbWFrZSBpdCB2ZXJ5IGhhcmQgdG8gZ2V0IHBpeGVsLXBlcmZlY3QgZGlzdGFuY2VzIGluIFdlYkdMLiBUaGlzXG4gKiBmdW5jdGlvbiByZXR1cm5zIGEgZmFjdG9yIHRoYXQgcHJvcGVybHkgY2FuY2VscyB0aGUgbWF0cml4IGVmZmVjdCBvbiBsZW5ndGhzLlxuICpcbiAqIFtqYWNvbXlhbF1cbiAqIFRvIGJlIGZ1bGx5IGhvbmVzdCwgSSBjYW4ndCByZWFsbHkgZXhwbGFpbiBoYXBwZW5zIGhlcmUuLi4gSSBub3RpY2UgdGhhdCB0aGVcbiAqIGZvbGxvd2luZyByYXRpbyB3b3JrcyAoaS5lLiBpdCBjb3JyZWN0bHkgY29tcGVuc2F0ZXMgdGhlIG1hdHJpeCBpbXBhY3Qgb24gYWxsXG4gKiBjYW1lcmEgc3RhdGVzIEkgY291bGQgdHJ5KTpcbiAqID4gYFIgPSBzaXplKFYpIC8gc2l6ZShNICogVikgLyBXYFxuICogYXMgbG9uZyBhcyBgTSAqIFZgIGlzIGluIHRoZSBkaXJlY3Rpb24gb2YgVyAoaWUuIHBhcmFsbGVsIHRvIChPeCkpLiBJdCB3b3Jrc1xuICogYXMgd2VsbCB3aXRoIEggYW5kIGEgdmVjdG9yIHRoYXQgdHJhbnNmb3JtcyBpbnRvIHNvbWV0aGluZyBwYXJhbGxlbCB0byAoT3kpLlxuICpcbiAqIEFsc28sIG5vdGUgdGhhdCB3ZSB1c2UgYGFuZ2xlYCBhbmQgbm90IGAtYW5nbGVgICh0aGF0IHdvdWxkIHNlZW0gbG9naWNhbCxcbiAqIHNpbmNlIHdlIHdhbnQgdG8gYW50aWNpcGF0ZSB0aGUgcm90YXRpb24pLCBiZWNhdXNlIHRoZSBpbWFnZSBpcyB2ZXJ0aWNhbGx5XG4gKiBzd2FwcGVkIGluIFdlYkdMLlxuICovXG5mdW5jdGlvbiBnZXRNYXRyaXhJbXBhY3QobWF0cml4LCBjYW1lcmFTdGF0ZSwgdmlld3BvcnREaW1lbnNpb25zKSB7XG4gIHZhciBfbXVsdGlwbHlWZWMgPSBtdWx0aXBseVZlYzIobWF0cml4LCB7XG4gICAgICB4OiBNYXRoLmNvcyhjYW1lcmFTdGF0ZS5hbmdsZSksXG4gICAgICB5OiBNYXRoLnNpbihjYW1lcmFTdGF0ZS5hbmdsZSlcbiAgICB9LCAwKSxcbiAgICB4ID0gX211bHRpcGx5VmVjLngsXG4gICAgeSA9IF9tdWx0aXBseVZlYy55O1xuICByZXR1cm4gMSAvIE1hdGguc3FydChNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpKSAvIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aDtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIGdyYXBoJ3Mgbm9kZSBleHRlbnQgaW4geCAmIHkuXG4gKi9cbmZ1bmN0aW9uIGdyYXBoRXh0ZW50KGdyYXBoKSB7XG4gIGlmICghZ3JhcGgub3JkZXIpIHJldHVybiB7XG4gICAgeDogWzAsIDFdLFxuICAgIHk6IFswLCAxXVxuICB9O1xuICB2YXIgeE1pbiA9IEluZmluaXR5O1xuICB2YXIgeE1heCA9IC1JbmZpbml0eTtcbiAgdmFyIHlNaW4gPSBJbmZpbml0eTtcbiAgdmFyIHlNYXggPSAtSW5maW5pdHk7XG4gIGdyYXBoLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChfLCBhdHRyKSB7XG4gICAgdmFyIHggPSBhdHRyLngsXG4gICAgICB5ID0gYXR0ci55O1xuICAgIGlmICh4IDwgeE1pbikgeE1pbiA9IHg7XG4gICAgaWYgKHggPiB4TWF4KSB4TWF4ID0geDtcbiAgICBpZiAoeSA8IHlNaW4pIHlNaW4gPSB5O1xuICAgIGlmICh5ID4geU1heCkgeU1heCA9IHk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHg6IFt4TWluLCB4TWF4XSxcbiAgICB5OiBbeU1pbiwgeU1heF1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ3JhcGggdmFyaWFibGUgaXMgYSB2YWxpZCBncmFwaCwgYW5kIGlmIHNpZ21hIGNhbiByZW5kZXIgaXQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlR3JhcGgoZ3JhcGgpIHtcbiAgLy8gY2hlY2sgaWYgaXQncyBhIHZhbGlkIGdyYXBob2xvZ3kgaW5zdGFuY2VcbiAgaWYgKCFpc0dyYXBoKGdyYXBoKSkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGludmFsaWQgZ3JhcGggaW5zdGFuY2UuXCIpO1xuXG4gIC8vIGNoZWNrIGlmIG5vZGVzIGhhdmUgeC95IGF0dHJpYnV0ZXNcbiAgZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKGtleSwgYXR0cmlidXRlcykge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGF0dHJpYnV0ZXMueCkgfHwgIU51bWJlci5pc0Zpbml0ZShhdHRyaWJ1dGVzLnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogQ29vcmRpbmF0ZXMgb2Ygbm9kZSBcIi5jb25jYXQoa2V5LCBcIiBhcmUgaW52YWxpZC4gQSBub2RlIG11c3QgaGF2ZSBhIG51bWVyaWMgJ3gnIGFuZCAneScgYXR0cmlidXRlLlwiKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBET00gZWxlbWVudHMgZWFzaWx5LlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgc3R5bGUsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmIChzdHlsZSkge1xuICAgIGZvciAodmFyIGsgaW4gc3R5bGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVba10gPSBzdHlsZVtrXTtcbiAgICB9XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKHZhciBfayBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShfaywgYXR0cmlidXRlc1tfa10pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIGJyb3dzZXIncyBwaXhlbCByYXRpby5cbiAqL1xuZnVuY3Rpb24gZ2V0UGl4ZWxSYXRpbygpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICByZXR1cm4gMTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBvcmRlcmluZyB0aGUgZ2l2ZW4gZWxlbWVudHMgaW4gcmV2ZXJzZSB6LW9yZGVyIHNvIHRoZXkgZHJhd25cbiAqIHRoZSBjb3JyZWN0IHdheS5cbiAqL1xuZnVuY3Rpb24gekluZGV4T3JkZXJpbmcoX2V4dGVudCwgZ2V0dGVyLCBlbGVtZW50cykge1xuICAvLyBJZiBrIGlzID4gbiwgd2UnbGwgdXNlIGEgc3RhbmRhcmQgc29ydFxuICByZXR1cm4gZWxlbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciB6QSA9IGdldHRlcihhKSB8fCAwLFxuICAgICAgekIgPSBnZXR0ZXIoYikgfHwgMDtcbiAgICBpZiAoekEgPCB6QikgcmV0dXJuIC0xO1xuICAgIGlmICh6QSA+IHpCKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbiAgfSk7XG5cbiAgLy8gVE9ETzogY291bnRpbmcgc29ydCBvcHRpbWl6YXRpb25cbn1cblxuLyoqXG4gKiBGYWN0b3J5IHJldHVybmluZyBhIGZ1bmN0aW9uIG5vcm1hbGl6aW5nIHRoZSBnaXZlbiBub2RlJ3MgcG9zaXRpb24gJiBzaXplLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU5vcm1hbGl6YXRpb25GdW5jdGlvbihleHRlbnQpIHtcbiAgdmFyIF9leHRlbnQkeCA9IF9zbGljZWRUb0FycmF5KGV4dGVudC54LCAyKSxcbiAgICBtaW5YID0gX2V4dGVudCR4WzBdLFxuICAgIG1heFggPSBfZXh0ZW50JHhbMV0sXG4gICAgX2V4dGVudCR5ID0gX3NsaWNlZFRvQXJyYXkoZXh0ZW50LnksIDIpLFxuICAgIG1pblkgPSBfZXh0ZW50JHlbMF0sXG4gICAgbWF4WSA9IF9leHRlbnQkeVsxXTtcbiAgdmFyIHJhdGlvID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKSxcbiAgICBkWCA9IChtYXhYICsgbWluWCkgLyAyLFxuICAgIGRZID0gKG1heFkgKyBtaW5ZKSAvIDI7XG4gIGlmIChyYXRpbyA9PT0gMCB8fCBNYXRoLmFicyhyYXRpbykgPT09IEluZmluaXR5IHx8IGlzTmFOKHJhdGlvKSkgcmF0aW8gPSAxO1xuICBpZiAoaXNOYU4oZFgpKSBkWCA9IDA7XG4gIGlmIChpc05hTihkWSkpIGRZID0gMDtcbiAgdmFyIGZuID0gZnVuY3Rpb24gZm4oZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLjUgKyAoZGF0YS54IC0gZFgpIC8gcmF0aW8sXG4gICAgICB5OiAwLjUgKyAoZGF0YS55IC0gZFkpIC8gcmF0aW9cbiAgICB9O1xuICB9O1xuXG4gIC8vIFRPRE86IHBvc3NpYmlsaXR5IHRvIGFwcGx5IHRoaXMgaW4gYmF0Y2ggb3ZlciBhcnJheSBvZiBpbmRpY2VzXG4gIGZuLmFwcGx5VG8gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRhdGEueCA9IDAuNSArIChkYXRhLnggLSBkWCkgLyByYXRpbztcbiAgICBkYXRhLnkgPSAwLjUgKyAoZGF0YS55IC0gZFkpIC8gcmF0aW87XG4gIH07XG4gIGZuLmludmVyc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBkWCArIHJhdGlvICogKGRhdGEueCAtIDAuNSksXG4gICAgICB5OiBkWSArIHJhdGlvICogKGRhdGEueSAtIDAuNSlcbiAgICB9O1xuICB9O1xuICBmbi5yYXRpbyA9IHJhdGlvO1xuICByZXR1cm4gZm47XG59XG5cbmV4cG9ydCB7IEFOSU1BVEVfREVGQVVMVFMgYXMgQSwgZ2V0TWF0cml4SW1wYWN0IGFzIGEsIGNyZWF0ZUVsZW1lbnQgYXMgYiwgY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uIGFzIGMsIGdldFBpeGVsUmF0aW8gYXMgZCwgZWFzaW5ncyBhcyBlLCBtdWx0aXBseVZlYzIgYXMgZiwgZ3JhcGhFeHRlbnQgYXMgZywgYW5pbWF0ZU5vZGVzIGFzIGgsIGlkZW50aXR5IGFzIGksIGdldENvcnJlY3Rpb25SYXRpbyBhcyBqLCBxdWFkcmF0aWNPdXQgYXMgaywgbGluZWFyIGFzIGwsIG1hdHJpeEZyb21DYW1lcmEgYXMgbSwgcXVhZHJhdGljSW5PdXQgYXMgbiwgY3ViaWNJbiBhcyBvLCBjdWJpY091dCBhcyBwLCBxdWFkcmF0aWNJbiBhcyBxLCBjdWJpY0luT3V0IGFzIHIsIHNjYWxlIGFzIHMsIHJvdGF0ZSBhcyB0LCB0cmFuc2xhdGUgYXMgdSwgdmFsaWRhdGVHcmFwaCBhcyB2LCBtdWx0aXBseSBhcyB3LCB6SW5kZXhPcmRlcmluZyBhcyB6IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/normalization-be445518.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/dist/sigma.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/sigma/dist/sigma.esm.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: () => (/* binding */ Camera),\n/* harmony export */   MouseCaptor: () => (/* binding */ MouseCaptor),\n/* harmony export */   Sigma: () => (/* binding */ Sigma$1),\n/* harmony export */   TouchCaptor: () => (/* binding */ TouchCaptor),\n/* harmony export */   \"default\": () => (/* binding */ Sigma)\n/* harmony export */ });\n/* harmony import */ var _index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-236c62ad.esm.js */ \"(ssr)/./node_modules/sigma/dist/index-236c62ad.esm.js\");\n/* harmony import */ var _inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./inherits-d1a1e29b.esm.js */ \"(ssr)/./node_modules/sigma/dist/inherits-d1a1e29b.esm.js\");\n/* harmony import */ var _types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/dist/sigma-types.esm.js */ \"(ssr)/./node_modules/sigma/types/dist/sigma-types.esm.js\");\n/* harmony import */ var _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./normalization-be445518.esm.js */ \"(ssr)/./node_modules/sigma/dist/normalization-be445518.esm.js\");\n/* harmony import */ var _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings/dist/sigma-settings.esm.js */ \"(ssr)/./node_modules/sigma/settings/dist/sigma-settings.esm.js\");\n/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ \"(ssr)/./node_modules/sigma/dist/colors-beb06eb2.esm.js\");\n/* harmony import */ var _data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./data-11df7124.esm.js */ \"(ssr)/./node_modules/sigma/dist/data-11df7124.esm.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n\n\n\n\n\n/**\n * Defaults.\n */\nvar DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\n/**\n * Camera class\n */\nvar Camera = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Camera() {\n    var _this;\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Camera);\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Camera);\n\n    // State\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"x\", 0.5);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"y\", 0.5);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"angle\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"ratio\", 1);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"minRatio\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"maxRatio\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabledZooming\", true);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabledPanning\", true);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabledRotation\", true);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"clean\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nextFrame\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"previousState\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabled\", true);\n    _this.previousState = _this.getState();\n    return _this;\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   */\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Camera, _TypedEventEmitter);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Camera, [{\n    key: \"enable\",\n    value:\n    /**\n     * Method used to enable the camera.\n     */\n    function enable() {\n      this.enabled = true;\n      return this;\n    }\n\n    /**\n     * Method used to disable the camera.\n     */\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n\n    /**\n     * Method used to retrieve the camera's current state.\n     */\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return {\n        x: this.x,\n        y: this.y,\n        angle: this.angle,\n        ratio: this.ratio\n      };\n    }\n\n    /**\n     * Method used to check whether the camera has the given state.\n     */\n  }, {\n    key: \"hasState\",\n    value: function hasState(state) {\n      return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n    }\n\n    /**\n     * Method used to retrieve the camera's previous state.\n     */\n  }, {\n    key: \"getPreviousState\",\n    value: function getPreviousState() {\n      var state = this.previousState;\n      if (!state) return null;\n      return {\n        x: state.x,\n        y: state.y,\n        angle: state.angle,\n        ratio: state.ratio\n      };\n    }\n\n    /**\n     * Method used to check minRatio and maxRatio values.\n     */\n  }, {\n    key: \"getBoundedRatio\",\n    value: function getBoundedRatio(ratio) {\n      var r = ratio;\n      if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n      if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n      return r;\n    }\n\n    /**\n     * Method used to check various things to return a legit state candidate.\n     */\n  }, {\n    key: \"validateState\",\n    value: function validateState(state) {\n      var validatedState = {};\n      if (this.enabledPanning && typeof state.x === \"number\") validatedState.x = state.x;\n      if (this.enabledPanning && typeof state.y === \"number\") validatedState.y = state.y;\n      if (this.enabledZooming && typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n      if (this.enabledRotation && typeof state.angle === \"number\") validatedState.angle = state.angle;\n      return this.clean ? this.clean((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.getState()), validatedState)) : validatedState;\n    }\n\n    /**\n     * Method used to check whether the camera is currently being animated.\n     */\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return !!this.nextFrame;\n    }\n\n    /**\n     * Method used to set the camera's state.\n     */\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      if (!this.enabled) return this;\n\n      // Keeping track of last state\n      this.previousState = this.getState();\n      var validState = this.validateState(state);\n      if (typeof validState.x === \"number\") this.x = validState.x;\n      if (typeof validState.y === \"number\") this.y = validState.y;\n      if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n      if (typeof validState.angle === \"number\") this.angle = validState.angle;\n\n      // Emitting\n      if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n      return this;\n    }\n\n    /**\n     * Method used to update the camera's state using a function.\n     */\n  }, {\n    key: \"updateState\",\n    value: function updateState(updater) {\n      this.setState(updater(this.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to animate the camera.\n     */\n  }, {\n    key: \"animate\",\n    value: function animate(state) {\n      var _this2 = this;\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      if (!callback) return new Promise(function (resolve) {\n        return _this2.animate(state, opts, resolve);\n      });\n      if (!this.enabled) return;\n      var options = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.A), opts);\n      var validState = this.validateState(state);\n      var easing = typeof options.easing === \"function\" ? options.easing : _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.e[options.easing];\n\n      // State\n      var start = Date.now(),\n        initialState = this.getState();\n\n      // Function performing the animation\n      var _fn = function fn() {\n        var t = (Date.now() - start) / options.duration;\n\n        // The animation is over:\n        if (t >= 1) {\n          _this2.nextFrame = null;\n          _this2.setState(validState);\n          if (_this2.animationCallback) {\n            _this2.animationCallback.call(null);\n            _this2.animationCallback = undefined;\n          }\n          return;\n        }\n        var coefficient = easing(t);\n        var newState = {};\n        if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n        if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n        if (_this2.enabledRotation && typeof validState.angle === \"number\") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n        if (typeof validState.ratio === \"number\") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n        _this2.setState(newState);\n        _this2.nextFrame = requestAnimationFrame(_fn);\n      };\n      if (this.nextFrame) {\n        cancelAnimationFrame(this.nextFrame);\n        if (this.animationCallback) this.animationCallback.call(null);\n        this.nextFrame = requestAnimationFrame(_fn);\n      } else {\n        _fn();\n      }\n      this.animationCallback = callback;\n    }\n\n    /**\n     * Method used to zoom the camera.\n     */\n  }, {\n    key: \"animatedZoom\",\n    value: function animatedZoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio / factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to unzoom the camera.\n     */\n  }, {\n    key: \"animatedUnzoom\",\n    value: function animatedUnzoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio * factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to reset the camera.\n     */\n  }, {\n    key: \"animatedReset\",\n    value: function animatedReset(options) {\n      return this.animate({\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0\n      }, options);\n    }\n\n    /**\n     * Returns a new Camera instance, with the same state as the current camera.\n     */\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return Camera.from(this.getState());\n    }\n  }], [{\n    key: \"from\",\n    value: function from(state) {\n      var camera = new Camera();\n      return camera.setState(state);\n    }\n  }]);\n}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nfunction getPosition(e, dom) {\n  var bbox = dom.getBoundingClientRect();\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getMouseCoords(e, dom) {\n  var res = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, getPosition(e, dom)), {}, {\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  });\n  return res;\n}\n\n/**\n * Takes a touch coords or a mouse coords, and always returns a clean mouse coords object.\n */\nfunction cleanMouseCoords(e) {\n  var res = \"x\" in e ? e : (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, e.touches[0] || e.previousTouches[0]), {}, {\n    original: e.original,\n    sigmaDefaultPrevented: e.sigmaDefaultPrevented,\n    preventSigmaDefault: function preventSigmaDefault() {\n      e.sigmaDefaultPrevented = true;\n      res.sigmaDefaultPrevented = true;\n    }\n  });\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getWheelCoords(e, dom) {\n  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, getMouseCoords(e, dom)), {}, {\n    delta: getWheelDelta(e)\n  });\n}\nvar MAX_TOUCHES = 2;\nfunction getTouchesArray(touches) {\n  var arr = [];\n  for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e               - A touch event.\n * @param  {Touch[]}     previousTouches - An array of the previously stored touches.\n * @param  {HTMLElement} dom             - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getTouchCoords(e, previousTouches, dom) {\n  var res = {\n    touches: getTouchesArray(e.touches).map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    previousTouches: previousTouches.map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  };\n  return res;\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nfunction getWheelDelta(e) {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return e.deltaY * -3 / 360;\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nvar Captor = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Captor(container, renderer) {\n    var _this;\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Captor);\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Captor);\n    // Properties\n    _this.container = container;\n    _this.renderer = renderer;\n    return _this;\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Captor, _TypedEventEmitter);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Captor);\n}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);\n\nvar MOUSE_SETTINGS_KEYS = [\"doubleClickTimeout\", \"doubleClickZoomingDuration\", \"doubleClickZoomingRatio\", \"dragTimeout\", \"draggedEventsTolerance\", \"inertiaDuration\", \"inertiaRatio\", \"zoomDuration\", \"zoomingRatio\"];\nvar DEFAULT_MOUSE_SETTINGS = MOUSE_SETTINGS_KEYS.reduce(function (iter, key) {\n  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, iter), {}, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, key, _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nvar MouseCaptor = /*#__PURE__*/function (_Captor) {\n  function MouseCaptor(container, renderer) {\n    var _this;\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, MouseCaptor);\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, MouseCaptor, [container, renderer]);\n\n    // Binding methods\n    // State\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabled\", true);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"draggedEvents\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"downStartTime\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"lastMouseX\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"lastMouseY\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"isMouseDown\", false);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"isMoving\", false);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"movingTimeout\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"startCameraState\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"clicks\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"doubleClickTimeout\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"currentWheelDirection\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"settings\", DEFAULT_MOUSE_SETTINGS);\n    _this.handleClick = _this.handleClick.bind(_this);\n    _this.handleRightClick = _this.handleRightClick.bind(_this);\n    _this.handleDown = _this.handleDown.bind(_this);\n    _this.handleUp = _this.handleUp.bind(_this);\n    _this.handleMove = _this.handleMove.bind(_this);\n    _this.handleWheel = _this.handleWheel.bind(_this);\n    _this.handleLeave = _this.handleLeave.bind(_this);\n    _this.handleEnter = _this.handleEnter.bind(_this);\n\n    // Binding events\n    container.addEventListener(\"click\", _this.handleClick, {\n      capture: false\n    });\n    container.addEventListener(\"contextmenu\", _this.handleRightClick, {\n      capture: false\n    });\n    container.addEventListener(\"mousedown\", _this.handleDown, {\n      capture: false\n    });\n    container.addEventListener(\"wheel\", _this.handleWheel, {\n      capture: false\n    });\n    container.addEventListener(\"mouseleave\", _this.handleLeave, {\n      capture: false\n    });\n    container.addEventListener(\"mouseenter\", _this.handleEnter, {\n      capture: false\n    });\n    document.addEventListener(\"mousemove\", _this.handleMove, {\n      capture: false\n    });\n    document.addEventListener(\"mouseup\", _this.handleUp, {\n      capture: false\n    });\n    return _this;\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(MouseCaptor, _Captor);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(MouseCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"click\", this.handleClick);\n      container.removeEventListener(\"contextmenu\", this.handleRightClick);\n      container.removeEventListener(\"mousedown\", this.handleDown);\n      container.removeEventListener(\"wheel\", this.handleWheel);\n      container.removeEventListener(\"mouseleave\", this.handleLeave);\n      container.removeEventListener(\"mouseenter\", this.handleEnter);\n      document.removeEventListener(\"mousemove\", this.handleMove);\n      document.removeEventListener(\"mouseup\", this.handleUp);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      this.clicks++;\n      if (this.clicks === 2) {\n        this.clicks = 0;\n        if (typeof this.doubleClickTimeout === \"number\") {\n          clearTimeout(this.doubleClickTimeout);\n          this.doubleClickTimeout = null;\n        }\n        return this.handleDoubleClick(e);\n      }\n      setTimeout(function () {\n        _this2.clicks = 0;\n        _this2.doubleClickTimeout = null;\n      }, this.settings.doubleClickTimeout);\n\n      // NOTE: this is here to prevent click events on drag\n      if (this.draggedEvents < this.settings.draggedEventsTolerance) this.emit(\"click\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleRightClick\",\n    value: function handleRightClick(e) {\n      if (!this.enabled) return;\n      this.emit(\"rightClick\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(e) {\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var mouseCoords = getMouseCoords(e, this.container);\n      this.emit(\"doubleClick\", mouseCoords);\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // default behavior\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticInOut\",\n        duration: this.settings.doubleClickZoomingDuration\n      });\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(e) {\n      if (!this.enabled) return;\n\n      // We only start dragging on left button\n      if (e.button === 0) {\n        this.startCameraState = this.renderer.getCamera().getState();\n        var _getPosition = getPosition(e, this.container),\n          x = _getPosition.x,\n          y = _getPosition.y;\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n        this.draggedEvents = 0;\n        this.downStartTime = Date.now();\n        this.isMouseDown = true;\n      }\n      this.emit(\"mousedown\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.isMouseDown) return;\n      var camera = this.renderer.getCamera();\n      this.isMouseDown = false;\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n        this.movingTimeout = null;\n      }\n      var _getPosition2 = getPosition(e, this.container),\n        x = _getPosition2.x,\n        y = _getPosition2.y;\n      var cameraState = camera.getState(),\n        previousCameraState = camera.getPreviousState() || {\n          x: 0,\n          y: 0\n        };\n      if (this.isMoving) {\n        camera.animate({\n          x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n        }, {\n          duration: this.settings.inertiaDuration,\n          easing: \"quadraticOut\"\n        });\n      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n        camera.setState({\n          x: cameraState.x,\n          y: cameraState.y\n        });\n      }\n      this.isMoving = false;\n      setTimeout(function () {\n        var shouldRefresh = _this3.draggedEvents > 0;\n        _this3.draggedEvents = 0;\n\n        // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n        // when someone releases camera pan drag after having stopped moving.\n        // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n        // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n        // It could be possible to render instead of scheduling a refresh but for\n        // now it seems good enough.\n        if (shouldRefresh && _this3.renderer.getSetting(\"hideEdgesOnMove\")) _this3.renderer.refresh();\n      }, 0);\n      this.emit(\"mouseup\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this4 = this;\n      if (!this.enabled) return;\n      var mouseCoords = getMouseCoords(e, this.container);\n\n      // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n      // a drag-and-drop effect that works even when the mouse is out of the\n      // container:\n      this.emit(\"mousemovebody\", mouseCoords);\n\n      // Only trigger the \"mousemove\" event when the mouse is actually hovering\n      // the container, to avoid weirdly hovering nodes and/or edges when the\n      // mouse is not hover the container:\n      if (e.target === this.container || e.composedPath()[0] === this.container) {\n        this.emit(\"mousemove\", mouseCoords);\n      }\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n      // stage while the mouse is not hover the container:\n      if (this.isMouseDown) {\n        this.isMoving = true;\n        this.draggedEvents++;\n        if (typeof this.movingTimeout === \"number\") {\n          clearTimeout(this.movingTimeout);\n        }\n        this.movingTimeout = window.setTimeout(function () {\n          _this4.movingTimeout = null;\n          _this4.isMoving = false;\n        }, this.settings.dragTimeout);\n        var camera = this.renderer.getCamera();\n        var _getPosition3 = getPosition(e, this.container),\n          eX = _getPosition3.x,\n          eY = _getPosition3.y;\n        var lastMouse = this.renderer.viewportToFramedGraph({\n          x: this.lastMouseX,\n          y: this.lastMouseY\n        });\n        var mouse = this.renderer.viewportToFramedGraph({\n          x: eX,\n          y: eY\n        });\n        var offsetX = lastMouse.x - mouse.x,\n          offsetY = lastMouse.y - mouse.y;\n        var cameraState = camera.getState();\n        var x = cameraState.x + offsetX,\n          y = cameraState.y + offsetY;\n        camera.setState({\n          x: x,\n          y: y\n        });\n        this.lastMouseX = eX;\n        this.lastMouseY = eY;\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      this.emit(\"mouseleave\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleEnter\",\n    value: function handleEnter(e) {\n      this.emit(\"mouseenter\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(e) {\n      var _this5 = this;\n      var camera = this.renderer.getCamera();\n      if (!this.enabled || !camera.enabledZooming) return;\n      var delta = getWheelDelta(e);\n      if (!delta) return;\n      var wheelCoords = getWheelCoords(e, this.container);\n      this.emit(\"wheel\", wheelCoords);\n      if (wheelCoords.sigmaDefaultPrevented) {\n        e.preventDefault();\n        e.stopPropagation();\n        return;\n      }\n\n      // Default behavior\n      var currentRatio = camera.getState().ratio;\n      var ratioDiff = delta > 0 ? 1 / this.settings.zoomingRatio : this.settings.zoomingRatio;\n      var newRatio = camera.getBoundedRatio(currentRatio * ratioDiff);\n      var wheelDirection = delta > 0 ? 1 : -1;\n      var now = Date.now();\n\n      // Exit early without preventing default behavior when ratio doesn't change:\n      if (currentRatio === newRatio) return;\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Cancel events that are too close each other and in the same direction:\n      if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < this.settings.zoomDuration / 5) {\n        return;\n      }\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticOut\",\n        duration: this.settings.zoomDuration\n      }, function () {\n        _this5.currentWheelDirection = 0;\n      });\n      this.currentWheelDirection = wheelDirection;\n      this.lastWheelTriggerTime = now;\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n}(Captor);\n\nvar TOUCH_SETTINGS_KEYS = [\"dragTimeout\", \"inertiaDuration\", \"inertiaRatio\", \"doubleClickTimeout\", \"doubleClickZoomingRatio\", \"doubleClickZoomingDuration\", \"tapMoveTolerance\"];\nvar DEFAULT_TOUCH_SETTINGS = TOUCH_SETTINGS_KEYS.reduce(function (iter, key) {\n  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, iter), {}, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, key, _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Touch captor class.\n *\n * @constructor\n */\nvar TouchCaptor = /*#__PURE__*/function (_Captor) {\n  function TouchCaptor(container, renderer) {\n    var _this;\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, TouchCaptor);\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, TouchCaptor, [container, renderer]);\n\n    // Binding methods:\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabled\", true);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"isMoving\", false);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"hasMoved\", false);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"touchMode\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"startTouchesPositions\", []);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"lastTouches\", []);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"lastTap\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"settings\", DEFAULT_TOUCH_SETTINGS);\n    _this.handleStart = _this.handleStart.bind(_this);\n    _this.handleLeave = _this.handleLeave.bind(_this);\n    _this.handleMove = _this.handleMove.bind(_this);\n\n    // Binding events\n    container.addEventListener(\"touchstart\", _this.handleStart, {\n      capture: false\n    });\n    container.addEventListener(\"touchcancel\", _this.handleLeave, {\n      capture: false\n    });\n    document.addEventListener(\"touchend\", _this.handleLeave, {\n      capture: false,\n      passive: false\n    });\n    document.addEventListener(\"touchmove\", _this.handleMove, {\n      capture: false,\n      passive: false\n    });\n    return _this;\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(TouchCaptor, _Captor);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(TouchCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"touchstart\", this.handleStart);\n      container.removeEventListener(\"touchcancel\", this.handleLeave);\n      document.removeEventListener(\"touchend\", this.handleLeave);\n      document.removeEventListener(\"touchmove\", this.handleMove);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n    }\n  }, {\n    key: \"handleStart\",\n    value: function handleStart(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      e.preventDefault();\n      var touches = getTouchesArray(e.touches);\n      this.touchMode = touches.length;\n      this.startCameraState = this.renderer.getCamera().getState();\n      this.startTouchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this2.container);\n      });\n\n      // When there are two touches down, let's record distance and angle as well:\n      if (this.touchMode === 2) {\n        var _this$startTouchesPos = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(this.startTouchesPositions, 2),\n          _this$startTouchesPos2 = _this$startTouchesPos[0],\n          x0 = _this$startTouchesPos2.x,\n          y0 = _this$startTouchesPos2.y,\n          _this$startTouchesPos3 = _this$startTouchesPos[1],\n          x1 = _this$startTouchesPos3.x,\n          y1 = _this$startTouchesPos3.y;\n        this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n        this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n      }\n      this.emit(\"touchdown\", getTouchCoords(e, this.lastTouches, this.container));\n      this.lastTouches = touches;\n      this.lastTouchesPositions = this.startTouchesPositions;\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      if (!this.enabled || !this.startTouchesPositions.length) return;\n      if (e.cancelable) e.preventDefault();\n      if (this.movingTimeout) {\n        this.isMoving = false;\n        clearTimeout(this.movingTimeout);\n      }\n      switch (this.touchMode) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        case 2:\n          if (e.touches.length === 1) {\n            this.handleStart(e);\n            e.preventDefault();\n            break;\n          }\n        /* falls through */\n        case 1:\n          if (this.isMoving) {\n            var camera = this.renderer.getCamera();\n            var cameraState = camera.getState(),\n              previousCameraState = camera.getPreviousState() || {\n                x: 0,\n                y: 0\n              };\n            camera.animate({\n              x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n            }, {\n              duration: this.settings.inertiaDuration,\n              easing: \"quadraticOut\"\n            });\n          }\n          this.hasMoved = false;\n          this.isMoving = false;\n          this.touchMode = 0;\n          break;\n      }\n      this.emit(\"touchup\", getTouchCoords(e, this.lastTouches, this.container));\n\n      // When the last touch ends and there hasn't been too much movement, trigger a \"tap\" or \"doubletap\" event:\n      if (!e.touches.length) {\n        var position = getPosition(this.lastTouches[0], this.container);\n        var downPosition = this.startTouchesPositions[0];\n        var dSquare = Math.pow(position.x - downPosition.x, 2) + Math.pow(position.y - downPosition.y, 2);\n        if (!e.touches.length && dSquare < Math.pow(this.settings.tapMoveTolerance, 2)) {\n          // Only trigger \"doubletap\" when the last tap is recent enough:\n          if (this.lastTap && Date.now() - this.lastTap.time < this.settings.doubleClickTimeout) {\n            var touchCoords = getTouchCoords(e, this.lastTouches, this.container);\n            this.emit(\"doubletap\", touchCoords);\n            this.lastTap = null;\n            if (!touchCoords.sigmaDefaultPrevented) {\n              var _camera = this.renderer.getCamera();\n              var newRatio = _camera.getBoundedRatio(_camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n              _camera.animate(this.renderer.getViewportZoomedState(position, newRatio), {\n                easing: \"quadraticInOut\",\n                duration: this.settings.doubleClickZoomingDuration\n              });\n            }\n          }\n          // Else, trigger a normal \"tap\" event:\n          else {\n            var _touchCoords = getTouchCoords(e, this.lastTouches, this.container);\n            this.emit(\"tap\", _touchCoords);\n            this.lastTap = {\n              time: Date.now(),\n              position: _touchCoords.touches[0] || _touchCoords.previousTouches[0]\n            };\n          }\n        }\n      }\n      this.lastTouches = getTouchesArray(e.touches);\n      this.startTouchesPositions = [];\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.startTouchesPositions.length) return;\n      e.preventDefault();\n      var touches = getTouchesArray(e.touches);\n      var touchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this3.container);\n      });\n      var lastTouches = this.lastTouches;\n      this.lastTouches = touches;\n      this.lastTouchesPositions = touchesPositions;\n      var touchCoords = getTouchCoords(e, lastTouches, this.container);\n      this.emit(\"touchmove\", touchCoords);\n      if (touchCoords.sigmaDefaultPrevented) return;\n\n      // If a move was initiated at some point, and we get back to start point,\n      // we should still consider that we did move (which also happens after a\n      // multiple touch when only one touch remains in which case handleStart\n      // is recalled within handleLeave).\n      // Now, some mobile browsers report zero-distance moves so we also check that\n      // one of the touches did actually move from the origin position.\n      this.hasMoved || (this.hasMoved = touchesPositions.some(function (position, idx) {\n        var startPosition = _this3.startTouchesPositions[idx];\n        return startPosition && (position.x !== startPosition.x || position.y !== startPosition.y);\n      }));\n\n      // If there was no move, do not trigger touch moves behavior\n      if (!this.hasMoved) {\n        return;\n      }\n      this.isMoving = true;\n      if (this.movingTimeout) clearTimeout(this.movingTimeout);\n      this.movingTimeout = window.setTimeout(function () {\n        _this3.isMoving = false;\n      }, this.settings.dragTimeout);\n      var camera = this.renderer.getCamera();\n      var startCameraState = this.startCameraState;\n      var padding = this.renderer.getSetting(\"stagePadding\");\n      switch (this.touchMode) {\n        case 1:\n          {\n            var _this$renderer$viewpo = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]),\n              xStart = _this$renderer$viewpo.x,\n              yStart = _this$renderer$viewpo.y;\n            var _this$renderer$viewpo2 = this.renderer.viewportToFramedGraph(touchesPositions[0]),\n              x = _this$renderer$viewpo2.x,\n              y = _this$renderer$viewpo2.y;\n            camera.setState({\n              x: startCameraState.x + xStart - x,\n              y: startCameraState.y + yStart - y\n            });\n            break;\n          }\n        case 2:\n          {\n            /**\n             * Here is the thinking here:\n             *\n             * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n             *    of the d'n'd and now\n             *\n             * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n             *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n             *    position of this same touch now\n             */\n            var newCameraState = {\n              x: 0.5,\n              y: 0.5,\n              angle: 0,\n              ratio: 1\n            };\n            var _touchesPositions$ = touchesPositions[0],\n              x0 = _touchesPositions$.x,\n              y0 = _touchesPositions$.y;\n            var _touchesPositions$2 = touchesPositions[1],\n              x1 = _touchesPositions$2.x,\n              y1 = _touchesPositions$2.y;\n            var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;\n            var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;\n\n            // 1.\n            var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n            newCameraState.ratio = newRatio;\n            newCameraState.angle = startCameraState.angle + angleDiff;\n\n            // 2.\n            var dimensions = this.getDimensions();\n            var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], {\n              cameraState: startCameraState\n            });\n            var smallestDimension = Math.min(dimensions.width, dimensions.height) - 2 * padding;\n            var dx = smallestDimension / dimensions.width;\n            var dy = smallestDimension / dimensions.height;\n            var ratio = newRatio / smallestDimension;\n\n            // Align with center of the graph:\n            var _x = x0 - smallestDimension / 2 / dx;\n            var _y = y0 - smallestDimension / 2 / dy;\n\n            // Rotate:\n            var _ref = [_x * Math.cos(-newCameraState.angle) - _y * Math.sin(-newCameraState.angle), _y * Math.cos(-newCameraState.angle) + _x * Math.sin(-newCameraState.angle)];\n            _x = _ref[0];\n            _y = _ref[1];\n            newCameraState.x = touchGraphPosition.x - _x * ratio;\n            newCameraState.y = touchGraphPosition.y + _y * ratio;\n            camera.setState(newCameraState);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n}(Captor);\n\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.a)(r);\n}\n\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(r) || _nonIterableSpread();\n}\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\n/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /*#__PURE__*/function () {\n  function LabelCandidate(key, size) {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, LabelCandidate);\n    this.key = key;\n    this.size = size;\n  }\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(LabelCandidate, null, [{\n    key: \"compare\",\n    value: function compare(first, second) {\n      // First we compare by size\n      if (first.size > second.size) return -1;\n      if (first.size < second.size) return 1;\n\n      // Then since no two nodes can have the same key, we use it to\n      // deterministically tie-break by key\n      if (first.key > second.key) return 1;\n\n      // NOTE: this comparator cannot return 0\n      return -1;\n    }\n  }]);\n}();\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /*#__PURE__*/function () {\n  function LabelGrid() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, LabelGrid);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"width\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"height\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"cellSize\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"columns\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"rows\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"cells\", {});\n  }\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(LabelGrid, [{\n    key: \"resizeAndClear\",\n    value: function resizeAndClear(dimensions, cellSize) {\n      this.width = dimensions.width;\n      this.height = dimensions.height;\n      this.cellSize = cellSize;\n      this.columns = Math.ceil(dimensions.width / cellSize);\n      this.rows = Math.ceil(dimensions.height / cellSize);\n      this.cells = {};\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(pos) {\n      var xIndex = Math.floor(pos.x / this.cellSize);\n      var yIndex = Math.floor(pos.y / this.cellSize);\n      return yIndex * this.columns + xIndex;\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, size, pos) {\n      var candidate = new LabelCandidate(key, size);\n      var index = this.getIndex(pos);\n      var cell = this.cells[index];\n      if (!cell) {\n        cell = [];\n        this.cells[index] = cell;\n      }\n      cell.push(candidate);\n    }\n  }, {\n    key: \"organize\",\n    value: function organize() {\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        cell.sort(LabelCandidate.compare);\n      }\n    }\n  }, {\n    key: \"getLabelsToDisplay\",\n    value: function getLabelsToDisplay(ratio, density) {\n      // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n      // TODO: adjust threshold lower, but increase cells a bit?\n      // TODO: hunt for geom issue in disguise\n      // TODO: memoize while ratio does not move. method to force recompute\n      var cellArea = this.cellSize * this.cellSize;\n      var scaledCellArea = cellArea / ratio / ratio;\n      var scaledDensity = scaledCellArea * density / cellArea;\n      var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n      var labels = [];\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n          labels.push(cell[i].key);\n        }\n      }\n      return labels;\n    }\n  }]);\n}();\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n    hoveredNode = params.hoveredNode,\n    highlightedNodes = params.highlightedNodes,\n    displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge(function (edge, _, source, target) {\n    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {\n      worthyEdges.push(edge);\n    }\n  });\n  return worthyEdges;\n}\n\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!hasOwnProperty.call(data, \"x\") || !hasOwnProperty.call(data, \"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"highlighted\")) data.highlighted = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, _key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma$1 = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Sigma(graph, container) {\n    var _this;\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Sigma);\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Sigma);\n\n    // Resolving settings\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"elements\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"canvasContexts\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"webGLContexts\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"pickingLayers\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"textures\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"frameBuffers\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"activeListeners\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"labelGrid\", new LabelGrid());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeDataCache\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgeDataCache\", {});\n    // Indices to keep track of the index of the item inside programs\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeProgramIndex\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgeProgramIndex\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodesWithForcedLabels\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgesWithForcedLabels\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeExtent\", {\n      x: [0, 1],\n      y: [0, 1]\n    });\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeZExtent\", [Infinity, -Infinity]);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgeZExtent\", [Infinity, -Infinity]);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"matrix\", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.i)());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"invMatrix\", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.i)());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"correctionRatio\", 1);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"customBBox\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"normalizationFunction\", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.c)({\n      x: [0, 1],\n      y: [0, 1]\n    }));\n    // Cache:\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"graphToViewportRatio\", 1);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"itemIDsIndex\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeIndices\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgeIndices\", {});\n    // Starting dimensions and pixel ratio\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"width\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"height\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"pixelRatio\", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.d)());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"pickingDownSizingRatio\", 2 * _this.pixelRatio);\n    // Graph State\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"displayedNodeLabels\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"displayedEdgeLabels\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"highlightedNodes\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"hoveredNode\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"hoveredEdge\", null);\n    // Internal states\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"renderFrame\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"renderHighlightedNodesFrame\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"needToProcess\", false);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"checkEdgesEventsFrame\", null);\n    // Programs\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodePrograms\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeHoverPrograms\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgePrograms\", {});\n    _this.settings = (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.resolveSettings)(settings);\n\n    // Validating\n    (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(_this.settings);\n    (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.v)(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      picking: settings.enableEdgeEvents\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\", {\n      picking: true\n    });\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\", {\n      style: {\n        touchAction: \"none\",\n        userSelect: \"none\"\n      }\n    });\n\n    // Initial resize\n    _this.resize();\n\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      _this.registerNodeProgram(type, _this.settings.nodeProgramClasses[type], _this.settings.nodeHoverProgramClasses[type]);\n    }\n    for (var _type in _this.settings.edgeProgramClasses) {\n      _this.registerEdgeProgram(_type, _this.settings.edgeProgramClasses[_type]);\n    }\n\n    // Initializing the camera\n    _this.camera = new Camera();\n\n    // Binding camera events\n    _this.bindCameraHandlers();\n\n    // Initializing captors\n    _this.mouseCaptor = new MouseCaptor(_this.elements.mouse, _this);\n    _this.mouseCaptor.setSettings(_this.settings);\n    _this.touchCaptor = new TouchCaptor(_this.elements.mouse, _this);\n    _this.touchCaptor.setSettings(_this.settings);\n\n    // Binding event handlers\n    _this.bindEventHandlers();\n\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    _this.refresh();\n    return _this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to register a node program\n   *\n   * @param  {string}           key              - The program's key, matching the related nodes \"type\" values.\n   * @param  {NodeProgramType}  NodeProgramClass - A nodes program class.\n   * @param  {NodeProgramType?} NodeHoverProgram - A nodes program class to render hovered nodes (optional).\n   * @return {Sigma}\n   */\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Sigma, _TypedEventEmitter);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Sigma, [{\n    key: \"registerNodeProgram\",\n    value: function registerNodeProgram(key, NodeProgramClass, NodeHoverProgram) {\n      if (this.nodePrograms[key]) this.nodePrograms[key].kill();\n      if (this.nodeHoverPrograms[key]) this.nodeHoverPrograms[key].kill();\n      this.nodePrograms[key] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);\n      this.nodeHoverPrograms[key] = new (NodeHoverProgram || NodeProgramClass)(this.webGLContexts.hoverNodes, null, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to register an edge program\n     *\n     * @param  {string}          key              - The program's key, matching the related edges \"type\" values.\n     * @param  {EdgeProgramType} EdgeProgramClass - An edges program class.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"registerEdgeProgram\",\n    value: function registerEdgeProgram(key, EdgeProgramClass) {\n      if (this.edgePrograms[key]) this.edgePrograms[key].kill();\n      this.edgePrograms[key] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister a node program\n     *\n     * @param  {string} key - The program's key, matching the related nodes \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterNodeProgram\",\n    value: function unregisterNodeProgram(key) {\n      if (this.nodePrograms[key]) {\n        var _this$nodePrograms = this.nodePrograms,\n          program = _this$nodePrograms[key],\n          programs = _objectWithoutProperties(_this$nodePrograms, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));\n        program.kill();\n        this.nodePrograms = programs;\n      }\n      if (this.nodeHoverPrograms[key]) {\n        var _this$nodeHoverProgra = this.nodeHoverPrograms,\n          _program = _this$nodeHoverProgra[key],\n          _programs = _objectWithoutProperties(_this$nodeHoverProgra, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));\n        _program.kill();\n        this.nodePrograms = _programs;\n      }\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister an edge program\n     *\n     * @param  {string} key - The program's key, matching the related edges \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterEdgeProgram\",\n    value: function unregisterEdgeProgram(key) {\n      if (this.edgePrograms[key]) {\n        var _this$edgePrograms = this.edgePrograms,\n          program = _this$edgePrograms[key],\n          programs = _objectWithoutProperties(_this$edgePrograms, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));\n        program.kill();\n        this.edgePrograms = programs;\n      }\n      return this;\n    }\n\n    /**\n     * Method (re)binding WebGL texture (for picking).\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resetWebGLTexture\",\n    value: function resetWebGLTexture(id) {\n      var gl = this.webGLContexts[id];\n      var frameBuffer = this.frameBuffers[id];\n      var currentTexture = this.textures[id];\n      if (currentTexture) gl.deleteTexture(currentTexture);\n      var pickingTexture = gl.createTexture();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n      this.textures[id] = pickingTexture;\n      return this;\n    }\n\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindCameraHandlers\",\n    value: function bindCameraHandlers() {\n      var _this2 = this;\n      this.activeListeners.camera = function () {\n        _this2.scheduleRender();\n      };\n      this.camera.on(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method unbinding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unbindCameraHandlers\",\n    value: function unbindCameraHandlers() {\n      this.camera.removeListener(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method that returns the closest node to a given position.\n     */\n  }, {\n    key: \"getNodeAtPosition\",\n    value: function getNodeAtPosition(position) {\n      var x = position.x,\n        y = position.y;\n      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.g)(this.webGLContexts.nodes, this.frameBuffers.nodes, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.c.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindEventHandlers\",\n    value: function bindEventHandlers() {\n      var _this3 = this;\n      // Handling window resize\n      this.activeListeners.handleResize = function () {\n        // need to call a refresh to rebuild the labelgrid\n        _this3.scheduleRefresh();\n      };\n      window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n      // Handling mouse move\n      this.activeListeners.handleMove = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        var nodeToHover = _this3.getNodeAtPosition(event);\n        if (nodeToHover && _this3.hoveredNode !== nodeToHover && !_this3.nodeDataCache[nodeToHover].hidden) {\n          // Handling passing from one node to the other directly\n          if (_this3.hoveredNode) _this3.emit(\"leaveNode\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.hoveredNode = nodeToHover;\n          _this3.emit(\"enterNode\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n            node: nodeToHover\n          }));\n          _this3.scheduleHighlightedNodesRender();\n          return;\n        }\n\n        // Checking if the hovered node is still hovered\n        if (_this3.hoveredNode) {\n          if (_this3.getNodeAtPosition(event) !== _this3.hoveredNode) {\n            var node = _this3.hoveredNode;\n            _this3.hoveredNode = null;\n            _this3.emit(\"leaveNode\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n              node: node\n            }));\n            _this3.scheduleHighlightedNodesRender();\n            return;\n          }\n        }\n        if (_this3.settings.enableEdgeEvents) {\n          var edgeToHover = _this3.hoveredNode ? null : _this3.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);\n          if (edgeToHover !== _this3.hoveredEdge) {\n            if (_this3.hoveredEdge) _this3.emit(\"leaveEdge\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n              edge: _this3.hoveredEdge\n            }));\n            if (edgeToHover) _this3.emit(\"enterEdge\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n              edge: edgeToHover\n            }));\n            _this3.hoveredEdge = edgeToHover;\n          }\n        }\n      };\n\n      // Handling mouse move over body (only to dispatch the proper event):\n      this.activeListeners.handleMoveBody = function (e) {\n        var event = cleanMouseCoords(e);\n        _this3.emit(\"moveBody\", {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        });\n      };\n\n      // Handling mouse leave stage:\n      this.activeListeners.handleLeave = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        if (_this3.hoveredNode) {\n          _this3.emit(\"leaveNode\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        if (_this3.settings.enableEdgeEvents && _this3.hoveredEdge) {\n          _this3.emit(\"leaveEdge\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n            edge: _this3.hoveredEdge\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        _this3.emit(\"leaveStage\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent));\n      };\n\n      // Handling mouse enter stage:\n      this.activeListeners.handleEnter = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        _this3.emit(\"enterStage\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent));\n      };\n\n      // Handling click\n      var createInteractionListener = function createInteractionListener(eventType) {\n        return function (e) {\n          var event = cleanMouseCoords(e);\n          var baseEvent = {\n            event: event,\n            preventSigmaDefault: function preventSigmaDefault() {\n              event.preventSigmaDefault();\n            }\n          };\n          var nodeAtPosition = _this3.getNodeAtPosition(event);\n          if (nodeAtPosition) return _this3.emit(\"\".concat(eventType, \"Node\"), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n            node: nodeAtPosition\n          }));\n          if (_this3.settings.enableEdgeEvents) {\n            var edge = _this3.getEdgeAtPoint(event.x, event.y);\n            if (edge) return _this3.emit(\"\".concat(eventType, \"Edge\"), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n              edge: edge\n            }));\n          }\n          return _this3.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n        };\n      };\n      this.activeListeners.handleClick = createInteractionListener(\"click\");\n      this.activeListeners.handleRightClick = createInteractionListener(\"rightClick\");\n      this.activeListeners.handleDoubleClick = createInteractionListener(\"doubleClick\");\n      this.activeListeners.handleWheel = createInteractionListener(\"wheel\");\n      this.activeListeners.handleDown = createInteractionListener(\"down\");\n      this.activeListeners.handleUp = createInteractionListener(\"up\");\n      this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n      this.mouseCaptor.on(\"mousemovebody\", this.activeListeners.handleMoveBody);\n      this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n      this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n      this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n      this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n      this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n      this.mouseCaptor.on(\"mouseup\", this.activeListeners.handleUp);\n      this.mouseCaptor.on(\"mouseleave\", this.activeListeners.handleLeave);\n      this.mouseCaptor.on(\"mouseenter\", this.activeListeners.handleEnter);\n      this.touchCaptor.on(\"touchdown\", this.activeListeners.handleDown);\n      this.touchCaptor.on(\"touchdown\", this.activeListeners.handleMove);\n      this.touchCaptor.on(\"touchup\", this.activeListeners.handleUp);\n      this.touchCaptor.on(\"touchmove\", this.activeListeners.handleMove);\n      this.touchCaptor.on(\"tap\", this.activeListeners.handleClick);\n      this.touchCaptor.on(\"doubletap\", this.activeListeners.handleDoubleClick);\n      this.touchCaptor.on(\"touchmove\", this.activeListeners.handleMoveBody);\n      return this;\n    }\n\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindGraphHandlers\",\n    value: function bindGraphHandlers() {\n      var _this4 = this;\n      var graph = this.graph;\n      var LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n      this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints;\n        var updatedFields = (_e$hints = e.hints) === null || _e$hints === void 0 ? void 0 : _e$hints.attributes;\n        // we process all nodes\n        _this4.graph.forEachNode(function (node) {\n          return _this4.updateNode(node);\n        });\n\n        // if coord, type or zIndex have changed, we need to schedule a render\n        // (zIndex for the programIndex)\n        var layoutChanged = !updatedFields || updatedFields.some(function (f) {\n          return LAYOUT_IMPACTING_FIELDS.has(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            nodes: graph.nodes()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n      this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints2;\n        var updatedFields = (_e$hints2 = e.hints) === null || _e$hints2 === void 0 ? void 0 : _e$hints2.attributes;\n        // we process all edges\n        _this4.graph.forEachEdge(function (edge) {\n          return _this4.updateEdge(edge);\n        });\n        var layoutChanged = updatedFields && [\"zIndex\", \"type\"].some(function (f) {\n          return updatedFields === null || updatedFields === void 0 ? void 0 : updatedFields.includes(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            edges: graph.edges()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n\n      // On add node, we add the node in indices and then call for a render\n      this.activeListeners.addNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.addNode(node);\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On update node, we update indices and then call for a render\n      this.activeListeners.updateNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop node, we remove the node from indices and then call for a refresh\n      this.activeListeners.dropNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.removeNode(node);\n        // schedule a render for everything\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On add edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.addEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.addEdge(edge);\n        // schedule a render for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          schedule: true\n        });\n      };\n\n      // On update edge, we update indices and then call for a refresh\n      this.activeListeners.updateEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // schedule a repaint for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.dropEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.removeEdge(edge);\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On clear edges, we clear the edge indices and then call for a refresh\n      this.activeListeners.clearEdgesGraphUpdate = function () {\n        // we clear the edge data structures\n        _this4.clearEdgeState();\n        _this4.clearEdgeIndices();\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On graph clear, we clear indices and then call for a refresh\n      this.activeListeners.clearGraphUpdate = function () {\n        // clear graph state\n        _this4.clearEdgeState();\n        _this4.clearNodeState();\n\n        // clear graph indices\n        _this4.clearEdgeIndices();\n        _this4.clearNodeIndices();\n\n        // schedule a render for all\n        _this4.refresh({\n          schedule: true\n        });\n      };\n      graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n      return this;\n    }\n\n    /**\n     * Method used to unbind handlers from the graph.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"unbindGraphHandlers\",\n    value: function unbindGraphHandlers() {\n      var graph = this.graph;\n      graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    }\n\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n  }, {\n    key: \"getEdgeAtPoint\",\n    value: function getEdgeAtPoint(x, y) {\n      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.g)(this.webGLContexts.edges, this.frameBuffers.edges, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.c.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method used to process the whole graph's data.\n     *  - extent\n     *  - normalizationFunction\n     *  - compute node's coordinate\n     *  - labelgrid\n     *  - program data allocation\n     * @return {Sigma}\n     */\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this5 = this;\n      this.emit(\"beforeProcess\");\n      var graph = this.graph;\n      var settings = this.settings;\n      var dimensions = this.getDimensions();\n\n      //\n      // NODES\n      //\n      this.nodeExtent = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.graph);\n      if (!this.settings.autoRescale) {\n        var width = dimensions.width,\n          height = dimensions.height;\n        var _this$nodeExtent = this.nodeExtent,\n          x = _this$nodeExtent.x,\n          y = _this$nodeExtent.y;\n        this.nodeExtent = {\n          x: [(x[0] + x[1]) / 2 - width / 2, (x[0] + x[1]) / 2 + width / 2],\n          y: [(y[0] + y[1]) / 2 - height / 2, (y[0] + y[1]) / 2 + height / 2]\n        };\n      }\n      this.normalizationFunction = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.c)(this.customBBox || this.nodeExtent);\n\n      // NOTE: it is important to compute this matrix after computing the node's extent\n      // because #.getGraphDimensions relies on it\n      var nullCamera = new Camera();\n      var nullCameraMatrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(nullCamera.getState(), dimensions, this.getGraphDimensions(), this.getStagePadding());\n      // Resetting the label grid\n      // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n      this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n      var nodesPerPrograms = {};\n      var nodeIndices = {};\n      var edgeIndices = {};\n      var itemIDsIndex = {};\n      var incrID = 1;\n      var nodes = graph.nodes();\n\n      // Do some indexation on the whole graph\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        var data = this.nodeDataCache[node];\n\n        // Get initial coordinates\n        var attrs = graph.getNodeAttributes(node);\n        data.x = attrs.x;\n        data.y = attrs.y;\n        this.normalizationFunction.applyTo(data);\n\n        // labelgrid\n        if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n          matrix: nullCameraMatrix\n        }));\n\n        // update count per program\n        nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      }\n      this.labelGrid.organize();\n\n      // Allocate memory to programs\n      for (var type in this.nodePrograms) {\n        if (!hasOwnProperty.call(this.nodePrograms, type)) {\n          throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n        }\n        this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        nodesPerPrograms[type] = 0;\n      }\n\n      // Order nodes by zIndex before to add them to program\n      if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1]) nodes = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.z)(this.nodeZExtent, function (node) {\n        return _this5.nodeDataCache[node].zIndex;\n      }, nodes);\n\n      // Add data to programs\n      for (var _i = 0, _l = nodes.length; _i < _l; _i++) {\n        var _node = nodes[_i];\n        nodeIndices[_node] = incrID;\n        itemIDsIndex[nodeIndices[_node]] = {\n          type: \"node\",\n          id: _node\n        };\n        incrID++;\n        var _data = this.nodeDataCache[_node];\n        this.addNodeToProgram(_node, nodeIndices[_node], nodesPerPrograms[_data.type]++);\n      }\n\n      //\n      // EDGES\n      //\n\n      var edgesPerPrograms = {};\n      var edges = graph.edges();\n\n      // Allocate memory to programs\n      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {\n        var edge = edges[_i2];\n        var _data2 = this.edgeDataCache[edge];\n        edgesPerPrograms[_data2.type] = (edgesPerPrograms[_data2.type] || 0) + 1;\n      }\n\n      // Order edges by zIndex before to add them to program\n      if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1]) edges = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.z)(this.edgeZExtent, function (edge) {\n        return _this5.edgeDataCache[edge].zIndex;\n      }, edges);\n      for (var _type2 in this.edgePrograms) {\n        if (!hasOwnProperty.call(this.edgePrograms, _type2)) {\n          throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(_type2, \"\\\"!\"));\n        }\n        this.edgePrograms[_type2].reallocate(edgesPerPrograms[_type2] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        edgesPerPrograms[_type2] = 0;\n      }\n\n      // Add data to programs\n      for (var _i3 = 0, _l3 = edges.length; _i3 < _l3; _i3++) {\n        var _edge = edges[_i3];\n        edgeIndices[_edge] = incrID;\n        itemIDsIndex[edgeIndices[_edge]] = {\n          type: \"edge\",\n          id: _edge\n        };\n        incrID++;\n        var _data3 = this.edgeDataCache[_edge];\n        this.addEdgeToProgram(_edge, edgeIndices[_edge], edgesPerPrograms[_data3.type]++);\n      }\n      this.itemIDsIndex = itemIDsIndex;\n      this.nodeIndices = nodeIndices;\n      this.edgeIndices = edgeIndices;\n      this.emit(\"afterProcess\");\n      return this;\n    }\n\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n  }, {\n    key: \"handleSettingsUpdate\",\n    value: function handleSettingsUpdate(oldSettings) {\n      var _this6 = this;\n      var settings = this.settings;\n      this.camera.minRatio = settings.minCameraRatio;\n      this.camera.maxRatio = settings.maxCameraRatio;\n      this.camera.enabledZooming = settings.enableCameraZooming;\n      this.camera.enabledPanning = settings.enableCameraPanning;\n      this.camera.enabledRotation = settings.enableCameraRotation;\n      if (settings.cameraPanBoundaries) {\n        this.camera.clean = function (state) {\n          return _this6.cleanCameraState(state, settings.cameraPanBoundaries && (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__._)(settings.cameraPanBoundaries) === \"object\" ? settings.cameraPanBoundaries : {});\n        };\n      } else {\n        this.camera.clean = null;\n      }\n      this.camera.setState(this.camera.validateState(this.camera.getState()));\n      if (oldSettings) {\n        // Check edge programs:\n        if (oldSettings.edgeProgramClasses !== settings.edgeProgramClasses) {\n          for (var type in settings.edgeProgramClasses) {\n            if (settings.edgeProgramClasses[type] !== oldSettings.edgeProgramClasses[type]) {\n              this.registerEdgeProgram(type, settings.edgeProgramClasses[type]);\n            }\n          }\n          for (var _type3 in oldSettings.edgeProgramClasses) {\n            if (!settings.edgeProgramClasses[_type3]) this.unregisterEdgeProgram(_type3);\n          }\n        }\n\n        // Check node programs:\n        if (oldSettings.nodeProgramClasses !== settings.nodeProgramClasses || oldSettings.nodeHoverProgramClasses !== settings.nodeHoverProgramClasses) {\n          for (var _type4 in settings.nodeProgramClasses) {\n            if (settings.nodeProgramClasses[_type4] !== oldSettings.nodeProgramClasses[_type4] || settings.nodeHoverProgramClasses[_type4] !== oldSettings.nodeHoverProgramClasses[_type4]) {\n              this.registerNodeProgram(_type4, settings.nodeProgramClasses[_type4], settings.nodeHoverProgramClasses[_type4]);\n            }\n          }\n          for (var _type5 in oldSettings.nodeProgramClasses) {\n            if (!settings.nodeProgramClasses[_type5]) this.unregisterNodeProgram(_type5);\n          }\n        }\n      }\n\n      // Update captors settings:\n      this.mouseCaptor.setSettings(this.settings);\n      this.touchCaptor.setSettings(this.settings);\n      return this;\n    }\n  }, {\n    key: \"cleanCameraState\",\n    value: function cleanCameraState(state) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$tolerance = _ref.tolerance,\n        tolerance = _ref$tolerance === void 0 ? 0 : _ref$tolerance,\n        boundaries = _ref.boundaries;\n      var newState = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, state);\n\n      // Extract necessary properties\n      var _ref2 = boundaries || this.nodeExtent,\n        _ref2$x = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(_ref2.x, 2),\n        xMinGraph = _ref2$x[0],\n        xMaxGraph = _ref2$x[1],\n        _ref2$y = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(_ref2.y, 2),\n        yMinGraph = _ref2$y[0],\n        yMaxGraph = _ref2$y[1];\n\n      // Transform the four corners of the graph rectangle using the provided camera state\n      var corners = [this.graphToViewport({\n        x: xMinGraph,\n        y: yMinGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMaxGraph,\n        y: yMinGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMinGraph,\n        y: yMaxGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMaxGraph,\n        y: yMaxGraph\n      }, {\n        cameraState: state\n      })];\n\n      // Look for new extents, based on these four corners\n      var xMin = Infinity,\n        xMax = -Infinity,\n        yMin = Infinity,\n        yMax = -Infinity;\n      corners.forEach(function (_ref3) {\n        var x = _ref3.x,\n          y = _ref3.y;\n        xMin = Math.min(xMin, x);\n        xMax = Math.max(xMax, x);\n        yMin = Math.min(yMin, y);\n        yMax = Math.max(yMax, y);\n      });\n\n      // For each dimension, constraint the smaller element (camera or graph) to fit in the larger one:\n      var graphWidth = xMax - xMin;\n      var graphHeight = yMax - yMin;\n      var _this$getDimensions = this.getDimensions(),\n        width = _this$getDimensions.width,\n        height = _this$getDimensions.height;\n      var dx = 0;\n      var dy = 0;\n      if (graphWidth >= width) {\n        if (xMax < width - tolerance) dx = xMax - (width - tolerance);else if (xMin > tolerance) dx = xMin - tolerance;\n      } else {\n        if (xMax > width + tolerance) dx = xMax - (width + tolerance);else if (xMin < -tolerance) dx = xMin + tolerance;\n      }\n      if (graphHeight >= height) {\n        if (yMax < height - tolerance) dy = yMax - (height - tolerance);else if (yMin > tolerance) dy = yMin - tolerance;\n      } else {\n        if (yMax > height + tolerance) dy = yMax - (height + tolerance);else if (yMin < -tolerance) dy = yMin + tolerance;\n      }\n      if (dx || dy) {\n        // Transform [dx, dy] from viewport to graph (using two different point to transform that vector):\n        var origin = this.viewportToFramedGraph({\n          x: 0,\n          y: 0\n        }, {\n          cameraState: state\n        });\n        var delta = this.viewportToFramedGraph({\n          x: dx,\n          y: dy\n        }, {\n          cameraState: state\n        });\n        dx = delta.x - origin.x;\n        dy = delta.y - origin.y;\n        newState.x += dx;\n        newState.y += dy;\n      }\n      return newState;\n    }\n\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      if (!this.settings.renderLabels) return this;\n      var cameraState = this.camera.getState();\n\n      // Selecting labels to draw\n      var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n      (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__.e)(labelsToDisplay, this.nodesWithForcedLabels);\n      this.displayedNodeLabels = new Set();\n\n      // Drawing labels\n      var context = this.canvasContexts.labels;\n      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n        var node = labelsToDisplay[i];\n        var data = this.nodeDataCache[node];\n\n        // If the node was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        // NOTE: we can do better probably\n        if (this.displayedNodeLabels.has(node)) continue;\n\n        // If the node is hidden, we don't need to display its label obviously\n        if (data.hidden) continue;\n        var _this$framedGraphToVi = this.framedGraphToViewport(data),\n          x = _this$framedGraphToVi.x,\n          y = _this$framedGraphToVi.y;\n\n        // NOTE: we can cache the labels we need to render until the camera's ratio changes\n        var size = this.scaleSize(data.size);\n\n        // Is node big enough?\n        if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n        // Is node actually on screen (with some margin)\n        // NOTE: we used to rely on the quadtree for this, but the coordinates\n        // conversion make it unreliable and at that point we already converted\n        // to viewport coordinates and since the label grid already culls the\n        // number of potential labels to display this looks like a good\n        // performance compromise.\n        // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n        // considering cells obviously outside of the range of the current\n        // view rectangle.\n        if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;\n\n        // Because displayed edge labels depend directly on actually rendered node\n        // labels, we need to only add to this.displayedNodeLabels nodes whose label\n        // is rendered.\n        // This makes this.displayedNodeLabels depend on viewport, which might become\n        // an issue once we start memoizing getLabelsToDisplay.\n        this.displayedNodeLabels.add(node);\n        var defaultDrawNodeLabel = this.settings.defaultDrawNodeLabel;\n        var nodeProgram = this.nodePrograms[data.type];\n        var drawLabel = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;\n        drawLabel(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), this.settings);\n      }\n      return this;\n    }\n\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderEdgeLabels\",\n    value: function renderEdgeLabels() {\n      if (!this.settings.renderEdgeLabels) return this;\n      var context = this.canvasContexts.edgeLabels;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n      var edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n        graph: this.graph,\n        hoveredNode: this.hoveredNode,\n        displayedNodeLabels: this.displayedNodeLabels,\n        highlightedNodes: this.highlightedNodes\n      });\n      (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__.e)(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n      var displayedLabels = new Set();\n      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n        var edge = edgeLabelsToDisplay[i],\n          extremities = this.graph.extremities(edge),\n          sourceData = this.nodeDataCache[extremities[0]],\n          targetData = this.nodeDataCache[extremities[1]],\n          edgeData = this.edgeDataCache[edge];\n\n        // If the edge was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        if (displayedLabels.has(edge)) continue;\n\n        // If the edge is hidden we don't need to display its label\n        // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n        if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n          continue;\n        }\n        var defaultDrawEdgeLabel = this.settings.defaultDrawEdgeLabel;\n        var edgeProgram = this.edgePrograms[edgeData.type];\n        var drawLabel = (edgeProgram === null || edgeProgram === void 0 ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;\n        drawLabel(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n          key: edge\n        }, edgeData), {}, {\n          size: this.scaleSize(edgeData.size)\n        }), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n          key: extremities[0]\n        }, sourceData), this.framedGraphToViewport(sourceData)), {}, {\n          size: this.scaleSize(sourceData.size)\n        }), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n          key: extremities[1]\n        }, targetData), this.framedGraphToViewport(targetData)), {}, {\n          size: this.scaleSize(targetData.size)\n        }), this.settings);\n        displayedLabels.add(edge);\n      }\n      this.displayedEdgeLabels = displayedLabels;\n      return this;\n    }\n\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderHighlightedNodes\",\n    value: function renderHighlightedNodes() {\n      var _this7 = this;\n      var context = this.canvasContexts.hovers;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n\n      // Rendering\n      var render = function render(node) {\n        var data = _this7.nodeDataCache[node];\n        var _this7$framedGraphToV = _this7.framedGraphToViewport(data),\n          x = _this7$framedGraphToV.x,\n          y = _this7$framedGraphToV.y;\n        var size = _this7.scaleSize(data.size);\n        var defaultDrawNodeHover = _this7.settings.defaultDrawNodeHover;\n        var nodeProgram = _this7.nodePrograms[data.type];\n        var drawHover = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;\n        drawHover(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), _this7.settings);\n      };\n      var nodesToRender = [];\n      if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n        nodesToRender.push(this.hoveredNode);\n      }\n      this.highlightedNodes.forEach(function (node) {\n        // The hovered node has already been highlighted\n        if (node !== _this7.hoveredNode) nodesToRender.push(node);\n      });\n\n      // Draw labels:\n      nodesToRender.forEach(function (node) {\n        return render(node);\n      });\n\n      // Draw WebGL nodes on top of the labels:\n      var nodesPerPrograms = {};\n\n      // 1. Count nodes per type:\n      nodesToRender.forEach(function (node) {\n        var type = _this7.nodeDataCache[node].type;\n        nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n      });\n      // 2. Allocate for each type for the proper number of nodes\n      for (var type in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // Also reset count, to use when rendering:\n        nodesPerPrograms[type] = 0;\n      }\n      // 3. Process all nodes to render:\n      nodesToRender.forEach(function (node) {\n        var data = _this7.nodeDataCache[node];\n        _this7.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n      });\n      // 4. Clear hovered nodes layer:\n      this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n      // 5. Render:\n      var renderParams = this.getRenderParams();\n      for (var _type6 in this.nodeHoverPrograms) {\n        var program = this.nodeHoverPrograms[_type6];\n        program.render(renderParams);\n      }\n    }\n\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n  }, {\n    key: \"scheduleHighlightedNodesRender\",\n    value: function scheduleHighlightedNodesRender() {\n      var _this8 = this;\n      if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {\n        // Resetting state\n        _this8.renderHighlightedNodesFrame = null;\n\n        // Rendering\n        _this8.renderHighlightedNodes();\n        _this8.renderEdgeLabels();\n      });\n    }\n\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this9 = this;\n      this.emit(\"beforeRender\");\n      var exitRender = function exitRender() {\n        _this9.emit(\"afterRender\");\n        return _this9;\n      };\n\n      // If a render was scheduled, we cancel it\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n\n      // First we need to resize\n      this.resize();\n\n      // Do we need to reprocess data?\n      if (this.needToProcess) this.process();\n      this.needToProcess = false;\n\n      // Clearing the canvases\n      this.clear();\n\n      // Prepare the textures\n      this.pickingLayers.forEach(function (layer) {\n        return _this9.resetWebGLTexture(layer);\n      });\n\n      // If we have no nodes we can stop right there\n      if (!this.graph.order) return exitRender();\n\n      // TODO: improve this heuristic or move to the captor itself?\n      // TODO: deal with the touch captor here as well\n      var mouseCaptor = this.mouseCaptor;\n      var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n\n      // Then we need to extract a matrix from the camera\n      var cameraState = this.camera.getState();\n      var viewportDimensions = this.getDimensions();\n      var graphDimensions = this.getGraphDimensions();\n      var padding = this.getStagePadding();\n      this.matrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(cameraState, viewportDimensions, graphDimensions, padding);\n      this.invMatrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(cameraState, viewportDimensions, graphDimensions, padding, true);\n      this.correctionRatio = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.a)(this.matrix, cameraState, viewportDimensions);\n      this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n      // [jacomyal]\n      // This comment is related to the one above the `getMatrixImpact` definition:\n      // - `this.correctionRatio` is somehow not completely explained\n      // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n      //   graph\n      // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n      // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n      // when I change the graph, the viewport or the camera. It might be useful later, so I prefer to let this comment:\n      // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n      var params = this.getRenderParams();\n\n      // Drawing nodes\n      for (var type in this.nodePrograms) {\n        var program = this.nodePrograms[type];\n        program.render(params);\n      }\n\n      // Drawing edges\n      if (!this.settings.hideEdgesOnMove || !moving) {\n        for (var _type7 in this.edgePrograms) {\n          var _program2 = this.edgePrograms[_type7];\n          _program2.render(params);\n        }\n      }\n\n      // Do not display labels on move per setting\n      if (this.settings.hideLabelsOnMove && moving) return exitRender();\n      this.renderLabels();\n      this.renderEdgeLabels();\n      this.renderHighlightedNodes();\n      return exitRender();\n    }\n\n    /**\n     * Add a node in the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"addNode\",\n    value: function addNode(key) {\n      // Node display data resolution:\n      //  1. First we get the node's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //     Note that this function must return a total object and won't be merged\n      //  3. We apply our defaults, while running some vital checks\n      //  4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getNodeAttributes(key));\n      if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);\n      var data = applyNodeDefaults(this.settings, key, attr);\n      this.nodeDataCache[key] = data;\n\n      // Label:\n      // We delete and add if needed because this function is also used from\n      // update\n      this.nodesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n      // Highlighted:\n      // We remove and re add if needed because this function is also used from\n      // update\n      this.highlightedNodes[\"delete\"](key);\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n      // zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update a node the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(key) {\n      this.addNode(key);\n\n      // Re-apply normalization on the node\n      var data = this.nodeDataCache[key];\n      this.normalizationFunction.applyTo(data);\n    }\n\n    /**\n     * Remove a node from the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(key) {\n      // Remove from node cache\n      delete this.nodeDataCache[key];\n      // Remove from node program index\n      delete this.nodeProgramIndex[key];\n      // Remove from higlighted nodes\n      this.highlightedNodes[\"delete\"](key);\n      // Remove from hovered\n      if (this.hoveredNode === key) this.hoveredNode = null;\n      // Remove from forced label\n      this.nodesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Add an edge into the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(key) {\n      // Edge display data resolution:\n      //  1. First we get the edge's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //  3. Note that this function must return a total object and won't be merged\n      //  4. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getEdgeAttributes(key));\n      if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);\n      var data = applyEdgeDefaults(this.settings, key, attr);\n      this.edgeDataCache[key] = data;\n\n      // Forced label\n      // we filter and re push if needed because this function is also used from\n      // update\n      this.edgesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n      // Check zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update an edge in the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(key) {\n      this.addEdge(key);\n    }\n\n    /**\n     * Remove an edge from the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"removeEdge\",\n    value: function removeEdge(key) {\n      // Remove from edge cache\n      delete this.edgeDataCache[key];\n      // Remove from programId index\n      delete this.edgeProgramIndex[key];\n      // Remove from hovered\n      if (this.hoveredEdge === key) this.hoveredEdge = null;\n      // Remove from forced label\n      this.edgesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Clear all indices related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeIndices\",\n    value: function clearNodeIndices() {\n      // LabelGrid & nodeExtent are only manage/populated in the process function\n      this.labelGrid = new LabelGrid();\n      this.nodeExtent = {\n        x: [0, 1],\n        y: [0, 1]\n      };\n      this.nodeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.nodesWithForcedLabels = new Set();\n      this.nodeZExtent = [Infinity, -Infinity];\n      this.highlightedNodes = new Set();\n    }\n\n    /**\n     * Clear all indices related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeIndices\",\n    value: function clearEdgeIndices() {\n      this.edgeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.edgesWithForcedLabels = new Set();\n      this.edgeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices.\n     * @private\n     */\n  }, {\n    key: \"clearIndices\",\n    value: function clearIndices() {\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n    }\n\n    /**\n     * Clear all graph state related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeState\",\n    value: function clearNodeState() {\n      this.displayedNodeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredNode = null;\n    }\n\n    /**\n     * Clear all graph state related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeState\",\n    value: function clearEdgeState() {\n      this.displayedEdgeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredEdge = null;\n    }\n\n    /**\n     * Clear all graph state.\n     * @private\n     */\n  }, {\n    key: \"clearState\",\n    value: function clearState() {\n      this.clearEdgeState();\n      this.clearNodeState();\n    }\n\n    /**\n     * Add the node data to its program.\n     * @private\n     * @param node The node's graphology ID\n     * @param fingerprint A fingerprint used to identity the node with picking\n     * @param position The index where to place the node in the program\n     */\n  }, {\n    key: \"addNodeToProgram\",\n    value: function addNodeToProgram(node, fingerprint, position) {\n      var data = this.nodeDataCache[node];\n      var nodeProgram = this.nodePrograms[data.type];\n      if (!nodeProgram) throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n      nodeProgram.process(fingerprint, position, data);\n      // Saving program index\n      this.nodeProgramIndex[node] = position;\n    }\n\n    /**\n     * Add the edge data to its program.\n     * @private\n     * @param edge The edge's graphology ID\n     * @param fingerprint A fingerprint used to identity the edge with picking\n     * @param position The index where to place the edge in the program\n     */\n  }, {\n    key: \"addEdgeToProgram\",\n    value: function addEdgeToProgram(edge, fingerprint, position) {\n      var data = this.edgeDataCache[edge];\n      var edgeProgram = this.edgePrograms[data.type];\n      if (!edgeProgram) throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(data.type, \"\\\"!\"));\n      var extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n      // Saving program index\n      this.edgeProgramIndex[edge] = position;\n    }\n\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n\n    /**\n     * Function used to get the render params.\n     *\n     * @return {RenderParams}\n     */\n  }, {\n    key: \"getRenderParams\",\n    value: function getRenderParams() {\n      return {\n        matrix: this.matrix,\n        invMatrix: this.invMatrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        cameraAngle: this.camera.angle,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio,\n        downSizingRatio: this.pickingDownSizingRatio,\n        minEdgeThickness: this.settings.minEdgeThickness,\n        antiAliasingFeather: this.settings.antiAliasingFeather\n      };\n    }\n\n    /**\n     * Function used to retrieve the actual stage padding value.\n     *\n     * @return {number}\n     */\n  }, {\n    key: \"getStagePadding\",\n    value: function getStagePadding() {\n      var _this$settings = this.settings,\n        stagePadding = _this$settings.stagePadding,\n        autoRescale = _this$settings.autoRescale;\n      return autoRescale ? stagePadding || 0 : 0;\n    }\n\n    /**\n     * Function used to create a layer element.\n     *\n     * @param {string} id - Context's id.\n     * @param {string} tag - The HTML tag to use.\n     * @param options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createLayer\",\n    value: function createLayer(id, tag) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (this.elements[id]) throw new Error(\"Sigma: a layer named \\\"\".concat(id, \"\\\" already exists\"));\n      var element = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.b)(tag, {\n        position: \"absolute\"\n      }, {\n        \"class\": \"sigma-\".concat(id)\n      });\n      if (options.style) Object.assign(element.style, options.style);\n      this.elements[id] = element;\n      if (\"beforeLayer\" in options && options.beforeLayer) {\n        this.elements[options.beforeLayer].before(element);\n      } else if (\"afterLayer\" in options && options.afterLayer) {\n        this.elements[options.afterLayer].after(element);\n      } else {\n        this.container.appendChild(element);\n      }\n      return element;\n    }\n\n    /**\n     * Function used to create a canvas element.\n     *\n     * @param {string} id - Context's id.\n     * @param options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvas\",\n    value: function createCanvas(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.createLayer(id, \"canvas\", options);\n    }\n\n    /**\n     * Function used to create a canvas context and add the relevant DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @param  options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvasContext\",\n    value: function createCanvasContext(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var canvas = this.createCanvas(id, options);\n      var contextOptions = {\n        preserveDrawingBuffer: false,\n        antialias: false\n      };\n      this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n      return this;\n    }\n\n    /**\n     * Function used to create a WebGL context and add the relevant DOM\n     * elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {WebGLRenderingContext}\n     */\n  }, {\n    key: \"createWebGLContext\",\n    value: function createWebGLContext(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var canvas = (options === null || options === void 0 ? void 0 : options.canvas) || this.createCanvas(id, options);\n      if (options.hidden) canvas.remove();\n      var contextOptions = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n        preserveDrawingBuffer: false,\n        antialias: false\n      }, options);\n      var context;\n\n      // First we try webgl2 for an easy performance boost\n      context = canvas.getContext(\"webgl2\", contextOptions);\n\n      // Else we fall back to webgl\n      if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n      // Edge, I am looking right at you...\n      if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n      var gl = context;\n      this.webGLContexts[id] = gl;\n\n      // Blending:\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Prepare frame buffer for picking layers:\n      if (options.picking) {\n        this.pickingLayers.add(id);\n        var newFrameBuffer = gl.createFramebuffer();\n        if (!newFrameBuffer) throw new Error(\"Sigma: cannot create a new frame buffer for layer \".concat(id));\n        this.frameBuffers[id] = newFrameBuffer;\n      }\n      return gl;\n    }\n\n    /**\n     * Function used to properly kill a layer.\n     *\n     * @param  {string} id - Layer id.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"killLayer\",\n    value: function killLayer(id) {\n      var element = this.elements[id];\n      if (!element) throw new Error(\"Sigma: cannot kill layer \".concat(id, \", which does not exist\"));\n      if (this.webGLContexts[id]) {\n        var _gl$getExtension;\n        var gl = this.webGLContexts[id];\n        (_gl$getExtension = gl.getExtension(\"WEBGL_lose_context\")) === null || _gl$getExtension === void 0 || _gl$getExtension.loseContext();\n        delete this.webGLContexts[id];\n      } else if (this.canvasContexts[id]) {\n        delete this.canvasContexts[id];\n      }\n\n      // Delete layer element\n      element.remove();\n      delete this.elements[id];\n      return this;\n    }\n\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.camera;\n    }\n\n    /**\n     * Method setting the renderer's camera.\n     *\n     * @param  {Camera} camera - New camera.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCamera\",\n    value: function setCamera(camera) {\n      this.unbindCameraHandlers();\n      this.camera = camera;\n      this.bindCameraHandlers();\n    }\n\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container;\n    }\n\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"getGraph\",\n    value: function getGraph() {\n      return this.graph;\n    }\n\n    /**\n     * Method used to set the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"setGraph\",\n    value: function setGraph(graph) {\n      if (graph === this.graph) return;\n\n      // Check hoveredNode and hoveredEdge\n      if (this.hoveredNode && !graph.hasNode(this.hoveredNode)) this.hoveredNode = null;\n      if (this.hoveredEdge && !graph.hasEdge(this.hoveredEdge)) this.hoveredEdge = null;\n\n      // Unbinding handlers on the current graph\n      this.unbindGraphHandlers();\n      if (this.checkEdgesEventsFrame !== null) {\n        cancelAnimationFrame(this.checkEdgesEventsFrame);\n        this.checkEdgesEventsFrame = null;\n      }\n\n      // Installing new graph\n      this.graph = graph;\n\n      // Binding new handlers\n      this.bindGraphHandlers();\n\n      // Re-rendering now to avoid discrepancies from now to next frame\n      this.refresh();\n    }\n\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n  }, {\n    key: \"getMouseCaptor\",\n    value: function getMouseCaptor() {\n      return this.mouseCaptor;\n    }\n\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n  }, {\n    key: \"getTouchCaptor\",\n    value: function getTouchCaptor() {\n      return this.touchCaptor;\n    }\n\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getGraphDimensions\",\n    value: function getGraphDimensions() {\n      var extent = this.customBBox || this.nodeExtent;\n      return {\n        width: extent.x[1] - extent.x[0] || 1,\n        height: extent.y[1] - extent.y[0] || 1\n      };\n    }\n\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's useful for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n  }, {\n    key: \"getNodeDisplayData\",\n    value: function getNodeDisplayData(key) {\n      var node = this.nodeDataCache[key];\n      return node ? Object.assign({}, node) : undefined;\n    }\n\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's useful for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n  }, {\n    key: \"getEdgeDisplayData\",\n    value: function getEdgeDisplayData(key) {\n      var edge = this.edgeDataCache[key];\n      return edge ? Object.assign({}, edge) : undefined;\n    }\n\n    /**\n     * Method used to get the set of currently displayed node labels.\n     *\n     * @return {Set<string>} A set of node keys whose label is displayed.\n     */\n  }, {\n    key: \"getNodeDisplayedLabels\",\n    value: function getNodeDisplayedLabels() {\n      return new Set(this.displayedNodeLabels);\n    }\n\n    /**\n     * Method used to get the set of currently displayed edge labels.\n     *\n     * @return {Set<string>} A set of edge keys whose label is displayed.\n     */\n  }, {\n    key: \"getEdgeDisplayedLabels\",\n    value: function getEdgeDisplayedLabels() {\n      return new Set(this.displayedEdgeLabels);\n    }\n\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n  }, {\n    key: \"getSettings\",\n    value: function getSettings() {\n      return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);\n    }\n\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n  }, {\n    key: \"getSetting\",\n    value: function getSetting(key) {\n      return this.settings[key];\n    }\n\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSetting\",\n    value: function setSetting(key, value) {\n      var oldValues = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);\n      this.settings[key] = value;\n      (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(this.settings);\n      this.handleSettingsUpdate(oldValues);\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"updateSetting\",\n    value: function updateSetting(key, updater) {\n      this.setSetting(key, updater(this.settings[key]));\n      return this;\n    }\n\n    /**\n     * Method setting multiple settings at once.\n     *\n     * @param  {Partial<Settings>} settings - The settings to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      var oldValues = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);\n      this.settings = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings), settings);\n      (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(this.settings);\n      this.handleSettingsUpdate(oldValues);\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method used to resize the renderer.\n     *\n     * @param  {boolean} force - If true, then resize is processed even if size is unchanged (optional).\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resize\",\n    value: function resize(force) {\n      var previousWidth = this.width,\n        previousHeight = this.height;\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      this.pixelRatio = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.d)();\n      if (this.width === 0) {\n        if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n      if (this.height === 0) {\n        if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n\n      // If nothing has changed, we can stop right here\n      if (!force && previousWidth === this.width && previousHeight === this.height) return this;\n\n      // Sizing dom elements\n      for (var id in this.elements) {\n        var element = this.elements[id];\n        element.style.width = this.width + \"px\";\n        element.style.height = this.height + \"px\";\n      }\n\n      // Sizing canvas contexts\n      for (var _id in this.canvasContexts) {\n        this.elements[_id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        if (this.pixelRatio !== 1) this.canvasContexts[_id].scale(this.pixelRatio, this.pixelRatio);\n      }\n\n      // Sizing WebGL contexts\n      for (var _id2 in this.webGLContexts) {\n        this.elements[_id2].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id2].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        var gl = this.webGLContexts[_id2];\n        gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n        // Clear picking texture if needed\n        if (this.pickingLayers.has(_id2)) {\n          var currentTexture = this.textures[_id2];\n          if (currentTexture) gl.deleteTexture(currentTexture);\n        }\n      }\n      this.emit(\"resize\");\n      return this;\n    }\n\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.emit(\"beforeClear\");\n      this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n      this.emit(\"afterClear\");\n      return this;\n    }\n\n    /**\n     * Method used to refresh, i.e. force the renderer to reprocess graph\n     * data and render, but keep the state.\n     * - if a partialGraph is provided, we only reprocess those nodes & edges.\n     * - if schedule is TRUE, we schedule a render instead of sync render\n     * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh(opts) {\n      var _this10 = this;\n      var skipIndexation = (opts === null || opts === void 0 ? void 0 : opts.skipIndexation) !== undefined ? opts === null || opts === void 0 ? void 0 : opts.skipIndexation : false;\n      var schedule = (opts === null || opts === void 0 ? void 0 : opts.schedule) !== undefined ? opts.schedule : false;\n      var fullRefresh = !opts || !opts.partialGraph;\n      if (fullRefresh) {\n        // Re-index graph data\n        this.clearEdgeIndices();\n        this.clearNodeIndices();\n        this.graph.forEachNode(function (node) {\n          return _this10.addNode(node);\n        });\n        this.graph.forEachEdge(function (edge) {\n          return _this10.addEdge(edge);\n        });\n      } else {\n        var _opts$partialGraph, _opts$partialGraph2;\n        var nodes = ((_opts$partialGraph = opts.partialGraph) === null || _opts$partialGraph === void 0 ? void 0 : _opts$partialGraph.nodes) || [];\n        for (var i = 0, l = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0; i < l; i++) {\n          var node = nodes[i];\n          // Recompute node's data (ie. apply reducer)\n          this.updateNode(node);\n          // Add node to the program if layout is unchanged.\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var programIndex = this.nodeProgramIndex[node];\n            if (programIndex === undefined) throw new Error(\"Sigma: node \\\"\".concat(node, \"\\\" can't be repaint\"));\n            this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n          }\n        }\n        var edges = (opts === null || opts === void 0 || (_opts$partialGraph2 = opts.partialGraph) === null || _opts$partialGraph2 === void 0 ? void 0 : _opts$partialGraph2.edges) || [];\n        for (var _i4 = 0, _l4 = edges.length; _i4 < _l4; _i4++) {\n          var edge = edges[_i4];\n          // Recompute edge's data (ie. apply reducer)\n          this.updateEdge(edge);\n          // Add edge to the program\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var _programIndex = this.edgeProgramIndex[edge];\n            if (_programIndex === undefined) throw new Error(\"Sigma: edge \\\"\".concat(edge, \"\\\" can't be repaint\"));\n            this.addEdgeToProgram(edge, this.edgeIndices[edge], _programIndex);\n          }\n        }\n      }\n\n      // Do we need to call the process function ?\n      if (fullRefresh || !skipIndexation) this.needToProcess = true;\n      if (schedule) this.scheduleRender();else this.render();\n      return this;\n    }\n\n    /**\n     * Method used to schedule a render at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRender\",\n    value: function scheduleRender() {\n      var _this11 = this;\n      if (!this.renderFrame) {\n        this.renderFrame = requestAnimationFrame(function () {\n          _this11.render();\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n     * at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRefresh\",\n    value: function scheduleRefresh(opts) {\n      return this.refresh((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, opts), {}, {\n        schedule: true\n      }));\n    }\n\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n  }, {\n    key: \"getViewportZoomedState\",\n    value: function getViewportZoomedState(viewportTarget, newRatio) {\n      var _this$camera$getState = this.camera.getState(),\n        ratio = _this$camera$getState.ratio,\n        angle = _this$camera$getState.angle,\n        x = _this$camera$getState.x,\n        y = _this$camera$getState.y;\n      var _this$settings2 = this.settings,\n        minCameraRatio = _this$settings2.minCameraRatio,\n        maxCameraRatio = _this$settings2.maxCameraRatio;\n      if (typeof maxCameraRatio === \"number\") newRatio = Math.min(newRatio, maxCameraRatio);\n      if (typeof minCameraRatio === \"number\") newRatio = Math.max(newRatio, minCameraRatio);\n      var ratioDiff = newRatio / ratio;\n      var center = {\n        x: this.width / 2,\n        y: this.height / 2\n      };\n      var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n      var graphCenterPosition = this.viewportToFramedGraph(center);\n      return {\n        angle: angle,\n        x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n        y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n        ratio: newRatio\n      };\n    }\n\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n  }, {\n    key: \"viewRectangle\",\n    value: function viewRectangle() {\n      var p1 = this.viewportToFramedGraph({\n          x: 0,\n          y: 0\n        }),\n        p2 = this.viewportToFramedGraph({\n          x: this.width,\n          y: 0\n        }),\n        h = this.viewportToFramedGraph({\n          x: 0,\n          y: this.height\n        });\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n        height: p2.y - h.y\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"framedGraphToViewport\",\n    value: function framedGraphToViewport(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n      var matrix = override.matrix ? override.matrix : recomputeMatrix ? (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding()) : this.matrix;\n      var viewportPos = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.f)(matrix, coordinates);\n      return {\n        x: (1 + viewportPos.x) * this.width / 2,\n        y: (1 - viewportPos.y) * this.height / 2\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"viewportToFramedGraph\",\n    value: function viewportToFramedGraph(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n      var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding(), true) : this.invMatrix;\n      var res = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.f)(invMatrix, {\n        x: coordinates.x / this.width * 2 - 1,\n        y: 1 - coordinates.y / this.height * 2\n      });\n      if (isNaN(res.x)) res.x = 0;\n      if (isNaN(res.y)) res.y = 0;\n      return res;\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"viewportToGraph\",\n    value: function viewportToGraph(viewportPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"graphToViewport\",\n    value: function graphToViewport(graphPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    }\n\n    /**\n     * Method returning the distance multiplier between the graph system and the\n     * viewport system.\n     */\n  }, {\n    key: \"getGraphToViewportRatio\",\n    value: function getGraphToViewportRatio() {\n      var graphP1 = {\n        x: 0,\n        y: 0\n      };\n      var graphP2 = {\n        x: 1,\n        y: 1\n      };\n      var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n      var viewportP1 = this.graphToViewport(graphP1);\n      var viewportP2 = this.graphToViewport(graphP2);\n      var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n      return viewportD / graphD;\n    }\n\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return this.nodeExtent;\n    }\n\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n  }, {\n    key: \"getCustomBBox\",\n    value: function getCustomBBox() {\n      return this.customBBox;\n    }\n\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCustomBBox\",\n    value: function setCustomBBox(customBBox) {\n      this.customBBox = customBBox;\n      this.scheduleRender();\n      return this;\n    }\n\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      // Emitting \"kill\" events so that plugins and such can cleanup\n      this.emit(\"kill\");\n\n      // Releasing events\n      this.removeAllListeners();\n\n      // Releasing camera handlers\n      this.unbindCameraHandlers();\n\n      // Releasing DOM events & captors\n      window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n      this.mouseCaptor.kill();\n      this.touchCaptor.kill();\n\n      // Releasing graph handlers\n      this.unbindGraphHandlers();\n\n      // Releasing cache & state\n      this.clearIndices();\n      this.clearState();\n      this.nodeDataCache = {};\n      this.edgeDataCache = {};\n      this.highlightedNodes.clear();\n\n      // Clearing frames\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n      if (this.renderHighlightedNodesFrame) {\n        cancelAnimationFrame(this.renderHighlightedNodesFrame);\n        this.renderHighlightedNodesFrame = null;\n      }\n\n      // Destroying canvases\n      var container = this.container;\n      while (container.firstChild) container.removeChild(container.firstChild);\n\n      // Kill programs:\n      for (var type in this.nodePrograms) {\n        this.nodePrograms[type].kill();\n      }\n      for (var _type8 in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[_type8].kill();\n      }\n      for (var _type9 in this.edgePrograms) {\n        this.edgePrograms[_type9].kill();\n      }\n      this.nodePrograms = {};\n      this.nodeHoverPrograms = {};\n      this.edgePrograms = {};\n\n      // Kill all canvas/WebGL contexts\n      for (var id in this.elements) {\n        this.killLayer(id);\n      }\n\n      // Destroying remaining collections\n      this.canvasContexts = {};\n      this.webGLContexts = {};\n      this.elements = {};\n    }\n\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n     * @return {number}              - The scaled size.\n     */\n  }, {\n    key: \"scaleSize\",\n    value: function scaleSize() {\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var cameraRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.camera.ratio;\n      return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1);\n    }\n\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n  }, {\n    key: \"getCanvases\",\n    value: function getCanvases() {\n      var res = {};\n      for (var layer in this.elements) if (this.elements[layer] instanceof HTMLCanvasElement) res[layer] = this.elements[layer];\n      return res;\n    }\n  }]);\n}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);\n\n/**\n * Sigma.js Library Endpoint\n * =========================\n *\n * The library endpoint.\n * @module\n */\nvar Sigma = Sigma$1;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9zaWdtYS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRjtBQUN1RDtBQUN0RTtBQUNxTztBQUM3TDtBQUNtRDtBQUM3RjtBQUNuRDtBQUNtQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBZTtBQUNuQixZQUFZLDREQUFVOztBQUV0QjtBQUNBLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNERBQVM7QUFDWCxTQUFTLDREQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsU0FBUyx5REFBYyxDQUFDLHlEQUFjLEdBQUcsV0FBVyxFQUFFLHlEQUFlLEdBQUcsT0FBTyxrRkFBZ0I7QUFDL0YsQ0FBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFlO0FBQ25CLFlBQVksNERBQVU7O0FBRXRCO0FBQ0EsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxFQUFFLDREQUFTO0FBQ1gsU0FBUyw0REFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0Esb0NBQW9DLDBEQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxH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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLENBQUMsNkVBQWlCOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoeWVvblxcRGVza3RvcFxcZnJvbnRlbmQtaGlkZGVubm9kZVxcbm9kZV9tb2R1bGVzXFxzaWdtYVxcZGlzdFxcc2lnbWEuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF8gYXMgX29iamVjdFNwcmVhZDIsIGEgYXMgX2RlZmluZVByb3BlcnR5IH0gZnJvbSAnLi9pbmRleC0yMzZjNjJhZC5lc20uanMnO1xuaW1wb3J0IHsgXyBhcyBfaW5oZXJpdHMsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgYyBhcyBfY2FsbFN1cGVyLCBkIGFzIF90b1Byb3BlcnR5S2V5IH0gZnJvbSAnLi9pbmhlcml0cy1kMWExZTI5Yi5lc20uanMnO1xuaW1wb3J0IHsgVHlwZWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi90eXBlcy9kaXN0L3NpZ21hLXR5cGVzLmVzbS5qcyc7XG5pbXBvcnQgeyBBIGFzIEFOSU1BVEVfREVGQVVMVFMsIGUgYXMgZWFzaW5ncywgZyBhcyBncmFwaEV4dGVudCwgYyBhcyBjcmVhdGVOb3JtYWxpemF0aW9uRnVuY3Rpb24sIG0gYXMgbWF0cml4RnJvbUNhbWVyYSwgeiBhcyB6SW5kZXhPcmRlcmluZywgYSBhcyBnZXRNYXRyaXhJbXBhY3QsIGIgYXMgY3JlYXRlRWxlbWVudCwgZCBhcyBnZXRQaXhlbFJhdGlvLCBmIGFzIG11bHRpcGx5VmVjMiwgaSBhcyBpZGVudGl0eSwgdiBhcyB2YWxpZGF0ZUdyYXBoIH0gZnJvbSAnLi9ub3JtYWxpemF0aW9uLWJlNDQ1NTE4LmVzbS5qcyc7XG5pbXBvcnQgeyBERUZBVUxUX1NFVFRJTkdTLCB2YWxpZGF0ZVNldHRpbmdzLCByZXNvbHZlU2V0dGluZ3MgfSBmcm9tICcuLi9zZXR0aW5ncy9kaXN0L3NpZ21hLXNldHRpbmdzLmVzbS5qcyc7XG5pbXBvcnQgeyBfIGFzIF9zbGljZWRUb0FycmF5LCBhIGFzIF9hcnJheUxpa2VUb0FycmF5LCBiIGFzIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgZyBhcyBnZXRQaXhlbENvbG9yLCBjIGFzIGNvbG9yVG9JbmRleCB9IGZyb20gJy4vY29sb3JzLWJlYjA2ZWIyLmVzbS5qcyc7XG5pbXBvcnQgeyBfIGFzIF90eXBlb2YsIGUgYXMgZXh0ZW5kIH0gZnJvbSAnLi9kYXRhLTExZGY3MTI0LmVzbS5qcyc7XG5pbXBvcnQgJ2V2ZW50cyc7XG5pbXBvcnQgJ2dyYXBob2xvZ3ktdXRpbHMvaXMtZ3JhcGgnO1xuXG4vKipcbiAqIERlZmF1bHRzLlxuICovXG52YXIgREVGQVVMVF9aT09NSU5HX1JBVElPID0gMS41O1xuXG4vKipcbiAqIEV2ZW50IHR5cGVzLlxuICovXG4vKipcbiAqIENhbWVyYSBjbGFzc1xuICovXG52YXIgQ2FtZXJhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHlwZWRFdmVudEVtaXR0ZXIpIHtcbiAgZnVuY3Rpb24gQ2FtZXJhKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FtZXJhKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgQ2FtZXJhKTtcblxuICAgIC8vIFN0YXRlXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInhcIiwgMC41KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwieVwiLCAwLjUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJhbmdsZVwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmF0aW9cIiwgMSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm1pblJhdGlvXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtYXhSYXRpb1wiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZW5hYmxlZFpvb21pbmdcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVuYWJsZWRQYW5uaW5nXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlbmFibGVkUm90YXRpb25cIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImNsZWFuXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJuZXh0RnJhbWVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInByZXZpb3VzU3RhdGVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVuYWJsZWRcIiwgdHJ1ZSk7XG4gICAgX3RoaXMucHJldmlvdXNTdGF0ZSA9IF90aGlzLmdldFN0YXRlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgdXNlZCB0byBjcmVhdGUgYSBDYW1lcmEgb2JqZWN0IHdpdGggYSBnaXZlbiBzdGF0ZS5cbiAgICovXG4gIF9pbmhlcml0cyhDYW1lcmEsIF9UeXBlZEV2ZW50RW1pdHRlcik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ2FtZXJhLCBbe1xuICAgIGtleTogXCJlbmFibGVcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBlbmFibGUgdGhlIGNhbWVyYS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZGlzYWJsZSB0aGUgY2FtZXJhLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmV0cmlldmUgdGhlIGNhbWVyYSdzIGN1cnJlbnQgc3RhdGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLngsXG4gICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgYW5nbGU6IHRoaXMuYW5nbGUsXG4gICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGNhbWVyYSBoYXMgdGhlIGdpdmVuIHN0YXRlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImhhc1N0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1N0YXRlKHN0YXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy54ID09PSBzdGF0ZS54ICYmIHRoaXMueSA9PT0gc3RhdGUueSAmJiB0aGlzLnJhdGlvID09PSBzdGF0ZS5yYXRpbyAmJiB0aGlzLmFuZ2xlID09PSBzdGF0ZS5hbmdsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZXRyaWV2ZSB0aGUgY2FtZXJhJ3MgcHJldmlvdXMgc3RhdGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHJldmlvdXNTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcmV2aW91c1N0YXRlKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5wcmV2aW91c1N0YXRlO1xuICAgICAgaWYgKCFzdGF0ZSkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBzdGF0ZS54LFxuICAgICAgICB5OiBzdGF0ZS55LFxuICAgICAgICBhbmdsZTogc3RhdGUuYW5nbGUsXG4gICAgICAgIHJhdGlvOiBzdGF0ZS5yYXRpb1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBjaGVjayBtaW5SYXRpbyBhbmQgbWF4UmF0aW8gdmFsdWVzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEJvdW5kZWRSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZGVkUmF0aW8ocmF0aW8pIHtcbiAgICAgIHZhciByID0gcmF0aW87XG4gICAgICBpZiAodHlwZW9mIHRoaXMubWluUmF0aW8gPT09IFwibnVtYmVyXCIpIHIgPSBNYXRoLm1heChyLCB0aGlzLm1pblJhdGlvKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5tYXhSYXRpbyA9PT0gXCJudW1iZXJcIikgciA9IE1hdGgubWluKHIsIHRoaXMubWF4UmF0aW8pO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gY2hlY2sgdmFyaW91cyB0aGluZ3MgdG8gcmV0dXJuIGEgbGVnaXQgc3RhdGUgY2FuZGlkYXRlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVTdGF0ZShzdGF0ZSkge1xuICAgICAgdmFyIHZhbGlkYXRlZFN0YXRlID0ge307XG4gICAgICBpZiAodGhpcy5lbmFibGVkUGFubmluZyAmJiB0eXBlb2Ygc3RhdGUueCA9PT0gXCJudW1iZXJcIikgdmFsaWRhdGVkU3RhdGUueCA9IHN0YXRlLng7XG4gICAgICBpZiAodGhpcy5lbmFibGVkUGFubmluZyAmJiB0eXBlb2Ygc3RhdGUueSA9PT0gXCJudW1iZXJcIikgdmFsaWRhdGVkU3RhdGUueSA9IHN0YXRlLnk7XG4gICAgICBpZiAodGhpcy5lbmFibGVkWm9vbWluZyAmJiB0eXBlb2Ygc3RhdGUucmF0aW8gPT09IFwibnVtYmVyXCIpIHZhbGlkYXRlZFN0YXRlLnJhdGlvID0gdGhpcy5nZXRCb3VuZGVkUmF0aW8oc3RhdGUucmF0aW8pO1xuICAgICAgaWYgKHRoaXMuZW5hYmxlZFJvdGF0aW9uICYmIHR5cGVvZiBzdGF0ZS5hbmdsZSA9PT0gXCJudW1iZXJcIikgdmFsaWRhdGVkU3RhdGUuYW5nbGUgPSBzdGF0ZS5hbmdsZTtcbiAgICAgIHJldHVybiB0aGlzLmNsZWFuID8gdGhpcy5jbGVhbihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5nZXRTdGF0ZSgpKSwgdmFsaWRhdGVkU3RhdGUpKSA6IHZhbGlkYXRlZFN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGNhbWVyYSBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNBbmltYXRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FuaW1hdGVkKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5uZXh0RnJhbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gc2V0IHRoZSBjYW1lcmEncyBzdGF0ZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBLZWVwaW5nIHRyYWNrIG9mIGxhc3Qgc3RhdGVcbiAgICAgIHRoaXMucHJldmlvdXNTdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgIHZhciB2YWxpZFN0YXRlID0gdGhpcy52YWxpZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS54ID09PSBcIm51bWJlclwiKSB0aGlzLnggPSB2YWxpZFN0YXRlLng7XG4gICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUueSA9PT0gXCJudW1iZXJcIikgdGhpcy55ID0gdmFsaWRTdGF0ZS55O1xuICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLnJhdGlvID09PSBcIm51bWJlclwiKSB0aGlzLnJhdGlvID0gdmFsaWRTdGF0ZS5yYXRpbztcbiAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS5hbmdsZSA9PT0gXCJudW1iZXJcIikgdGhpcy5hbmdsZSA9IHZhbGlkU3RhdGUuYW5nbGU7XG5cbiAgICAgIC8vIEVtaXR0aW5nXG4gICAgICBpZiAoIXRoaXMuaGFzU3RhdGUodGhpcy5wcmV2aW91c1N0YXRlKSkgdGhpcy5lbWl0KFwidXBkYXRlZFwiLCB0aGlzLmdldFN0YXRlKCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gdXBkYXRlIHRoZSBjYW1lcmEncyBzdGF0ZSB1c2luZyBhIGZ1bmN0aW9uLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHVwZGF0ZXIpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUodXBkYXRlcih0aGlzLmdldFN0YXRlKCkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGFuaW1hdGUgdGhlIGNhbWVyYS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGUoc3RhdGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5hbmltYXRlKHN0YXRlLCBvcHRzLCByZXNvbHZlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIEFOSU1BVEVfREVGQVVMVFMpLCBvcHRzKTtcbiAgICAgIHZhciB2YWxpZFN0YXRlID0gdGhpcy52YWxpZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICAgIHZhciBlYXNpbmcgPSB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuZWFzaW5nIDogZWFzaW5nc1tvcHRpb25zLmVhc2luZ107XG5cbiAgICAgIC8vIFN0YXRlXG4gICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxuICAgICAgICBpbml0aWFsU3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIEZ1bmN0aW9uIHBlcmZvcm1pbmcgdGhlIGFuaW1hdGlvblxuICAgICAgdmFyIF9mbiA9IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgICB2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gb3B0aW9ucy5kdXJhdGlvbjtcblxuICAgICAgICAvLyBUaGUgYW5pbWF0aW9uIGlzIG92ZXI6XG4gICAgICAgIGlmICh0ID49IDEpIHtcbiAgICAgICAgICBfdGhpczIubmV4dEZyYW1lID0gbnVsbDtcbiAgICAgICAgICBfdGhpczIuc2V0U3RhdGUodmFsaWRTdGF0ZSk7XG4gICAgICAgICAgaWYgKF90aGlzMi5hbmltYXRpb25DYWxsYmFjaykge1xuICAgICAgICAgICAgX3RoaXMyLmFuaW1hdGlvbkNhbGxiYWNrLmNhbGwobnVsbCk7XG4gICAgICAgICAgICBfdGhpczIuYW5pbWF0aW9uQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29lZmZpY2llbnQgPSBlYXNpbmcodCk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUueCA9PT0gXCJudW1iZXJcIikgbmV3U3RhdGUueCA9IGluaXRpYWxTdGF0ZS54ICsgKHZhbGlkU3RhdGUueCAtIGluaXRpYWxTdGF0ZS54KSAqIGNvZWZmaWNpZW50O1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUueSA9PT0gXCJudW1iZXJcIikgbmV3U3RhdGUueSA9IGluaXRpYWxTdGF0ZS55ICsgKHZhbGlkU3RhdGUueSAtIGluaXRpYWxTdGF0ZS55KSAqIGNvZWZmaWNpZW50O1xuICAgICAgICBpZiAoX3RoaXMyLmVuYWJsZWRSb3RhdGlvbiAmJiB0eXBlb2YgdmFsaWRTdGF0ZS5hbmdsZSA9PT0gXCJudW1iZXJcIikgbmV3U3RhdGUuYW5nbGUgPSBpbml0aWFsU3RhdGUuYW5nbGUgKyAodmFsaWRTdGF0ZS5hbmdsZSAtIGluaXRpYWxTdGF0ZS5hbmdsZSkgKiBjb2VmZmljaWVudDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLnJhdGlvID09PSBcIm51bWJlclwiKSBuZXdTdGF0ZS5yYXRpbyA9IGluaXRpYWxTdGF0ZS5yYXRpbyArICh2YWxpZFN0YXRlLnJhdGlvIC0gaW5pdGlhbFN0YXRlLnJhdGlvKSAqIGNvZWZmaWNpZW50O1xuICAgICAgICBfdGhpczIuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICBfdGhpczIubmV4dEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9mbik7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubmV4dEZyYW1lKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubmV4dEZyYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uQ2FsbGJhY2spIHRoaXMuYW5pbWF0aW9uQ2FsbGJhY2suY2FsbChudWxsKTtcbiAgICAgICAgdGhpcy5uZXh0RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX2ZuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9mbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5hbmltYXRpb25DYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHpvb20gdGhlIGNhbWVyYS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlZFpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZWRab29tKGZhY3Rvck9yT3B0aW9ucykge1xuICAgICAgaWYgKCFmYWN0b3JPck9wdGlvbnMpIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICByYXRpbzogdGhpcy5yYXRpbyAvIERFRkFVTFRfWk9PTUlOR19SQVRJT1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGZhY3Rvck9yT3B0aW9ucyA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvIC8gZmFjdG9yT3JPcHRpb25zXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICByYXRpbzogdGhpcy5yYXRpbyAvIChmYWN0b3JPck9wdGlvbnMuZmFjdG9yIHx8IERFRkFVTFRfWk9PTUlOR19SQVRJTylcbiAgICAgIH0sIGZhY3Rvck9yT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gdW56b29tIHRoZSBjYW1lcmEuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZWRVbnpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZWRVbnpvb20oZmFjdG9yT3JPcHRpb25zKSB7XG4gICAgICBpZiAoIWZhY3Rvck9yT3B0aW9ucykgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvICogREVGQVVMVF9aT09NSU5HX1JBVElPXG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgZmFjdG9yT3JPcHRpb25zID09PSBcIm51bWJlclwiKSByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW8gKiBmYWN0b3JPck9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvICogKGZhY3Rvck9yT3B0aW9ucy5mYWN0b3IgfHwgREVGQVVMVF9aT09NSU5HX1JBVElPKVxuICAgICAgfSwgZmFjdG9yT3JPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZXNldCB0aGUgY2FtZXJhLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVkUmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZWRSZXNldChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgeDogMC41LFxuICAgICAgICB5OiAwLjUsXG4gICAgICAgIHJhdGlvOiAxLFxuICAgICAgICBhbmdsZTogMFxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBDYW1lcmEgaW5zdGFuY2UsIHdpdGggdGhlIHNhbWUgc3RhdGUgYXMgdGhlIGN1cnJlbnQgY2FtZXJhLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weSgpIHtcbiAgICAgIHJldHVybiBDYW1lcmEuZnJvbSh0aGlzLmdldFN0YXRlKCkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShzdGF0ZSkge1xuICAgICAgdmFyIGNhbWVyYSA9IG5ldyBDYW1lcmEoKTtcbiAgICAgIHJldHVybiBjYW1lcmEuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH1cbiAgfV0pO1xufShUeXBlZEV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogQ2FwdG9yIHV0aWxzIGZ1bmN0aW9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogRXh0cmFjdCB0aGUgbG9jYWwgWCBhbmQgWSBjb29yZGluYXRlcyBmcm9tIGEgbW91c2UgZXZlbnQgb3IgdG91Y2ggb2JqZWN0LiBJZlxuICogYSBET00gZWxlbWVudCBpcyBnaXZlbiwgaXQgdXNlcyB0aGlzIGVsZW1lbnQncyBvZmZzZXQgdG8gY29tcHV0ZSB0aGUgcG9zaXRpb25cbiAqICh0aGlzIGFsbG93cyB1c2luZyBldmVudHMgdGhhdCBhcmUgbm90IGJvdW5kIHRvIHRoZSBjb250YWluZXIgaXRzZWxmIGFuZFxuICogc3RpbGwgaGF2ZSBhIHByb3BlciBwb3NpdGlvbikuXG4gKlxuICogQHBhcmFtICB7ZXZlbnR9ICAgICAgIGUgLSBBIG1vdXNlIGV2ZW50IG9yIHRvdWNoIG9iamVjdC5cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBkb20gLSBBIERPTSBlbGVtZW50IHRvIGNvbXB1dGUgb2Zmc2V0IHJlbGF0aXZlbHkgdG8uXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgVGhlIGxvY2FsIFkgdmFsdWUgb2YgdGhlIG1vdXNlLlxuICovXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihlLCBkb20pIHtcbiAgdmFyIGJib3ggPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeDogZS5jbGllbnRYIC0gYmJveC5sZWZ0LFxuICAgIHk6IGUuY2xpZW50WSAtIGJib3gudG9wXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydCBtb3VzZSBjb29yZHMgdG8gc2lnbWEgY29vcmRzLlxuICpcbiAqIEBwYXJhbSAge2V2ZW50fSAgICAgICBlICAgLSBBIG1vdXNlIGV2ZW50IG9yIHRvdWNoIG9iamVjdC5cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBkb20gLSBBIERPTSBlbGVtZW50IHRvIGNvbXB1dGUgb2Zmc2V0IHJlbGF0aXZlbHkgdG8uXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vdXNlQ29vcmRzKGUsIGRvbSkge1xuICB2YXIgcmVzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGdldFBvc2l0aW9uKGUsIGRvbSkpLCB7fSwge1xuICAgIHNpZ21hRGVmYXVsdFByZXZlbnRlZDogZmFsc2UsXG4gICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gcHJldmVudFNpZ21hRGVmYXVsdCgpIHtcbiAgICAgIHJlcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgb3JpZ2luYWw6IGVcbiAgfSk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogVGFrZXMgYSB0b3VjaCBjb29yZHMgb3IgYSBtb3VzZSBjb29yZHMsIGFuZCBhbHdheXMgcmV0dXJucyBhIGNsZWFuIG1vdXNlIGNvb3JkcyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsZWFuTW91c2VDb29yZHMoZSkge1xuICB2YXIgcmVzID0gXCJ4XCIgaW4gZSA/IGUgOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZS50b3VjaGVzWzBdIHx8IGUucHJldmlvdXNUb3VjaGVzWzBdKSwge30sIHtcbiAgICBvcmlnaW5hbDogZS5vcmlnaW5hbCxcbiAgICBzaWdtYURlZmF1bHRQcmV2ZW50ZWQ6IGUuc2lnbWFEZWZhdWx0UHJldmVudGVkLFxuICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICBlLnNpZ21hRGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICByZXMuc2lnbWFEZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIENvbnZlcnQgbW91c2Ugd2hlZWwgZXZlbnQgY29vcmRzIHRvIHNpZ21hIGNvb3Jkcy5cbiAqXG4gKiBAcGFyYW0gIHtldmVudH0gICAgICAgZSAgIC0gQSB3aGVlbCBtb3VzZSBldmVudC5cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBkb20gLSBBIERPTSBlbGVtZW50IHRvIGNvbXB1dGUgb2Zmc2V0IHJlbGF0aXZlbHkgdG8uXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFdoZWVsQ29vcmRzKGUsIGRvbSkge1xuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGdldE1vdXNlQ29vcmRzKGUsIGRvbSkpLCB7fSwge1xuICAgIGRlbHRhOiBnZXRXaGVlbERlbHRhKGUpXG4gIH0pO1xufVxudmFyIE1BWF9UT1VDSEVTID0gMjtcbmZ1bmN0aW9uIGdldFRvdWNoZXNBcnJheSh0b3VjaGVzKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBNYXRoLm1pbih0b3VjaGVzLmxlbmd0aCwgTUFYX1RPVUNIRVMpOyBpIDwgbDsgaSsrKSBhcnIucHVzaCh0b3VjaGVzW2ldKTtcbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRvdWNoIGNvb3JkcyB0byBzaWdtYSBjb29yZHMuXG4gKlxuICogQHBhcmFtICB7ZXZlbnR9ICAgICAgIGUgICAgICAgICAgICAgICAtIEEgdG91Y2ggZXZlbnQuXG4gKiBAcGFyYW0gIHtUb3VjaFtdfSAgICAgcHJldmlvdXNUb3VjaGVzIC0gQW4gYXJyYXkgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHRvdWNoZXMuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZG9tICAgICAgICAgICAgIC0gQSBET00gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldCByZWxhdGl2ZWx5IHRvLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaENvb3JkcyhlLCBwcmV2aW91c1RvdWNoZXMsIGRvbSkge1xuICB2YXIgcmVzID0ge1xuICAgIHRvdWNoZXM6IGdldFRvdWNoZXNBcnJheShlLnRvdWNoZXMpLm1hcChmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbih0b3VjaCwgZG9tKTtcbiAgICB9KSxcbiAgICBwcmV2aW91c1RvdWNoZXM6IHByZXZpb3VzVG91Y2hlcy5tYXAoZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICByZXR1cm4gZ2V0UG9zaXRpb24odG91Y2gsIGRvbSk7XG4gICAgfSksXG4gICAgc2lnbWFEZWZhdWx0UHJldmVudGVkOiBmYWxzZSxcbiAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgcmVzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfSxcbiAgICBvcmlnaW5hbDogZVxuICB9O1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIHdoZWVsIGRlbHRhIGZyb20gYSBtb3VzZSBldmVudCBvciB0b3VjaCBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7ZXZlbnR9ICBlIC0gQSBtb3VzZSBldmVudCBvciB0b3VjaCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICBUaGUgd2hlZWwgZGVsdGEgb2YgdGhlIG1vdXNlLlxuICovXG5mdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcbiAgLy8gVE9ETzogY2hlY2sgdGhvc2UgcmF0aW9zIGFnYWluIHRvIGVuc3VyZSBhIGNsZWFuIENocm9tZS9GaXJlZm94IGNvbXBhdFxuICBpZiAodHlwZW9mIGUuZGVsdGFZICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZS5kZWx0YVkgKiAtMyAvIDM2MDtcbiAgaWYgKHR5cGVvZiBlLmRldGFpbCAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGUuZGV0YWlsIC8gLTk7XG4gIHRocm93IG5ldyBFcnJvcihcIkNhcHRvcjogY291bGQgbm90IGV4dHJhY3QgZGVsdGEgZnJvbSBldmVudC5cIik7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgcmVwcmVzZW50aW5nIGEgY2FwdG9yIGxpa2UgdGhlIHVzZXIncyBtb3VzZSBvciB0b3VjaCBjb250cm9scy5cbiAqL1xudmFyIENhcHRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1R5cGVkRXZlbnRFbWl0dGVyKSB7XG4gIGZ1bmN0aW9uIENhcHRvcihjb250YWluZXIsIHJlbmRlcmVyKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXB0b3IpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBDYXB0b3IpO1xuICAgIC8vIFByb3BlcnRpZXNcbiAgICBfdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgX3RoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKENhcHRvciwgX1R5cGVkRXZlbnRFbWl0dGVyKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDYXB0b3IpO1xufShUeXBlZEV2ZW50RW1pdHRlcik7XG5cbnZhciBNT1VTRV9TRVRUSU5HU19LRVlTID0gW1wiZG91YmxlQ2xpY2tUaW1lb3V0XCIsIFwiZG91YmxlQ2xpY2tab29taW5nRHVyYXRpb25cIiwgXCJkb3VibGVDbGlja1pvb21pbmdSYXRpb1wiLCBcImRyYWdUaW1lb3V0XCIsIFwiZHJhZ2dlZEV2ZW50c1RvbGVyYW5jZVwiLCBcImluZXJ0aWFEdXJhdGlvblwiLCBcImluZXJ0aWFSYXRpb1wiLCBcInpvb21EdXJhdGlvblwiLCBcInpvb21pbmdSYXRpb1wiXTtcbnZhciBERUZBVUxUX01PVVNFX1NFVFRJTkdTID0gTU9VU0VfU0VUVElOR1NfS0VZUy5yZWR1Y2UoZnVuY3Rpb24gKGl0ZXIsIGtleSkge1xuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGl0ZXIpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIERFRkFVTFRfU0VUVElOR1Nba2V5XSkpO1xufSwge30pO1xuXG4vKipcbiAqIEV2ZW50IHR5cGVzLlxuICovXG4vKipcbiAqIE1vdXNlIGNhcHRvciBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1vdXNlQ2FwdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2FwdG9yKSB7XG4gIGZ1bmN0aW9uIE1vdXNlQ2FwdG9yKGNvbnRhaW5lciwgcmVuZGVyZXIpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vdXNlQ2FwdG9yKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgTW91c2VDYXB0b3IsIFtjb250YWluZXIsIHJlbmRlcmVyXSk7XG5cbiAgICAvLyBCaW5kaW5nIG1ldGhvZHNcbiAgICAvLyBTdGF0ZVxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlbmFibGVkXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJkcmFnZ2VkRXZlbnRzXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJkb3duU3RhcnRUaW1lXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJsYXN0TW91c2VYXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJsYXN0TW91c2VZXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpc01vdXNlRG93blwiLCBmYWxzZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImlzTW92aW5nXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibW92aW5nVGltZW91dFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic3RhcnRDYW1lcmFTdGF0ZVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY2xpY2tzXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJkb3VibGVDbGlja1RpbWVvdXRcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImN1cnJlbnRXaGVlbERpcmVjdGlvblwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic2V0dGluZ3NcIiwgREVGQVVMVF9NT1VTRV9TRVRUSU5HUyk7XG4gICAgX3RoaXMuaGFuZGxlQ2xpY2sgPSBfdGhpcy5oYW5kbGVDbGljay5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVSaWdodENsaWNrID0gX3RoaXMuaGFuZGxlUmlnaHRDbGljay5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVEb3duID0gX3RoaXMuaGFuZGxlRG93bi5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVVcCA9IF90aGlzLmhhbmRsZVVwLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZU1vdmUgPSBfdGhpcy5oYW5kbGVNb3ZlLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZVdoZWVsID0gX3RoaXMuaGFuZGxlV2hlZWwuYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlTGVhdmUgPSBfdGhpcy5oYW5kbGVMZWF2ZS5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVFbnRlciA9IF90aGlzLmhhbmRsZUVudGVyLmJpbmQoX3RoaXMpO1xuXG4gICAgLy8gQmluZGluZyBldmVudHNcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF90aGlzLmhhbmRsZUNsaWNrLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX3RoaXMuaGFuZGxlUmlnaHRDbGljaywge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfdGhpcy5oYW5kbGVEb3duLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgX3RoaXMuaGFuZGxlV2hlZWwsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIF90aGlzLmhhbmRsZUxlYXZlLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCBfdGhpcy5oYW5kbGVFbnRlciwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIF90aGlzLmhhbmRsZU1vdmUsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgX3RoaXMuaGFuZGxlVXAsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhNb3VzZUNhcHRvciwgX0NhcHRvcik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTW91c2VDYXB0b3IsIFt7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIHRoaXMuaGFuZGxlUmlnaHRDbGljayk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLmhhbmRsZURvd24pO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLmhhbmRsZVdoZWVsKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLmhhbmRsZUxlYXZlKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCB0aGlzLmhhbmRsZUVudGVyKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVNb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuaGFuZGxlVXApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgICB0aGlzLmNsaWNrcysrO1xuICAgICAgaWYgKHRoaXMuY2xpY2tzID09PSAyKSB7XG4gICAgICAgIHRoaXMuY2xpY2tzID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRvdWJsZUNsaWNrVGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRvdWJsZUNsaWNrVGltZW91dCk7XG4gICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZURvdWJsZUNsaWNrKGUpO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5jbGlja3MgPSAwO1xuICAgICAgICBfdGhpczIuZG91YmxlQ2xpY2tUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH0sIHRoaXMuc2V0dGluZ3MuZG91YmxlQ2xpY2tUaW1lb3V0KTtcblxuICAgICAgLy8gTk9URTogdGhpcyBpcyBoZXJlIHRvIHByZXZlbnQgY2xpY2sgZXZlbnRzIG9uIGRyYWdcbiAgICAgIGlmICh0aGlzLmRyYWdnZWRFdmVudHMgPCB0aGlzLnNldHRpbmdzLmRyYWdnZWRFdmVudHNUb2xlcmFuY2UpIHRoaXMuZW1pdChcImNsaWNrXCIsIGdldE1vdXNlQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVJpZ2h0Q2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUmlnaHRDbGljayhlKSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5lbWl0KFwicmlnaHRDbGlja1wiLCBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVEb3VibGVDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayhlKSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHZhciBtb3VzZUNvb3JkcyA9IGdldE1vdXNlQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuZW1pdChcImRvdWJsZUNsaWNrXCIsIG1vdXNlQ29vcmRzKTtcbiAgICAgIGlmIChtb3VzZUNvb3Jkcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgLy8gZGVmYXVsdCBiZWhhdmlvclxuICAgICAgdmFyIGNhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICB2YXIgbmV3UmF0aW8gPSBjYW1lcmEuZ2V0Qm91bmRlZFJhdGlvKGNhbWVyYS5nZXRTdGF0ZSgpLnJhdGlvIC8gdGhpcy5zZXR0aW5ncy5kb3VibGVDbGlja1pvb21pbmdSYXRpbyk7XG4gICAgICBjYW1lcmEuYW5pbWF0ZSh0aGlzLnJlbmRlcmVyLmdldFZpZXdwb3J0Wm9vbWVkU3RhdGUoZ2V0UG9zaXRpb24oZSwgdGhpcy5jb250YWluZXIpLCBuZXdSYXRpbyksIHtcbiAgICAgICAgZWFzaW5nOiBcInF1YWRyYXRpY0luT3V0XCIsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLnNldHRpbmdzLmRvdWJsZUNsaWNrWm9vbWluZ0R1cmF0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEb3duKGUpIHtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG5cbiAgICAgIC8vIFdlIG9ubHkgc3RhcnQgZHJhZ2dpbmcgb24gbGVmdCBidXR0b25cbiAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YXJ0Q2FtZXJhU3RhdGUgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpLmdldFN0YXRlKCk7XG4gICAgICAgIHZhciBfZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihlLCB0aGlzLmNvbnRhaW5lciksXG4gICAgICAgICAgeCA9IF9nZXRQb3NpdGlvbi54LFxuICAgICAgICAgIHkgPSBfZ2V0UG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5sYXN0TW91c2VYID0geDtcbiAgICAgICAgdGhpcy5sYXN0TW91c2VZID0geTtcbiAgICAgICAgdGhpcy5kcmFnZ2VkRXZlbnRzID0gMDtcbiAgICAgICAgdGhpcy5kb3duU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5pc01vdXNlRG93biA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJtb3VzZWRvd25cIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlVXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVXAoZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5pc01vdXNlRG93bikgcmV0dXJuO1xuICAgICAgdmFyIGNhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICB0aGlzLmlzTW91c2VEb3duID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIHRoaXMubW92aW5nVGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tb3ZpbmdUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5tb3ZpbmdUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBfZ2V0UG9zaXRpb24yID0gZ2V0UG9zaXRpb24oZSwgdGhpcy5jb250YWluZXIpLFxuICAgICAgICB4ID0gX2dldFBvc2l0aW9uMi54LFxuICAgICAgICB5ID0gX2dldFBvc2l0aW9uMi55O1xuICAgICAgdmFyIGNhbWVyYVN0YXRlID0gY2FtZXJhLmdldFN0YXRlKCksXG4gICAgICAgIHByZXZpb3VzQ2FtZXJhU3RhdGUgPSBjYW1lcmEuZ2V0UHJldmlvdXNTdGF0ZSgpIHx8IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmlzTW92aW5nKSB7XG4gICAgICAgIGNhbWVyYS5hbmltYXRlKHtcbiAgICAgICAgICB4OiBjYW1lcmFTdGF0ZS54ICsgdGhpcy5zZXR0aW5ncy5pbmVydGlhUmF0aW8gKiAoY2FtZXJhU3RhdGUueCAtIHByZXZpb3VzQ2FtZXJhU3RhdGUueCksXG4gICAgICAgICAgeTogY2FtZXJhU3RhdGUueSArIHRoaXMuc2V0dGluZ3MuaW5lcnRpYVJhdGlvICogKGNhbWVyYVN0YXRlLnkgLSBwcmV2aW91c0NhbWVyYVN0YXRlLnkpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5zZXR0aW5ncy5pbmVydGlhRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBcInF1YWRyYXRpY091dFwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxhc3RNb3VzZVggIT09IHggfHwgdGhpcy5sYXN0TW91c2VZICE9PSB5KSB7XG4gICAgICAgIGNhbWVyYS5zZXRTdGF0ZSh7XG4gICAgICAgICAgeDogY2FtZXJhU3RhdGUueCxcbiAgICAgICAgICB5OiBjYW1lcmFTdGF0ZS55XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaG91bGRSZWZyZXNoID0gX3RoaXMzLmRyYWdnZWRFdmVudHMgPiAwO1xuICAgICAgICBfdGhpczMuZHJhZ2dlZEV2ZW50cyA9IDA7XG5cbiAgICAgICAgLy8gTk9URTogdGhpcyByZWZyZXNoIGlzIGhlcmUgdG8gbWFrZSBzdXJlIGBoaWRlRWRnZXNPbk1vdmVgIGNhbiB3b3JrXG4gICAgICAgIC8vIHdoZW4gc29tZW9uZSByZWxlYXNlcyBjYW1lcmEgcGFuIGRyYWcgYWZ0ZXIgaGF2aW5nIHN0b3BwZWQgbW92aW5nLlxuICAgICAgICAvLyBTZWUgY29tbWl0OiBodHRwczovL2dpdGh1Yi5jb20vamFjb215YWwvc2lnbWEuanMvY29tbWl0L2NmZDkxOTdmNzAzMTkxMDlkYjZiNjc1ZGQ3YzgyYmU0OTNjYTk1YTJcbiAgICAgICAgLy8gU2VlIGFsc28gaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYWNvbXlhbC9zaWdtYS5qcy9pc3N1ZXMvMTI5MFxuICAgICAgICAvLyBJdCBjb3VsZCBiZSBwb3NzaWJsZSB0byByZW5kZXIgaW5zdGVhZCBvZiBzY2hlZHVsaW5nIGEgcmVmcmVzaCBidXQgZm9yXG4gICAgICAgIC8vIG5vdyBpdCBzZWVtcyBnb29kIGVub3VnaC5cbiAgICAgICAgaWYgKHNob3VsZFJlZnJlc2ggJiYgX3RoaXMzLnJlbmRlcmVyLmdldFNldHRpbmcoXCJoaWRlRWRnZXNPbk1vdmVcIikpIF90aGlzMy5yZW5kZXJlci5yZWZyZXNoKCk7XG4gICAgICB9LCAwKTtcbiAgICAgIHRoaXMuZW1pdChcIm1vdXNldXBcIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3ZlKGUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHZhciBtb3VzZUNvb3JkcyA9IGdldE1vdXNlQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKTtcblxuICAgICAgLy8gQWx3YXlzIHRyaWdnZXIgYSBcIm1vdXNlbW92ZWJvZHlcIiBldmVudCwgc28gdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBkZXZlbG9wXG4gICAgICAvLyBhIGRyYWctYW5kLWRyb3AgZWZmZWN0IHRoYXQgd29ya3MgZXZlbiB3aGVuIHRoZSBtb3VzZSBpcyBvdXQgb2YgdGhlXG4gICAgICAvLyBjb250YWluZXI6XG4gICAgICB0aGlzLmVtaXQoXCJtb3VzZW1vdmVib2R5XCIsIG1vdXNlQ29vcmRzKTtcblxuICAgICAgLy8gT25seSB0cmlnZ2VyIHRoZSBcIm1vdXNlbW92ZVwiIGV2ZW50IHdoZW4gdGhlIG1vdXNlIGlzIGFjdHVhbGx5IGhvdmVyaW5nXG4gICAgICAvLyB0aGUgY29udGFpbmVyLCB0byBhdm9pZCB3ZWlyZGx5IGhvdmVyaW5nIG5vZGVzIGFuZC9vciBlZGdlcyB3aGVuIHRoZVxuICAgICAgLy8gbW91c2UgaXMgbm90IGhvdmVyIHRoZSBjb250YWluZXI6XG4gICAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuY29udGFpbmVyIHx8IGUuY29tcG9zZWRQYXRoKClbMF0gPT09IHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm1vdXNlbW92ZVwiLCBtb3VzZUNvb3Jkcyk7XG4gICAgICB9XG4gICAgICBpZiAobW91c2VDb29yZHMuc2lnbWFEZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVuIFwiaXNNb3VzZURvd25cIiBhbGwgdGhlIHRpbWUsIHRvIGFsbG93IGRyYWdnaW5nIHRoZVxuICAgICAgLy8gc3RhZ2Ugd2hpbGUgdGhlIG1vdXNlIGlzIG5vdCBob3ZlciB0aGUgY29udGFpbmVyOlxuICAgICAgaWYgKHRoaXMuaXNNb3VzZURvd24pIHtcbiAgICAgICAgdGhpcy5pc01vdmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZHJhZ2dlZEV2ZW50cysrO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubW92aW5nVGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdmluZ1RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92aW5nVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQubW92aW5nVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgX3RoaXM0LmlzTW92aW5nID0gZmFsc2U7XG4gICAgICAgIH0sIHRoaXMuc2V0dGluZ3MuZHJhZ1RpbWVvdXQpO1xuICAgICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgICAgdmFyIF9nZXRQb3NpdGlvbjMgPSBnZXRQb3NpdGlvbihlLCB0aGlzLmNvbnRhaW5lciksXG4gICAgICAgICAgZVggPSBfZ2V0UG9zaXRpb24zLngsXG4gICAgICAgICAgZVkgPSBfZ2V0UG9zaXRpb24zLnk7XG4gICAgICAgIHZhciBsYXN0TW91c2UgPSB0aGlzLnJlbmRlcmVyLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogdGhpcy5sYXN0TW91c2VYLFxuICAgICAgICAgIHk6IHRoaXMubGFzdE1vdXNlWVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1vdXNlID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgoe1xuICAgICAgICAgIHg6IGVYLFxuICAgICAgICAgIHk6IGVZXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IGxhc3RNb3VzZS54IC0gbW91c2UueCxcbiAgICAgICAgICBvZmZzZXRZID0gbGFzdE1vdXNlLnkgLSBtb3VzZS55O1xuICAgICAgICB2YXIgY2FtZXJhU3RhdGUgPSBjYW1lcmEuZ2V0U3RhdGUoKTtcbiAgICAgICAgdmFyIHggPSBjYW1lcmFTdGF0ZS54ICsgb2Zmc2V0WCxcbiAgICAgICAgICB5ID0gY2FtZXJhU3RhdGUueSArIG9mZnNldFk7XG4gICAgICAgIGNhbWVyYS5zZXRTdGF0ZSh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxhc3RNb3VzZVggPSBlWDtcbiAgICAgICAgdGhpcy5sYXN0TW91c2VZID0gZVk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTGVhdmUoZSkge1xuICAgICAgdGhpcy5lbWl0KFwibW91c2VsZWF2ZVwiLCBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVFbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVFbnRlcihlKSB7XG4gICAgICB0aGlzLmVtaXQoXCJtb3VzZWVudGVyXCIsIGdldE1vdXNlQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVdoZWVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVdoZWVsKGUpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgdmFyIGNhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhY2FtZXJhLmVuYWJsZWRab29taW5nKSByZXR1cm47XG4gICAgICB2YXIgZGVsdGEgPSBnZXRXaGVlbERlbHRhKGUpO1xuICAgICAgaWYgKCFkZWx0YSkgcmV0dXJuO1xuICAgICAgdmFyIHdoZWVsQ29vcmRzID0gZ2V0V2hlZWxDb29yZHMoZSwgdGhpcy5jb250YWluZXIpO1xuICAgICAgdGhpcy5lbWl0KFwid2hlZWxcIiwgd2hlZWxDb29yZHMpO1xuICAgICAgaWYgKHdoZWVsQ29vcmRzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRGVmYXVsdCBiZWhhdmlvclxuICAgICAgdmFyIGN1cnJlbnRSYXRpbyA9IGNhbWVyYS5nZXRTdGF0ZSgpLnJhdGlvO1xuICAgICAgdmFyIHJhdGlvRGlmZiA9IGRlbHRhID4gMCA/IDEgLyB0aGlzLnNldHRpbmdzLnpvb21pbmdSYXRpbyA6IHRoaXMuc2V0dGluZ3Muem9vbWluZ1JhdGlvO1xuICAgICAgdmFyIG5ld1JhdGlvID0gY2FtZXJhLmdldEJvdW5kZWRSYXRpbyhjdXJyZW50UmF0aW8gKiByYXRpb0RpZmYpO1xuICAgICAgdmFyIHdoZWVsRGlyZWN0aW9uID0gZGVsdGEgPiAwID8gMSA6IC0xO1xuICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgd2l0aG91dCBwcmV2ZW50aW5nIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiByYXRpbyBkb2Vzbid0IGNoYW5nZTpcbiAgICAgIGlmIChjdXJyZW50UmF0aW8gPT09IG5ld1JhdGlvKSByZXR1cm47XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAvLyBDYW5jZWwgZXZlbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSBlYWNoIG90aGVyIGFuZCBpbiB0aGUgc2FtZSBkaXJlY3Rpb246XG4gICAgICBpZiAodGhpcy5jdXJyZW50V2hlZWxEaXJlY3Rpb24gPT09IHdoZWVsRGlyZWN0aW9uICYmIHRoaXMubGFzdFdoZWVsVHJpZ2dlclRpbWUgJiYgbm93IC0gdGhpcy5sYXN0V2hlZWxUcmlnZ2VyVGltZSA8IHRoaXMuc2V0dGluZ3Muem9vbUR1cmF0aW9uIC8gNSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYW1lcmEuYW5pbWF0ZSh0aGlzLnJlbmRlcmVyLmdldFZpZXdwb3J0Wm9vbWVkU3RhdGUoZ2V0UG9zaXRpb24oZSwgdGhpcy5jb250YWluZXIpLCBuZXdSYXRpbyksIHtcbiAgICAgICAgZWFzaW5nOiBcInF1YWRyYXRpY091dFwiLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5zZXR0aW5ncy56b29tRHVyYXRpb25cbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM1LmN1cnJlbnRXaGVlbERpcmVjdGlvbiA9IDA7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY3VycmVudFdoZWVsRGlyZWN0aW9uID0gd2hlZWxEaXJlY3Rpb247XG4gICAgICB0aGlzLmxhc3RXaGVlbFRyaWdnZXJUaW1lID0gbm93O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIH1cbiAgfV0pO1xufShDYXB0b3IpO1xuXG52YXIgVE9VQ0hfU0VUVElOR1NfS0VZUyA9IFtcImRyYWdUaW1lb3V0XCIsIFwiaW5lcnRpYUR1cmF0aW9uXCIsIFwiaW5lcnRpYVJhdGlvXCIsIFwiZG91YmxlQ2xpY2tUaW1lb3V0XCIsIFwiZG91YmxlQ2xpY2tab29taW5nUmF0aW9cIiwgXCJkb3VibGVDbGlja1pvb21pbmdEdXJhdGlvblwiLCBcInRhcE1vdmVUb2xlcmFuY2VcIl07XG52YXIgREVGQVVMVF9UT1VDSF9TRVRUSU5HUyA9IFRPVUNIX1NFVFRJTkdTX0tFWVMucmVkdWNlKGZ1bmN0aW9uIChpdGVyLCBrZXkpIHtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBpdGVyKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBERUZBVUxUX1NFVFRJTkdTW2tleV0pKTtcbn0sIHt9KTtcblxuLyoqXG4gKiBFdmVudCB0eXBlcy5cbiAqL1xuLyoqXG4gKiBUb3VjaCBjYXB0b3IgY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBUb3VjaENhcHRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NhcHRvcikge1xuICBmdW5jdGlvbiBUb3VjaENhcHRvcihjb250YWluZXIsIHJlbmRlcmVyKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb3VjaENhcHRvcik7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFRvdWNoQ2FwdG9yLCBbY29udGFpbmVyLCByZW5kZXJlcl0pO1xuXG4gICAgLy8gQmluZGluZyBtZXRob2RzOlxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlbmFibGVkXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpc01vdmluZ1wiLCBmYWxzZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhc01vdmVkXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwidG91Y2hNb2RlXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzdGFydFRvdWNoZXNQb3NpdGlvbnNcIiwgW10pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJsYXN0VG91Y2hlc1wiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImxhc3RUYXBcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInNldHRpbmdzXCIsIERFRkFVTFRfVE9VQ0hfU0VUVElOR1MpO1xuICAgIF90aGlzLmhhbmRsZVN0YXJ0ID0gX3RoaXMuaGFuZGxlU3RhcnQuYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlTGVhdmUgPSBfdGhpcy5oYW5kbGVMZWF2ZS5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVNb3ZlID0gX3RoaXMuaGFuZGxlTW92ZS5iaW5kKF90aGlzKTtcblxuICAgIC8vIEJpbmRpbmcgZXZlbnRzXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLmhhbmRsZVN0YXJ0LCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgX3RoaXMuaGFuZGxlTGVhdmUsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90aGlzLmhhbmRsZUxlYXZlLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBfdGhpcy5oYW5kbGVNb3ZlLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhUb3VjaENhcHRvciwgX0NhcHRvcik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVG91Y2hDYXB0b3IsIFt7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLmhhbmRsZVN0YXJ0KTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdGhpcy5oYW5kbGVMZWF2ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5oYW5kbGVMZWF2ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuaGFuZGxlTW92ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGltZW5zaW9ucygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVN0YXJ0KGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlc0FycmF5KGUudG91Y2hlcyk7XG4gICAgICB0aGlzLnRvdWNoTW9kZSA9IHRvdWNoZXMubGVuZ3RoO1xuICAgICAgdGhpcy5zdGFydENhbWVyYVN0YXRlID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKS5nZXRTdGF0ZSgpO1xuICAgICAgdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMgPSB0b3VjaGVzLm1hcChmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvc2l0aW9uKHRvdWNoLCBfdGhpczIuY29udGFpbmVyKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBXaGVuIHRoZXJlIGFyZSB0d28gdG91Y2hlcyBkb3duLCBsZXQncyByZWNvcmQgZGlzdGFuY2UgYW5kIGFuZ2xlIGFzIHdlbGw6XG4gICAgICBpZiAodGhpcy50b3VjaE1vZGUgPT09IDIpIHtcbiAgICAgICAgdmFyIF90aGlzJHN0YXJ0VG91Y2hlc1BvcyA9IF9zbGljZWRUb0FycmF5KHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zLCAyKSxcbiAgICAgICAgICBfdGhpcyRzdGFydFRvdWNoZXNQb3MyID0gX3RoaXMkc3RhcnRUb3VjaGVzUG9zWzBdLFxuICAgICAgICAgIHgwID0gX3RoaXMkc3RhcnRUb3VjaGVzUG9zMi54LFxuICAgICAgICAgIHkwID0gX3RoaXMkc3RhcnRUb3VjaGVzUG9zMi55LFxuICAgICAgICAgIF90aGlzJHN0YXJ0VG91Y2hlc1BvczMgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3NbMV0sXG4gICAgICAgICAgeDEgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3MzLngsXG4gICAgICAgICAgeTEgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3MzLnk7XG4gICAgICAgIHRoaXMuc3RhcnRUb3VjaGVzQW5nbGUgPSBNYXRoLmF0YW4yKHkxIC0geTAsIHgxIC0geDApO1xuICAgICAgICB0aGlzLnN0YXJ0VG91Y2hlc0Rpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDAsIDIpICsgTWF0aC5wb3coeTEgLSB5MCwgMikpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwidG91Y2hkb3duXCIsIGdldFRvdWNoQ29vcmRzKGUsIHRoaXMubGFzdFRvdWNoZXMsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgICB0aGlzLmxhc3RUb3VjaGVzID0gdG91Y2hlcztcbiAgICAgIHRoaXMubGFzdFRvdWNoZXNQb3NpdGlvbnMgPSB0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTGVhdmUoZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIXRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgaWYgKGUuY2FuY2VsYWJsZSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHRoaXMubW92aW5nVGltZW91dCkge1xuICAgICAgICB0aGlzLmlzTW92aW5nID0gZmFsc2U7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0aGlzLnRvdWNoTW9kZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN0YXJ0KGUpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAodGhpcy5pc01vdmluZykge1xuICAgICAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICAgICAgICB2YXIgY2FtZXJhU3RhdGUgPSBjYW1lcmEuZ2V0U3RhdGUoKSxcbiAgICAgICAgICAgICAgcHJldmlvdXNDYW1lcmFTdGF0ZSA9IGNhbWVyYS5nZXRQcmV2aW91c1N0YXRlKCkgfHwge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FtZXJhLmFuaW1hdGUoe1xuICAgICAgICAgICAgICB4OiBjYW1lcmFTdGF0ZS54ICsgdGhpcy5zZXR0aW5ncy5pbmVydGlhUmF0aW8gKiAoY2FtZXJhU3RhdGUueCAtIHByZXZpb3VzQ2FtZXJhU3RhdGUueCksXG4gICAgICAgICAgICAgIHk6IGNhbWVyYVN0YXRlLnkgKyB0aGlzLnNldHRpbmdzLmluZXJ0aWFSYXRpbyAqIChjYW1lcmFTdGF0ZS55IC0gcHJldmlvdXNDYW1lcmFTdGF0ZS55KVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5zZXR0aW5ncy5pbmVydGlhRHVyYXRpb24sXG4gICAgICAgICAgICAgIGVhc2luZzogXCJxdWFkcmF0aWNPdXRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmlzTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50b3VjaE1vZGUgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwidG91Y2h1cFwiLCBnZXRUb3VjaENvb3JkcyhlLCB0aGlzLmxhc3RUb3VjaGVzLCB0aGlzLmNvbnRhaW5lcikpO1xuXG4gICAgICAvLyBXaGVuIHRoZSBsYXN0IHRvdWNoIGVuZHMgYW5kIHRoZXJlIGhhc24ndCBiZWVuIHRvbyBtdWNoIG1vdmVtZW50LCB0cmlnZ2VyIGEgXCJ0YXBcIiBvciBcImRvdWJsZXRhcFwiIGV2ZW50OlxuICAgICAgaWYgKCFlLnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHRoaXMubGFzdFRvdWNoZXNbMF0sIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGRvd25Qb3NpdGlvbiA9IHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zWzBdO1xuICAgICAgICB2YXIgZFNxdWFyZSA9IE1hdGgucG93KHBvc2l0aW9uLnggLSBkb3duUG9zaXRpb24ueCwgMikgKyBNYXRoLnBvdyhwb3NpdGlvbi55IC0gZG93blBvc2l0aW9uLnksIDIpO1xuICAgICAgICBpZiAoIWUudG91Y2hlcy5sZW5ndGggJiYgZFNxdWFyZSA8IE1hdGgucG93KHRoaXMuc2V0dGluZ3MudGFwTW92ZVRvbGVyYW5jZSwgMikpIHtcbiAgICAgICAgICAvLyBPbmx5IHRyaWdnZXIgXCJkb3VibGV0YXBcIiB3aGVuIHRoZSBsYXN0IHRhcCBpcyByZWNlbnQgZW5vdWdoOlxuICAgICAgICAgIGlmICh0aGlzLmxhc3RUYXAgJiYgRGF0ZS5ub3coKSAtIHRoaXMubGFzdFRhcC50aW1lIDwgdGhpcy5zZXR0aW5ncy5kb3VibGVDbGlja1RpbWVvdXQpIHtcbiAgICAgICAgICAgIHZhciB0b3VjaENvb3JkcyA9IGdldFRvdWNoQ29vcmRzKGUsIHRoaXMubGFzdFRvdWNoZXMsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRvdWJsZXRhcFwiLCB0b3VjaENvb3Jkcyk7XG4gICAgICAgICAgICB0aGlzLmxhc3RUYXAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCF0b3VjaENvb3Jkcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9jYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgICAgICAgICB2YXIgbmV3UmF0aW8gPSBfY2FtZXJhLmdldEJvdW5kZWRSYXRpbyhfY2FtZXJhLmdldFN0YXRlKCkucmF0aW8gLyB0aGlzLnNldHRpbmdzLmRvdWJsZUNsaWNrWm9vbWluZ1JhdGlvKTtcbiAgICAgICAgICAgICAgX2NhbWVyYS5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0Vmlld3BvcnRab29tZWRTdGF0ZShwb3NpdGlvbiwgbmV3UmF0aW8pLCB7XG4gICAgICAgICAgICAgICAgZWFzaW5nOiBcInF1YWRyYXRpY0luT3V0XCIsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuc2V0dGluZ3MuZG91YmxlQ2xpY2tab29taW5nRHVyYXRpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEVsc2UsIHRyaWdnZXIgYSBub3JtYWwgXCJ0YXBcIiBldmVudDpcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfdG91Y2hDb29yZHMgPSBnZXRUb3VjaENvb3JkcyhlLCB0aGlzLmxhc3RUb3VjaGVzLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ0YXBcIiwgX3RvdWNoQ29vcmRzKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFRhcCA9IHtcbiAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IF90b3VjaENvb3Jkcy50b3VjaGVzWzBdIHx8IF90b3VjaENvb3Jkcy5wcmV2aW91c1RvdWNoZXNbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RUb3VjaGVzID0gZ2V0VG91Y2hlc0FycmF5KGUudG91Y2hlcyk7XG4gICAgICB0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9ucyA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdmUoZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMubGVuZ3RoKSByZXR1cm47XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXNBcnJheShlLnRvdWNoZXMpO1xuICAgICAgdmFyIHRvdWNoZXNQb3NpdGlvbnMgPSB0b3VjaGVzLm1hcChmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvc2l0aW9uKHRvdWNoLCBfdGhpczMuY29udGFpbmVyKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhc3RUb3VjaGVzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICAgIHRoaXMubGFzdFRvdWNoZXMgPSB0b3VjaGVzO1xuICAgICAgdGhpcy5sYXN0VG91Y2hlc1Bvc2l0aW9ucyA9IHRvdWNoZXNQb3NpdGlvbnM7XG4gICAgICB2YXIgdG91Y2hDb29yZHMgPSBnZXRUb3VjaENvb3JkcyhlLCBsYXN0VG91Y2hlcywgdGhpcy5jb250YWluZXIpO1xuICAgICAgdGhpcy5lbWl0KFwidG91Y2htb3ZlXCIsIHRvdWNoQ29vcmRzKTtcbiAgICAgIGlmICh0b3VjaENvb3Jkcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgLy8gSWYgYSBtb3ZlIHdhcyBpbml0aWF0ZWQgYXQgc29tZSBwb2ludCwgYW5kIHdlIGdldCBiYWNrIHRvIHN0YXJ0IHBvaW50LFxuICAgICAgLy8gd2Ugc2hvdWxkIHN0aWxsIGNvbnNpZGVyIHRoYXQgd2UgZGlkIG1vdmUgKHdoaWNoIGFsc28gaGFwcGVucyBhZnRlciBhXG4gICAgICAvLyBtdWx0aXBsZSB0b3VjaCB3aGVuIG9ubHkgb25lIHRvdWNoIHJlbWFpbnMgaW4gd2hpY2ggY2FzZSBoYW5kbGVTdGFydFxuICAgICAgLy8gaXMgcmVjYWxsZWQgd2l0aGluIGhhbmRsZUxlYXZlKS5cbiAgICAgIC8vIE5vdywgc29tZSBtb2JpbGUgYnJvd3NlcnMgcmVwb3J0IHplcm8tZGlzdGFuY2UgbW92ZXMgc28gd2UgYWxzbyBjaGVjayB0aGF0XG4gICAgICAvLyBvbmUgb2YgdGhlIHRvdWNoZXMgZGlkIGFjdHVhbGx5IG1vdmUgZnJvbSB0aGUgb3JpZ2luIHBvc2l0aW9uLlxuICAgICAgdGhpcy5oYXNNb3ZlZCB8fCAodGhpcy5oYXNNb3ZlZCA9IHRvdWNoZXNQb3NpdGlvbnMuc29tZShmdW5jdGlvbiAocG9zaXRpb24sIGlkeCkge1xuICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IF90aGlzMy5zdGFydFRvdWNoZXNQb3NpdGlvbnNbaWR4XTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0UG9zaXRpb24gJiYgKHBvc2l0aW9uLnggIT09IHN0YXJ0UG9zaXRpb24ueCB8fCBwb3NpdGlvbi55ICE9PSBzdGFydFBvc2l0aW9uLnkpO1xuICAgICAgfSkpO1xuXG4gICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gbW92ZSwgZG8gbm90IHRyaWdnZXIgdG91Y2ggbW92ZXMgYmVoYXZpb3JcbiAgICAgIGlmICghdGhpcy5oYXNNb3ZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLm1vdmluZ1RpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLm1vdmluZ1RpbWVvdXQpO1xuICAgICAgdGhpcy5tb3ZpbmdUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIH0sIHRoaXMuc2V0dGluZ3MuZHJhZ1RpbWVvdXQpO1xuICAgICAgdmFyIGNhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICB2YXIgc3RhcnRDYW1lcmFTdGF0ZSA9IHRoaXMuc3RhcnRDYW1lcmFTdGF0ZTtcbiAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5yZW5kZXJlci5nZXRTZXR0aW5nKFwic3RhZ2VQYWRkaW5nXCIpO1xuICAgICAgc3dpdGNoICh0aGlzLnRvdWNoTW9kZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF90aGlzJHJlbmRlcmVyJHZpZXdwbyA9IHRoaXMucmVuZGVyZXIudmlld3BvcnRUb0ZyYW1lZEdyYXBoKCh0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9ucyB8fCBbXSlbMF0pLFxuICAgICAgICAgICAgICB4U3RhcnQgPSBfdGhpcyRyZW5kZXJlciR2aWV3cG8ueCxcbiAgICAgICAgICAgICAgeVN0YXJ0ID0gX3RoaXMkcmVuZGVyZXIkdmlld3BvLnk7XG4gICAgICAgICAgICB2YXIgX3RoaXMkcmVuZGVyZXIkdmlld3BvMiA9IHRoaXMucmVuZGVyZXIudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHRvdWNoZXNQb3NpdGlvbnNbMF0pLFxuICAgICAgICAgICAgICB4ID0gX3RoaXMkcmVuZGVyZXIkdmlld3BvMi54LFxuICAgICAgICAgICAgICB5ID0gX3RoaXMkcmVuZGVyZXIkdmlld3BvMi55O1xuICAgICAgICAgICAgY2FtZXJhLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgeDogc3RhcnRDYW1lcmFTdGF0ZS54ICsgeFN0YXJ0IC0geCxcbiAgICAgICAgICAgICAgeTogc3RhcnRDYW1lcmFTdGF0ZS55ICsgeVN0YXJ0IC0geVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhlcmUgaXMgdGhlIHRoaW5raW5nIGhlcmU6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogMS4gV2UgY2FuIGZpbmQgdGhlIG5ldyBhbmdsZSBhbmQgcmF0aW8sIGJ5IGNvbXBhcmluZyB0aGUgdmVjdG9yIGZyb20gXCJ0b3VjaCBvbmVcIiB0byBcInRvdWNoIHR3b1wiIGF0IHRoZSBzdGFydFxuICAgICAgICAgICAgICogICAgb2YgdGhlIGQnbidkIGFuZCBub3dcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAyLiBXZSBjYW4gdXNlIGBDYW1lcmEjdmlld3BvcnRUb0dyYXBoYCBpbnNpZGUgZm9ybXVsYSB0byByZXRyaWV2ZSB0aGUgbmV3IGNhbWVyYSBwb3NpdGlvbiwgdXNpbmcgdGhlIGdyYXBoXG4gICAgICAgICAgICAgKiAgICBwb3NpdGlvbiBvZiBhIHRvdWNoIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGQnbidkICh1c2luZyBgc3RhcnRDYW1lcmEudmlld3BvcnRUb0dyYXBoYCkgYW5kIHRoZSB2aWV3cG9ydFxuICAgICAgICAgICAgICogICAgcG9zaXRpb24gb2YgdGhpcyBzYW1lIHRvdWNoIG5vd1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgbmV3Q2FtZXJhU3RhdGUgPSB7XG4gICAgICAgICAgICAgIHg6IDAuNSxcbiAgICAgICAgICAgICAgeTogMC41LFxuICAgICAgICAgICAgICBhbmdsZTogMCxcbiAgICAgICAgICAgICAgcmF0aW86IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3RvdWNoZXNQb3NpdGlvbnMkID0gdG91Y2hlc1Bvc2l0aW9uc1swXSxcbiAgICAgICAgICAgICAgeDAgPSBfdG91Y2hlc1Bvc2l0aW9ucyQueCxcbiAgICAgICAgICAgICAgeTAgPSBfdG91Y2hlc1Bvc2l0aW9ucyQueTtcbiAgICAgICAgICAgIHZhciBfdG91Y2hlc1Bvc2l0aW9ucyQyID0gdG91Y2hlc1Bvc2l0aW9uc1sxXSxcbiAgICAgICAgICAgICAgeDEgPSBfdG91Y2hlc1Bvc2l0aW9ucyQyLngsXG4gICAgICAgICAgICAgIHkxID0gX3RvdWNoZXNQb3NpdGlvbnMkMi55O1xuICAgICAgICAgICAgdmFyIGFuZ2xlRGlmZiA9IE1hdGguYXRhbjIoeTEgLSB5MCwgeDEgLSB4MCkgLSB0aGlzLnN0YXJ0VG91Y2hlc0FuZ2xlO1xuICAgICAgICAgICAgdmFyIHJhdGlvRGlmZiA9IE1hdGguaHlwb3QoeTEgLSB5MCwgeDEgLSB4MCkgLyB0aGlzLnN0YXJ0VG91Y2hlc0Rpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyAxLlxuICAgICAgICAgICAgdmFyIG5ld1JhdGlvID0gY2FtZXJhLmdldEJvdW5kZWRSYXRpbyhzdGFydENhbWVyYVN0YXRlLnJhdGlvIC8gcmF0aW9EaWZmKTtcbiAgICAgICAgICAgIG5ld0NhbWVyYVN0YXRlLnJhdGlvID0gbmV3UmF0aW87XG4gICAgICAgICAgICBuZXdDYW1lcmFTdGF0ZS5hbmdsZSA9IHN0YXJ0Q2FtZXJhU3RhdGUuYW5nbGUgKyBhbmdsZURpZmY7XG5cbiAgICAgICAgICAgIC8vIDIuXG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9ucygpO1xuICAgICAgICAgICAgdmFyIHRvdWNoR3JhcGhQb3NpdGlvbiA9IHRoaXMucmVuZGVyZXIudmlld3BvcnRUb0ZyYW1lZEdyYXBoKCh0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9ucyB8fCBbXSlbMF0sIHtcbiAgICAgICAgICAgICAgY2FtZXJhU3RhdGU6IHN0YXJ0Q2FtZXJhU3RhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHNtYWxsZXN0RGltZW5zaW9uID0gTWF0aC5taW4oZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpIC0gMiAqIHBhZGRpbmc7XG4gICAgICAgICAgICB2YXIgZHggPSBzbWFsbGVzdERpbWVuc2lvbiAvIGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICB2YXIgZHkgPSBzbWFsbGVzdERpbWVuc2lvbiAvIGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHJhdGlvID0gbmV3UmF0aW8gLyBzbWFsbGVzdERpbWVuc2lvbjtcblxuICAgICAgICAgICAgLy8gQWxpZ24gd2l0aCBjZW50ZXIgb2YgdGhlIGdyYXBoOlxuICAgICAgICAgICAgdmFyIF94ID0geDAgLSBzbWFsbGVzdERpbWVuc2lvbiAvIDIgLyBkeDtcbiAgICAgICAgICAgIHZhciBfeSA9IHkwIC0gc21hbGxlc3REaW1lbnNpb24gLyAyIC8gZHk7XG5cbiAgICAgICAgICAgIC8vIFJvdGF0ZTpcbiAgICAgICAgICAgIHZhciBfcmVmID0gW194ICogTWF0aC5jb3MoLW5ld0NhbWVyYVN0YXRlLmFuZ2xlKSAtIF95ICogTWF0aC5zaW4oLW5ld0NhbWVyYVN0YXRlLmFuZ2xlKSwgX3kgKiBNYXRoLmNvcygtbmV3Q2FtZXJhU3RhdGUuYW5nbGUpICsgX3ggKiBNYXRoLnNpbigtbmV3Q2FtZXJhU3RhdGUuYW5nbGUpXTtcbiAgICAgICAgICAgIF94ID0gX3JlZlswXTtcbiAgICAgICAgICAgIF95ID0gX3JlZlsxXTtcbiAgICAgICAgICAgIG5ld0NhbWVyYVN0YXRlLnggPSB0b3VjaEdyYXBoUG9zaXRpb24ueCAtIF94ICogcmF0aW87XG4gICAgICAgICAgICBuZXdDYW1lcmFTdGF0ZS55ID0gdG91Y2hHcmFwaFBvc2l0aW9uLnkgKyBfeSAqIHJhdGlvO1xuICAgICAgICAgICAgY2FtZXJhLnNldFN0YXRlKG5ld0NhbWVyYVN0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2V0dGluZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9XG4gIH1dKTtcbn0oQ2FwdG9yKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7XG4gIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheShyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHtcbiAgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9O1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7XG4gICAgaWYgKC0xICE9PSBlLmluZGV4T2YobikpIGNvbnRpbnVlO1xuICAgIHRbbl0gPSByW25dO1xuICB9XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZSwgdCkge1xuICBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307XG4gIHZhciBvLFxuICAgIHIsXG4gICAgaSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGUsIHQpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICBmb3IgKHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKykgbyA9IG5bcl0sIC0xID09PSB0LmluZGV4T2YobykgJiYge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCBvKSAmJiAoaVtvXSA9IGVbb10pO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG4vKipcbiAqIFNpZ21hLmpzIExhYmVscyBIZXVyaXN0aWNzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBNaXNjZWxsYW5lb3VzIGhldXJpc3RpY3MgcmVsYXRlZCB0byBsYWJlbCBkaXNwbGF5LlxuICogQG1vZHVsZVxuICovXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHNpbmdsZSBjYW5kaWRhdGUgZm9yIHRoZSBsYWJlbCBncmlkIHNlbGVjdGlvbi5cbiAqXG4gKiBJdCBhbHNvIGRlc2NyaWJlcyBhIGRldGVybWluaXN0aWMgd2F5IHRvIGNvbXBhcmUgdHdvIGNhbmRpZGF0ZXMgdG8gYXNzZXNzXG4gKiB3aGljaCBvbmUgaXMgYmV0dGVyLlxuICovXG52YXIgTGFiZWxDYW5kaWRhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYWJlbENhbmRpZGF0ZShrZXksIHNpemUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGFiZWxDYW5kaWRhdGUpO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMYWJlbENhbmRpZGF0ZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiY29tcGFyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgIC8vIEZpcnN0IHdlIGNvbXBhcmUgYnkgc2l6ZVxuICAgICAgaWYgKGZpcnN0LnNpemUgPiBzZWNvbmQuc2l6ZSkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGZpcnN0LnNpemUgPCBzZWNvbmQuc2l6ZSkgcmV0dXJuIDE7XG5cbiAgICAgIC8vIFRoZW4gc2luY2Ugbm8gdHdvIG5vZGVzIGNhbiBoYXZlIHRoZSBzYW1lIGtleSwgd2UgdXNlIGl0IHRvXG4gICAgICAvLyBkZXRlcm1pbmlzdGljYWxseSB0aWUtYnJlYWsgYnkga2V5XG4gICAgICBpZiAoZmlyc3Qua2V5ID4gc2Vjb25kLmtleSkgcmV0dXJuIDE7XG5cbiAgICAgIC8vIE5PVEU6IHRoaXMgY29tcGFyYXRvciBjYW5ub3QgcmV0dXJuIDBcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgMkQgc3BhdGlhbCBncmlkIGRpdmlkZWQgaW50byBjb25zdGFudC1zaXplIGNlbGxzLlxuICovXG52YXIgTGFiZWxHcmlkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGFiZWxHcmlkKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbEdyaWQpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpZHRoXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlaWdodFwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjZWxsU2l6ZVwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2x1bW5zXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJvd3NcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2VsbHNcIiwge30pO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTGFiZWxHcmlkLCBbe1xuICAgIGtleTogXCJyZXNpemVBbmRDbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemVBbmRDbGVhcihkaW1lbnNpb25zLCBjZWxsU2l6ZSkge1xuICAgICAgdGhpcy53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgdGhpcy5jZWxsU2l6ZSA9IGNlbGxTaXplO1xuICAgICAgdGhpcy5jb2x1bW5zID0gTWF0aC5jZWlsKGRpbWVuc2lvbnMud2lkdGggLyBjZWxsU2l6ZSk7XG4gICAgICB0aGlzLnJvd3MgPSBNYXRoLmNlaWwoZGltZW5zaW9ucy5oZWlnaHQgLyBjZWxsU2l6ZSk7XG4gICAgICB0aGlzLmNlbGxzID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluZGV4KHBvcykge1xuICAgICAgdmFyIHhJbmRleCA9IE1hdGguZmxvb3IocG9zLnggLyB0aGlzLmNlbGxTaXplKTtcbiAgICAgIHZhciB5SW5kZXggPSBNYXRoLmZsb29yKHBvcy55IC8gdGhpcy5jZWxsU2l6ZSk7XG4gICAgICByZXR1cm4geUluZGV4ICogdGhpcy5jb2x1bW5zICsgeEluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGtleSwgc2l6ZSwgcG9zKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlID0gbmV3IExhYmVsQ2FuZGlkYXRlKGtleSwgc2l6ZSk7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KHBvcyk7XG4gICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbHNbaW5kZXhdO1xuICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgIGNlbGwgPSBbXTtcbiAgICAgICAgdGhpcy5jZWxsc1tpbmRleF0gPSBjZWxsO1xuICAgICAgfVxuICAgICAgY2VsbC5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9yZ2FuaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9yZ2FuaXplKCkge1xuICAgICAgZm9yICh2YXIgayBpbiB0aGlzLmNlbGxzKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1trXTtcbiAgICAgICAgY2VsbC5zb3J0KExhYmVsQ2FuZGlkYXRlLmNvbXBhcmUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYWJlbHNUb0Rpc3BsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFiZWxzVG9EaXNwbGF5KHJhdGlvLCBkZW5zaXR5KSB7XG4gICAgICAvLyBUT0RPOiB3b3JrIG9uIHZpc2libGUgbm9kZXMgdG8gb3B0aW1pemU/IF4gLT4gdGhyZXNob2xkIG91dHNpZGUgc28gdGhhdCBtZW1vaXphdGlvbiB3b3Jrcz9cbiAgICAgIC8vIFRPRE86IGFkanVzdCB0aHJlc2hvbGQgbG93ZXIsIGJ1dCBpbmNyZWFzZSBjZWxscyBhIGJpdD9cbiAgICAgIC8vIFRPRE86IGh1bnQgZm9yIGdlb20gaXNzdWUgaW4gZGlzZ3Vpc2VcbiAgICAgIC8vIFRPRE86IG1lbW9pemUgd2hpbGUgcmF0aW8gZG9lcyBub3QgbW92ZS4gbWV0aG9kIHRvIGZvcmNlIHJlY29tcHV0ZVxuICAgICAgdmFyIGNlbGxBcmVhID0gdGhpcy5jZWxsU2l6ZSAqIHRoaXMuY2VsbFNpemU7XG4gICAgICB2YXIgc2NhbGVkQ2VsbEFyZWEgPSBjZWxsQXJlYSAvIHJhdGlvIC8gcmF0aW87XG4gICAgICB2YXIgc2NhbGVkRGVuc2l0eSA9IHNjYWxlZENlbGxBcmVhICogZGVuc2l0eSAvIGNlbGxBcmVhO1xuICAgICAgdmFyIGxhYmVsc1RvRGlzcGxheVBlckNlbGwgPSBNYXRoLmNlaWwoc2NhbGVkRGVuc2l0eSk7XG4gICAgICB2YXIgbGFiZWxzID0gW107XG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMuY2VsbHMpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzW2tdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGxhYmVsc1RvRGlzcGxheVBlckNlbGwsIGNlbGwubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgbGFiZWxzLnB1c2goY2VsbFtpXS5rZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG4vKipcbiAqIExhYmVsIGhldXJpc3RpYyBzZWxlY3RpbmcgZWRnZSBsYWJlbHMgdG8gZGlzcGxheSwgYmFzZWQgb24gZGlzcGxheWVkIG5vZGVcbiAqIGxhYmVsc1xuICpcbiAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zICAgICAgICAgICAgICAgICAtIFBhcmFtZXRlcnM6XG4gKiBAcGFyYW0gIHtTZXR9ICAgICAgZGlzcGxheWVkTm9kZUxhYmVscyAgLSBDdXJyZW50bHkgZGlzcGxheWVkIG5vZGUgbGFiZWxzLlxuICogQHBhcmFtICB7U2V0fSAgICAgIGhpZ2hsaWdodGVkTm9kZXMgICAgIC0gSGlnaGxpZ2h0ZWQgbm9kZXMuXG4gKiBAcGFyYW0gIHtHcmFwaH0gICAgZ3JhcGggICAgICAgICAgICAgICAgLSBUaGUgcmVuZGVyZWQgZ3JhcGguXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgaG92ZXJlZE5vZGUgICAgICAgICAgLSBIb3ZlcmVkIG5vZGUgKG9wdGlvbmFsKVxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIHNlbGVjdGVkIGxhYmVscy5cbiAqL1xuZnVuY3Rpb24gZWRnZUxhYmVsc1RvRGlzcGxheUZyb21Ob2RlcyhwYXJhbXMpIHtcbiAgdmFyIGdyYXBoID0gcGFyYW1zLmdyYXBoLFxuICAgIGhvdmVyZWROb2RlID0gcGFyYW1zLmhvdmVyZWROb2RlLFxuICAgIGhpZ2hsaWdodGVkTm9kZXMgPSBwYXJhbXMuaGlnaGxpZ2h0ZWROb2RlcyxcbiAgICBkaXNwbGF5ZWROb2RlTGFiZWxzID0gcGFyYW1zLmRpc3BsYXllZE5vZGVMYWJlbHM7XG4gIHZhciB3b3J0aHlFZGdlcyA9IFtdO1xuXG4gIC8vIFRPRE86IHRoZSBjb2RlIGJlbG93IGNhbiBiZSBvcHRpbWl6ZWQgdXNpbmcgIy5mb3JFYWNoIGFuZCBiYXRjaGluZyB0aGUgY29kZSBwZXIgYWRqXG5cbiAgLy8gV2Ugc2hvdWxkIGRpc3BsYXkgYW4gZWRnZSdzIGxhYmVsIGlmOlxuICAvLyAgIC0gQW55IG9mIGl0cyBleHRyZW1pdGllcyBpcyBoaWdobGlnaHRlZCBvciBob3ZlcmVkXG4gIC8vICAgLSBCb3RoIG9mIGl0cyBleHRyZW1pdGllcyBoYXMgaXRzIGxhYmVsIHNob3duXG4gIGdyYXBoLmZvckVhY2hFZGdlKGZ1bmN0aW9uIChlZGdlLCBfLCBzb3VyY2UsIHRhcmdldCkge1xuICAgIGlmIChzb3VyY2UgPT09IGhvdmVyZWROb2RlIHx8IHRhcmdldCA9PT0gaG92ZXJlZE5vZGUgfHwgaGlnaGxpZ2h0ZWROb2Rlcy5oYXMoc291cmNlKSB8fCBoaWdobGlnaHRlZE5vZGVzLmhhcyh0YXJnZXQpIHx8IGRpc3BsYXllZE5vZGVMYWJlbHMuaGFzKHNvdXJjZSkgJiYgZGlzcGxheWVkTm9kZUxhYmVscy5oYXModGFyZ2V0KSkge1xuICAgICAgd29ydGh5RWRnZXMucHVzaChlZGdlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gd29ydGh5RWRnZXM7XG59XG5cbi8qKlxuICogQ29uc3RhbnRzLlxuICovXG52YXIgWF9MQUJFTF9NQVJHSU4gPSAxNTA7XG52YXIgWV9MQUJFTF9NQVJHSU4gPSA1MDtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW1wb3J0YW50IGZ1bmN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlOb2RlRGVmYXVsdHMoc2V0dGluZ3MsIGtleSwgZGF0YSkge1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJ4XCIpIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwieVwiKSkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgcG9zaXRpb24gKHgsIHkpIGZvciBub2RlIFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIuIEFsbCB5b3VyIG5vZGVzIG11c3QgaGF2ZSBhIG51bWJlciBcXFwieFxcXCIgYW5kIFxcXCJ5XFxcIi4gTWF5YmUgeW91ciBmb3Jnb3QgdG8gYXBwbHkgYSBsYXlvdXQgb3IgeW91ciBcXFwibm9kZVJlZHVjZXJcXFwiIGlzIG5vdCByZXR1cm5pbmcgdGhlIGNvcnJlY3QgZGF0YT9cIikpO1xuICBpZiAoIWRhdGEuY29sb3IpIGRhdGEuY29sb3IgPSBzZXR0aW5ncy5kZWZhdWx0Tm9kZUNvbG9yO1xuICBpZiAoIWRhdGEubGFiZWwgJiYgZGF0YS5sYWJlbCAhPT0gXCJcIikgZGF0YS5sYWJlbCA9IG51bGw7XG4gIGlmIChkYXRhLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgZGF0YS5sYWJlbCAhPT0gbnVsbCkgZGF0YS5sYWJlbCA9IFwiXCIgKyBkYXRhLmxhYmVsO2Vsc2UgZGF0YS5sYWJlbCA9IG51bGw7XG4gIGlmICghZGF0YS5zaXplKSBkYXRhLnNpemUgPSAyO1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJoaWRkZW5cIikpIGRhdGEuaGlkZGVuID0gZmFsc2U7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcImhpZ2hsaWdodGVkXCIpKSBkYXRhLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcImZvcmNlTGFiZWxcIikpIGRhdGEuZm9yY2VMYWJlbCA9IGZhbHNlO1xuICBpZiAoIWRhdGEudHlwZSB8fCBkYXRhLnR5cGUgPT09IFwiXCIpIGRhdGEudHlwZSA9IHNldHRpbmdzLmRlZmF1bHROb2RlVHlwZTtcbiAgaWYgKCFkYXRhLnpJbmRleCkgZGF0YS56SW5kZXggPSAwO1xuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGFwcGx5RWRnZURlZmF1bHRzKHNldHRpbmdzLCBfa2V5LCBkYXRhKSB7XG4gIGlmICghZGF0YS5jb2xvcikgZGF0YS5jb2xvciA9IHNldHRpbmdzLmRlZmF1bHRFZGdlQ29sb3I7XG4gIGlmICghZGF0YS5sYWJlbCkgZGF0YS5sYWJlbCA9IFwiXCI7XG4gIGlmICghZGF0YS5zaXplKSBkYXRhLnNpemUgPSAwLjU7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcImhpZGRlblwiKSkgZGF0YS5oaWRkZW4gPSBmYWxzZTtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwiZm9yY2VMYWJlbFwiKSkgZGF0YS5mb3JjZUxhYmVsID0gZmFsc2U7XG4gIGlmICghZGF0YS50eXBlIHx8IGRhdGEudHlwZSA9PT0gXCJcIikgZGF0YS50eXBlID0gc2V0dGluZ3MuZGVmYXVsdEVkZ2VUeXBlO1xuICBpZiAoIWRhdGEuekluZGV4KSBkYXRhLnpJbmRleCA9IDA7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1haW4gY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0dyYXBofSAgICAgICBncmFwaCAgICAgLSBHcmFwaCB0byByZW5kZXIuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBET00gY29udGFpbmVyIGluIHdoaWNoIHRvIHJlbmRlci5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIHNldHRpbmdzICAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICovXG52YXIgU2lnbWEkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1R5cGVkRXZlbnRFbWl0dGVyKSB7XG4gIGZ1bmN0aW9uIFNpZ21hKGdyYXBoLCBjb250YWluZXIpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdmFyIHNldHRpbmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2lnbWEpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBTaWdtYSk7XG5cbiAgICAvLyBSZXNvbHZpbmcgc2V0dGluZ3NcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZWxlbWVudHNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjYW52YXNDb250ZXh0c1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIndlYkdMQ29udGV4dHNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwaWNraW5nTGF5ZXJzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInRleHR1cmVzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZnJhbWVCdWZmZXJzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiYWN0aXZlTGlzdGVuZXJzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibGFiZWxHcmlkXCIsIG5ldyBMYWJlbEdyaWQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVEYXRhQ2FjaGVcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlZGdlRGF0YUNhY2hlXCIsIHt9KTtcbiAgICAvLyBJbmRpY2VzIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGluZGV4IG9mIHRoZSBpdGVtIGluc2lkZSBwcm9ncmFtc1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub2RlUHJvZ3JhbUluZGV4XCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZWRnZVByb2dyYW1JbmRleFwiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVzV2l0aEZvcmNlZExhYmVsc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlZGdlc1dpdGhGb3JjZWRMYWJlbHNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9kZUV4dGVudFwiLCB7XG4gICAgICB4OiBbMCwgMV0sXG4gICAgICB5OiBbMCwgMV1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9kZVpFeHRlbnRcIiwgW0luZmluaXR5LCAtSW5maW5pdHldKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZWRnZVpFeHRlbnRcIiwgW0luZmluaXR5LCAtSW5maW5pdHldKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibWF0cml4XCIsIGlkZW50aXR5KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpbnZNYXRyaXhcIiwgaWRlbnRpdHkoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImNvcnJlY3Rpb25SYXRpb1wiLCAxKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY3VzdG9tQkJveFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9ybWFsaXphdGlvbkZ1bmN0aW9uXCIsIGNyZWF0ZU5vcm1hbGl6YXRpb25GdW5jdGlvbih7XG4gICAgICB4OiBbMCwgMV0sXG4gICAgICB5OiBbMCwgMV1cbiAgICB9KSk7XG4gICAgLy8gQ2FjaGU6XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImdyYXBoVG9WaWV3cG9ydFJhdGlvXCIsIDEpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpdGVtSURzSW5kZXhcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub2RlSW5kaWNlc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVkZ2VJbmRpY2VzXCIsIHt9KTtcbiAgICAvLyBTdGFydGluZyBkaW1lbnNpb25zIGFuZCBwaXhlbCByYXRpb1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ3aWR0aFwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGVpZ2h0XCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwaXhlbFJhdGlvXCIsIGdldFBpeGVsUmF0aW8oKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInBpY2tpbmdEb3duU2l6aW5nUmF0aW9cIiwgMiAqIF90aGlzLnBpeGVsUmF0aW8pO1xuICAgIC8vIEdyYXBoIFN0YXRlXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImRpc3BsYXllZE5vZGVMYWJlbHNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZGlzcGxheWVkRWRnZUxhYmVsc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoaWdobGlnaHRlZE5vZGVzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhvdmVyZWROb2RlXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJob3ZlcmVkRWRnZVwiLCBudWxsKTtcbiAgICAvLyBJbnRlcm5hbCBzdGF0ZXNcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVyRnJhbWVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibmVlZFRvUHJvY2Vzc1wiLCBmYWxzZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImNoZWNrRWRnZXNFdmVudHNGcmFtZVwiLCBudWxsKTtcbiAgICAvLyBQcm9ncmFtc1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub2RlUHJvZ3JhbXNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub2RlSG92ZXJQcm9ncmFtc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVkZ2VQcm9ncmFtc1wiLCB7fSk7XG4gICAgX3RoaXMuc2V0dGluZ3MgPSByZXNvbHZlU2V0dGluZ3Moc2V0dGluZ3MpO1xuXG4gICAgLy8gVmFsaWRhdGluZ1xuICAgIHZhbGlkYXRlU2V0dGluZ3MoX3RoaXMuc2V0dGluZ3MpO1xuICAgIHZhbGlkYXRlR3JhcGgoZ3JhcGgpO1xuICAgIGlmICghKGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvbnRhaW5lciBzaG91bGQgYmUgYW4gaHRtbCBlbGVtZW50LlwiKTtcblxuICAgIC8vIFByb3BlcnRpZXNcbiAgICBfdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIF90aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgIC8vIEluaXRpYWxpemluZyBjb250ZXh0c1xuICAgIF90aGlzLmNyZWF0ZVdlYkdMQ29udGV4dChcImVkZ2VzXCIsIHtcbiAgICAgIHBpY2tpbmc6IHNldHRpbmdzLmVuYWJsZUVkZ2VFdmVudHNcbiAgICB9KTtcbiAgICBfdGhpcy5jcmVhdGVDYW52YXNDb250ZXh0KFwiZWRnZUxhYmVsc1wiKTtcbiAgICBfdGhpcy5jcmVhdGVXZWJHTENvbnRleHQoXCJub2Rlc1wiLCB7XG4gICAgICBwaWNraW5nOiB0cnVlXG4gICAgfSk7XG4gICAgX3RoaXMuY3JlYXRlQ2FudmFzQ29udGV4dChcImxhYmVsc1wiKTtcbiAgICBfdGhpcy5jcmVhdGVDYW52YXNDb250ZXh0KFwiaG92ZXJzXCIpO1xuICAgIF90aGlzLmNyZWF0ZVdlYkdMQ29udGV4dChcImhvdmVyTm9kZXNcIik7XG4gICAgX3RoaXMuY3JlYXRlQ2FudmFzQ29udGV4dChcIm1vdXNlXCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHRvdWNoQWN0aW9uOiBcIm5vbmVcIixcbiAgICAgICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEluaXRpYWwgcmVzaXplXG4gICAgX3RoaXMucmVzaXplKCk7XG5cbiAgICAvLyBMb2FkaW5nIHByb2dyYW1zXG4gICAgZm9yICh2YXIgdHlwZSBpbiBfdGhpcy5zZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXMpIHtcbiAgICAgIF90aGlzLnJlZ2lzdGVyTm9kZVByb2dyYW0odHlwZSwgX3RoaXMuc2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzW3R5cGVdLCBfdGhpcy5zZXR0aW5ncy5ub2RlSG92ZXJQcm9ncmFtQ2xhc3Nlc1t0eXBlXSk7XG4gICAgfVxuICAgIGZvciAodmFyIF90eXBlIGluIF90aGlzLnNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgX3RoaXMucmVnaXN0ZXJFZGdlUHJvZ3JhbShfdHlwZSwgX3RoaXMuc2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzW190eXBlXSk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6aW5nIHRoZSBjYW1lcmFcbiAgICBfdGhpcy5jYW1lcmEgPSBuZXcgQ2FtZXJhKCk7XG5cbiAgICAvLyBCaW5kaW5nIGNhbWVyYSBldmVudHNcbiAgICBfdGhpcy5iaW5kQ2FtZXJhSGFuZGxlcnMoKTtcblxuICAgIC8vIEluaXRpYWxpemluZyBjYXB0b3JzXG4gICAgX3RoaXMubW91c2VDYXB0b3IgPSBuZXcgTW91c2VDYXB0b3IoX3RoaXMuZWxlbWVudHMubW91c2UsIF90aGlzKTtcbiAgICBfdGhpcy5tb3VzZUNhcHRvci5zZXRTZXR0aW5ncyhfdGhpcy5zZXR0aW5ncyk7XG4gICAgX3RoaXMudG91Y2hDYXB0b3IgPSBuZXcgVG91Y2hDYXB0b3IoX3RoaXMuZWxlbWVudHMubW91c2UsIF90aGlzKTtcbiAgICBfdGhpcy50b3VjaENhcHRvci5zZXRTZXR0aW5ncyhfdGhpcy5zZXR0aW5ncyk7XG5cbiAgICAvLyBCaW5kaW5nIGV2ZW50IGhhbmRsZXJzXG4gICAgX3RoaXMuYmluZEV2ZW50SGFuZGxlcnMoKTtcblxuICAgIC8vIEJpbmRpbmcgZ3JhcGggaGFuZGxlcnNcbiAgICBfdGhpcy5iaW5kR3JhcGhIYW5kbGVycygpO1xuXG4gICAgLy8gVHJpZ2dlciBldmVudHVhbCBzZXR0aW5ncy1yZWxhdGVkIHRoaW5nc1xuICAgIF90aGlzLmhhbmRsZVNldHRpbmdzVXBkYXRlKCk7XG5cbiAgICAvLyBQcm9jZXNzaW5nIGRhdGEgZm9yIHRoZSBmaXJzdCB0aW1lICYgcmVuZGVyXG4gICAgX3RoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBJbnRlcm5hbCBtZXRob2RzLlxuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gcmVnaXN0ZXIgYSBub2RlIHByb2dyYW1cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAga2V5ICAgICAgICAgICAgICAtIFRoZSBwcm9ncmFtJ3Mga2V5LCBtYXRjaGluZyB0aGUgcmVsYXRlZCBub2RlcyBcInR5cGVcIiB2YWx1ZXMuXG4gICAqIEBwYXJhbSAge05vZGVQcm9ncmFtVHlwZX0gIE5vZGVQcm9ncmFtQ2xhc3MgLSBBIG5vZGVzIHByb2dyYW0gY2xhc3MuXG4gICAqIEBwYXJhbSAge05vZGVQcm9ncmFtVHlwZT99IE5vZGVIb3ZlclByb2dyYW0gLSBBIG5vZGVzIHByb2dyYW0gY2xhc3MgdG8gcmVuZGVyIGhvdmVyZWQgbm9kZXMgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybiB7U2lnbWF9XG4gICAqL1xuICBfaW5oZXJpdHMoU2lnbWEsIF9UeXBlZEV2ZW50RW1pdHRlcik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoU2lnbWEsIFt7XG4gICAga2V5OiBcInJlZ2lzdGVyTm9kZVByb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJOb2RlUHJvZ3JhbShrZXksIE5vZGVQcm9ncmFtQ2xhc3MsIE5vZGVIb3ZlclByb2dyYW0pIHtcbiAgICAgIGlmICh0aGlzLm5vZGVQcm9ncmFtc1trZXldKSB0aGlzLm5vZGVQcm9ncmFtc1trZXldLmtpbGwoKTtcbiAgICAgIGlmICh0aGlzLm5vZGVIb3ZlclByb2dyYW1zW2tleV0pIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNba2V5XS5raWxsKCk7XG4gICAgICB0aGlzLm5vZGVQcm9ncmFtc1trZXldID0gbmV3IE5vZGVQcm9ncmFtQ2xhc3ModGhpcy53ZWJHTENvbnRleHRzLm5vZGVzLCB0aGlzLmZyYW1lQnVmZmVycy5ub2RlcywgdGhpcyk7XG4gICAgICB0aGlzLm5vZGVIb3ZlclByb2dyYW1zW2tleV0gPSBuZXcgKE5vZGVIb3ZlclByb2dyYW0gfHwgTm9kZVByb2dyYW1DbGFzcykodGhpcy53ZWJHTENvbnRleHRzLmhvdmVyTm9kZXMsIG51bGwsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byByZWdpc3RlciBhbiBlZGdlIHByb2dyYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAga2V5ICAgICAgICAgICAgICAtIFRoZSBwcm9ncmFtJ3Mga2V5LCBtYXRjaGluZyB0aGUgcmVsYXRlZCBlZGdlcyBcInR5cGVcIiB2YWx1ZXMuXG4gICAgICogQHBhcmFtICB7RWRnZVByb2dyYW1UeXBlfSBFZGdlUHJvZ3JhbUNsYXNzIC0gQW4gZWRnZXMgcHJvZ3JhbSBjbGFzcy5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZWdpc3RlckVkZ2VQcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyRWRnZVByb2dyYW0oa2V5LCBFZGdlUHJvZ3JhbUNsYXNzKSB7XG4gICAgICBpZiAodGhpcy5lZGdlUHJvZ3JhbXNba2V5XSkgdGhpcy5lZGdlUHJvZ3JhbXNba2V5XS5raWxsKCk7XG4gICAgICB0aGlzLmVkZ2VQcm9ncmFtc1trZXldID0gbmV3IEVkZ2VQcm9ncmFtQ2xhc3ModGhpcy53ZWJHTENvbnRleHRzLmVkZ2VzLCB0aGlzLmZyYW1lQnVmZmVycy5lZGdlcywgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHVucmVnaXN0ZXIgYSBub2RlIHByb2dyYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IC0gVGhlIHByb2dyYW0ncyBrZXksIG1hdGNoaW5nIHRoZSByZWxhdGVkIG5vZGVzIFwidHlwZVwiIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1bnJlZ2lzdGVyTm9kZVByb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5yZWdpc3Rlck5vZGVQcm9ncmFtKGtleSkge1xuICAgICAgaWYgKHRoaXMubm9kZVByb2dyYW1zW2tleV0pIHtcbiAgICAgICAgdmFyIF90aGlzJG5vZGVQcm9ncmFtcyA9IHRoaXMubm9kZVByb2dyYW1zLFxuICAgICAgICAgIHByb2dyYW0gPSBfdGhpcyRub2RlUHJvZ3JhbXNba2V5XSxcbiAgICAgICAgICBwcm9ncmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRub2RlUHJvZ3JhbXMsIFtrZXldLm1hcChfdG9Qcm9wZXJ0eUtleSkpO1xuICAgICAgICBwcm9ncmFtLmtpbGwoKTtcbiAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXMgPSBwcm9ncmFtcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5vZGVIb3ZlclByb2dyYW1zW2tleV0pIHtcbiAgICAgICAgdmFyIF90aGlzJG5vZGVIb3ZlclByb2dyYSA9IHRoaXMubm9kZUhvdmVyUHJvZ3JhbXMsXG4gICAgICAgICAgX3Byb2dyYW0gPSBfdGhpcyRub2RlSG92ZXJQcm9ncmFba2V5XSxcbiAgICAgICAgICBfcHJvZ3JhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkbm9kZUhvdmVyUHJvZ3JhLCBba2V5XS5tYXAoX3RvUHJvcGVydHlLZXkpKTtcbiAgICAgICAgX3Byb2dyYW0ua2lsbCgpO1xuICAgICAgICB0aGlzLm5vZGVQcm9ncmFtcyA9IF9wcm9ncmFtcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gdW5yZWdpc3RlciBhbiBlZGdlIHByb2dyYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IC0gVGhlIHByb2dyYW0ncyBrZXksIG1hdGNoaW5nIHRoZSByZWxhdGVkIGVkZ2VzIFwidHlwZVwiIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1bnJlZ2lzdGVyRWRnZVByb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5yZWdpc3RlckVkZ2VQcm9ncmFtKGtleSkge1xuICAgICAgaWYgKHRoaXMuZWRnZVByb2dyYW1zW2tleV0pIHtcbiAgICAgICAgdmFyIF90aGlzJGVkZ2VQcm9ncmFtcyA9IHRoaXMuZWRnZVByb2dyYW1zLFxuICAgICAgICAgIHByb2dyYW0gPSBfdGhpcyRlZGdlUHJvZ3JhbXNba2V5XSxcbiAgICAgICAgICBwcm9ncmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRlZGdlUHJvZ3JhbXMsIFtrZXldLm1hcChfdG9Qcm9wZXJ0eUtleSkpO1xuICAgICAgICBwcm9ncmFtLmtpbGwoKTtcbiAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXMgPSBwcm9ncmFtcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCAocmUpYmluZGluZyBXZWJHTCB0ZXh0dXJlIChmb3IgcGlja2luZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFdlYkdMVGV4dHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFdlYkdMVGV4dHVyZShpZCkge1xuICAgICAgdmFyIGdsID0gdGhpcy53ZWJHTENvbnRleHRzW2lkXTtcbiAgICAgIHZhciBmcmFtZUJ1ZmZlciA9IHRoaXMuZnJhbWVCdWZmZXJzW2lkXTtcbiAgICAgIHZhciBjdXJyZW50VGV4dHVyZSA9IHRoaXMudGV4dHVyZXNbaWRdO1xuICAgICAgaWYgKGN1cnJlbnRUZXh0dXJlKSBnbC5kZWxldGVUZXh0dXJlKGN1cnJlbnRUZXh0dXJlKTtcbiAgICAgIHZhciBwaWNraW5nVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgcGlja2luZ1RleHR1cmUpO1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHBpY2tpbmdUZXh0dXJlLCAwKTtcbiAgICAgIHRoaXMudGV4dHVyZXNbaWRdID0gcGlja2luZ1RleHR1cmU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgYmluZGluZyBjYW1lcmEgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJiaW5kQ2FtZXJhSGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZENhbWVyYUhhbmRsZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY2FtZXJhLm9uKFwidXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jYW1lcmEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVuYmluZGluZyBjYW1lcmEgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRDYW1lcmFIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRDYW1lcmFIYW5kbGVycygpIHtcbiAgICAgIHRoaXMuY2FtZXJhLnJlbW92ZUxpc3RlbmVyKFwidXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jYW1lcmEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgY2xvc2VzdCBub2RlIHRvIGEgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9kZUF0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZUF0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgIHZhciB4ID0gcG9zaXRpb24ueCxcbiAgICAgICAgeSA9IHBvc2l0aW9uLnk7XG4gICAgICB2YXIgY29sb3IgPSBnZXRQaXhlbENvbG9yKHRoaXMud2ViR0xDb250ZXh0cy5ub2RlcywgdGhpcy5mcmFtZUJ1ZmZlcnMubm9kZXMsIHgsIHksIHRoaXMucGl4ZWxSYXRpbywgdGhpcy5waWNraW5nRG93blNpemluZ1JhdGlvKTtcbiAgICAgIHZhciBpbmRleCA9IGNvbG9yVG9JbmRleC5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShjb2xvcikpO1xuICAgICAgdmFyIGl0ZW1BdCA9IHRoaXMuaXRlbUlEc0luZGV4W2luZGV4XTtcbiAgICAgIHJldHVybiBpdGVtQXQgJiYgaXRlbUF0LnR5cGUgPT09IFwibm9kZVwiID8gaXRlbUF0LmlkIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgYmluZGluZyBldmVudCBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImJpbmRFdmVudEhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudEhhbmRsZXJzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICAvLyBIYW5kbGluZyB3aW5kb3cgcmVzaXplXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5lZWQgdG8gY2FsbCBhIHJlZnJlc2ggdG8gcmVidWlsZCB0aGUgbGFiZWxncmlkXG4gICAgICAgIF90aGlzMy5zY2hlZHVsZVJlZnJlc2goKTtcbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVSZXNpemUpO1xuXG4gICAgICAvLyBIYW5kbGluZyBtb3VzZSBtb3ZlXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY2xlYW5Nb3VzZUNvb3JkcyhlKTtcbiAgICAgICAgdmFyIGJhc2VFdmVudCA9IHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gcHJldmVudFNpZ21hRGVmYXVsdCgpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnRTaWdtYURlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBub2RlVG9Ib3ZlciA9IF90aGlzMy5nZXROb2RlQXRQb3NpdGlvbihldmVudCk7XG4gICAgICAgIGlmIChub2RlVG9Ib3ZlciAmJiBfdGhpczMuaG92ZXJlZE5vZGUgIT09IG5vZGVUb0hvdmVyICYmICFfdGhpczMubm9kZURhdGFDYWNoZVtub2RlVG9Ib3Zlcl0uaGlkZGVuKSB7XG4gICAgICAgICAgLy8gSGFuZGxpbmcgcGFzc2luZyBmcm9tIG9uZSBub2RlIHRvIHRoZSBvdGhlciBkaXJlY3RseVxuICAgICAgICAgIGlmIChfdGhpczMuaG92ZXJlZE5vZGUpIF90aGlzMy5lbWl0KFwibGVhdmVOb2RlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgbm9kZTogX3RoaXMzLmhvdmVyZWROb2RlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIF90aGlzMy5ob3ZlcmVkTm9kZSA9IG5vZGVUb0hvdmVyO1xuICAgICAgICAgIF90aGlzMy5lbWl0KFwiZW50ZXJOb2RlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgbm9kZTogbm9kZVRvSG92ZXJcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgX3RoaXMzLnNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlcigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNraW5nIGlmIHRoZSBob3ZlcmVkIG5vZGUgaXMgc3RpbGwgaG92ZXJlZFxuICAgICAgICBpZiAoX3RoaXMzLmhvdmVyZWROb2RlKSB7XG4gICAgICAgICAgaWYgKF90aGlzMy5nZXROb2RlQXRQb3NpdGlvbihldmVudCkgIT09IF90aGlzMy5ob3ZlcmVkTm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBfdGhpczMuaG92ZXJlZE5vZGU7XG4gICAgICAgICAgICBfdGhpczMuaG92ZXJlZE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMzLmVtaXQoXCJsZWF2ZU5vZGVcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIF90aGlzMy5zY2hlZHVsZUhpZ2hsaWdodGVkTm9kZXNSZW5kZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzMy5zZXR0aW5ncy5lbmFibGVFZGdlRXZlbnRzKSB7XG4gICAgICAgICAgdmFyIGVkZ2VUb0hvdmVyID0gX3RoaXMzLmhvdmVyZWROb2RlID8gbnVsbCA6IF90aGlzMy5nZXRFZGdlQXRQb2ludChiYXNlRXZlbnQuZXZlbnQueCwgYmFzZUV2ZW50LmV2ZW50LnkpO1xuICAgICAgICAgIGlmIChlZGdlVG9Ib3ZlciAhPT0gX3RoaXMzLmhvdmVyZWRFZGdlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMzLmhvdmVyZWRFZGdlKSBfdGhpczMuZW1pdChcImxlYXZlRWRnZVwiLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgICAgZWRnZTogX3RoaXMzLmhvdmVyZWRFZGdlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoZWRnZVRvSG92ZXIpIF90aGlzMy5lbWl0KFwiZW50ZXJFZGdlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgICBlZGdlOiBlZGdlVG9Ib3ZlclxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgX3RoaXMzLmhvdmVyZWRFZGdlID0gZWRnZVRvSG92ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBIYW5kbGluZyBtb3VzZSBtb3ZlIG92ZXIgYm9keSAob25seSB0byBkaXNwYXRjaCB0aGUgcHJvcGVyIGV2ZW50KTpcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZU1vdmVCb2R5ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY2xlYW5Nb3VzZUNvb3JkcyhlKTtcbiAgICAgICAgX3RoaXMzLmVtaXQoXCJtb3ZlQm9keVwiLCB7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50U2lnbWFEZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsaW5nIG1vdXNlIGxlYXZlIHN0YWdlOlxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTGVhdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjbGVhbk1vdXNlQ29vcmRzKGUpO1xuICAgICAgICB2YXIgYmFzZUV2ZW50ID0ge1xuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudFNpZ21hRGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKF90aGlzMy5ob3ZlcmVkTm9kZSkge1xuICAgICAgICAgIF90aGlzMy5lbWl0KFwibGVhdmVOb2RlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgbm9kZTogX3RoaXMzLmhvdmVyZWROb2RlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIF90aGlzMy5zY2hlZHVsZUhpZ2hsaWdodGVkTm9kZXNSZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMzLnNldHRpbmdzLmVuYWJsZUVkZ2VFdmVudHMgJiYgX3RoaXMzLmhvdmVyZWRFZGdlKSB7XG4gICAgICAgICAgX3RoaXMzLmVtaXQoXCJsZWF2ZUVkZ2VcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICBlZGdlOiBfdGhpczMuaG92ZXJlZEVkZ2VcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgX3RoaXMzLnNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMy5lbWl0KFwibGVhdmVTdGFnZVwiLCBfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBIYW5kbGluZyBtb3VzZSBlbnRlciBzdGFnZTpcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZUVudGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY2xlYW5Nb3VzZUNvb3JkcyhlKTtcbiAgICAgICAgdmFyIGJhc2VFdmVudCA9IHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gcHJldmVudFNpZ21hRGVmYXVsdCgpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnRTaWdtYURlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzMy5lbWl0KFwiZW50ZXJTdGFnZVwiLCBfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBIYW5kbGluZyBjbGlja1xuICAgICAgdmFyIGNyZWF0ZUludGVyYWN0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiBjcmVhdGVJbnRlcmFjdGlvbkxpc3RlbmVyKGV2ZW50VHlwZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgZXZlbnQgPSBjbGVhbk1vdXNlQ29vcmRzKGUpO1xuICAgICAgICAgIHZhciBiYXNlRXZlbnQgPSB7XG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50U2lnbWFEZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgbm9kZUF0UG9zaXRpb24gPSBfdGhpczMuZ2V0Tm9kZUF0UG9zaXRpb24oZXZlbnQpO1xuICAgICAgICAgIGlmIChub2RlQXRQb3NpdGlvbikgcmV0dXJuIF90aGlzMy5lbWl0KFwiXCIuY29uY2F0KGV2ZW50VHlwZSwgXCJOb2RlXCIpLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVBdFBvc2l0aW9uXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGlmIChfdGhpczMuc2V0dGluZ3MuZW5hYmxlRWRnZUV2ZW50cykge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczMuZ2V0RWRnZUF0UG9pbnQoZXZlbnQueCwgZXZlbnQueSk7XG4gICAgICAgICAgICBpZiAoZWRnZSkgcmV0dXJuIF90aGlzMy5lbWl0KFwiXCIuY29uY2F0KGV2ZW50VHlwZSwgXCJFZGdlXCIpLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgICAgZWRnZTogZWRnZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3RoaXMzLmVtaXQoXCJcIi5jb25jYXQoZXZlbnRUeXBlLCBcIlN0YWdlXCIpLCBiYXNlRXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZUNsaWNrID0gY3JlYXRlSW50ZXJhY3Rpb25MaXN0ZW5lcihcImNsaWNrXCIpO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlUmlnaHRDbGljayA9IGNyZWF0ZUludGVyYWN0aW9uTGlzdGVuZXIoXCJyaWdodENsaWNrXCIpO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRG91YmxlQ2xpY2sgPSBjcmVhdGVJbnRlcmFjdGlvbkxpc3RlbmVyKFwiZG91YmxlQ2xpY2tcIik7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVXaGVlbCA9IGNyZWF0ZUludGVyYWN0aW9uTGlzdGVuZXIoXCJ3aGVlbFwiKTtcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvd24gPSBjcmVhdGVJbnRlcmFjdGlvbkxpc3RlbmVyKFwiZG93blwiKTtcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVVwID0gY3JlYXRlSW50ZXJhY3Rpb25MaXN0ZW5lcihcInVwXCIpO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNlbW92ZVwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVNb3ZlKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJtb3VzZW1vdmVib2R5XCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZU1vdmVCb2R5KTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJjbGlja1wiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVDbGljayk7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwicmlnaHRDbGlja1wiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVSaWdodENsaWNrKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJkb3VibGVDbGlja1wiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVEb3VibGVDbGljayk7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwid2hlZWxcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlV2hlZWwpO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNlZG93blwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVEb3duKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJtb3VzZXVwXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVVwKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJtb3VzZWxlYXZlXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZUxlYXZlKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJtb3VzZWVudGVyXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZUVudGVyKTtcbiAgICAgIHRoaXMudG91Y2hDYXB0b3Iub24oXCJ0b3VjaGRvd25cIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRG93bik7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLm9uKFwidG91Y2hkb3duXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZU1vdmUpO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5vbihcInRvdWNodXBcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlVXApO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5vbihcInRvdWNobW92ZVwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVNb3ZlKTtcbiAgICAgIHRoaXMudG91Y2hDYXB0b3Iub24oXCJ0YXBcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlQ2xpY2spO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5vbihcImRvdWJsZXRhcFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVEb3VibGVDbGljayk7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLm9uKFwidG91Y2htb3ZlXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZU1vdmVCb2R5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBiaW5kaW5nIGdyYXBoIGhhbmRsZXJzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJiaW5kR3JhcGhIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kR3JhcGhIYW5kbGVycygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgIHZhciBMQVlPVVRfSU1QQUNUSU5HX0ZJRUxEUyA9IG5ldyBTZXQoW1wieFwiLCBcInlcIiwgXCJ6SW5kZXhcIiwgXCJ0eXBlXCJdKTtcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmVhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZWRHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfZSRoaW50cztcbiAgICAgICAgdmFyIHVwZGF0ZWRGaWVsZHMgPSAoX2UkaGludHMgPSBlLmhpbnRzKSA9PT0gbnVsbCB8fCBfZSRoaW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UkaGludHMuYXR0cmlidXRlcztcbiAgICAgICAgLy8gd2UgcHJvY2VzcyBhbGwgbm9kZXNcbiAgICAgICAgX3RoaXM0LmdyYXBoLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC51cGRhdGVOb2RlKG5vZGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiBjb29yZCwgdHlwZSBvciB6SW5kZXggaGF2ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgcmVuZGVyXG4gICAgICAgIC8vICh6SW5kZXggZm9yIHRoZSBwcm9ncmFtSW5kZXgpXG4gICAgICAgIHZhciBsYXlvdXRDaGFuZ2VkID0gIXVwZGF0ZWRGaWVsZHMgfHwgdXBkYXRlZEZpZWxkcy5zb21lKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIExBWU9VVF9JTVBBQ1RJTkdfRklFTERTLmhhcyhmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBwYXJ0aWFsR3JhcGg6IHtcbiAgICAgICAgICAgIG5vZGVzOiBncmFwaC5ub2RlcygpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBza2lwSW5kZXhhdGlvbjogIWxheW91dENoYW5nZWQsXG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZWFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlZEdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9lJGhpbnRzMjtcbiAgICAgICAgdmFyIHVwZGF0ZWRGaWVsZHMgPSAoX2UkaGludHMyID0gZS5oaW50cykgPT09IG51bGwgfHwgX2UkaGludHMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZSRoaW50czIuYXR0cmlidXRlcztcbiAgICAgICAgLy8gd2UgcHJvY2VzcyBhbGwgZWRnZXNcbiAgICAgICAgX3RoaXM0LmdyYXBoLmZvckVhY2hFZGdlKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC51cGRhdGVFZGdlKGVkZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxheW91dENoYW5nZWQgPSB1cGRhdGVkRmllbGRzICYmIFtcInpJbmRleFwiLCBcInR5cGVcIl0uc29tZShmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVkRmllbGRzID09PSBudWxsIHx8IHVwZGF0ZWRGaWVsZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVwZGF0ZWRGaWVsZHMuaW5jbHVkZXMoZik7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgcGFydGlhbEdyYXBoOiB7XG4gICAgICAgICAgICBlZGdlczogZ3JhcGguZWRnZXMoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2tpcEluZGV4YXRpb246ICFsYXlvdXRDaGFuZ2VkLFxuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gYWRkIG5vZGUsIHdlIGFkZCB0aGUgbm9kZSBpbiBpbmRpY2VzIGFuZCB0aGVuIGNhbGwgZm9yIGEgcmVuZGVyXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5hZGROb2RlR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHBheWxvYWQua2V5O1xuICAgICAgICAvLyB3ZSBwcm9jZXNzIHRoZSBub2RlXG4gICAgICAgIF90aGlzNC5hZGROb2RlKG5vZGUpO1xuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlbmRlciBmb3IgdGhlIG5vZGVcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHBhcnRpYWxHcmFwaDoge1xuICAgICAgICAgICAgbm9kZXM6IFtub2RlXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2tpcEluZGV4YXRpb246IGZhbHNlLFxuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gdXBkYXRlIG5vZGUsIHdlIHVwZGF0ZSBpbmRpY2VzIGFuZCB0aGVuIGNhbGwgZm9yIGEgcmVuZGVyXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy51cGRhdGVOb2RlR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHBheWxvYWQua2V5O1xuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlbmRlciBmb3IgdGhlIG5vZGVcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHBhcnRpYWxHcmFwaDoge1xuICAgICAgICAgICAgbm9kZXM6IFtub2RlXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2tpcEluZGV4YXRpb246IGZhbHNlLFxuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gZHJvcCBub2RlLCB3ZSByZW1vdmUgdGhlIG5vZGUgZnJvbSBpbmRpY2VzIGFuZCB0aGVuIGNhbGwgZm9yIGEgcmVmcmVzaFxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcE5vZGVHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBub2RlID0gcGF5bG9hZC5rZXk7XG4gICAgICAgIC8vIHdlIHByb2Nlc3MgdGhlIG5vZGVcbiAgICAgICAgX3RoaXM0LnJlbW92ZU5vZGUobm9kZSk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciBldmVyeXRoaW5nXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIGFkZCBlZGdlLCB3ZSByZW1vdmUgdGhlIGVkZ2UgZnJvbSBpbmRpY2VzIGFuZCB0aGVuIGNhbGwgZm9yIGEgcmVmcmVzaFxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuYWRkRWRnZUdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBwYXlsb2FkLmtleTtcbiAgICAgICAgLy8gd2UgcHJvY2VzcyB0aGUgZWRnZVxuICAgICAgICBfdGhpczQuYWRkRWRnZShlZGdlKTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIHRoZSBlZGdlXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBwYXJ0aWFsR3JhcGg6IHtcbiAgICAgICAgICAgIGVkZ2VzOiBbZWRnZV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gdXBkYXRlIGVkZ2UsIHdlIHVwZGF0ZSBpbmRpY2VzIGFuZCB0aGVuIGNhbGwgZm9yIGEgcmVmcmVzaFxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMudXBkYXRlRWRnZUdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBwYXlsb2FkLmtleTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZXBhaW50IGZvciB0aGUgZWRnZVxuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgcGFydGlhbEdyYXBoOiB7XG4gICAgICAgICAgICBlZGdlczogW2VkZ2VdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBza2lwSW5kZXhhdGlvbjogZmFsc2UsXG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiBkcm9wIGVkZ2UsIHdlIHJlbW92ZSB0aGUgZWRnZSBmcm9tIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZWZyZXNoXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5kcm9wRWRnZUdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBwYXlsb2FkLmtleTtcbiAgICAgICAgLy8gd2UgcHJvY2VzcyB0aGUgZWRnZVxuICAgICAgICBfdGhpczQucmVtb3ZlRWRnZShlZGdlKTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIGFsbCBlZGdlc1xuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiBjbGVhciBlZGdlcywgd2UgY2xlYXIgdGhlIGVkZ2UgaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlZnJlc2hcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyRWRnZXNHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gd2UgY2xlYXIgdGhlIGVkZ2UgZGF0YSBzdHJ1Y3R1cmVzXG4gICAgICAgIF90aGlzNC5jbGVhckVkZ2VTdGF0ZSgpO1xuICAgICAgICBfdGhpczQuY2xlYXJFZGdlSW5kaWNlcygpO1xuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlbmRlciBmb3IgYWxsIGVkZ2VzXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIGdyYXBoIGNsZWFyLCB3ZSBjbGVhciBpbmRpY2VzIGFuZCB0aGVuIGNhbGwgZm9yIGEgcmVmcmVzaFxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2xlYXJHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2xlYXIgZ3JhcGggc3RhdGVcbiAgICAgICAgX3RoaXM0LmNsZWFyRWRnZVN0YXRlKCk7XG4gICAgICAgIF90aGlzNC5jbGVhck5vZGVTdGF0ZSgpO1xuXG4gICAgICAgIC8vIGNsZWFyIGdyYXBoIGluZGljZXNcbiAgICAgICAgX3RoaXM0LmNsZWFyRWRnZUluZGljZXMoKTtcbiAgICAgICAgX3RoaXM0LmNsZWFyTm9kZUluZGljZXMoKTtcblxuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlbmRlciBmb3IgYWxsXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBncmFwaC5vbihcIm5vZGVBZGRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5hZGROb2RlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJub2RlRHJvcHBlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5kcm9wTm9kZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwibm9kZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnVwZGF0ZU5vZGVHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImVhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZWFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlZEdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwiZWRnZUFkZGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmFkZEVkZ2VHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImVkZ2VEcm9wcGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BFZGdlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJlZGdlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMudXBkYXRlRWRnZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwiZWFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5lYWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVkR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJlZGdlc0NsZWFyZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2xlYXJFZGdlc0dyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwiY2xlYXJlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckdyYXBoVXBkYXRlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHVuYmluZCBoYW5kbGVycyBmcm9tIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRHcmFwaEhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZEdyYXBoSGFuZGxlcnMoKSB7XG4gICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJub2RlQWRkZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuYWRkTm9kZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwibm9kZURyb3BwZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcE5vZGVHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcIm5vZGVBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy51cGRhdGVOb2RlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlYWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmVhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZWRHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcImVkZ2VBZGRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5hZGRFZGdlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlZGdlRHJvcHBlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5kcm9wRWRnZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnVwZGF0ZUVkZ2VHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcImVhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZWFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlZEdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWRnZXNDbGVhcmVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyRWRnZXNHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcImNsZWFyZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2xlYXJHcmFwaFVwZGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGxvb2tpbmcgZm9yIGFuIGVkZ2UgY29sbGlkaW5nIHdpdGggYSBnaXZlbiBwb2ludCBhdCAoeCwgeSkuIFJldHVybnNcbiAgICAgKiB0aGUga2V5IG9mIHRoZSBlZGdlIGlmIGFueSwgb3IgbnVsbCBlbHNlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEVkZ2VBdFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVkZ2VBdFBvaW50KHgsIHkpIHtcbiAgICAgIHZhciBjb2xvciA9IGdldFBpeGVsQ29sb3IodGhpcy53ZWJHTENvbnRleHRzLmVkZ2VzLCB0aGlzLmZyYW1lQnVmZmVycy5lZGdlcywgeCwgeSwgdGhpcy5waXhlbFJhdGlvLCB0aGlzLnBpY2tpbmdEb3duU2l6aW5nUmF0aW8pO1xuICAgICAgdmFyIGluZGV4ID0gY29sb3JUb0luZGV4LmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGNvbG9yKSk7XG4gICAgICB2YXIgaXRlbUF0ID0gdGhpcy5pdGVtSURzSW5kZXhbaW5kZXhdO1xuICAgICAgcmV0dXJuIGl0ZW1BdCAmJiBpdGVtQXQudHlwZSA9PT0gXCJlZGdlXCIgPyBpdGVtQXQuaWQgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHByb2Nlc3MgdGhlIHdob2xlIGdyYXBoJ3MgZGF0YS5cbiAgICAgKiAgLSBleHRlbnRcbiAgICAgKiAgLSBub3JtYWxpemF0aW9uRnVuY3Rpb25cbiAgICAgKiAgLSBjb21wdXRlIG5vZGUncyBjb29yZGluYXRlXG4gICAgICogIC0gbGFiZWxncmlkXG4gICAgICogIC0gcHJvZ3JhbSBkYXRhIGFsbG9jYXRpb25cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIHRoaXMuZW1pdChcImJlZm9yZVByb2Nlc3NcIik7XG4gICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zKCk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBOT0RFU1xuICAgICAgLy9cbiAgICAgIHRoaXMubm9kZUV4dGVudCA9IGdyYXBoRXh0ZW50KHRoaXMuZ3JhcGgpO1xuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmF1dG9SZXNjYWxlKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGRpbWVuc2lvbnMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgIHZhciBfdGhpcyRub2RlRXh0ZW50ID0gdGhpcy5ub2RlRXh0ZW50LFxuICAgICAgICAgIHggPSBfdGhpcyRub2RlRXh0ZW50LngsXG4gICAgICAgICAgeSA9IF90aGlzJG5vZGVFeHRlbnQueTtcbiAgICAgICAgdGhpcy5ub2RlRXh0ZW50ID0ge1xuICAgICAgICAgIHg6IFsoeFswXSArIHhbMV0pIC8gMiAtIHdpZHRoIC8gMiwgKHhbMF0gKyB4WzFdKSAvIDIgKyB3aWR0aCAvIDJdLFxuICAgICAgICAgIHk6IFsoeVswXSArIHlbMV0pIC8gMiAtIGhlaWdodCAvIDIsICh5WzBdICsgeVsxXSkgLyAyICsgaGVpZ2h0IC8gMl1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uID0gY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uKHRoaXMuY3VzdG9tQkJveCB8fCB0aGlzLm5vZGVFeHRlbnQpO1xuXG4gICAgICAvLyBOT1RFOiBpdCBpcyBpbXBvcnRhbnQgdG8gY29tcHV0ZSB0aGlzIG1hdHJpeCBhZnRlciBjb21wdXRpbmcgdGhlIG5vZGUncyBleHRlbnRcbiAgICAgIC8vIGJlY2F1c2UgIy5nZXRHcmFwaERpbWVuc2lvbnMgcmVsaWVzIG9uIGl0XG4gICAgICB2YXIgbnVsbENhbWVyYSA9IG5ldyBDYW1lcmEoKTtcbiAgICAgIHZhciBudWxsQ2FtZXJhTWF0cml4ID0gbWF0cml4RnJvbUNhbWVyYShudWxsQ2FtZXJhLmdldFN0YXRlKCksIGRpbWVuc2lvbnMsIHRoaXMuZ2V0R3JhcGhEaW1lbnNpb25zKCksIHRoaXMuZ2V0U3RhZ2VQYWRkaW5nKCkpO1xuICAgICAgLy8gUmVzZXR0aW5nIHRoZSBsYWJlbCBncmlkXG4gICAgICAvLyBUT0RPOiBpdCdzIHByb2JhYmx5IGJldHRlciB0byBkbyB0aGlzIGV4cGxpY2l0bHkgb3Igb24gcmVzaXplcyBmb3IgbGF5b3V0IGFuZCBhbmltc1xuICAgICAgdGhpcy5sYWJlbEdyaWQucmVzaXplQW5kQ2xlYXIoZGltZW5zaW9ucywgc2V0dGluZ3MubGFiZWxHcmlkQ2VsbFNpemUpO1xuICAgICAgdmFyIG5vZGVzUGVyUHJvZ3JhbXMgPSB7fTtcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHt9O1xuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0ge307XG4gICAgICB2YXIgaXRlbUlEc0luZGV4ID0ge307XG4gICAgICB2YXIgaW5jcklEID0gMTtcbiAgICAgIHZhciBub2RlcyA9IGdyYXBoLm5vZGVzKCk7XG5cbiAgICAgIC8vIERvIHNvbWUgaW5kZXhhdGlvbiBvbiB0aGUgd2hvbGUgZ3JhcGhcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW25vZGVdO1xuXG4gICAgICAgIC8vIEdldCBpbml0aWFsIGNvb3JkaW5hdGVzXG4gICAgICAgIHZhciBhdHRycyA9IGdyYXBoLmdldE5vZGVBdHRyaWJ1dGVzKG5vZGUpO1xuICAgICAgICBkYXRhLnggPSBhdHRycy54O1xuICAgICAgICBkYXRhLnkgPSBhdHRycy55O1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbi5hcHBseVRvKGRhdGEpO1xuXG4gICAgICAgIC8vIGxhYmVsZ3JpZFxuICAgICAgICBpZiAodHlwZW9mIGRhdGEubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgIWRhdGEuaGlkZGVuKSB0aGlzLmxhYmVsR3JpZC5hZGQobm9kZSwgZGF0YS5zaXplLCB0aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydChkYXRhLCB7XG4gICAgICAgICAgbWF0cml4OiBudWxsQ2FtZXJhTWF0cml4XG4gICAgICAgIH0pKTtcblxuICAgICAgICAvLyB1cGRhdGUgY291bnQgcGVyIHByb2dyYW1cbiAgICAgICAgbm9kZXNQZXJQcm9ncmFtc1tkYXRhLnR5cGVdID0gKG5vZGVzUGVyUHJvZ3JhbXNbZGF0YS50eXBlXSB8fCAwKSArIDE7XG4gICAgICB9XG4gICAgICB0aGlzLmxhYmVsR3JpZC5vcmdhbml6ZSgpO1xuXG4gICAgICAvLyBBbGxvY2F0ZSBtZW1vcnkgdG8gcHJvZ3JhbXNcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5ub2RlUHJvZ3JhbXMpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubm9kZVByb2dyYW1zLCB0eXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjb3VsZCBub3QgZmluZCBhIHN1aXRhYmxlIHByb2dyYW0gZm9yIG5vZGUgdHlwZSBcXFwiXCIuY29uY2F0KHR5cGUsIFwiXFxcIiFcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZVByb2dyYW1zW3R5cGVdLnJlYWxsb2NhdGUobm9kZXNQZXJQcm9ncmFtc1t0eXBlXSB8fCAwKTtcbiAgICAgICAgLy8gV2UgcmVzZXQgdGhhdCBjb3VudCBoZXJlLCBzbyB0aGF0IHdlIGNhbiByZXVzZSBpdCB3aGlsZSBjYWxsaW5nIHRoZSBQcm9ncmFtI3Byb2Nlc3MgbWV0aG9kczpcbiAgICAgICAgbm9kZXNQZXJQcm9ncmFtc1t0eXBlXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIE9yZGVyIG5vZGVzIGJ5IHpJbmRleCBiZWZvcmUgdG8gYWRkIHRoZW0gdG8gcHJvZ3JhbVxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuekluZGV4ICYmIHRoaXMubm9kZVpFeHRlbnRbMF0gIT09IHRoaXMubm9kZVpFeHRlbnRbMV0pIG5vZGVzID0gekluZGV4T3JkZXJpbmcodGhpcy5ub2RlWkV4dGVudCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNS5ub2RlRGF0YUNhY2hlW25vZGVdLnpJbmRleDtcbiAgICAgIH0sIG5vZGVzKTtcblxuICAgICAgLy8gQWRkIGRhdGEgdG8gcHJvZ3JhbXNcbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2wgPSBub2Rlcy5sZW5ndGg7IF9pIDwgX2w7IF9pKyspIHtcbiAgICAgICAgdmFyIF9ub2RlID0gbm9kZXNbX2ldO1xuICAgICAgICBub2RlSW5kaWNlc1tfbm9kZV0gPSBpbmNySUQ7XG4gICAgICAgIGl0ZW1JRHNJbmRleFtub2RlSW5kaWNlc1tfbm9kZV1dID0ge1xuICAgICAgICAgIHR5cGU6IFwibm9kZVwiLFxuICAgICAgICAgIGlkOiBfbm9kZVxuICAgICAgICB9O1xuICAgICAgICBpbmNySUQrKztcbiAgICAgICAgdmFyIF9kYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW19ub2RlXTtcbiAgICAgICAgdGhpcy5hZGROb2RlVG9Qcm9ncmFtKF9ub2RlLCBub2RlSW5kaWNlc1tfbm9kZV0sIG5vZGVzUGVyUHJvZ3JhbXNbX2RhdGEudHlwZV0rKyk7XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICAvLyBFREdFU1xuICAgICAgLy9cblxuICAgICAgdmFyIGVkZ2VzUGVyUHJvZ3JhbXMgPSB7fTtcbiAgICAgIHZhciBlZGdlcyA9IGdyYXBoLmVkZ2VzKCk7XG5cbiAgICAgIC8vIEFsbG9jYXRlIG1lbW9yeSB0byBwcm9ncmFtc1xuICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2wyID0gZWRnZXMubGVuZ3RoOyBfaTIgPCBfbDI7IF9pMisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbX2kyXTtcbiAgICAgICAgdmFyIF9kYXRhMiA9IHRoaXMuZWRnZURhdGFDYWNoZVtlZGdlXTtcbiAgICAgICAgZWRnZXNQZXJQcm9ncmFtc1tfZGF0YTIudHlwZV0gPSAoZWRnZXNQZXJQcm9ncmFtc1tfZGF0YTIudHlwZV0gfHwgMCkgKyAxO1xuICAgICAgfVxuXG4gICAgICAvLyBPcmRlciBlZGdlcyBieSB6SW5kZXggYmVmb3JlIHRvIGFkZCB0aGVtIHRvIHByb2dyYW1cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnpJbmRleCAmJiB0aGlzLmVkZ2VaRXh0ZW50WzBdICE9PSB0aGlzLmVkZ2VaRXh0ZW50WzFdKSBlZGdlcyA9IHpJbmRleE9yZGVyaW5nKHRoaXMuZWRnZVpFeHRlbnQsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczUuZWRnZURhdGFDYWNoZVtlZGdlXS56SW5kZXg7XG4gICAgICB9LCBlZGdlcyk7XG4gICAgICBmb3IgKHZhciBfdHlwZTIgaW4gdGhpcy5lZGdlUHJvZ3JhbXMpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZWRnZVByb2dyYW1zLCBfdHlwZTIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvdWxkIG5vdCBmaW5kIGEgc3VpdGFibGUgcHJvZ3JhbSBmb3IgZWRnZSB0eXBlIFxcXCJcIi5jb25jYXQoX3R5cGUyLCBcIlxcXCIhXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1tfdHlwZTJdLnJlYWxsb2NhdGUoZWRnZXNQZXJQcm9ncmFtc1tfdHlwZTJdIHx8IDApO1xuICAgICAgICAvLyBXZSByZXNldCB0aGF0IGNvdW50IGhlcmUsIHNvIHRoYXQgd2UgY2FuIHJldXNlIGl0IHdoaWxlIGNhbGxpbmcgdGhlIFByb2dyYW0jcHJvY2VzcyBtZXRob2RzOlxuICAgICAgICBlZGdlc1BlclByb2dyYW1zW190eXBlMl0gPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgZGF0YSB0byBwcm9ncmFtc1xuICAgICAgZm9yICh2YXIgX2kzID0gMCwgX2wzID0gZWRnZXMubGVuZ3RoOyBfaTMgPCBfbDM7IF9pMysrKSB7XG4gICAgICAgIHZhciBfZWRnZSA9IGVkZ2VzW19pM107XG4gICAgICAgIGVkZ2VJbmRpY2VzW19lZGdlXSA9IGluY3JJRDtcbiAgICAgICAgaXRlbUlEc0luZGV4W2VkZ2VJbmRpY2VzW19lZGdlXV0gPSB7XG4gICAgICAgICAgdHlwZTogXCJlZGdlXCIsXG4gICAgICAgICAgaWQ6IF9lZGdlXG4gICAgICAgIH07XG4gICAgICAgIGluY3JJRCsrO1xuICAgICAgICB2YXIgX2RhdGEzID0gdGhpcy5lZGdlRGF0YUNhY2hlW19lZGdlXTtcbiAgICAgICAgdGhpcy5hZGRFZGdlVG9Qcm9ncmFtKF9lZGdlLCBlZGdlSW5kaWNlc1tfZWRnZV0sIGVkZ2VzUGVyUHJvZ3JhbXNbX2RhdGEzLnR5cGVdKyspO1xuICAgICAgfVxuICAgICAgdGhpcy5pdGVtSURzSW5kZXggPSBpdGVtSURzSW5kZXg7XG4gICAgICB0aGlzLm5vZGVJbmRpY2VzID0gbm9kZUluZGljZXM7XG4gICAgICB0aGlzLmVkZ2VJbmRpY2VzID0gZWRnZUluZGljZXM7XG4gICAgICB0aGlzLmVtaXQoXCJhZnRlclByb2Nlc3NcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBiYWNrcG9ydHMgcG90ZW50aWFsIHNldHRpbmdzIHVwZGF0ZXMgd2hlcmUgaXQncyBuZWVkZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVTZXR0aW5nc1VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVTZXR0aW5nc1VwZGF0ZShvbGRTZXR0aW5ncykge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgdGhpcy5jYW1lcmEubWluUmF0aW8gPSBzZXR0aW5ncy5taW5DYW1lcmFSYXRpbztcbiAgICAgIHRoaXMuY2FtZXJhLm1heFJhdGlvID0gc2V0dGluZ3MubWF4Q2FtZXJhUmF0aW87XG4gICAgICB0aGlzLmNhbWVyYS5lbmFibGVkWm9vbWluZyA9IHNldHRpbmdzLmVuYWJsZUNhbWVyYVpvb21pbmc7XG4gICAgICB0aGlzLmNhbWVyYS5lbmFibGVkUGFubmluZyA9IHNldHRpbmdzLmVuYWJsZUNhbWVyYVBhbm5pbmc7XG4gICAgICB0aGlzLmNhbWVyYS5lbmFibGVkUm90YXRpb24gPSBzZXR0aW5ncy5lbmFibGVDYW1lcmFSb3RhdGlvbjtcbiAgICAgIGlmIChzZXR0aW5ncy5jYW1lcmFQYW5Cb3VuZGFyaWVzKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhLmNsZWFuID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNi5jbGVhbkNhbWVyYVN0YXRlKHN0YXRlLCBzZXR0aW5ncy5jYW1lcmFQYW5Cb3VuZGFyaWVzICYmIF90eXBlb2Yoc2V0dGluZ3MuY2FtZXJhUGFuQm91bmRhcmllcykgPT09IFwib2JqZWN0XCIgPyBzZXR0aW5ncy5jYW1lcmFQYW5Cb3VuZGFyaWVzIDoge30pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYW1lcmEuY2xlYW4gPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jYW1lcmEuc2V0U3RhdGUodGhpcy5jYW1lcmEudmFsaWRhdGVTdGF0ZSh0aGlzLmNhbWVyYS5nZXRTdGF0ZSgpKSk7XG4gICAgICBpZiAob2xkU2V0dGluZ3MpIHtcbiAgICAgICAgLy8gQ2hlY2sgZWRnZSBwcm9ncmFtczpcbiAgICAgICAgaWYgKG9sZFNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3NlcyAhPT0gc2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBzZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXMpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXNbdHlwZV0gIT09IG9sZFNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlc1t0eXBlXSkge1xuICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyRWRnZVByb2dyYW0odHlwZSwgc2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzW3R5cGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgX3R5cGUzIGluIG9sZFNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXNbX3R5cGUzXSkgdGhpcy51bnJlZ2lzdGVyRWRnZVByb2dyYW0oX3R5cGUzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBub2RlIHByb2dyYW1zOlxuICAgICAgICBpZiAob2xkU2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzICE9PSBzZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXMgfHwgb2xkU2V0dGluZ3Mubm9kZUhvdmVyUHJvZ3JhbUNsYXNzZXMgIT09IHNldHRpbmdzLm5vZGVIb3ZlclByb2dyYW1DbGFzc2VzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX3R5cGU0IGluIHNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlc1tfdHlwZTRdICE9PSBvbGRTZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXNbX3R5cGU0XSB8fCBzZXR0aW5ncy5ub2RlSG92ZXJQcm9ncmFtQ2xhc3Nlc1tfdHlwZTRdICE9PSBvbGRTZXR0aW5ncy5ub2RlSG92ZXJQcm9ncmFtQ2xhc3Nlc1tfdHlwZTRdKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJOb2RlUHJvZ3JhbShfdHlwZTQsIHNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlc1tfdHlwZTRdLCBzZXR0aW5ncy5ub2RlSG92ZXJQcm9ncmFtQ2xhc3Nlc1tfdHlwZTRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgX3R5cGU1IGluIG9sZFNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXNbX3R5cGU1XSkgdGhpcy51bnJlZ2lzdGVyTm9kZVByb2dyYW0oX3R5cGU1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGNhcHRvcnMgc2V0dGluZ3M6XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLnNldFNldHRpbmdzKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5zZXRTZXR0aW5ncyh0aGlzLnNldHRpbmdzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbkNhbWVyYVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFuQ2FtZXJhU3RhdGUoc3RhdGUpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgX3JlZiR0b2xlcmFuY2UgPSBfcmVmLnRvbGVyYW5jZSxcbiAgICAgICAgdG9sZXJhbmNlID0gX3JlZiR0b2xlcmFuY2UgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHRvbGVyYW5jZSxcbiAgICAgICAgYm91bmRhcmllcyA9IF9yZWYuYm91bmRhcmllcztcbiAgICAgIHZhciBuZXdTdGF0ZSA9IF9vYmplY3RTcHJlYWQyKHt9LCBzdGF0ZSk7XG5cbiAgICAgIC8vIEV4dHJhY3QgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAgICAgIHZhciBfcmVmMiA9IGJvdW5kYXJpZXMgfHwgdGhpcy5ub2RlRXh0ZW50LFxuICAgICAgICBfcmVmMiR4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIueCwgMiksXG4gICAgICAgIHhNaW5HcmFwaCA9IF9yZWYyJHhbMF0sXG4gICAgICAgIHhNYXhHcmFwaCA9IF9yZWYyJHhbMV0sXG4gICAgICAgIF9yZWYyJHkgPSBfc2xpY2VkVG9BcnJheShfcmVmMi55LCAyKSxcbiAgICAgICAgeU1pbkdyYXBoID0gX3JlZjIkeVswXSxcbiAgICAgICAgeU1heEdyYXBoID0gX3JlZjIkeVsxXTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHRoZSBmb3VyIGNvcm5lcnMgb2YgdGhlIGdyYXBoIHJlY3RhbmdsZSB1c2luZyB0aGUgcHJvdmlkZWQgY2FtZXJhIHN0YXRlXG4gICAgICB2YXIgY29ybmVycyA9IFt0aGlzLmdyYXBoVG9WaWV3cG9ydCh7XG4gICAgICAgIHg6IHhNaW5HcmFwaCxcbiAgICAgICAgeTogeU1pbkdyYXBoXG4gICAgICB9LCB7XG4gICAgICAgIGNhbWVyYVN0YXRlOiBzdGF0ZVxuICAgICAgfSksIHRoaXMuZ3JhcGhUb1ZpZXdwb3J0KHtcbiAgICAgICAgeDogeE1heEdyYXBoLFxuICAgICAgICB5OiB5TWluR3JhcGhcbiAgICAgIH0sIHtcbiAgICAgICAgY2FtZXJhU3RhdGU6IHN0YXRlXG4gICAgICB9KSwgdGhpcy5ncmFwaFRvVmlld3BvcnQoe1xuICAgICAgICB4OiB4TWluR3JhcGgsXG4gICAgICAgIHk6IHlNYXhHcmFwaFxuICAgICAgfSwge1xuICAgICAgICBjYW1lcmFTdGF0ZTogc3RhdGVcbiAgICAgIH0pLCB0aGlzLmdyYXBoVG9WaWV3cG9ydCh7XG4gICAgICAgIHg6IHhNYXhHcmFwaCxcbiAgICAgICAgeTogeU1heEdyYXBoXG4gICAgICB9LCB7XG4gICAgICAgIGNhbWVyYVN0YXRlOiBzdGF0ZVxuICAgICAgfSldO1xuXG4gICAgICAvLyBMb29rIGZvciBuZXcgZXh0ZW50cywgYmFzZWQgb24gdGhlc2UgZm91ciBjb3JuZXJzXG4gICAgICB2YXIgeE1pbiA9IEluZmluaXR5LFxuICAgICAgICB4TWF4ID0gLUluZmluaXR5LFxuICAgICAgICB5TWluID0gSW5maW5pdHksXG4gICAgICAgIHlNYXggPSAtSW5maW5pdHk7XG4gICAgICBjb3JuZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciB4ID0gX3JlZjMueCxcbiAgICAgICAgICB5ID0gX3JlZjMueTtcbiAgICAgICAgeE1pbiA9IE1hdGgubWluKHhNaW4sIHgpO1xuICAgICAgICB4TWF4ID0gTWF0aC5tYXgoeE1heCwgeCk7XG4gICAgICAgIHlNaW4gPSBNYXRoLm1pbih5TWluLCB5KTtcbiAgICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHkpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZvciBlYWNoIGRpbWVuc2lvbiwgY29uc3RyYWludCB0aGUgc21hbGxlciBlbGVtZW50IChjYW1lcmEgb3IgZ3JhcGgpIHRvIGZpdCBpbiB0aGUgbGFyZ2VyIG9uZTpcbiAgICAgIHZhciBncmFwaFdpZHRoID0geE1heCAtIHhNaW47XG4gICAgICB2YXIgZ3JhcGhIZWlnaHQgPSB5TWF4IC0geU1pbjtcbiAgICAgIHZhciBfdGhpcyRnZXREaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zKCksXG4gICAgICAgIHdpZHRoID0gX3RoaXMkZ2V0RGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkZ2V0RGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICB2YXIgZHggPSAwO1xuICAgICAgdmFyIGR5ID0gMDtcbiAgICAgIGlmIChncmFwaFdpZHRoID49IHdpZHRoKSB7XG4gICAgICAgIGlmICh4TWF4IDwgd2lkdGggLSB0b2xlcmFuY2UpIGR4ID0geE1heCAtICh3aWR0aCAtIHRvbGVyYW5jZSk7ZWxzZSBpZiAoeE1pbiA+IHRvbGVyYW5jZSkgZHggPSB4TWluIC0gdG9sZXJhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHhNYXggPiB3aWR0aCArIHRvbGVyYW5jZSkgZHggPSB4TWF4IC0gKHdpZHRoICsgdG9sZXJhbmNlKTtlbHNlIGlmICh4TWluIDwgLXRvbGVyYW5jZSkgZHggPSB4TWluICsgdG9sZXJhbmNlO1xuICAgICAgfVxuICAgICAgaWYgKGdyYXBoSGVpZ2h0ID49IGhlaWdodCkge1xuICAgICAgICBpZiAoeU1heCA8IGhlaWdodCAtIHRvbGVyYW5jZSkgZHkgPSB5TWF4IC0gKGhlaWdodCAtIHRvbGVyYW5jZSk7ZWxzZSBpZiAoeU1pbiA+IHRvbGVyYW5jZSkgZHkgPSB5TWluIC0gdG9sZXJhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHlNYXggPiBoZWlnaHQgKyB0b2xlcmFuY2UpIGR5ID0geU1heCAtIChoZWlnaHQgKyB0b2xlcmFuY2UpO2Vsc2UgaWYgKHlNaW4gPCAtdG9sZXJhbmNlKSBkeSA9IHlNaW4gKyB0b2xlcmFuY2U7XG4gICAgICB9XG4gICAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgICAgLy8gVHJhbnNmb3JtIFtkeCwgZHldIGZyb20gdmlld3BvcnQgdG8gZ3JhcGggKHVzaW5nIHR3byBkaWZmZXJlbnQgcG9pbnQgdG8gdHJhbnNmb3JtIHRoYXQgdmVjdG9yKTpcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNhbWVyYVN0YXRlOiBzdGF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRlbHRhID0gdGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgoe1xuICAgICAgICAgIHg6IGR4LFxuICAgICAgICAgIHk6IGR5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjYW1lcmFTdGF0ZTogc3RhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIGR4ID0gZGVsdGEueCAtIG9yaWdpbi54O1xuICAgICAgICBkeSA9IGRlbHRhLnkgLSBvcmlnaW4ueTtcbiAgICAgICAgbmV3U3RhdGUueCArPSBkeDtcbiAgICAgICAgbmV3U3RhdGUueSArPSBkeTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZW5kZXIgbGFiZWxzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckxhYmVscygpIHtcbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5yZW5kZXJMYWJlbHMpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGNhbWVyYVN0YXRlID0gdGhpcy5jYW1lcmEuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gU2VsZWN0aW5nIGxhYmVscyB0byBkcmF3XG4gICAgICB2YXIgbGFiZWxzVG9EaXNwbGF5ID0gdGhpcy5sYWJlbEdyaWQuZ2V0TGFiZWxzVG9EaXNwbGF5KGNhbWVyYVN0YXRlLnJhdGlvLCB0aGlzLnNldHRpbmdzLmxhYmVsRGVuc2l0eSk7XG4gICAgICBleHRlbmQobGFiZWxzVG9EaXNwbGF5LCB0aGlzLm5vZGVzV2l0aEZvcmNlZExhYmVscyk7XG4gICAgICB0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMgPSBuZXcgU2V0KCk7XG5cbiAgICAgIC8vIERyYXdpbmcgbGFiZWxzXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY2FudmFzQ29udGV4dHMubGFiZWxzO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsYWJlbHNUb0Rpc3BsYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbGFiZWxzVG9EaXNwbGF5W2ldO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtub2RlXTtcblxuICAgICAgICAvLyBJZiB0aGUgbm9kZSB3YXMgYWxyZWFkeSBkcmF3biAobGlrZSBpZiBpdCBpcyBlbGlnaWJsZSBBTkQgaGFzXG4gICAgICAgIC8vIGBmb3JjZUxhYmVsYCksIHdlIGRvbid0IHdhbnQgdG8gZHJhdyBpdCBhZ2FpblxuICAgICAgICAvLyBOT1RFOiB3ZSBjYW4gZG8gYmV0dGVyIHByb2JhYmx5XG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMuaGFzKG5vZGUpKSBjb250aW51ZTtcblxuICAgICAgICAvLyBJZiB0aGUgbm9kZSBpcyBoaWRkZW4sIHdlIGRvbid0IG5lZWQgdG8gZGlzcGxheSBpdHMgbGFiZWwgb2J2aW91c2x5XG4gICAgICAgIGlmIChkYXRhLmhpZGRlbikgY29udGludWU7XG4gICAgICAgIHZhciBfdGhpcyRmcmFtZWRHcmFwaFRvVmkgPSB0aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydChkYXRhKSxcbiAgICAgICAgICB4ID0gX3RoaXMkZnJhbWVkR3JhcGhUb1ZpLngsXG4gICAgICAgICAgeSA9IF90aGlzJGZyYW1lZEdyYXBoVG9WaS55O1xuXG4gICAgICAgIC8vIE5PVEU6IHdlIGNhbiBjYWNoZSB0aGUgbGFiZWxzIHdlIG5lZWQgdG8gcmVuZGVyIHVudGlsIHRoZSBjYW1lcmEncyByYXRpbyBjaGFuZ2VzXG4gICAgICAgIHZhciBzaXplID0gdGhpcy5zY2FsZVNpemUoZGF0YS5zaXplKTtcblxuICAgICAgICAvLyBJcyBub2RlIGJpZyBlbm91Z2g/XG4gICAgICAgIGlmICghZGF0YS5mb3JjZUxhYmVsICYmIHNpemUgPCB0aGlzLnNldHRpbmdzLmxhYmVsUmVuZGVyZWRTaXplVGhyZXNob2xkKSBjb250aW51ZTtcblxuICAgICAgICAvLyBJcyBub2RlIGFjdHVhbGx5IG9uIHNjcmVlbiAod2l0aCBzb21lIG1hcmdpbilcbiAgICAgICAgLy8gTk9URTogd2UgdXNlZCB0byByZWx5IG9uIHRoZSBxdWFkdHJlZSBmb3IgdGhpcywgYnV0IHRoZSBjb29yZGluYXRlc1xuICAgICAgICAvLyBjb252ZXJzaW9uIG1ha2UgaXQgdW5yZWxpYWJsZSBhbmQgYXQgdGhhdCBwb2ludCB3ZSBhbHJlYWR5IGNvbnZlcnRlZFxuICAgICAgICAvLyB0byB2aWV3cG9ydCBjb29yZGluYXRlcyBhbmQgc2luY2UgdGhlIGxhYmVsIGdyaWQgYWxyZWFkeSBjdWxscyB0aGVcbiAgICAgICAgLy8gbnVtYmVyIG9mIHBvdGVudGlhbCBsYWJlbHMgdG8gZGlzcGxheSB0aGlzIGxvb2tzIGxpa2UgYSBnb29kXG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIGNvbXByb21pc2UuXG4gICAgICAgIC8vIE5PVEU6IGxhYmVsR3JpZC5nZXRMYWJlbHNUb0Rpc3BsYXkgY291bGQgcHJvYmFibHkgb3B0aW1pemUgYnkgbm90XG4gICAgICAgIC8vIGNvbnNpZGVyaW5nIGNlbGxzIG9idmlvdXNseSBvdXRzaWRlIG9mIHRoZSByYW5nZSBvZiB0aGUgY3VycmVudFxuICAgICAgICAvLyB2aWV3IHJlY3RhbmdsZS5cbiAgICAgICAgaWYgKHggPCAtWF9MQUJFTF9NQVJHSU4gfHwgeCA+IHRoaXMud2lkdGggKyBYX0xBQkVMX01BUkdJTiB8fCB5IDwgLVlfTEFCRUxfTUFSR0lOIHx8IHkgPiB0aGlzLmhlaWdodCArIFlfTEFCRUxfTUFSR0lOKSBjb250aW51ZTtcblxuICAgICAgICAvLyBCZWNhdXNlIGRpc3BsYXllZCBlZGdlIGxhYmVscyBkZXBlbmQgZGlyZWN0bHkgb24gYWN0dWFsbHkgcmVuZGVyZWQgbm9kZVxuICAgICAgICAvLyBsYWJlbHMsIHdlIG5lZWQgdG8gb25seSBhZGQgdG8gdGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzIG5vZGVzIHdob3NlIGxhYmVsXG4gICAgICAgIC8vIGlzIHJlbmRlcmVkLlxuICAgICAgICAvLyBUaGlzIG1ha2VzIHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscyBkZXBlbmQgb24gdmlld3BvcnQsIHdoaWNoIG1pZ2h0IGJlY29tZVxuICAgICAgICAvLyBhbiBpc3N1ZSBvbmNlIHdlIHN0YXJ0IG1lbW9pemluZyBnZXRMYWJlbHNUb0Rpc3BsYXkuXG4gICAgICAgIHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscy5hZGQobm9kZSk7XG4gICAgICAgIHZhciBkZWZhdWx0RHJhd05vZGVMYWJlbCA9IHRoaXMuc2V0dGluZ3MuZGVmYXVsdERyYXdOb2RlTGFiZWw7XG4gICAgICAgIHZhciBub2RlUHJvZ3JhbSA9IHRoaXMubm9kZVByb2dyYW1zW2RhdGEudHlwZV07XG4gICAgICAgIHZhciBkcmF3TGFiZWwgPSAobm9kZVByb2dyYW0gPT09IG51bGwgfHwgbm9kZVByb2dyYW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVQcm9ncmFtLmRyYXdMYWJlbCkgfHwgZGVmYXVsdERyYXdOb2RlTGFiZWw7XG4gICAgICAgIGRyYXdMYWJlbChjb250ZXh0LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAga2V5OiBub2RlXG4gICAgICAgIH0sIGRhdGEpLCB7fSwge1xuICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH0pLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlbmRlciBlZGdlIGxhYmVscywgYmFzZWQgb24gd2hpY2ggbm9kZSBsYWJlbHMgd2VyZVxuICAgICAqIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyRWRnZUxhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJFZGdlTGFiZWxzKCkge1xuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnJlbmRlckVkZ2VMYWJlbHMpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNhbnZhc0NvbnRleHRzLmVkZ2VMYWJlbHM7XG5cbiAgICAgIC8vIENsZWFyaW5nXG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB2YXIgZWRnZUxhYmVsc1RvRGlzcGxheSA9IGVkZ2VMYWJlbHNUb0Rpc3BsYXlGcm9tTm9kZXMoe1xuICAgICAgICBncmFwaDogdGhpcy5ncmFwaCxcbiAgICAgICAgaG92ZXJlZE5vZGU6IHRoaXMuaG92ZXJlZE5vZGUsXG4gICAgICAgIGRpc3BsYXllZE5vZGVMYWJlbHM6IHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscyxcbiAgICAgICAgaGlnaGxpZ2h0ZWROb2RlczogdGhpcy5oaWdobGlnaHRlZE5vZGVzXG4gICAgICB9KTtcbiAgICAgIGV4dGVuZChlZGdlTGFiZWxzVG9EaXNwbGF5LCB0aGlzLmVkZ2VzV2l0aEZvcmNlZExhYmVscyk7XG4gICAgICB2YXIgZGlzcGxheWVkTGFiZWxzID0gbmV3IFNldCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlZGdlTGFiZWxzVG9EaXNwbGF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VMYWJlbHNUb0Rpc3BsYXlbaV0sXG4gICAgICAgICAgZXh0cmVtaXRpZXMgPSB0aGlzLmdyYXBoLmV4dHJlbWl0aWVzKGVkZ2UpLFxuICAgICAgICAgIHNvdXJjZURhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbZXh0cmVtaXRpZXNbMF1dLFxuICAgICAgICAgIHRhcmdldERhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbZXh0cmVtaXRpZXNbMV1dLFxuICAgICAgICAgIGVkZ2VEYXRhID0gdGhpcy5lZGdlRGF0YUNhY2hlW2VkZ2VdO1xuXG4gICAgICAgIC8vIElmIHRoZSBlZGdlIHdhcyBhbHJlYWR5IGRyYXduIChsaWtlIGlmIGl0IGlzIGVsaWdpYmxlIEFORCBoYXNcbiAgICAgICAgLy8gYGZvcmNlTGFiZWxgKSwgd2UgZG9uJ3Qgd2FudCB0byBkcmF3IGl0IGFnYWluXG4gICAgICAgIGlmIChkaXNwbGF5ZWRMYWJlbHMuaGFzKGVkZ2UpKSBjb250aW51ZTtcblxuICAgICAgICAvLyBJZiB0aGUgZWRnZSBpcyBoaWRkZW4gd2UgZG9uJ3QgbmVlZCB0byBkaXNwbGF5IGl0cyBsYWJlbFxuICAgICAgICAvLyBOT1RFOiB0aGUgdGVzdCBvbiBzb3VyY2VEYXRhICYgdGFyZ2V0RGF0YSBpcyBwcm9iYWJseSBwYXJhbm9pZCBhdCB0aGlzIHBvaW50P1xuICAgICAgICBpZiAoZWRnZURhdGEuaGlkZGVuIHx8IHNvdXJjZURhdGEuaGlkZGVuIHx8IHRhcmdldERhdGEuaGlkZGVuKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmF1bHREcmF3RWRnZUxhYmVsID0gdGhpcy5zZXR0aW5ncy5kZWZhdWx0RHJhd0VkZ2VMYWJlbDtcbiAgICAgICAgdmFyIGVkZ2VQcm9ncmFtID0gdGhpcy5lZGdlUHJvZ3JhbXNbZWRnZURhdGEudHlwZV07XG4gICAgICAgIHZhciBkcmF3TGFiZWwgPSAoZWRnZVByb2dyYW0gPT09IG51bGwgfHwgZWRnZVByb2dyYW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkZ2VQcm9ncmFtLmRyYXdMYWJlbCkgfHwgZGVmYXVsdERyYXdFZGdlTGFiZWw7XG4gICAgICAgIGRyYXdMYWJlbChjb250ZXh0LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAga2V5OiBlZGdlXG4gICAgICAgIH0sIGVkZ2VEYXRhKSwge30sIHtcbiAgICAgICAgICBzaXplOiB0aGlzLnNjYWxlU2l6ZShlZGdlRGF0YS5zaXplKVxuICAgICAgICB9KSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIGtleTogZXh0cmVtaXRpZXNbMF1cbiAgICAgICAgfSwgc291cmNlRGF0YSksIHRoaXMuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KHNvdXJjZURhdGEpKSwge30sIHtcbiAgICAgICAgICBzaXplOiB0aGlzLnNjYWxlU2l6ZShzb3VyY2VEYXRhLnNpemUpXG4gICAgICAgIH0pLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAga2V5OiBleHRyZW1pdGllc1sxXVxuICAgICAgICB9LCB0YXJnZXREYXRhKSwgdGhpcy5mcmFtZWRHcmFwaFRvVmlld3BvcnQodGFyZ2V0RGF0YSkpLCB7fSwge1xuICAgICAgICAgIHNpemU6IHRoaXMuc2NhbGVTaXplKHRhcmdldERhdGEuc2l6ZSlcbiAgICAgICAgfSksIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICBkaXNwbGF5ZWRMYWJlbHMuYWRkKGVkZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNwbGF5ZWRFZGdlTGFiZWxzID0gZGlzcGxheWVkTGFiZWxzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVuZGVyIHRoZSBoaWdobGlnaHRlZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckhpZ2hsaWdodGVkTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVySGlnaGxpZ2h0ZWROb2RlcygpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNhbnZhc0NvbnRleHRzLmhvdmVycztcblxuICAgICAgLy8gQ2xlYXJpbmdcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgLy8gUmVuZGVyaW5nXG4gICAgICB2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKG5vZGUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfdGhpczcubm9kZURhdGFDYWNoZVtub2RlXTtcbiAgICAgICAgdmFyIF90aGlzNyRmcmFtZWRHcmFwaFRvViA9IF90aGlzNy5mcmFtZWRHcmFwaFRvVmlld3BvcnQoZGF0YSksXG4gICAgICAgICAgeCA9IF90aGlzNyRmcmFtZWRHcmFwaFRvVi54LFxuICAgICAgICAgIHkgPSBfdGhpczckZnJhbWVkR3JhcGhUb1YueTtcbiAgICAgICAgdmFyIHNpemUgPSBfdGhpczcuc2NhbGVTaXplKGRhdGEuc2l6ZSk7XG4gICAgICAgIHZhciBkZWZhdWx0RHJhd05vZGVIb3ZlciA9IF90aGlzNy5zZXR0aW5ncy5kZWZhdWx0RHJhd05vZGVIb3ZlcjtcbiAgICAgICAgdmFyIG5vZGVQcm9ncmFtID0gX3RoaXM3Lm5vZGVQcm9ncmFtc1tkYXRhLnR5cGVdO1xuICAgICAgICB2YXIgZHJhd0hvdmVyID0gKG5vZGVQcm9ncmFtID09PSBudWxsIHx8IG5vZGVQcm9ncmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlUHJvZ3JhbS5kcmF3SG92ZXIpIHx8IGRlZmF1bHREcmF3Tm9kZUhvdmVyO1xuICAgICAgICBkcmF3SG92ZXIoY29udGV4dCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIGtleTogbm9kZVxuICAgICAgICB9LCBkYXRhKSwge30sIHtcbiAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9KSwgX3RoaXM3LnNldHRpbmdzKTtcbiAgICAgIH07XG4gICAgICB2YXIgbm9kZXNUb1JlbmRlciA9IFtdO1xuICAgICAgaWYgKHRoaXMuaG92ZXJlZE5vZGUgJiYgIXRoaXMubm9kZURhdGFDYWNoZVt0aGlzLmhvdmVyZWROb2RlXS5oaWRkZW4pIHtcbiAgICAgICAgbm9kZXNUb1JlbmRlci5wdXNoKHRoaXMuaG92ZXJlZE5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgLy8gVGhlIGhvdmVyZWQgbm9kZSBoYXMgYWxyZWFkeSBiZWVuIGhpZ2hsaWdodGVkXG4gICAgICAgIGlmIChub2RlICE9PSBfdGhpczcuaG92ZXJlZE5vZGUpIG5vZGVzVG9SZW5kZXIucHVzaChub2RlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBEcmF3IGxhYmVsczpcbiAgICAgIG5vZGVzVG9SZW5kZXIuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gcmVuZGVyKG5vZGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIERyYXcgV2ViR0wgbm9kZXMgb24gdG9wIG9mIHRoZSBsYWJlbHM6XG4gICAgICB2YXIgbm9kZXNQZXJQcm9ncmFtcyA9IHt9O1xuXG4gICAgICAvLyAxLiBDb3VudCBub2RlcyBwZXIgdHlwZTpcbiAgICAgIG5vZGVzVG9SZW5kZXIuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgdHlwZSA9IF90aGlzNy5ub2RlRGF0YUNhY2hlW25vZGVdLnR5cGU7XG4gICAgICAgIG5vZGVzUGVyUHJvZ3JhbXNbdHlwZV0gPSAobm9kZXNQZXJQcm9ncmFtc1t0eXBlXSB8fCAwKSArIDE7XG4gICAgICB9KTtcbiAgICAgIC8vIDIuIEFsbG9jYXRlIGZvciBlYWNoIHR5cGUgZm9yIHRoZSBwcm9wZXIgbnVtYmVyIG9mIG5vZGVzXG4gICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXMpIHtcbiAgICAgICAgdGhpcy5ub2RlSG92ZXJQcm9ncmFtc1t0eXBlXS5yZWFsbG9jYXRlKG5vZGVzUGVyUHJvZ3JhbXNbdHlwZV0gfHwgMCk7XG4gICAgICAgIC8vIEFsc28gcmVzZXQgY291bnQsIHRvIHVzZSB3aGVuIHJlbmRlcmluZzpcbiAgICAgICAgbm9kZXNQZXJQcm9ncmFtc1t0eXBlXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyAzLiBQcm9jZXNzIGFsbCBub2RlcyB0byByZW5kZXI6XG4gICAgICBub2Rlc1RvUmVuZGVyLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfdGhpczcubm9kZURhdGFDYWNoZVtub2RlXTtcbiAgICAgICAgX3RoaXM3Lm5vZGVIb3ZlclByb2dyYW1zW2RhdGEudHlwZV0ucHJvY2VzcygwLCBub2Rlc1BlclByb2dyYW1zW2RhdGEudHlwZV0rKywgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIC8vIDQuIENsZWFyIGhvdmVyZWQgbm9kZXMgbGF5ZXI6XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHMuaG92ZXJOb2Rlcy5jbGVhcih0aGlzLndlYkdMQ29udGV4dHMuaG92ZXJOb2Rlcy5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgIC8vIDUuIFJlbmRlcjpcbiAgICAgIHZhciByZW5kZXJQYXJhbXMgPSB0aGlzLmdldFJlbmRlclBhcmFtcygpO1xuICAgICAgZm9yICh2YXIgX3R5cGU2IGluIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLm5vZGVIb3ZlclByb2dyYW1zW190eXBlNl07XG4gICAgICAgIHByb2dyYW0ucmVuZGVyKHJlbmRlclBhcmFtcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gc2NoZWR1bGUgYSBob3ZlciByZW5kZXIuXG4gICAgICpcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzY2hlZHVsZUhpZ2hsaWdodGVkTm9kZXNSZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NoZWR1bGVIaWdobGlnaHRlZE5vZGVzUmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5yZW5kZXJIaWdobGlnaHRlZE5vZGVzRnJhbWUgfHwgdGhpcy5yZW5kZXJGcmFtZSkgcmV0dXJuO1xuICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHRlZE5vZGVzRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXNldHRpbmcgc3RhdGVcbiAgICAgICAgX3RoaXM4LnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSA9IG51bGw7XG5cbiAgICAgICAgLy8gUmVuZGVyaW5nXG4gICAgICAgIF90aGlzOC5yZW5kZXJIaWdobGlnaHRlZE5vZGVzKCk7XG4gICAgICAgIF90aGlzOC5yZW5kZXJFZGdlTGFiZWxzKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZW5kZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgICB0aGlzLmVtaXQoXCJiZWZvcmVSZW5kZXJcIik7XG4gICAgICB2YXIgZXhpdFJlbmRlciA9IGZ1bmN0aW9uIGV4aXRSZW5kZXIoKSB7XG4gICAgICAgIF90aGlzOS5lbWl0KFwiYWZ0ZXJSZW5kZXJcIik7XG4gICAgICAgIHJldHVybiBfdGhpczk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJZiBhIHJlbmRlciB3YXMgc2NoZWR1bGVkLCB3ZSBjYW5jZWwgaXRcbiAgICAgIGlmICh0aGlzLnJlbmRlckZyYW1lKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyRnJhbWUpO1xuICAgICAgICB0aGlzLnJlbmRlckZyYW1lID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3Qgd2UgbmVlZCB0byByZXNpemVcbiAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgIC8vIERvIHdlIG5lZWQgdG8gcmVwcm9jZXNzIGRhdGE/XG4gICAgICBpZiAodGhpcy5uZWVkVG9Qcm9jZXNzKSB0aGlzLnByb2Nlc3MoKTtcbiAgICAgIHRoaXMubmVlZFRvUHJvY2VzcyA9IGZhbHNlO1xuXG4gICAgICAvLyBDbGVhcmluZyB0aGUgY2FudmFzZXNcbiAgICAgIHRoaXMuY2xlYXIoKTtcblxuICAgICAgLy8gUHJlcGFyZSB0aGUgdGV4dHVyZXNcbiAgICAgIHRoaXMucGlja2luZ0xheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICByZXR1cm4gX3RoaXM5LnJlc2V0V2ViR0xUZXh0dXJlKGxheWVyKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIG5vIG5vZGVzIHdlIGNhbiBzdG9wIHJpZ2h0IHRoZXJlXG4gICAgICBpZiAoIXRoaXMuZ3JhcGgub3JkZXIpIHJldHVybiBleGl0UmVuZGVyKCk7XG5cbiAgICAgIC8vIFRPRE86IGltcHJvdmUgdGhpcyBoZXVyaXN0aWMgb3IgbW92ZSB0byB0aGUgY2FwdG9yIGl0c2VsZj9cbiAgICAgIC8vIFRPRE86IGRlYWwgd2l0aCB0aGUgdG91Y2ggY2FwdG9yIGhlcmUgYXMgd2VsbFxuICAgICAgdmFyIG1vdXNlQ2FwdG9yID0gdGhpcy5tb3VzZUNhcHRvcjtcbiAgICAgIHZhciBtb3ZpbmcgPSB0aGlzLmNhbWVyYS5pc0FuaW1hdGVkKCkgfHwgbW91c2VDYXB0b3IuaXNNb3ZpbmcgfHwgbW91c2VDYXB0b3IuZHJhZ2dlZEV2ZW50cyB8fCBtb3VzZUNhcHRvci5jdXJyZW50V2hlZWxEaXJlY3Rpb247XG5cbiAgICAgIC8vIFRoZW4gd2UgbmVlZCB0byBleHRyYWN0IGEgbWF0cml4IGZyb20gdGhlIGNhbWVyYVxuICAgICAgdmFyIGNhbWVyYVN0YXRlID0gdGhpcy5jYW1lcmEuZ2V0U3RhdGUoKTtcbiAgICAgIHZhciB2aWV3cG9ydERpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnMoKTtcbiAgICAgIHZhciBncmFwaERpbWVuc2lvbnMgPSB0aGlzLmdldEdyYXBoRGltZW5zaW9ucygpO1xuICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmdldFN0YWdlUGFkZGluZygpO1xuICAgICAgdGhpcy5tYXRyaXggPSBtYXRyaXhGcm9tQ2FtZXJhKGNhbWVyYVN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMsIGdyYXBoRGltZW5zaW9ucywgcGFkZGluZyk7XG4gICAgICB0aGlzLmludk1hdHJpeCA9IG1hdHJpeEZyb21DYW1lcmEoY2FtZXJhU3RhdGUsIHZpZXdwb3J0RGltZW5zaW9ucywgZ3JhcGhEaW1lbnNpb25zLCBwYWRkaW5nLCB0cnVlKTtcbiAgICAgIHRoaXMuY29ycmVjdGlvblJhdGlvID0gZ2V0TWF0cml4SW1wYWN0KHRoaXMubWF0cml4LCBjYW1lcmFTdGF0ZSwgdmlld3BvcnREaW1lbnNpb25zKTtcbiAgICAgIHRoaXMuZ3JhcGhUb1ZpZXdwb3J0UmF0aW8gPSB0aGlzLmdldEdyYXBoVG9WaWV3cG9ydFJhdGlvKCk7XG5cbiAgICAgIC8vIFtqYWNvbXlhbF1cbiAgICAgIC8vIFRoaXMgY29tbWVudCBpcyByZWxhdGVkIHRvIHRoZSBvbmUgYWJvdmUgdGhlIGBnZXRNYXRyaXhJbXBhY3RgIGRlZmluaXRpb246XG4gICAgICAvLyAtIGB0aGlzLmNvcnJlY3Rpb25SYXRpb2AgaXMgc29tZWhvdyBub3QgY29tcGxldGVseSBleHBsYWluZWRcbiAgICAgIC8vIC0gYHRoaXMuZ3JhcGhUb1ZpZXdwb3J0UmF0aW9gIGlzIHRoZSByYXRpbyBvZiBhIGRpc3RhbmNlIGluIHRoZSB2aWV3cG9ydCBkaXZpZGVkIGJ5IHRoZSBzYW1lIGRpc3RhbmNlIGluIHRoZVxuICAgICAgLy8gICBncmFwaFxuICAgICAgLy8gLSBgdGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24ucmF0aW9gIGlzIGJhc2ljYWxseSBgTWF0aC5tYXgoZ3JhcGhEWCwgZ3JhcGhEWSlgXG4gICAgICAvLyBBbmQgbm93LCBJIG9ic2VydmUgdGhhdCBpZiBJIG11bHRpcGx5IHRoZXNlIHRocmVlIHJhdGlvcywgSSBoYXZlIHNvbWV0aGluZyBjb25zdGFudCwgd2hpY2ggdmFsdWUgcmVtYWlucyAyLCBldmVuXG4gICAgICAvLyB3aGVuIEkgY2hhbmdlIHRoZSBncmFwaCwgdGhlIHZpZXdwb3J0IG9yIHRoZSBjYW1lcmEuIEl0IG1pZ2h0IGJlIHVzZWZ1bCBsYXRlciwgc28gSSBwcmVmZXIgdG8gbGV0IHRoaXMgY29tbWVudDpcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZ3JhcGhUb1ZpZXdwb3J0UmF0aW8gKiB0aGlzLmNvcnJlY3Rpb25SYXRpbyAqIHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uLnJhdGlvICogMik7XG5cbiAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmdldFJlbmRlclBhcmFtcygpO1xuXG4gICAgICAvLyBEcmF3aW5nIG5vZGVzXG4gICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMubm9kZVByb2dyYW1zKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5ub2RlUHJvZ3JhbXNbdHlwZV07XG4gICAgICAgIHByb2dyYW0ucmVuZGVyKHBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIERyYXdpbmcgZWRnZXNcbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5oaWRlRWRnZXNPbk1vdmUgfHwgIW1vdmluZykge1xuICAgICAgICBmb3IgKHZhciBfdHlwZTcgaW4gdGhpcy5lZGdlUHJvZ3JhbXMpIHtcbiAgICAgICAgICB2YXIgX3Byb2dyYW0yID0gdGhpcy5lZGdlUHJvZ3JhbXNbX3R5cGU3XTtcbiAgICAgICAgICBfcHJvZ3JhbTIucmVuZGVyKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG8gbm90IGRpc3BsYXkgbGFiZWxzIG9uIG1vdmUgcGVyIHNldHRpbmdcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmhpZGVMYWJlbHNPbk1vdmUgJiYgbW92aW5nKSByZXR1cm4gZXhpdFJlbmRlcigpO1xuICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoKTtcbiAgICAgIHRoaXMucmVuZGVyRWRnZUxhYmVscygpO1xuICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHRlZE5vZGVzKCk7XG4gICAgICByZXR1cm4gZXhpdFJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5vZGUgaW4gdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5vZGUncyBncmFwaG9sb2d5IElEXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGROb2RlKGtleSkge1xuICAgICAgLy8gTm9kZSBkaXNwbGF5IGRhdGEgcmVzb2x1dGlvbjpcbiAgICAgIC8vICAxLiBGaXJzdCB3ZSBnZXQgdGhlIG5vZGUncyBhdHRyaWJ1dGVzXG4gICAgICAvLyAgMi4gV2Ugb3B0aW9uYWxseSByZWR1Y2UgdGhlbSB1c2luZyB0aGUgZnVuY3Rpb24gcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAgICAgIC8vICAgICBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHRvdGFsIG9iamVjdCBhbmQgd29uJ3QgYmUgbWVyZ2VkXG4gICAgICAvLyAgMy4gV2UgYXBwbHkgb3VyIGRlZmF1bHRzLCB3aGlsZSBydW5uaW5nIHNvbWUgdml0YWwgY2hlY2tzXG4gICAgICAvLyAgNC4gV2UgYXBwbHkgdGhlIG5vcm1hbGl6YXRpb24gZnVuY3Rpb25cbiAgICAgIC8vIFdlIHNoYWxsb3cgY29weSBub2RlIGRhdGEgdG8gYXZvaWQgZGFuZ2Vyb3VzIGJlaGF2aW9ycyBmcm9tIHJlZHVjZXJzXG4gICAgICB2YXIgYXR0ciA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ3JhcGguZ2V0Tm9kZUF0dHJpYnV0ZXMoa2V5KSk7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5ub2RlUmVkdWNlcikgYXR0ciA9IHRoaXMuc2V0dGluZ3Mubm9kZVJlZHVjZXIoa2V5LCBhdHRyKTtcbiAgICAgIHZhciBkYXRhID0gYXBwbHlOb2RlRGVmYXVsdHModGhpcy5zZXR0aW5ncywga2V5LCBhdHRyKTtcbiAgICAgIHRoaXMubm9kZURhdGFDYWNoZVtrZXldID0gZGF0YTtcblxuICAgICAgLy8gTGFiZWw6XG4gICAgICAvLyBXZSBkZWxldGUgYW5kIGFkZCBpZiBuZWVkZWQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIGFsc28gdXNlZCBmcm9tXG4gICAgICAvLyB1cGRhdGVcbiAgICAgIHRoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICBpZiAoZGF0YS5mb3JjZUxhYmVsICYmICFkYXRhLmhpZGRlbikgdGhpcy5ub2Rlc1dpdGhGb3JjZWRMYWJlbHMuYWRkKGtleSk7XG5cbiAgICAgIC8vIEhpZ2hsaWdodGVkOlxuICAgICAgLy8gV2UgcmVtb3ZlIGFuZCByZSBhZGQgaWYgbmVlZGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBhbHNvIHVzZWQgZnJvbVxuICAgICAgLy8gdXBkYXRlXG4gICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXNbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIGlmIChkYXRhLmhpZ2hsaWdodGVkICYmICFkYXRhLmhpZGRlbikgdGhpcy5oaWdobGlnaHRlZE5vZGVzLmFkZChrZXkpO1xuXG4gICAgICAvLyB6SW5kZXhcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnpJbmRleCkge1xuICAgICAgICBpZiAoZGF0YS56SW5kZXggPCB0aGlzLm5vZGVaRXh0ZW50WzBdKSB0aGlzLm5vZGVaRXh0ZW50WzBdID0gZGF0YS56SW5kZXg7XG4gICAgICAgIGlmIChkYXRhLnpJbmRleCA+IHRoaXMubm9kZVpFeHRlbnRbMV0pIHRoaXMubm9kZVpFeHRlbnRbMV0gPSBkYXRhLnpJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBub2RlIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBub2RlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTm9kZShrZXkpIHtcbiAgICAgIHRoaXMuYWRkTm9kZShrZXkpO1xuXG4gICAgICAvLyBSZS1hcHBseSBub3JtYWxpemF0aW9uIG9uIHRoZSBub2RlXG4gICAgICB2YXIgZGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtrZXldO1xuICAgICAgdGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24uYXBwbHlUbyhkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBub2RlIGZyb20gdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5vZGUncyBncmFwaG9sb2d5IElEXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVOb2RlKGtleSkge1xuICAgICAgLy8gUmVtb3ZlIGZyb20gbm9kZSBjYWNoZVxuICAgICAgZGVsZXRlIHRoaXMubm9kZURhdGFDYWNoZVtrZXldO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gbm9kZSBwcm9ncmFtIGluZGV4XG4gICAgICBkZWxldGUgdGhpcy5ub2RlUHJvZ3JhbUluZGV4W2tleV07XG4gICAgICAvLyBSZW1vdmUgZnJvbSBoaWdsaWdodGVkIG5vZGVzXG4gICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXNbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGhvdmVyZWRcbiAgICAgIGlmICh0aGlzLmhvdmVyZWROb2RlID09PSBrZXkpIHRoaXMuaG92ZXJlZE5vZGUgPSBudWxsO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gZm9yY2VkIGxhYmVsXG4gICAgICB0aGlzLm5vZGVzV2l0aEZvcmNlZExhYmVsc1tcImRlbGV0ZVwiXShrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBlZGdlIGludG8gdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGVkZ2UncyBncmFwaG9sb2d5IElEXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFZGdlKGtleSkge1xuICAgICAgLy8gRWRnZSBkaXNwbGF5IGRhdGEgcmVzb2x1dGlvbjpcbiAgICAgIC8vICAxLiBGaXJzdCB3ZSBnZXQgdGhlIGVkZ2UncyBhdHRyaWJ1dGVzXG4gICAgICAvLyAgMi4gV2Ugb3B0aW9uYWxseSByZWR1Y2UgdGhlbSB1c2luZyB0aGUgZnVuY3Rpb24gcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAgICAgIC8vICAzLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHRvdGFsIG9iamVjdCBhbmQgd29uJ3QgYmUgbWVyZ2VkXG4gICAgICAvLyAgNC4gV2UgYXBwbHkgb3VyIGRlZmF1bHRzLCB3aGlsZSBydW5uaW5nIHNvbWUgdml0YWwgY2hlY2tzXG4gICAgICAvLyBXZSBzaGFsbG93IGNvcHkgZWRnZSBkYXRhIHRvIGF2b2lkIGRhbmdlcm91cyBiZWhhdmlvcnMgZnJvbSByZWR1Y2Vyc1xuICAgICAgdmFyIGF0dHIgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdyYXBoLmdldEVkZ2VBdHRyaWJ1dGVzKGtleSkpO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZWRnZVJlZHVjZXIpIGF0dHIgPSB0aGlzLnNldHRpbmdzLmVkZ2VSZWR1Y2VyKGtleSwgYXR0cik7XG4gICAgICB2YXIgZGF0YSA9IGFwcGx5RWRnZURlZmF1bHRzKHRoaXMuc2V0dGluZ3MsIGtleSwgYXR0cik7XG4gICAgICB0aGlzLmVkZ2VEYXRhQ2FjaGVba2V5XSA9IGRhdGE7XG5cbiAgICAgIC8vIEZvcmNlZCBsYWJlbFxuICAgICAgLy8gd2UgZmlsdGVyIGFuZCByZSBwdXNoIGlmIG5lZWRlZCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyB1c2VkIGZyb21cbiAgICAgIC8vIHVwZGF0ZVxuICAgICAgdGhpcy5lZGdlc1dpdGhGb3JjZWRMYWJlbHNbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIGlmIChkYXRhLmZvcmNlTGFiZWwgJiYgIWRhdGEuaGlkZGVuKSB0aGlzLmVkZ2VzV2l0aEZvcmNlZExhYmVscy5hZGQoa2V5KTtcblxuICAgICAgLy8gQ2hlY2sgekluZGV4XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy56SW5kZXgpIHtcbiAgICAgICAgaWYgKGRhdGEuekluZGV4IDwgdGhpcy5lZGdlWkV4dGVudFswXSkgdGhpcy5lZGdlWkV4dGVudFswXSA9IGRhdGEuekluZGV4O1xuICAgICAgICBpZiAoZGF0YS56SW5kZXggPiB0aGlzLmVkZ2VaRXh0ZW50WzFdKSB0aGlzLmVkZ2VaRXh0ZW50WzFdID0gZGF0YS56SW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFuIGVkZ2UgaW4gdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGVkZ2UncyBncmFwaG9sb2d5IElEXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFZGdlKGtleSkge1xuICAgICAgdGhpcy5hZGRFZGdlKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGVkZ2UgZnJvbSB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgZWRnZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUVkZ2Uoa2V5KSB7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBlZGdlIGNhY2hlXG4gICAgICBkZWxldGUgdGhpcy5lZGdlRGF0YUNhY2hlW2tleV07XG4gICAgICAvLyBSZW1vdmUgZnJvbSBwcm9ncmFtSWQgaW5kZXhcbiAgICAgIGRlbGV0ZSB0aGlzLmVkZ2VQcm9ncmFtSW5kZXhba2V5XTtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGhvdmVyZWRcbiAgICAgIGlmICh0aGlzLmhvdmVyZWRFZGdlID09PSBrZXkpIHRoaXMuaG92ZXJlZEVkZ2UgPSBudWxsO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gZm9yY2VkIGxhYmVsXG4gICAgICB0aGlzLmVkZ2VzV2l0aEZvcmNlZExhYmVsc1tcImRlbGV0ZVwiXShrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBpbmRpY2VzIHJlbGF0ZWQgdG8gbm9kZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhck5vZGVJbmRpY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyTm9kZUluZGljZXMoKSB7XG4gICAgICAvLyBMYWJlbEdyaWQgJiBub2RlRXh0ZW50IGFyZSBvbmx5IG1hbmFnZS9wb3B1bGF0ZWQgaW4gdGhlIHByb2Nlc3MgZnVuY3Rpb25cbiAgICAgIHRoaXMubGFiZWxHcmlkID0gbmV3IExhYmVsR3JpZCgpO1xuICAgICAgdGhpcy5ub2RlRXh0ZW50ID0ge1xuICAgICAgICB4OiBbMCwgMV0sXG4gICAgICAgIHk6IFswLCAxXVxuICAgICAgfTtcbiAgICAgIHRoaXMubm9kZURhdGFDYWNoZSA9IHt9O1xuICAgICAgdGhpcy5lZGdlUHJvZ3JhbUluZGV4ID0ge307XG4gICAgICB0aGlzLm5vZGVzV2l0aEZvcmNlZExhYmVscyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMubm9kZVpFeHRlbnQgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGluZGljZXMgcmVsYXRlZCB0byBlZGdlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFyRWRnZUluZGljZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJFZGdlSW5kaWNlcygpIHtcbiAgICAgIHRoaXMuZWRnZURhdGFDYWNoZSA9IHt9O1xuICAgICAgdGhpcy5lZGdlUHJvZ3JhbUluZGV4ID0ge307XG4gICAgICB0aGlzLmVkZ2VzV2l0aEZvcmNlZExhYmVscyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuZWRnZVpFeHRlbnQgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGluZGljZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhckluZGljZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJJbmRpY2VzKCkge1xuICAgICAgdGhpcy5jbGVhckVkZ2VJbmRpY2VzKCk7XG4gICAgICB0aGlzLmNsZWFyTm9kZUluZGljZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZ3JhcGggc3RhdGUgcmVsYXRlZCB0byBub2Rlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFyTm9kZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyTm9kZVN0YXRlKCkge1xuICAgICAgdGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5ob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGdyYXBoIHN0YXRlIHJlbGF0ZWQgdG8gZWRnZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhckVkZ2VTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckVkZ2VTdGF0ZSgpIHtcbiAgICAgIHRoaXMuZGlzcGxheWVkRWRnZUxhYmVscyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuaG92ZXJlZEVkZ2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBncmFwaCBzdGF0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFyU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJTdGF0ZSgpIHtcbiAgICAgIHRoaXMuY2xlYXJFZGdlU3RhdGUoKTtcbiAgICAgIHRoaXMuY2xlYXJOb2RlU3RhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIG5vZGUgZGF0YSB0byBpdHMgcHJvZ3JhbS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqIEBwYXJhbSBmaW5nZXJwcmludCBBIGZpbmdlcnByaW50IHVzZWQgdG8gaWRlbnRpdHkgdGhlIG5vZGUgd2l0aCBwaWNraW5nXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBpbmRleCB3aGVyZSB0byBwbGFjZSB0aGUgbm9kZSBpbiB0aGUgcHJvZ3JhbVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZE5vZGVUb1Byb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZVRvUHJvZ3JhbShub2RlLCBmaW5nZXJwcmludCwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW25vZGVdO1xuICAgICAgdmFyIG5vZGVQcm9ncmFtID0gdGhpcy5ub2RlUHJvZ3JhbXNbZGF0YS50eXBlXTtcbiAgICAgIGlmICghbm9kZVByb2dyYW0pIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjb3VsZCBub3QgZmluZCBhIHN1aXRhYmxlIHByb2dyYW0gZm9yIG5vZGUgdHlwZSBcXFwiXCIuY29uY2F0KGRhdGEudHlwZSwgXCJcXFwiIVwiKSk7XG4gICAgICBub2RlUHJvZ3JhbS5wcm9jZXNzKGZpbmdlcnByaW50LCBwb3NpdGlvbiwgZGF0YSk7XG4gICAgICAvLyBTYXZpbmcgcHJvZ3JhbSBpbmRleFxuICAgICAgdGhpcy5ub2RlUHJvZ3JhbUluZGV4W25vZGVdID0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBlZGdlIGRhdGEgdG8gaXRzIHByb2dyYW0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gZWRnZSBUaGUgZWRnZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKiBAcGFyYW0gZmluZ2VycHJpbnQgQSBmaW5nZXJwcmludCB1c2VkIHRvIGlkZW50aXR5IHRoZSBlZGdlIHdpdGggcGlja2luZ1xuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgaW5kZXggd2hlcmUgdG8gcGxhY2UgdGhlIGVkZ2UgaW4gdGhlIHByb2dyYW1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRFZGdlVG9Qcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVkZ2VUb1Byb2dyYW0oZWRnZSwgZmluZ2VycHJpbnQsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZWRnZURhdGFDYWNoZVtlZGdlXTtcbiAgICAgIHZhciBlZGdlUHJvZ3JhbSA9IHRoaXMuZWRnZVByb2dyYW1zW2RhdGEudHlwZV07XG4gICAgICBpZiAoIWVkZ2VQcm9ncmFtKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY291bGQgbm90IGZpbmQgYSBzdWl0YWJsZSBwcm9ncmFtIGZvciBlZGdlIHR5cGUgXFxcIlwiLmNvbmNhdChkYXRhLnR5cGUsIFwiXFxcIiFcIikpO1xuICAgICAgdmFyIGV4dHJlbWl0aWVzID0gdGhpcy5ncmFwaC5leHRyZW1pdGllcyhlZGdlKSxcbiAgICAgICAgc291cmNlRGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtleHRyZW1pdGllc1swXV0sXG4gICAgICAgIHRhcmdldERhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbZXh0cmVtaXRpZXNbMV1dO1xuICAgICAgZWRnZVByb2dyYW0ucHJvY2VzcyhmaW5nZXJwcmludCwgcG9zaXRpb24sIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpO1xuICAgICAgLy8gU2F2aW5nIHByb2dyYW0gaW5kZXhcbiAgICAgIHRoaXMuZWRnZVByb2dyYW1JbmRleFtlZGdlXSA9IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIFB1YmxpYyBBUEkuXG4gICAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGdldCB0aGUgcmVuZGVyIHBhcmFtcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1JlbmRlclBhcmFtc31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZW5kZXJQYXJhbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVuZGVyUGFyYW1zKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0cml4OiB0aGlzLm1hdHJpeCxcbiAgICAgICAgaW52TWF0cml4OiB0aGlzLmludk1hdHJpeCxcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgIHBpeGVsUmF0aW86IHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgem9vbVJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgY2FtZXJhQW5nbGU6IHRoaXMuY2FtZXJhLmFuZ2xlLFxuICAgICAgICBzaXplUmF0aW86IDEgLyB0aGlzLnNjYWxlU2l6ZSgpLFxuICAgICAgICBjb3JyZWN0aW9uUmF0aW86IHRoaXMuY29ycmVjdGlvblJhdGlvLFxuICAgICAgICBkb3duU2l6aW5nUmF0aW86IHRoaXMucGlja2luZ0Rvd25TaXppbmdSYXRpbyxcbiAgICAgICAgbWluRWRnZVRoaWNrbmVzczogdGhpcy5zZXR0aW5ncy5taW5FZGdlVGhpY2tuZXNzLFxuICAgICAgICBhbnRpQWxpYXNpbmdGZWF0aGVyOiB0aGlzLnNldHRpbmdzLmFudGlBbGlhc2luZ0ZlYXRoZXJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byByZXRyaWV2ZSB0aGUgYWN0dWFsIHN0YWdlIHBhZGRpbmcgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3RhZ2VQYWRkaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YWdlUGFkZGluZygpIHtcbiAgICAgIHZhciBfdGhpcyRzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgIHN0YWdlUGFkZGluZyA9IF90aGlzJHNldHRpbmdzLnN0YWdlUGFkZGluZyxcbiAgICAgICAgYXV0b1Jlc2NhbGUgPSBfdGhpcyRzZXR0aW5ncy5hdXRvUmVzY2FsZTtcbiAgICAgIHJldHVybiBhdXRvUmVzY2FsZSA/IHN0YWdlUGFkZGluZyB8fCAwIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBhIGxheWVyIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBDb250ZXh0J3MgaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyAtIFRoZSBIVE1MIHRhZyB0byB1c2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVMYXllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVMYXllcihpZCwgdGFnKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tpZF0pIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBhIGxheWVyIG5hbWVkIFxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIiBhbHJlYWR5IGV4aXN0c1wiKSk7XG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQodGFnLCB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICAgIH0sIHtcbiAgICAgICAgXCJjbGFzc1wiOiBcInNpZ21hLVwiLmNvbmNhdChpZClcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuc3R5bGUpIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgb3B0aW9ucy5zdHlsZSk7XG4gICAgICB0aGlzLmVsZW1lbnRzW2lkXSA9IGVsZW1lbnQ7XG4gICAgICBpZiAoXCJiZWZvcmVMYXllclwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5iZWZvcmVMYXllcikge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW29wdGlvbnMuYmVmb3JlTGF5ZXJdLmJlZm9yZShlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoXCJhZnRlckxheWVyXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmFmdGVyTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tvcHRpb25zLmFmdGVyTGF5ZXJdLmFmdGVyKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBhIGNhbnZhcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gQ29udGV4dCdzIGlkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyhpZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5ZXIoaWQsIFwiY2FudmFzXCIsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIGEgY2FudmFzIGNvbnRleHQgYW5kIGFkZCB0aGUgcmVsZXZhbnQgRE9NIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBpZCAtIENvbnRleHQncyBpZC5cbiAgICAgKiBAcGFyYW0gIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVDYW52YXNDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhc0NvbnRleHQoaWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhcyhpZCwgb3B0aW9ucyk7XG4gICAgICB2YXIgY29udGV4dE9wdGlvbnMgPSB7XG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICAgIGFudGlhbGlhczogZmFsc2VcbiAgICAgIH07XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHRzW2lkXSA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dE9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgYSBXZWJHTCBjb250ZXh0IGFuZCBhZGQgdGhlIHJlbGV2YW50IERPTVxuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgaWQgICAgICAtIENvbnRleHQncyBpZC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3Q/fSBvcHRpb25zIC0gI2dldENvbnRleHQgcGFyYW1zIHRvIG92ZXJyaWRlIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlV2ViR0xDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVdlYkdMQ29udGV4dChpZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNhbnZhcyA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FudmFzKSB8fCB0aGlzLmNyZWF0ZUNhbnZhcyhpZCwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5oaWRkZW4pIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICB2YXIgY29udGV4dDtcblxuICAgICAgLy8gRmlyc3Qgd2UgdHJ5IHdlYmdsMiBmb3IgYW4gZWFzeSBwZXJmb3JtYW5jZSBib29zdFxuICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIGNvbnRleHRPcHRpb25zKTtcblxuICAgICAgLy8gRWxzZSB3ZSBmYWxsIGJhY2sgdG8gd2ViZ2xcbiAgICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgY29udGV4dE9wdGlvbnMpO1xuXG4gICAgICAvLyBFZGdlLCBJIGFtIGxvb2tpbmcgcmlnaHQgYXQgeW91Li4uXG4gICAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICB2YXIgZ2wgPSBjb250ZXh0O1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzW2lkXSA9IGdsO1xuXG4gICAgICAvLyBCbGVuZGluZzpcbiAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG4gICAgICAvLyBQcmVwYXJlIGZyYW1lIGJ1ZmZlciBmb3IgcGlja2luZyBsYXllcnM6XG4gICAgICBpZiAob3B0aW9ucy5waWNraW5nKSB7XG4gICAgICAgIHRoaXMucGlja2luZ0xheWVycy5hZGQoaWQpO1xuICAgICAgICB2YXIgbmV3RnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICBpZiAoIW5ld0ZyYW1lQnVmZmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY2Fubm90IGNyZWF0ZSBhIG5ldyBmcmFtZSBidWZmZXIgZm9yIGxheWVyIFwiLmNvbmNhdChpZCkpO1xuICAgICAgICB0aGlzLmZyYW1lQnVmZmVyc1tpZF0gPSBuZXdGcmFtZUJ1ZmZlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIHByb3Blcmx5IGtpbGwgYSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gaWQgLSBMYXllciBpZC5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJraWxsTGF5ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbExheWVyKGlkKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbaWRdO1xuICAgICAgaWYgKCFlbGVtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY2Fubm90IGtpbGwgbGF5ZXIgXCIuY29uY2F0KGlkLCBcIiwgd2hpY2ggZG9lcyBub3QgZXhpc3RcIikpO1xuICAgICAgaWYgKHRoaXMud2ViR0xDb250ZXh0c1tpZF0pIHtcbiAgICAgICAgdmFyIF9nbCRnZXRFeHRlbnNpb247XG4gICAgICAgIHZhciBnbCA9IHRoaXMud2ViR0xDb250ZXh0c1tpZF07XG4gICAgICAgIChfZ2wkZ2V0RXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpKSA9PT0gbnVsbCB8fCBfZ2wkZ2V0RXh0ZW5zaW9uID09PSB2b2lkIDAgfHwgX2dsJGdldEV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgICAgICBkZWxldGUgdGhpcy53ZWJHTENvbnRleHRzW2lkXTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jYW52YXNDb250ZXh0c1tpZF0pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FudmFzQ29udGV4dHNbaWRdO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWxldGUgbGF5ZXIgZWxlbWVudFxuICAgICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmVsZW1lbnRzW2lkXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIHJlbmRlcmVyJ3MgY2FtZXJhLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Q2FtZXJhfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldENhbWVyYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYW1lcmEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW1lcmE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHNldHRpbmcgdGhlIHJlbmRlcmVyJ3MgY2FtZXJhLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7Q2FtZXJhfSBjYW1lcmEgLSBOZXcgY2FtZXJhLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldENhbWVyYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYW1lcmEoY2FtZXJhKSB7XG4gICAgICB0aGlzLnVuYmluZENhbWVyYUhhbmRsZXJzKCk7XG4gICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIHRoaXMuYmluZENhbWVyYUhhbmRsZXJzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udGFpbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRhaW5lcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSByZW5kZXJlcidzIGdyYXBoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7R3JhcGh9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0R3JhcGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R3JhcGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ncmFwaDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzZXQgdGhlIHJlbmRlcmVyJ3MgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRHcmFwaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRHcmFwaChncmFwaCkge1xuICAgICAgaWYgKGdyYXBoID09PSB0aGlzLmdyYXBoKSByZXR1cm47XG5cbiAgICAgIC8vIENoZWNrIGhvdmVyZWROb2RlIGFuZCBob3ZlcmVkRWRnZVxuICAgICAgaWYgKHRoaXMuaG92ZXJlZE5vZGUgJiYgIWdyYXBoLmhhc05vZGUodGhpcy5ob3ZlcmVkTm9kZSkpIHRoaXMuaG92ZXJlZE5vZGUgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuaG92ZXJlZEVkZ2UgJiYgIWdyYXBoLmhhc0VkZ2UodGhpcy5ob3ZlcmVkRWRnZSkpIHRoaXMuaG92ZXJlZEVkZ2UgPSBudWxsO1xuXG4gICAgICAvLyBVbmJpbmRpbmcgaGFuZGxlcnMgb24gdGhlIGN1cnJlbnQgZ3JhcGhcbiAgICAgIHRoaXMudW5iaW5kR3JhcGhIYW5kbGVycygpO1xuICAgICAgaWYgKHRoaXMuY2hlY2tFZGdlc0V2ZW50c0ZyYW1lICE9PSBudWxsKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuY2hlY2tFZGdlc0V2ZW50c0ZyYW1lKTtcbiAgICAgICAgdGhpcy5jaGVja0VkZ2VzRXZlbnRzRnJhbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnN0YWxsaW5nIG5ldyBncmFwaFxuICAgICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuXG4gICAgICAvLyBCaW5kaW5nIG5ldyBoYW5kbGVyc1xuICAgICAgdGhpcy5iaW5kR3JhcGhIYW5kbGVycygpO1xuXG4gICAgICAvLyBSZS1yZW5kZXJpbmcgbm93IHRvIGF2b2lkIGRpc2NyZXBhbmNpZXMgZnJvbSBub3cgdG8gbmV4dCBmcmFtZVxuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgbW91c2UgY2FwdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TW91c2VDYXB0b3J9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TW91c2VDYXB0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW91c2VDYXB0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZUNhcHRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSB0b3VjaCBjYXB0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtUb3VjaENhcHRvcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb3VjaENhcHRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3VjaENhcHRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvdWNoQ2FwdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGN1cnJlbnQgcmVuZGVyZXIncyBkaW1lbnNpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RGltZW5zaW9uc31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXREaW1lbnNpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjdXJyZW50IGdyYXBoJ3MgZGltZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0RpbWVuc2lvbnN9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0R3JhcGhEaW1lbnNpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdyYXBoRGltZW5zaW9ucygpIHtcbiAgICAgIHZhciBleHRlbnQgPSB0aGlzLmN1c3RvbUJCb3ggfHwgdGhpcy5ub2RlRXh0ZW50O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGV4dGVudC54WzFdIC0gZXh0ZW50LnhbMF0gfHwgMSxcbiAgICAgICAgaGVpZ2h0OiBleHRlbnQueVsxXSAtIGV4dGVudC55WzBdIHx8IDFcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IGFsbCB0aGUgc2lnbWEgbm9kZSBhdHRyaWJ1dGVzLlxuICAgICAqIEl0J3MgdXNlZnVsIGZvciBleGFtcGxlIHRvIGdldCB0aGUgcG9zaXRpb24gb2YgYSBub2RlXG4gICAgICogYW5kIHRvIGdldCB2YWx1ZXMgdGhhdCBhcmUgc2V0IGJ5IHRoZSBub2RlUmVkdWNlclxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgbm9kZSdzIGtleS5cbiAgICAgKiBAcmV0dXJuIHtOb2RlRGlzcGxheURhdGEgfCB1bmRlZmluZWR9IEEgY29weSBvZiB0aGUgZGVzaXJlZCBub2RlJ3MgYXR0cmlidXRlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXROb2RlRGlzcGxheURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZURpc3BsYXlEYXRhKGtleSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVEYXRhQ2FjaGVba2V5XTtcbiAgICAgIHJldHVybiBub2RlID8gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IGFsbCB0aGUgc2lnbWEgZWRnZSBhdHRyaWJ1dGVzLlxuICAgICAqIEl0J3MgdXNlZnVsIGZvciBleGFtcGxlIHRvIGdldCB2YWx1ZXMgdGhhdCBhcmUgc2V0IGJ5IHRoZSBlZGdlUmVkdWNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IC0gVGhlIGVkZ2UncyBrZXkuXG4gICAgICogQHJldHVybiB7RWRnZURpc3BsYXlEYXRhIHwgdW5kZWZpbmVkfSBBIGNvcHkgb2YgdGhlIGRlc2lyZWQgZWRnZSdzIGF0dHJpYnV0ZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWRnZURpc3BsYXlEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVkZ2VEaXNwbGF5RGF0YShrZXkpIHtcbiAgICAgIHZhciBlZGdlID0gdGhpcy5lZGdlRGF0YUNhY2hlW2tleV07XG4gICAgICByZXR1cm4gZWRnZSA/IE9iamVjdC5hc3NpZ24oe30sIGVkZ2UpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSBkaXNwbGF5ZWQgbm9kZSBsYWJlbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTZXQ8c3RyaW5nPn0gQSBzZXQgb2Ygbm9kZSBrZXlzIHdob3NlIGxhYmVsIGlzIGRpc3BsYXllZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXROb2RlRGlzcGxheWVkTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVEaXNwbGF5ZWRMYWJlbHMoKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSBkaXNwbGF5ZWQgZWRnZSBsYWJlbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTZXQ8c3RyaW5nPn0gQSBzZXQgb2YgZWRnZSBrZXlzIHdob3NlIGxhYmVsIGlzIGRpc3BsYXllZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZGdlRGlzcGxheWVkTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVkZ2VEaXNwbGF5ZWRMYWJlbHMoKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh0aGlzLmRpc3BsYXllZEVkZ2VMYWJlbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgYSBjb3B5IG9mIHRoZSBzZXR0aW5ncyBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2V0dGluZ3N9IEEgY29weSBvZiB0aGUgc2V0dGluZ3MgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXR0aW5ncygpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgY3VycmVudCB2YWx1ZSBmb3IgYSBnaXZlbiBzZXR0aW5nIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IC0gVGhlIHNldHRpbmcga2V5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJuIHthbnl9IFRoZSB2YWx1ZSBhdHRhY2hlZCB0byB0aGlzIHNldHRpbmcga2V5IG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXR0aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNldHRpbmcoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1trZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBzZXR0aW5nIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIHNldHRpbmcga2V5LiBOb3RlIHRoYXQgdGhpcyB3aWxsIHNjaGVkdWxlXG4gICAgICogYSBuZXcgcmVuZGVyIG5leHQgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleSAtIFRoZSBzZXR0aW5nIGtleSB0byBzZXQuXG4gICAgICogQHBhcmFtICB7YW55fSAgICB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2V0dGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZXR0aW5nKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvbGRWYWx1ZXMgPSBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICB0aGlzLnNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgICAgIHZhbGlkYXRlU2V0dGluZ3ModGhpcy5zZXR0aW5ncyk7XG4gICAgICB0aGlzLmhhbmRsZVNldHRpbmdzVXBkYXRlKG9sZFZhbHVlcyk7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVwZGF0aW5nIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIHNldHRpbmcga2V5IHVzaW5nIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIHNjaGVkdWxlIGEgbmV3IHJlbmRlciBuZXh0IGZyYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgIGtleSAgICAgLSBUaGUgc2V0dGluZyBrZXkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSB1cGRhdGVyIC0gVGhlIHVwZGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTZXR0aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNldHRpbmcoa2V5LCB1cGRhdGVyKSB7XG4gICAgICB0aGlzLnNldFNldHRpbmcoa2V5LCB1cGRhdGVyKHRoaXMuc2V0dGluZ3Nba2V5XSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHNldHRpbmcgbXVsdGlwbGUgc2V0dGluZ3MgYXQgb25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1BhcnRpYWw8U2V0dGluZ3M+fSBzZXR0aW5ncyAtIFRoZSBzZXR0aW5ncyB0byBzZXQuXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2V0dGluZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgIHZhciBvbGRWYWx1ZXMgPSBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICB0aGlzLnNldHRpbmdzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMuc2V0dGluZ3MpLCBzZXR0aW5ncyk7XG4gICAgICB2YWxpZGF0ZVNldHRpbmdzKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgdGhpcy5oYW5kbGVTZXR0aW5nc1VwZGF0ZShvbGRWYWx1ZXMpO1xuICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2goKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlc2l6ZSB0aGUgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBmb3JjZSAtIElmIHRydWUsIHRoZW4gcmVzaXplIGlzIHByb2Nlc3NlZCBldmVuIGlmIHNpemUgaXMgdW5jaGFuZ2VkIChvcHRpb25hbCkuXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShmb3JjZSkge1xuICAgICAgdmFyIHByZXZpb3VzV2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICBwcmV2aW91c0hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICB0aGlzLnBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKCk7XG4gICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5hbGxvd0ludmFsaWRDb250YWluZXIpIHRoaXMud2lkdGggPSAxO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IENvbnRhaW5lciBoYXMgbm8gd2lkdGguIFlvdSBjYW4gc2V0IHRoZSBhbGxvd0ludmFsaWRDb250YWluZXIgc2V0dGluZyB0byB0cnVlIHRvIHN0b3Agc2VlaW5nIHRoaXMgZXJyb3IuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmFsbG93SW52YWxpZENvbnRhaW5lcikgdGhpcy5oZWlnaHQgPSAxO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IENvbnRhaW5lciBoYXMgbm8gaGVpZ2h0LiBZb3UgY2FuIHNldCB0aGUgYWxsb3dJbnZhbGlkQ29udGFpbmVyIHNldHRpbmcgdG8gdHJ1ZSB0byBzdG9wIHNlZWluZyB0aGlzIGVycm9yLlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm90aGluZyBoYXMgY2hhbmdlZCwgd2UgY2FuIHN0b3AgcmlnaHQgaGVyZVxuICAgICAgaWYgKCFmb3JjZSAmJiBwcmV2aW91c1dpZHRoID09PSB0aGlzLndpZHRoICYmIHByZXZpb3VzSGVpZ2h0ID09PSB0aGlzLmhlaWdodCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIFNpemluZyBkb20gZWxlbWVudHNcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2lkXTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpemluZyBjYW52YXMgY29udGV4dHNcbiAgICAgIGZvciAodmFyIF9pZCBpbiB0aGlzLmNhbnZhc0NvbnRleHRzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbX2lkXS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvICsgXCJweFwiKTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tfaWRdLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyArIFwicHhcIik7XG4gICAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW8gIT09IDEpIHRoaXMuY2FudmFzQ29udGV4dHNbX2lkXS5zY2FsZSh0aGlzLnBpeGVsUmF0aW8sIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpemluZyBXZWJHTCBjb250ZXh0c1xuICAgICAgZm9yICh2YXIgX2lkMiBpbiB0aGlzLndlYkdMQ29udGV4dHMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tfaWQyXS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvICsgXCJweFwiKTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tfaWQyXS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8gKyBcInB4XCIpO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLndlYkdMQ29udGV4dHNbX2lkMl07XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8sIHRoaXMuaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKTtcblxuICAgICAgICAvLyBDbGVhciBwaWNraW5nIHRleHR1cmUgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnBpY2tpbmdMYXllcnMuaGFzKF9pZDIpKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUZXh0dXJlID0gdGhpcy50ZXh0dXJlc1tfaWQyXTtcbiAgICAgICAgICBpZiAoY3VycmVudFRleHR1cmUpIGdsLmRlbGV0ZVRleHR1cmUoY3VycmVudFRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJyZXNpemVcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBjbGVhciBhbGwgdGhlIGNhbnZhc2VzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmVtaXQoXCJiZWZvcmVDbGVhclwiKTtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cy5ub2Rlcy5iaW5kRnJhbWVidWZmZXIoV2ViR0xSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cy5ub2Rlcy5jbGVhcihXZWJHTFJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHMuZWRnZXMuYmluZEZyYW1lYnVmZmVyKFdlYkdMUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHMuZWRnZXMuY2xlYXIoV2ViR0xSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzLmhvdmVyTm9kZXMuY2xlYXIoV2ViR0xSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0cy5sYWJlbHMuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dHMuaG92ZXJzLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHRzLmVkZ2VMYWJlbHMuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuZW1pdChcImFmdGVyQ2xlYXJcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZWZyZXNoLCBpLmUuIGZvcmNlIHRoZSByZW5kZXJlciB0byByZXByb2Nlc3MgZ3JhcGhcbiAgICAgKiBkYXRhIGFuZCByZW5kZXIsIGJ1dCBrZWVwIHRoZSBzdGF0ZS5cbiAgICAgKiAtIGlmIGEgcGFydGlhbEdyYXBoIGlzIHByb3ZpZGVkLCB3ZSBvbmx5IHJlcHJvY2VzcyB0aG9zZSBub2RlcyAmIGVkZ2VzLlxuICAgICAqIC0gaWYgc2NoZWR1bGUgaXMgVFJVRSwgd2Ugc2NoZWR1bGUgYSByZW5kZXIgaW5zdGVhZCBvZiBzeW5jIHJlbmRlclxuICAgICAqIC0gaWYgc2tpcEluZGV4YXRpb24gaXMgVFJVRSwgdGhlbiBsYWJlbEdyaWQgJiBwcm9ncmFtIGluZGV4YXRpb24gYXJlIHNraXBwZWQgKGNhbiBiZSB1c2VkIGlmIHlvdSBoYXZlbid0IG1vZGlmeSB4LCB5LCB6SW5kZXggJiBzaXplKVxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKG9wdHMpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcbiAgICAgIHZhciBza2lwSW5kZXhhdGlvbiA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2tpcEluZGV4YXRpb24pICE9PSB1bmRlZmluZWQgPyBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2tpcEluZGV4YXRpb24gOiBmYWxzZTtcbiAgICAgIHZhciBzY2hlZHVsZSA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2NoZWR1bGUpICE9PSB1bmRlZmluZWQgPyBvcHRzLnNjaGVkdWxlIDogZmFsc2U7XG4gICAgICB2YXIgZnVsbFJlZnJlc2ggPSAhb3B0cyB8fCAhb3B0cy5wYXJ0aWFsR3JhcGg7XG4gICAgICBpZiAoZnVsbFJlZnJlc2gpIHtcbiAgICAgICAgLy8gUmUtaW5kZXggZ3JhcGggZGF0YVxuICAgICAgICB0aGlzLmNsZWFyRWRnZUluZGljZXMoKTtcbiAgICAgICAgdGhpcy5jbGVhck5vZGVJbmRpY2VzKCk7XG4gICAgICAgIHRoaXMuZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMxMC5hZGROb2RlKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ncmFwaC5mb3JFYWNoRWRnZShmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczEwLmFkZEVkZ2UoZWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9vcHRzJHBhcnRpYWxHcmFwaCwgX29wdHMkcGFydGlhbEdyYXBoMjtcbiAgICAgICAgdmFyIG5vZGVzID0gKChfb3B0cyRwYXJ0aWFsR3JhcGggPSBvcHRzLnBhcnRpYWxHcmFwaCkgPT09IG51bGwgfHwgX29wdHMkcGFydGlhbEdyYXBoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0cyRwYXJ0aWFsR3JhcGgubm9kZXMpIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IChub2RlcyA9PT0gbnVsbCB8fCBub2RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZXMubGVuZ3RoKSB8fCAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAvLyBSZWNvbXB1dGUgbm9kZSdzIGRhdGEgKGllLiBhcHBseSByZWR1Y2VyKVxuICAgICAgICAgIHRoaXMudXBkYXRlTm9kZShub2RlKTtcbiAgICAgICAgICAvLyBBZGQgbm9kZSB0byB0aGUgcHJvZ3JhbSBpZiBsYXlvdXQgaXMgdW5jaGFuZ2VkLlxuICAgICAgICAgIC8vIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRvbmUgaW4gdGhlIHByb2Nlc3MgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoc2tpcEluZGV4YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtSW5kZXggPSB0aGlzLm5vZGVQcm9ncmFtSW5kZXhbbm9kZV07XG4gICAgICAgICAgICBpZiAocHJvZ3JhbUluZGV4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBub2RlIFxcXCJcIi5jb25jYXQobm9kZSwgXCJcXFwiIGNhbid0IGJlIHJlcGFpbnRcIikpO1xuICAgICAgICAgICAgdGhpcy5hZGROb2RlVG9Qcm9ncmFtKG5vZGUsIHRoaXMubm9kZUluZGljZXNbbm9kZV0sIHByb2dyYW1JbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBlZGdlcyA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCB8fCAoX29wdHMkcGFydGlhbEdyYXBoMiA9IG9wdHMucGFydGlhbEdyYXBoKSA9PT0gbnVsbCB8fCBfb3B0cyRwYXJ0aWFsR3JhcGgyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0cyRwYXJ0aWFsR3JhcGgyLmVkZ2VzKSB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX2w0ID0gZWRnZXMubGVuZ3RoOyBfaTQgPCBfbDQ7IF9pNCsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tfaTRdO1xuICAgICAgICAgIC8vIFJlY29tcHV0ZSBlZGdlJ3MgZGF0YSAoaWUuIGFwcGx5IHJlZHVjZXIpXG4gICAgICAgICAgdGhpcy51cGRhdGVFZGdlKGVkZ2UpO1xuICAgICAgICAgIC8vIEFkZCBlZGdlIHRvIHRoZSBwcm9ncmFtXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZG9uZSBpbiB0aGUgcHJvY2VzcyBmdW5jdGlvblxuICAgICAgICAgIGlmIChza2lwSW5kZXhhdGlvbikge1xuICAgICAgICAgICAgdmFyIF9wcm9ncmFtSW5kZXggPSB0aGlzLmVkZ2VQcm9ncmFtSW5kZXhbZWRnZV07XG4gICAgICAgICAgICBpZiAoX3Byb2dyYW1JbmRleCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogZWRnZSBcXFwiXCIuY29uY2F0KGVkZ2UsIFwiXFxcIiBjYW4ndCBiZSByZXBhaW50XCIpKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRWRnZVRvUHJvZ3JhbShlZGdlLCB0aGlzLmVkZ2VJbmRpY2VzW2VkZ2VdLCBfcHJvZ3JhbUluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG8gd2UgbmVlZCB0byBjYWxsIHRoZSBwcm9jZXNzIGZ1bmN0aW9uID9cbiAgICAgIGlmIChmdWxsUmVmcmVzaCB8fCAhc2tpcEluZGV4YXRpb24pIHRoaXMubmVlZFRvUHJvY2VzcyA9IHRydWU7XG4gICAgICBpZiAoc2NoZWR1bGUpIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtlbHNlIHRoaXMucmVuZGVyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzY2hlZHVsZSBhIHJlbmRlciBhdCB0aGUgbmV4dCBhdmFpbGFibGUgZnJhbWUuXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIHNhZmVseSBjYWxsZWQgb24gYSBzYW1lIGZyYW1lIGJlY2F1c2UgaXQgYmFzaWNhbGx5XG4gICAgICogZGVib3VuY2VzIHJlZnJlc2ggdG8gdGhlIG5leHQgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzY2hlZHVsZVJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlZHVsZVJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5yZW5kZXJGcmFtZSkge1xuICAgICAgICB0aGlzLnJlbmRlckZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczExLnJlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNjaGVkdWxlIGEgcmVmcmVzaCAoaS5lLiBmdWxseSByZXByb2Nlc3MgZ3JhcGggZGF0YSBhbmQgcmVuZGVyKVxuICAgICAqIGF0IHRoZSBuZXh0IGF2YWlsYWJsZSBmcmFtZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgc2FmZWx5IGNhbGxlZCBvbiBhIHNhbWUgZnJhbWUgYmVjYXVzZSBpdCBiYXNpY2FsbHlcbiAgICAgKiBkZWJvdW5jZXMgcmVmcmVzaCB0byB0aGUgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNjaGVkdWxlUmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlZHVsZVJlZnJlc2gob3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaChfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0cyksIHt9LCB7XG4gICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gKHVuKXpvb20sIHdoaWxlIHByZXNlcnZpbmcgdGhlIHBvc2l0aW9uIG9mIGEgdmlld3BvcnQgcG9pbnQuXG4gICAgICogVXNlZCBmb3IgaW5zdGFuY2UgdG8gem9vbSBcIm9uIHRoZSBtb3VzZSBjdXJzb3JcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2aWV3cG9ydFRhcmdldFxuICAgICAqIEBwYXJhbSBuZXdSYXRpb1xuICAgICAqIEByZXR1cm4ge0NhbWVyYVN0YXRlfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFZpZXdwb3J0Wm9vbWVkU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vmlld3BvcnRab29tZWRTdGF0ZSh2aWV3cG9ydFRhcmdldCwgbmV3UmF0aW8pIHtcbiAgICAgIHZhciBfdGhpcyRjYW1lcmEkZ2V0U3RhdGUgPSB0aGlzLmNhbWVyYS5nZXRTdGF0ZSgpLFxuICAgICAgICByYXRpbyA9IF90aGlzJGNhbWVyYSRnZXRTdGF0ZS5yYXRpbyxcbiAgICAgICAgYW5nbGUgPSBfdGhpcyRjYW1lcmEkZ2V0U3RhdGUuYW5nbGUsXG4gICAgICAgIHggPSBfdGhpcyRjYW1lcmEkZ2V0U3RhdGUueCxcbiAgICAgICAgeSA9IF90aGlzJGNhbWVyYSRnZXRTdGF0ZS55O1xuICAgICAgdmFyIF90aGlzJHNldHRpbmdzMiA9IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgIG1pbkNhbWVyYVJhdGlvID0gX3RoaXMkc2V0dGluZ3MyLm1pbkNhbWVyYVJhdGlvLFxuICAgICAgICBtYXhDYW1lcmFSYXRpbyA9IF90aGlzJHNldHRpbmdzMi5tYXhDYW1lcmFSYXRpbztcbiAgICAgIGlmICh0eXBlb2YgbWF4Q2FtZXJhUmF0aW8gPT09IFwibnVtYmVyXCIpIG5ld1JhdGlvID0gTWF0aC5taW4obmV3UmF0aW8sIG1heENhbWVyYVJhdGlvKTtcbiAgICAgIGlmICh0eXBlb2YgbWluQ2FtZXJhUmF0aW8gPT09IFwibnVtYmVyXCIpIG5ld1JhdGlvID0gTWF0aC5tYXgobmV3UmF0aW8sIG1pbkNhbWVyYVJhdGlvKTtcbiAgICAgIHZhciByYXRpb0RpZmYgPSBuZXdSYXRpbyAvIHJhdGlvO1xuICAgICAgdmFyIGNlbnRlciA9IHtcbiAgICAgICAgeDogdGhpcy53aWR0aCAvIDIsXG4gICAgICAgIHk6IHRoaXMuaGVpZ2h0IC8gMlxuICAgICAgfTtcbiAgICAgIHZhciBncmFwaE1vdXNlUG9zaXRpb24gPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh2aWV3cG9ydFRhcmdldCk7XG4gICAgICB2YXIgZ3JhcGhDZW50ZXJQb3NpdGlvbiA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKGNlbnRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgIHg6IChncmFwaE1vdXNlUG9zaXRpb24ueCAtIGdyYXBoQ2VudGVyUG9zaXRpb24ueCkgKiAoMSAtIHJhdGlvRGlmZikgKyB4LFxuICAgICAgICB5OiAoZ3JhcGhNb3VzZVBvc2l0aW9uLnkgLSBncmFwaENlbnRlclBvc2l0aW9uLnkpICogKDEgLSByYXRpb0RpZmYpICsgeSxcbiAgICAgICAgcmF0aW86IG5ld1JhdGlvXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGFic3RyYWN0IHJlY3RhbmdsZSBjb250YWluaW5nIHRoZSBncmFwaCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgY2FtZXJhJ3Mgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIHZpZXcncyByZWN0YW5nbGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlld1JlY3RhbmdsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWV3UmVjdGFuZ2xlKCkge1xuICAgICAgdmFyIHAxID0gdGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgoe1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9KSxcbiAgICAgICAgcDIgPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogdGhpcy53aWR0aCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0pLFxuICAgICAgICBoID0gdGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgoe1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogdGhpcy5oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogcDEueCxcbiAgICAgICAgeTE6IHAxLnksXG4gICAgICAgIHgyOiBwMi54LFxuICAgICAgICB5MjogcDIueSxcbiAgICAgICAgaGVpZ2h0OiBwMi55IC0gaC55XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgZnJvbSB0aGUgZnJhbWVkIGdyYXBoIHN5c3RlbSB0byB0aGUgdmlld3BvcnQgc3lzdGVtLiBJdCBhbGxvd3NcbiAgICAgKiBvdmVycmlkaW5nIGFueXRoaW5nIHRoYXQgaXMgdXNlZCB0byBnZXQgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCwgb3IgZXZlbiB0aGUgbWF0cml4IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEJlIGNhcmVmdWwgaWYgb3ZlcnJpZGluZyBkaW1lbnNpb25zLCBwYWRkaW5nIG9yIGNhbWVyYVN0YXRlLCBhcyB0aGUgY29tcHV0YXRpb24gb2YgdGhlIG1hdHJpeCBpcyBub3QgdGhlIGxpZ2h0ZXN0XG4gICAgICogb2YgY29tcHV0YXRpb25zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZyYW1lZEdyYXBoVG9WaWV3cG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcmFtZWRHcmFwaFRvVmlld3BvcnQoY29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBvdmVycmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgcmVjb21wdXRlTWF0cml4ID0gISFvdmVycmlkZS5jYW1lcmFTdGF0ZSB8fCAhIW92ZXJyaWRlLnZpZXdwb3J0RGltZW5zaW9ucyB8fCAhIW92ZXJyaWRlLmdyYXBoRGltZW5zaW9ucztcbiAgICAgIHZhciBtYXRyaXggPSBvdmVycmlkZS5tYXRyaXggPyBvdmVycmlkZS5tYXRyaXggOiByZWNvbXB1dGVNYXRyaXggPyBtYXRyaXhGcm9tQ2FtZXJhKG92ZXJyaWRlLmNhbWVyYVN0YXRlIHx8IHRoaXMuY2FtZXJhLmdldFN0YXRlKCksIG92ZXJyaWRlLnZpZXdwb3J0RGltZW5zaW9ucyB8fCB0aGlzLmdldERpbWVuc2lvbnMoKSwgb3ZlcnJpZGUuZ3JhcGhEaW1lbnNpb25zIHx8IHRoaXMuZ2V0R3JhcGhEaW1lbnNpb25zKCksIG92ZXJyaWRlLnBhZGRpbmcgfHwgdGhpcy5nZXRTdGFnZVBhZGRpbmcoKSkgOiB0aGlzLm1hdHJpeDtcbiAgICAgIHZhciB2aWV3cG9ydFBvcyA9IG11bHRpcGx5VmVjMihtYXRyaXgsIGNvb3JkaW5hdGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6ICgxICsgdmlld3BvcnRQb3MueCkgKiB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgeTogKDEgLSB2aWV3cG9ydFBvcy55KSAqIHRoaXMuaGVpZ2h0IC8gMlxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IGZyb20gdGhlIHZpZXdwb3J0IHN5c3RlbSB0byB0aGUgZnJhbWVkIGdyYXBoIHN5c3RlbS4gSXQgYWxsb3dzXG4gICAgICogb3ZlcnJpZGluZyBhbnl0aGluZyB0aGF0IGlzIHVzZWQgdG8gZ2V0IHRoZSB0cmFuc2xhdGlvbiBtYXRyaXgsIG9yIGV2ZW4gdGhlIG1hdHJpeCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBCZSBjYXJlZnVsIGlmIG92ZXJyaWRpbmcgZGltZW5zaW9ucywgcGFkZGluZyBvciBjYW1lcmFTdGF0ZSwgYXMgdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBtYXRyaXggaXMgbm90IHRoZSBsaWdodGVzdFxuICAgICAqIG9mIGNvbXB1dGF0aW9ucy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ2aWV3cG9ydFRvRnJhbWVkR3JhcGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlld3BvcnRUb0ZyYW1lZEdyYXBoKGNvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIHJlY29tcHV0ZU1hdHJpeCA9ICEhb3ZlcnJpZGUuY2FtZXJhU3RhdGUgfHwgISFvdmVycmlkZS52aWV3cG9ydERpbWVuc2lvbnMgfHwgIW92ZXJyaWRlLmdyYXBoRGltZW5zaW9ucztcbiAgICAgIHZhciBpbnZNYXRyaXggPSBvdmVycmlkZS5tYXRyaXggPyBvdmVycmlkZS5tYXRyaXggOiByZWNvbXB1dGVNYXRyaXggPyBtYXRyaXhGcm9tQ2FtZXJhKG92ZXJyaWRlLmNhbWVyYVN0YXRlIHx8IHRoaXMuY2FtZXJhLmdldFN0YXRlKCksIG92ZXJyaWRlLnZpZXdwb3J0RGltZW5zaW9ucyB8fCB0aGlzLmdldERpbWVuc2lvbnMoKSwgb3ZlcnJpZGUuZ3JhcGhEaW1lbnNpb25zIHx8IHRoaXMuZ2V0R3JhcGhEaW1lbnNpb25zKCksIG92ZXJyaWRlLnBhZGRpbmcgfHwgdGhpcy5nZXRTdGFnZVBhZGRpbmcoKSwgdHJ1ZSkgOiB0aGlzLmludk1hdHJpeDtcbiAgICAgIHZhciByZXMgPSBtdWx0aXBseVZlYzIoaW52TWF0cml4LCB7XG4gICAgICAgIHg6IGNvb3JkaW5hdGVzLnggLyB0aGlzLndpZHRoICogMiAtIDEsXG4gICAgICAgIHk6IDEgLSBjb29yZGluYXRlcy55IC8gdGhpcy5oZWlnaHQgKiAyXG4gICAgICB9KTtcbiAgICAgIGlmIChpc05hTihyZXMueCkpIHJlcy54ID0gMDtcbiAgICAgIGlmIChpc05hTihyZXMueSkpIHJlcy55ID0gMDtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gdHJhbnNsYXRlIGEgcG9pbnQncyBjb29yZGluYXRlcyBmcm9tIHRoZSB2aWV3cG9ydCBzeXN0ZW0gKHBpeGVsIGRpc3RhbmNlIGZyb20gdGhlIHRvcC1sZWZ0IG9mIHRoZVxuICAgICAqIHN0YWdlKSB0byB0aGUgZ3JhcGggc3lzdGVtICh0aGUgcmVmZXJlbmNlIHN5c3RlbSBvZiBkYXRhIGFzIHRoZXkgYXJlIGluIHRoZSBnaXZlbiBncmFwaCBpbnN0YW5jZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhY2NlcHRzIGFuIG9wdGlvbmFsIGNhbWVyYSB3aGljaCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBuZWVkIHRvIHRyYW5zbGF0ZSBjb29yZGluYXRlc1xuICAgICAqIGJhc2VkIG9uIGEgZGlmZmVyZW50IHZpZXcgdGhhbiB0aGUgb25lIGJlaW5nIGN1cnJlbnRseSBiZWluZyBkaXNwbGF5ZWQgb24gc2NyZWVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlc30gICAgICAgICAgICAgICAgICB2aWV3cG9ydFBvaW50XG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlQ29udmVyc2lvbk92ZXJyaWRlfSBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZpZXdwb3J0VG9HcmFwaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWV3cG9ydFRvR3JhcGgodmlld3BvcnRQb2ludCkge1xuICAgICAgdmFyIG92ZXJyaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbi5pbnZlcnNlKHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHZpZXdwb3J0UG9pbnQsIG92ZXJyaWRlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gdHJhbnNsYXRlIGEgcG9pbnQncyBjb29yZGluYXRlcyBmcm9tIHRoZSBncmFwaCBzeXN0ZW0gKHRoZSByZWZlcmVuY2Ugc3lzdGVtIG9mIGRhdGEgYXMgdGhleSBhcmUgaW5cbiAgICAgKiB0aGUgZ2l2ZW4gZ3JhcGggaW5zdGFuY2UpIHRvIHRoZSB2aWV3cG9ydCBzeXN0ZW0gKHBpeGVsIGRpc3RhbmNlIGZyb20gdGhlIHRvcC1sZWZ0IG9mIHRoZSBzdGFnZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhY2NlcHRzIGFuIG9wdGlvbmFsIGNhbWVyYSB3aGljaCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBuZWVkIHRvIHRyYW5zbGF0ZSBjb29yZGluYXRlc1xuICAgICAqIGJhc2VkIG9uIGEgZGlmZmVyZW50IHZpZXcgdGhhbiB0aGUgb25lIGJlaW5nIGN1cnJlbnRseSBiZWluZyBkaXNwbGF5ZWQgb24gc2NyZWVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlc30gICAgICAgICAgICAgICAgICBncmFwaFBvaW50XG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlQ29udmVyc2lvbk92ZXJyaWRlfSBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdyYXBoVG9WaWV3cG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncmFwaFRvVmlld3BvcnQoZ3JhcGhQb2ludCkge1xuICAgICAgdmFyIG92ZXJyaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiB0aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydCh0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbihncmFwaFBvaW50KSwgb3ZlcnJpZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGRpc3RhbmNlIG11bHRpcGxpZXIgYmV0d2VlbiB0aGUgZ3JhcGggc3lzdGVtIGFuZCB0aGVcbiAgICAgKiB2aWV3cG9ydCBzeXN0ZW0uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0R3JhcGhUb1ZpZXdwb3J0UmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R3JhcGhUb1ZpZXdwb3J0UmF0aW8oKSB7XG4gICAgICB2YXIgZ3JhcGhQMSA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIHZhciBncmFwaFAyID0ge1xuICAgICAgICB4OiAxLFxuICAgICAgICB5OiAxXG4gICAgICB9O1xuICAgICAgdmFyIGdyYXBoRCA9IE1hdGguc3FydChNYXRoLnBvdyhncmFwaFAxLnggLSBncmFwaFAyLngsIDIpICsgTWF0aC5wb3coZ3JhcGhQMS55IC0gZ3JhcGhQMi55LCAyKSk7XG4gICAgICB2YXIgdmlld3BvcnRQMSA9IHRoaXMuZ3JhcGhUb1ZpZXdwb3J0KGdyYXBoUDEpO1xuICAgICAgdmFyIHZpZXdwb3J0UDIgPSB0aGlzLmdyYXBoVG9WaWV3cG9ydChncmFwaFAyKTtcbiAgICAgIHZhciB2aWV3cG9ydEQgPSBNYXRoLnNxcnQoTWF0aC5wb3codmlld3BvcnRQMS54IC0gdmlld3BvcnRQMi54LCAyKSArIE1hdGgucG93KHZpZXdwb3J0UDEueSAtIHZpZXdwb3J0UDIueSwgMikpO1xuICAgICAgcmV0dXJuIHZpZXdwb3J0RCAvIGdyYXBoRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBncmFwaCdzIGJvdW5kaW5nIGJveC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3sgeDogRXh0ZW50LCB5OiBFeHRlbnQgfX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRCQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJCb3goKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlRXh0ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdyYXBoJ3MgY3VzdG9tIGJvdW5kaW5nIGJveCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHJldHVybiB7eyB4OiBFeHRlbnQsIHk6IEV4dGVudCB9IHwgbnVsbH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDdXN0b21CQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1c3RvbUJCb3goKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXN0b21CQm94O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIG92ZXJyaWRlIHRoZSBncmFwaCdzIGJvdW5kaW5nIGJveCB3aXRoIGEgY3VzdG9tIG9uZS4gR2l2ZSBgbnVsbGAgYXMgdGhlIGFyZ3VtZW50IHRvIHN0b3Agb3ZlcnJpZGluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldEN1c3RvbUJCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VzdG9tQkJveChjdXN0b21CQm94KSB7XG4gICAgICB0aGlzLmN1c3RvbUJCb3ggPSBjdXN0b21CQm94O1xuICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gc2h1dCB0aGUgY29udGFpbmVyICYgcmVsZWFzZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwia2lsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgLy8gRW1pdHRpbmcgXCJraWxsXCIgZXZlbnRzIHNvIHRoYXQgcGx1Z2lucyBhbmQgc3VjaCBjYW4gY2xlYW51cFxuICAgICAgdGhpcy5lbWl0KFwia2lsbFwiKTtcblxuICAgICAgLy8gUmVsZWFzaW5nIGV2ZW50c1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgICAgLy8gUmVsZWFzaW5nIGNhbWVyYSBoYW5kbGVyc1xuICAgICAgdGhpcy51bmJpbmRDYW1lcmFIYW5kbGVycygpO1xuXG4gICAgICAvLyBSZWxlYXNpbmcgRE9NIGV2ZW50cyAmIGNhcHRvcnNcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVJlc2l6ZSk7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLmtpbGwoKTtcbiAgICAgIHRoaXMudG91Y2hDYXB0b3Iua2lsbCgpO1xuXG4gICAgICAvLyBSZWxlYXNpbmcgZ3JhcGggaGFuZGxlcnNcbiAgICAgIHRoaXMudW5iaW5kR3JhcGhIYW5kbGVycygpO1xuXG4gICAgICAvLyBSZWxlYXNpbmcgY2FjaGUgJiBzdGF0ZVxuICAgICAgdGhpcy5jbGVhckluZGljZXMoKTtcbiAgICAgIHRoaXMuY2xlYXJTdGF0ZSgpO1xuICAgICAgdGhpcy5ub2RlRGF0YUNhY2hlID0ge307XG4gICAgICB0aGlzLmVkZ2VEYXRhQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2Rlcy5jbGVhcigpO1xuXG4gICAgICAvLyBDbGVhcmluZyBmcmFtZXNcbiAgICAgIGlmICh0aGlzLnJlbmRlckZyYW1lKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyRnJhbWUpO1xuICAgICAgICB0aGlzLnJlbmRlckZyYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSk7XG4gICAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gRGVzdHJveWluZyBjYW52YXNlc1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgd2hpbGUgKGNvbnRhaW5lci5maXJzdENoaWxkKSBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXG4gICAgICAvLyBLaWxsIHByb2dyYW1zOlxuICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLm5vZGVQcm9ncmFtcykge1xuICAgICAgICB0aGlzLm5vZGVQcm9ncmFtc1t0eXBlXS5raWxsKCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfdHlwZTggaW4gdGhpcy5ub2RlSG92ZXJQcm9ncmFtcykge1xuICAgICAgICB0aGlzLm5vZGVIb3ZlclByb2dyYW1zW190eXBlOF0ua2lsbCgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3R5cGU5IGluIHRoaXMuZWRnZVByb2dyYW1zKSB7XG4gICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW190eXBlOV0ua2lsbCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5ub2RlUHJvZ3JhbXMgPSB7fTtcbiAgICAgIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXMgPSB7fTtcbiAgICAgIHRoaXMuZWRnZVByb2dyYW1zID0ge307XG5cbiAgICAgIC8vIEtpbGwgYWxsIGNhbnZhcy9XZWJHTCBjb250ZXh0c1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5lbGVtZW50cykge1xuICAgICAgICB0aGlzLmtpbGxMYXllcihpZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlc3Ryb3lpbmcgcmVtYWluaW5nIGNvbGxlY3Rpb25zXG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHRzID0ge307XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHMgPSB7fTtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzY2FsZSB0aGUgZ2l2ZW4gc2l6ZSBhY2NvcmRpbmcgdG8gdGhlIGNhbWVyYSdzIHJhdGlvLCBpLmUuXG4gICAgICogem9vbWluZyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge251bWJlcj99IHNpemUgLSAgICAgICAgVGhlIHNpemUgdG8gc2NhbGUgKG5vZGUgc2l6ZSwgZWRnZSB0aGlja25lc3MgZXRjLikuXG4gICAgICogQHBhcmFtICB7bnVtYmVyP30gY2FtZXJhUmF0aW8gLSBBIGNhbWVyYSByYXRpbyAoZGVmYXVsdHMgdG8gdGhlIGFjdHVhbCBjYW1lcmEgcmF0aW8pLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgIC0gVGhlIHNjYWxlZCBzaXplLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNjYWxlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2FsZVNpemUoKSB7XG4gICAgICB2YXIgc2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcbiAgICAgIHZhciBjYW1lcmFSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5jYW1lcmEucmF0aW87XG4gICAgICByZXR1cm4gc2l6ZSAvIHRoaXMuc2V0dGluZ3Muem9vbVRvU2l6ZVJhdGlvRnVuY3Rpb24oY2FtZXJhUmF0aW8pICogKHRoaXMuZ2V0U2V0dGluZyhcIml0ZW1TaXplc1JlZmVyZW5jZVwiKSA9PT0gXCJwb3NpdGlvbnNcIiA/IGNhbWVyYVJhdGlvICogdGhpcy5ncmFwaFRvVmlld3BvcnRSYXRpbyA6IDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IHJldHVybnMgdGhlIGNvbGxlY3Rpb24gb2YgYWxsIHVzZWQgY2FudmFzZXMuXG4gICAgICogQXQgdGhlIG1vbWVudCwgdGhlIGluc3RhbnRpYXRlZCBjYW52YXNlcyBhcmUgdGhlIGZvbGxvd2luZywgYW5kIGluIHRoZVxuICAgICAqIGZvbGxvd2luZyBvcmRlciBpbiB0aGUgRE9NOlxuICAgICAqIC0gYGVkZ2VzYFxuICAgICAqIC0gYG5vZGVzYFxuICAgICAqIC0gYGVkZ2VMYWJlbHNgXG4gICAgICogLSBgbGFiZWxzYFxuICAgICAqIC0gYGhvdmVyc2BcbiAgICAgKiAtIGBob3Zlck5vZGVzYFxuICAgICAqIC0gYG1vdXNlYFxuICAgICAqXG4gICAgICogQHJldHVybiB7UGxhaW5PYmplY3Q8SFRNTENhbnZhc0VsZW1lbnQ+fSAtIFRoZSBjb2xsZWN0aW9uIG9mIGNhbnZhc2VzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldENhbnZhc2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhbnZhc2VzKCkge1xuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgZm9yICh2YXIgbGF5ZXIgaW4gdGhpcy5lbGVtZW50cykgaWYgKHRoaXMuZWxlbWVudHNbbGF5ZXJdIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHJlc1tsYXllcl0gPSB0aGlzLmVsZW1lbnRzW2xheWVyXTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9XSk7XG59KFR5cGVkRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBTaWdtYS5qcyBMaWJyYXJ5IEVuZHBvaW50XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogVGhlIGxpYnJhcnkgZW5kcG9pbnQuXG4gKiBAbW9kdWxlXG4gKi9cbnZhciBTaWdtYSA9IFNpZ21hJDE7XG5cbmV4cG9ydCB7IENhbWVyYSwgTW91c2VDYXB0b3IsIFNpZ21hJDEgYXMgU2lnbWEsIFRvdWNoQ2FwdG9yLCBTaWdtYSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/sigma.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/settings/dist/sigma-settings.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/sigma/settings/dist/sigma-settings.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_EDGE_PROGRAM_CLASSES: () => (/* binding */ DEFAULT_EDGE_PROGRAM_CLASSES),\n/* harmony export */   DEFAULT_NODE_PROGRAM_CLASSES: () => (/* binding */ DEFAULT_NODE_PROGRAM_CLASSES),\n/* harmony export */   DEFAULT_SETTINGS: () => (/* binding */ DEFAULT_SETTINGS),\n/* harmony export */   resolveSettings: () => (/* binding */ resolveSettings),\n/* harmony export */   validateSettings: () => (/* binding */ validateSettings)\n/* harmony export */ });\n/* harmony import */ var _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/index-236c62ad.esm.js */ \"(ssr)/./node_modules/sigma/dist/index-236c62ad.esm.js\");\n/* harmony import */ var _dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/data-11df7124.esm.js */ \"(ssr)/./node_modules/sigma/dist/data-11df7124.esm.js\");\n\n\n\n\n\n/**\n * Sigma.js Settings\n * =================================\n *\n * The list of settings and some handy functions.\n * @module\n */\n\n/**\n * Sigma.js settings\n * =================================\n */\n\nvar DEFAULT_SETTINGS = {\n  // Performance\n  hideEdgesOnMove: false,\n  hideLabelsOnMove: false,\n  renderLabels: true,\n  renderEdgeLabels: false,\n  enableEdgeEvents: false,\n  // Component rendering\n  defaultNodeColor: \"#999\",\n  defaultNodeType: \"circle\",\n  defaultEdgeColor: \"#ccc\",\n  defaultEdgeType: \"line\",\n  labelFont: \"Arial\",\n  labelSize: 14,\n  labelWeight: \"normal\",\n  labelColor: {\n    color: \"#000\"\n  },\n  edgeLabelFont: \"Arial\",\n  edgeLabelSize: 14,\n  edgeLabelWeight: \"normal\",\n  edgeLabelColor: {\n    attribute: \"color\"\n  },\n  stagePadding: 30,\n  defaultDrawEdgeLabel: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.d,\n  defaultDrawNodeLabel: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.b,\n  defaultDrawNodeHover: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.c,\n  minEdgeThickness: 1.7,\n  antiAliasingFeather: 1,\n  // Mouse and touch settings\n  dragTimeout: 100,\n  draggedEventsTolerance: 3,\n  inertiaDuration: 200,\n  inertiaRatio: 3,\n  zoomDuration: 250,\n  zoomingRatio: 1.7,\n  doubleClickTimeout: 300,\n  doubleClickZoomingRatio: 2.2,\n  doubleClickZoomingDuration: 200,\n  tapMoveTolerance: 10,\n  // Size and scaling\n  zoomToSizeRatioFunction: Math.sqrt,\n  itemSizesReference: \"screen\",\n  autoRescale: true,\n  autoCenter: true,\n  // Labels\n  labelDensity: 1,\n  labelGridCellSize: 100,\n  labelRenderedSizeThreshold: 6,\n  // Reducers\n  nodeReducer: null,\n  edgeReducer: null,\n  // Features\n  zIndex: false,\n  minCameraRatio: null,\n  maxCameraRatio: null,\n  enableCameraZooming: true,\n  enableCameraPanning: true,\n  enableCameraRotation: true,\n  cameraPanBoundaries: null,\n  // Lifecycle\n  allowInvalidContainer: false,\n  // Program classes\n  nodeProgramClasses: {},\n  nodeHoverProgramClasses: {},\n  edgeProgramClasses: {}\n};\nvar DEFAULT_NODE_PROGRAM_CLASSES = {\n  circle: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.N\n};\nvar DEFAULT_EDGE_PROGRAM_CLASSES = {\n  arrow: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.E,\n  line: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.e\n};\nfunction validateSettings(settings) {\n  if (typeof settings.labelDensity !== \"number\" || settings.labelDensity < 0) {\n    throw new Error(\"Settings: invalid `labelDensity`. Expecting a positive number.\");\n  }\n  var minCameraRatio = settings.minCameraRatio,\n    maxCameraRatio = settings.maxCameraRatio;\n  if (typeof minCameraRatio === \"number\" && typeof maxCameraRatio === \"number\" && maxCameraRatio < minCameraRatio) {\n    throw new Error(\"Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`.\");\n  }\n}\nfunction resolveSettings(settings) {\n  var resolvedSettings = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_SETTINGS, settings);\n  resolvedSettings.nodeProgramClasses = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_NODE_PROGRAM_CLASSES, resolvedSettings.nodeProgramClasses);\n  resolvedSettings.edgeProgramClasses = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_EDGE_PROGRAM_CLASSES, resolvedSettings.edgeProgramClasses);\n  return resolvedSettings;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvc2V0dGluZ3MvZGlzdC9zaWdtYS1zZXR0aW5ncy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF3TTtBQUMxSTtBQUNqQjtBQUNGOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsMERBQXFCO0FBQzdDLHdCQUF3QiwwREFBaUI7QUFDekMsd0JBQXdCLDBEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMERBQWlCO0FBQzNCO0FBQ0E7QUFDQSxTQUFTLDBEQUFnQjtBQUN6QixRQUFRLDBEQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQU0sR0FBRztBQUNsQyx3Q0FBd0MsNkRBQU0sR0FBRztBQUNqRCx3Q0FBd0MsNkRBQU0sR0FBRztBQUNqRDtBQUNBOztBQUUySCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoeWVvblxcRGVza3RvcFxcZnJvbnRlbmQtaGlkZGVubm9kZVxcbm9kZV9tb2R1bGVzXFxzaWdtYVxcc2V0dGluZ3NcXGRpc3RcXHNpZ21hLXNldHRpbmdzLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkIGFzIGRyYXdTdHJhaWdodEVkZ2VMYWJlbCwgYiBhcyBkcmF3RGlzY05vZGVMYWJlbCwgYyBhcyBkcmF3RGlzY05vZGVIb3ZlciwgTiBhcyBOb2RlQ2lyY2xlUHJvZ3JhbSwgRSBhcyBFZGdlQXJyb3dQcm9ncmFtLCBlIGFzIEVkZ2VSZWN0YW5nbGVQcm9ncmFtIH0gZnJvbSAnLi4vLi4vZGlzdC9pbmRleC0yMzZjNjJhZC5lc20uanMnO1xuaW1wb3J0IHsgYSBhcyBhc3NpZ24gfSBmcm9tICcuLi8uLi9kaXN0L2RhdGEtMTFkZjcxMjQuZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vZGlzdC9pbmhlcml0cy1kMWExZTI5Yi5lc20uanMnO1xuaW1wb3J0ICcuLi8uLi9kaXN0L2NvbG9ycy1iZWIwNmViMi5lc20uanMnO1xuXG4vKipcbiAqIFNpZ21hLmpzIFNldHRpbmdzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgbGlzdCBvZiBzZXR0aW5ncyBhbmQgc29tZSBoYW5keSBmdW5jdGlvbnMuXG4gKiBAbW9kdWxlXG4gKi9cblxuLyoqXG4gKiBTaWdtYS5qcyBzZXR0aW5nc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxudmFyIERFRkFVTFRfU0VUVElOR1MgPSB7XG4gIC8vIFBlcmZvcm1hbmNlXG4gIGhpZGVFZGdlc09uTW92ZTogZmFsc2UsXG4gIGhpZGVMYWJlbHNPbk1vdmU6IGZhbHNlLFxuICByZW5kZXJMYWJlbHM6IHRydWUsXG4gIHJlbmRlckVkZ2VMYWJlbHM6IGZhbHNlLFxuICBlbmFibGVFZGdlRXZlbnRzOiBmYWxzZSxcbiAgLy8gQ29tcG9uZW50IHJlbmRlcmluZ1xuICBkZWZhdWx0Tm9kZUNvbG9yOiBcIiM5OTlcIixcbiAgZGVmYXVsdE5vZGVUeXBlOiBcImNpcmNsZVwiLFxuICBkZWZhdWx0RWRnZUNvbG9yOiBcIiNjY2NcIixcbiAgZGVmYXVsdEVkZ2VUeXBlOiBcImxpbmVcIixcbiAgbGFiZWxGb250OiBcIkFyaWFsXCIsXG4gIGxhYmVsU2l6ZTogMTQsXG4gIGxhYmVsV2VpZ2h0OiBcIm5vcm1hbFwiLFxuICBsYWJlbENvbG9yOiB7XG4gICAgY29sb3I6IFwiIzAwMFwiXG4gIH0sXG4gIGVkZ2VMYWJlbEZvbnQ6IFwiQXJpYWxcIixcbiAgZWRnZUxhYmVsU2l6ZTogMTQsXG4gIGVkZ2VMYWJlbFdlaWdodDogXCJub3JtYWxcIixcbiAgZWRnZUxhYmVsQ29sb3I6IHtcbiAgICBhdHRyaWJ1dGU6IFwiY29sb3JcIlxuICB9LFxuICBzdGFnZVBhZGRpbmc6IDMwLFxuICBkZWZhdWx0RHJhd0VkZ2VMYWJlbDogZHJhd1N0cmFpZ2h0RWRnZUxhYmVsLFxuICBkZWZhdWx0RHJhd05vZGVMYWJlbDogZHJhd0Rpc2NOb2RlTGFiZWwsXG4gIGRlZmF1bHREcmF3Tm9kZUhvdmVyOiBkcmF3RGlzY05vZGVIb3ZlcixcbiAgbWluRWRnZVRoaWNrbmVzczogMS43LFxuICBhbnRpQWxpYXNpbmdGZWF0aGVyOiAxLFxuICAvLyBNb3VzZSBhbmQgdG91Y2ggc2V0dGluZ3NcbiAgZHJhZ1RpbWVvdXQ6IDEwMCxcbiAgZHJhZ2dlZEV2ZW50c1RvbGVyYW5jZTogMyxcbiAgaW5lcnRpYUR1cmF0aW9uOiAyMDAsXG4gIGluZXJ0aWFSYXRpbzogMyxcbiAgem9vbUR1cmF0aW9uOiAyNTAsXG4gIHpvb21pbmdSYXRpbzogMS43LFxuICBkb3VibGVDbGlja1RpbWVvdXQ6IDMwMCxcbiAgZG91YmxlQ2xpY2tab29taW5nUmF0aW86IDIuMixcbiAgZG91YmxlQ2xpY2tab29taW5nRHVyYXRpb246IDIwMCxcbiAgdGFwTW92ZVRvbGVyYW5jZTogMTAsXG4gIC8vIFNpemUgYW5kIHNjYWxpbmdcbiAgem9vbVRvU2l6ZVJhdGlvRnVuY3Rpb246IE1hdGguc3FydCxcbiAgaXRlbVNpemVzUmVmZXJlbmNlOiBcInNjcmVlblwiLFxuICBhdXRvUmVzY2FsZTogdHJ1ZSxcbiAgYXV0b0NlbnRlcjogdHJ1ZSxcbiAgLy8gTGFiZWxzXG4gIGxhYmVsRGVuc2l0eTogMSxcbiAgbGFiZWxHcmlkQ2VsbFNpemU6IDEwMCxcbiAgbGFiZWxSZW5kZXJlZFNpemVUaHJlc2hvbGQ6IDYsXG4gIC8vIFJlZHVjZXJzXG4gIG5vZGVSZWR1Y2VyOiBudWxsLFxuICBlZGdlUmVkdWNlcjogbnVsbCxcbiAgLy8gRmVhdHVyZXNcbiAgekluZGV4OiBmYWxzZSxcbiAgbWluQ2FtZXJhUmF0aW86IG51bGwsXG4gIG1heENhbWVyYVJhdGlvOiBudWxsLFxuICBlbmFibGVDYW1lcmFab29taW5nOiB0cnVlLFxuICBlbmFibGVDYW1lcmFQYW5uaW5nOiB0cnVlLFxuICBlbmFibGVDYW1lcmFSb3RhdGlvbjogdHJ1ZSxcbiAgY2FtZXJhUGFuQm91bmRhcmllczogbnVsbCxcbiAgLy8gTGlmZWN5Y2xlXG4gIGFsbG93SW52YWxpZENvbnRhaW5lcjogZmFsc2UsXG4gIC8vIFByb2dyYW0gY2xhc3Nlc1xuICBub2RlUHJvZ3JhbUNsYXNzZXM6IHt9LFxuICBub2RlSG92ZXJQcm9ncmFtQ2xhc3Nlczoge30sXG4gIGVkZ2VQcm9ncmFtQ2xhc3Nlczoge31cbn07XG52YXIgREVGQVVMVF9OT0RFX1BST0dSQU1fQ0xBU1NFUyA9IHtcbiAgY2lyY2xlOiBOb2RlQ2lyY2xlUHJvZ3JhbVxufTtcbnZhciBERUZBVUxUX0VER0VfUFJPR1JBTV9DTEFTU0VTID0ge1xuICBhcnJvdzogRWRnZUFycm93UHJvZ3JhbSxcbiAgbGluZTogRWRnZVJlY3RhbmdsZVByb2dyYW1cbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gIGlmICh0eXBlb2Ygc2V0dGluZ3MubGFiZWxEZW5zaXR5ICE9PSBcIm51bWJlclwiIHx8IHNldHRpbmdzLmxhYmVsRGVuc2l0eSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nczogaW52YWxpZCBgbGFiZWxEZW5zaXR5YC4gRXhwZWN0aW5nIGEgcG9zaXRpdmUgbnVtYmVyLlwiKTtcbiAgfVxuICB2YXIgbWluQ2FtZXJhUmF0aW8gPSBzZXR0aW5ncy5taW5DYW1lcmFSYXRpbyxcbiAgICBtYXhDYW1lcmFSYXRpbyA9IHNldHRpbmdzLm1heENhbWVyYVJhdGlvO1xuICBpZiAodHlwZW9mIG1pbkNhbWVyYVJhdGlvID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBtYXhDYW1lcmFSYXRpbyA9PT0gXCJudW1iZXJcIiAmJiBtYXhDYW1lcmFSYXRpbyA8IG1pbkNhbWVyYVJhdGlvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0dGluZ3M6IGludmFsaWQgY2FtZXJhIHJhdGlvIGJvdW5kYXJpZXMuIEV4cGVjdGluZyBgbWF4Q2FtZXJhUmF0aW9gIHRvIGJlIGdyZWF0ZXIgdGhhbiBgbWluQ2FtZXJhUmF0aW9gLlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gIHZhciByZXNvbHZlZFNldHRpbmdzID0gYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBzZXR0aW5ncyk7XG4gIHJlc29sdmVkU2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzID0gYXNzaWduKHt9LCBERUZBVUxUX05PREVfUFJPR1JBTV9DTEFTU0VTLCByZXNvbHZlZFNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlcyk7XG4gIHJlc29sdmVkU2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzID0gYXNzaWduKHt9LCBERUZBVUxUX0VER0VfUFJPR1JBTV9DTEFTU0VTLCByZXNvbHZlZFNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlcyk7XG4gIHJldHVybiByZXNvbHZlZFNldHRpbmdzO1xufVxuXG5leHBvcnQgeyBERUZBVUxUX0VER0VfUFJPR1JBTV9DTEFTU0VTLCBERUZBVUxUX05PREVfUFJPR1JBTV9DTEFTU0VTLCBERUZBVUxUX1NFVFRJTkdTLCByZXNvbHZlU2V0dGluZ3MsIHZhbGlkYXRlU2V0dGluZ3MgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/settings/dist/sigma-settings.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/types/dist/sigma-types.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/sigma/types/dist/sigma-types.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedEventEmitter: () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var _dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/inherits-d1a1e29b.esm.js */ \"(ssr)/./node_modules/sigma/dist/inherits-d1a1e29b.esm.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n/**\n * Util type to represent maps of typed elements, but implemented with\n * JavaScript objects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * Returns a type similar to T, but with the K set of properties of the type\n * T *required*, and the rest optional.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * Returns a type similar to Partial<T>, but with at least one key set.\n */\n\n/**\n * Custom event emitter types.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nvar TypedEventEmitter = /*#__PURE__*/function (_ref) {\n  function TypedEventEmitter() {\n    var _this;\n    (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, TypedEventEmitter);\n    _this = (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, TypedEventEmitter);\n    _this.rawEmitter = _this;\n    return _this;\n  }\n  (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(TypedEventEmitter, _ref);\n  return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(TypedEventEmitter);\n}(events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter);\n\n/**\n * Event types.\n */\n\n/**\n * Export various other types:\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvdHlwZXMvZGlzdC9zaWdtYS10eXBlcy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErSDtBQUN6Rjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFlO0FBQ25CLFlBQVksaUVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxpRUFBUztBQUNYLFNBQVMsaUVBQVk7QUFDckIsQ0FBQyxDQUFDLGdEQUFZOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRTZCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGh5ZW9uXFxEZXNrdG9wXFxmcm9udGVuZC1oaWRkZW5ub2RlXFxub2RlX21vZHVsZXNcXHNpZ21hXFx0eXBlc1xcZGlzdFxcc2lnbWEtdHlwZXMuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF8gYXMgX2luaGVyaXRzLCBhIGFzIF9jcmVhdGVDbGFzcywgYiBhcyBfY2xhc3NDYWxsQ2hlY2ssIGMgYXMgX2NhbGxTdXBlciB9IGZyb20gJy4uLy4uL2Rpc3QvaW5oZXJpdHMtZDFhMWUyOWIuZXNtLmpzJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbi8qKlxuICogVXRpbCB0eXBlIHRvIHJlcHJlc2VudCBtYXBzIG9mIHR5cGVkIGVsZW1lbnRzLCBidXQgaW1wbGVtZW50ZWQgd2l0aFxuICogSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcbiAqIFJldHVybnMgYSB0eXBlIHNpbWlsYXIgdG8gVCwgYnV0IHdpdGggdGhlIEsgc2V0IG9mIHByb3BlcnRpZXMgb2YgdGhlIHR5cGVcbiAqIFQgKnJlcXVpcmVkKiwgYW5kIHRoZSByZXN0IG9wdGlvbmFsLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcbiAqIFJldHVybnMgYSB0eXBlIHNpbWlsYXIgdG8gUGFydGlhbDxUPiwgYnV0IHdpdGggYXQgbGVhc3Qgb25lIGtleSBzZXQuXG4gKi9cblxuLyoqXG4gKiBDdXN0b20gZXZlbnQgZW1pdHRlciB0eXBlcy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxudmFyIFR5cGVkRXZlbnRFbWl0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfcmVmKSB7XG4gIGZ1bmN0aW9uIFR5cGVkRXZlbnRFbWl0dGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZWRFdmVudEVtaXR0ZXIpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBUeXBlZEV2ZW50RW1pdHRlcik7XG4gICAgX3RoaXMucmF3RW1pdHRlciA9IF90aGlzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoVHlwZWRFdmVudEVtaXR0ZXIsIF9yZWYpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFR5cGVkRXZlbnRFbWl0dGVyKTtcbn0oRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBFdmVudCB0eXBlcy5cbiAqL1xuXG4vKipcbiAqIEV4cG9ydCB2YXJpb3VzIG90aGVyIHR5cGVzOlxuICovXG5cbmV4cG9ydCB7IFR5cGVkRXZlbnRFbWl0dGVyIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/types/dist/sigma-types.esm.js\n");

/***/ })

};
;