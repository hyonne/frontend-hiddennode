/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_sigma_dist_sigma_esm_js"],{

/***/ "(app-pages-browser)/./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGVub3ZvXFxEZXNrdG9wXFxmcm9udGVuZFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZXZlbnRzXFxldmVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/events/events.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphology-utils/is-graph.js":
/*!***************************************************!*\
  !*** ./node_modules/graphology-utils/is-graph.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGVub3ZvXFxEZXNrdG9wXFxmcm9udGVuZFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZ3JhcGhvbG9neS11dGlsc1xcaXMtZ3JhcGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcmFwaG9sb2d5IGlzR3JhcGhcbiAqID09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBWZXJ5IHNpbXBsZSBmdW5jdGlvbiBhaW1pbmcgYXQgZW5zdXJpbmcgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFcbiAqIGdyYXBob2xvZ3kgaW5zdGFuY2UuXG4gKi9cblxuLyoqXG4gKiBDaGVja2luZyB0aGUgdmFsdWUgaXMgYSBncmFwaG9sb2d5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAge2FueX0gICAgIHZhbHVlIC0gVGFyZ2V0IHZhbHVlLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dyYXBoKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHZhbHVlLmFkZFVuZGlyZWN0ZWRFZGdlV2l0aEtleSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5kcm9wTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5tdWx0aSA9PT0gJ2Jvb2xlYW4nXG4gICk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphology-utils/is-graph.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/sigma/dist/colors-beb06eb2.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/sigma/dist/colors-beb06eb2.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   H: () => (/* binding */ HTML_COLORS),\n/* harmony export */   _: () => (/* binding */ _slicedToArray),\n/* harmony export */   a: () => (/* binding */ _arrayLikeToArray),\n/* harmony export */   b: () => (/* binding */ _unsupportedIterableToArray),\n/* harmony export */   c: () => (/* binding */ colorToIndex),\n/* harmony export */   d: () => (/* binding */ colorToArray),\n/* harmony export */   e: () => (/* binding */ extractPixel),\n/* harmony export */   f: () => (/* binding */ floatColor),\n/* harmony export */   g: () => (/* binding */ getPixelColor),\n/* harmony export */   i: () => (/* binding */ indexToColor),\n/* harmony export */   p: () => (/* binding */ parseColor),\n/* harmony export */   r: () => (/* binding */ rgbaToFloat)\n/* harmony export */ });\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\n\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\n\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\n\nvar HTML_COLORS = {\n  black: \"#000000\",\n  silver: \"#C0C0C0\",\n  gray: \"#808080\",\n  grey: \"#808080\",\n  white: \"#FFFFFF\",\n  maroon: \"#800000\",\n  red: \"#FF0000\",\n  purple: \"#800080\",\n  fuchsia: \"#FF00FF\",\n  green: \"#008000\",\n  lime: \"#00FF00\",\n  olive: \"#808000\",\n  yellow: \"#FFFF00\",\n  navy: \"#000080\",\n  blue: \"#0000FF\",\n  teal: \"#008080\",\n  aqua: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  mediumblue: \"#0000CD\",\n  darkgreen: \"#006400\",\n  darkcyan: \"#008B8B\",\n  deepskyblue: \"#00BFFF\",\n  darkturquoise: \"#00CED1\",\n  mediumspringgreen: \"#00FA9A\",\n  springgreen: \"#00FF7F\",\n  cyan: \"#00FFFF\",\n  midnightblue: \"#191970\",\n  dodgerblue: \"#1E90FF\",\n  lightseagreen: \"#20B2AA\",\n  forestgreen: \"#228B22\",\n  seagreen: \"#2E8B57\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  limegreen: \"#32CD32\",\n  mediumseagreen: \"#3CB371\",\n  turquoise: \"#40E0D0\",\n  royalblue: \"#4169E1\",\n  steelblue: \"#4682B4\",\n  darkslateblue: \"#483D8B\",\n  mediumturquoise: \"#48D1CC\",\n  indigo: \"#4B0082\",\n  darkolivegreen: \"#556B2F\",\n  cadetblue: \"#5F9EA0\",\n  cornflowerblue: \"#6495ED\",\n  rebeccapurple: \"#663399\",\n  mediumaquamarine: \"#66CDAA\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  slateblue: \"#6A5ACD\",\n  olivedrab: \"#6B8E23\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  mediumslateblue: \"#7B68EE\",\n  lawngreen: \"#7CFC00\",\n  chartreuse: \"#7FFF00\",\n  aquamarine: \"#7FFFD4\",\n  skyblue: \"#87CEEB\",\n  lightskyblue: \"#87CEFA\",\n  blueviolet: \"#8A2BE2\",\n  darkred: \"#8B0000\",\n  darkmagenta: \"#8B008B\",\n  saddlebrown: \"#8B4513\",\n  darkseagreen: \"#8FBC8F\",\n  lightgreen: \"#90EE90\",\n  mediumpurple: \"#9370DB\",\n  darkviolet: \"#9400D3\",\n  palegreen: \"#98FB98\",\n  darkorchid: \"#9932CC\",\n  yellowgreen: \"#9ACD32\",\n  sienna: \"#A0522D\",\n  brown: \"#A52A2A\",\n  darkgray: \"#A9A9A9\",\n  darkgrey: \"#A9A9A9\",\n  lightblue: \"#ADD8E6\",\n  greenyellow: \"#ADFF2F\",\n  paleturquoise: \"#AFEEEE\",\n  lightsteelblue: \"#B0C4DE\",\n  powderblue: \"#B0E0E6\",\n  firebrick: \"#B22222\",\n  darkgoldenrod: \"#B8860B\",\n  mediumorchid: \"#BA55D3\",\n  rosybrown: \"#BC8F8F\",\n  darkkhaki: \"#BDB76B\",\n  mediumvioletred: \"#C71585\",\n  indianred: \"#CD5C5C\",\n  peru: \"#CD853F\",\n  chocolate: \"#D2691E\",\n  tan: \"#D2B48C\",\n  lightgray: \"#D3D3D3\",\n  lightgrey: \"#D3D3D3\",\n  thistle: \"#D8BFD8\",\n  orchid: \"#DA70D6\",\n  goldenrod: \"#DAA520\",\n  palevioletred: \"#DB7093\",\n  crimson: \"#DC143C\",\n  gainsboro: \"#DCDCDC\",\n  plum: \"#DDA0DD\",\n  burlywood: \"#DEB887\",\n  lightcyan: \"#E0FFFF\",\n  lavender: \"#E6E6FA\",\n  darksalmon: \"#E9967A\",\n  violet: \"#EE82EE\",\n  palegoldenrod: \"#EEE8AA\",\n  lightcoral: \"#F08080\",\n  khaki: \"#F0E68C\",\n  aliceblue: \"#F0F8FF\",\n  honeydew: \"#F0FFF0\",\n  azure: \"#F0FFFF\",\n  sandybrown: \"#F4A460\",\n  wheat: \"#F5DEB3\",\n  beige: \"#F5F5DC\",\n  whitesmoke: \"#F5F5F5\",\n  mintcream: \"#F5FFFA\",\n  ghostwhite: \"#F8F8FF\",\n  salmon: \"#FA8072\",\n  antiquewhite: \"#FAEBD7\",\n  linen: \"#FAF0E6\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  oldlace: \"#FDF5E6\",\n  magenta: \"#FF00FF\",\n  deeppink: \"#FF1493\",\n  orangered: \"#FF4500\",\n  tomato: \"#FF6347\",\n  hotpink: \"#FF69B4\",\n  coral: \"#FF7F50\",\n  darkorange: \"#FF8C00\",\n  lightsalmon: \"#FFA07A\",\n  orange: \"#FFA500\",\n  lightpink: \"#FFB6C1\",\n  pink: \"#FFC0CB\",\n  gold: \"#FFD700\",\n  peachpuff: \"#FFDAB9\",\n  navajowhite: \"#FFDEAD\",\n  moccasin: \"#FFE4B5\",\n  bisque: \"#FFE4C4\",\n  mistyrose: \"#FFE4E1\",\n  blanchedalmond: \"#FFEBCD\",\n  papayawhip: \"#FFEFD5\",\n  lavenderblush: \"#FFF0F5\",\n  seashell: \"#FFF5EE\",\n  cornsilk: \"#FFF8DC\",\n  lemonchiffon: \"#FFFACD\",\n  floralwhite: \"#FFFAF0\",\n  snow: \"#FFFAFA\",\n  lightyellow: \"#FFFFE0\",\n  ivory: \"#FFFFF0\"\n};\n\n/**\n * Function extracting the color at the given pixel.\n */\nfunction extractPixel(gl, x, y, array) {\n  var data = array || new Uint8Array(4);\n  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);\n  return data;\n}\n\n/**\n * Memoized function returning a float-encoded color from various string\n * formats describing colors.\n */\nvar INT8 = new Int8Array(4);\nvar INT32 = new Int32Array(INT8.buffer, 0, 1);\nvar FLOAT32 = new Float32Array(INT8.buffer, 0, 1);\nvar RGBA_TEST_REGEX = /^\\s*rgba?\\s*\\(/;\nvar RGBA_EXTRACT_REGEX = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)(?:\\s*,\\s*(.*)?)?\\)\\s*$/;\nfunction parseColor(val) {\n  var r = 0; // byte\n  var g = 0; // byte\n  var b = 0; // byte\n  var a = 1; // float\n\n  // Handling hexadecimal notation\n  if (val[0] === \"#\") {\n    if (val.length === 4) {\n      r = parseInt(val.charAt(1) + val.charAt(1), 16);\n      g = parseInt(val.charAt(2) + val.charAt(2), 16);\n      b = parseInt(val.charAt(3) + val.charAt(3), 16);\n    } else {\n      r = parseInt(val.charAt(1) + val.charAt(2), 16);\n      g = parseInt(val.charAt(3) + val.charAt(4), 16);\n      b = parseInt(val.charAt(5) + val.charAt(6), 16);\n    }\n    if (val.length === 9) {\n      a = parseInt(val.charAt(7) + val.charAt(8), 16) / 255;\n    }\n  }\n\n  // Handling rgb notation\n  else if (RGBA_TEST_REGEX.test(val)) {\n    var match = val.match(RGBA_EXTRACT_REGEX);\n    if (match) {\n      r = +match[1];\n      g = +match[2];\n      b = +match[3];\n      if (match[4]) a = +match[4];\n    }\n  }\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nvar FLOAT_COLOR_CACHE = {};\nfor (var htmlColor in HTML_COLORS) {\n  FLOAT_COLOR_CACHE[htmlColor] = floatColor(HTML_COLORS[htmlColor]);\n  // Replicating cache for hex values for free\n  FLOAT_COLOR_CACHE[HTML_COLORS[htmlColor]] = FLOAT_COLOR_CACHE[htmlColor];\n}\nfunction rgbaToFloat(r, g, b, a, masking) {\n  INT32[0] = a << 24 | b << 16 | g << 8 | r;\n  if (masking) INT32[0] = INT32[0] & 0xfeffffff;\n  return FLOAT32[0];\n}\nfunction floatColor(val) {\n  // The html color names are case-insensitive\n  val = val.toLowerCase();\n\n  // If the color is already computed, we yield it\n  if (typeof FLOAT_COLOR_CACHE[val] !== \"undefined\") return FLOAT_COLOR_CACHE[val];\n  var parsed = parseColor(val);\n  var r = parsed.r,\n    g = parsed.g,\n    b = parsed.b;\n  var a = parsed.a;\n  a = a * 255 | 0;\n  var color = rgbaToFloat(r, g, b, a, true);\n  FLOAT_COLOR_CACHE[val] = color;\n  return color;\n}\nfunction colorToArray(val, masking) {\n  FLOAT32[0] = floatColor(val);\n  var intValue = INT32[0];\n  if (masking) {\n    intValue = intValue | 0x01000000;\n  }\n  var r = intValue & 0xff;\n  var g = intValue >> 8 & 0xff;\n  var b = intValue >> 16 & 0xff;\n  var a = intValue >> 24 & 0xff;\n  return [r, g, b, a];\n}\nvar FLOAT_INDEX_CACHE = {};\nfunction indexToColor(index) {\n  // If the index is already computed, we yield it\n  if (typeof FLOAT_INDEX_CACHE[index] !== \"undefined\") return FLOAT_INDEX_CACHE[index];\n\n  // To address issue #1397, one strategy is to keep encoding 4 bytes colors,\n  // but with alpha hard-set to 1.0 (or 255):\n  var r = (index & 0x00ff0000) >>> 16;\n  var g = (index & 0x0000ff00) >>> 8;\n  var b = index & 0x000000ff;\n  var a = 0x000000ff;\n\n  // The original 4 bytes color encoding was the following:\n  // const r = (index & 0xff000000) >>> 24;\n  // const g = (index & 0x00ff0000) >>> 16;\n  // const b = (index & 0x0000ff00) >>> 8;\n  // const a = index & 0x000000ff;\n\n  var color = rgbaToFloat(r, g, b, a, true);\n  FLOAT_INDEX_CACHE[index] = color;\n  return color;\n}\nfunction colorToIndex(r, g, b, _a) {\n  // As for the function indexToColor, because of #1397 and the \"alpha is always\n  // 1.0\" strategy, we need to fix this function as well:\n  return b + (g << 8) + (r << 16);\n\n  // The original 4 bytes color decoding is the following:\n  // return a + (b << 8) + (g << 16) + (r << 24);\n}\nfunction getPixelColor(gl, frameBuffer, x, y, pixelRatio, downSizingRatio) {\n  var bufferX = Math.floor(x / downSizingRatio * pixelRatio);\n  var bufferY = Math.floor(gl.drawingBufferHeight / downSizingRatio - y / downSizingRatio * pixelRatio);\n  var pixel = new Uint8Array(4);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.readPixels(bufferX, bufferY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n  var _pixel = _slicedToArray(pixel, 4),\n    r = _pixel[0],\n    g = _pixel[1],\n    b = _pixel[2],\n    a = _pixel[3];\n  return [r, g, b, a];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zaWdtYS9kaXN0L2NvbG9ycy1iZWIwNmViMi5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVksa0VBQWtFO0FBQ3RGLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStQIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxlbm92b1xcRGVza3RvcFxcZnJvbnRlbmRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHNpZ21hXFxkaXN0XFxjb2xvcnMtYmViMDZlYjIuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHtcbiAgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpO1xuICBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTtcbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxudmFyIEhUTUxfQ09MT1JTID0ge1xuICBibGFjazogXCIjMDAwMDAwXCIsXG4gIHNpbHZlcjogXCIjQzBDMEMwXCIsXG4gIGdyYXk6IFwiIzgwODA4MFwiLFxuICBncmV5OiBcIiM4MDgwODBcIixcbiAgd2hpdGU6IFwiI0ZGRkZGRlwiLFxuICBtYXJvb246IFwiIzgwMDAwMFwiLFxuICByZWQ6IFwiI0ZGMDAwMFwiLFxuICBwdXJwbGU6IFwiIzgwMDA4MFwiLFxuICBmdWNoc2lhOiBcIiNGRjAwRkZcIixcbiAgZ3JlZW46IFwiIzAwODAwMFwiLFxuICBsaW1lOiBcIiMwMEZGMDBcIixcbiAgb2xpdmU6IFwiIzgwODAwMFwiLFxuICB5ZWxsb3c6IFwiI0ZGRkYwMFwiLFxuICBuYXZ5OiBcIiMwMDAwODBcIixcbiAgYmx1ZTogXCIjMDAwMEZGXCIsXG4gIHRlYWw6IFwiIzAwODA4MFwiLFxuICBhcXVhOiBcIiMwMEZGRkZcIixcbiAgZGFya2JsdWU6IFwiIzAwMDA4QlwiLFxuICBtZWRpdW1ibHVlOiBcIiMwMDAwQ0RcIixcbiAgZGFya2dyZWVuOiBcIiMwMDY0MDBcIixcbiAgZGFya2N5YW46IFwiIzAwOEI4QlwiLFxuICBkZWVwc2t5Ymx1ZTogXCIjMDBCRkZGXCIsXG4gIGRhcmt0dXJxdW9pc2U6IFwiIzAwQ0VEMVwiLFxuICBtZWRpdW1zcHJpbmdncmVlbjogXCIjMDBGQTlBXCIsXG4gIHNwcmluZ2dyZWVuOiBcIiMwMEZGN0ZcIixcbiAgY3lhbjogXCIjMDBGRkZGXCIsXG4gIG1pZG5pZ2h0Ymx1ZTogXCIjMTkxOTcwXCIsXG4gIGRvZGdlcmJsdWU6IFwiIzFFOTBGRlwiLFxuICBsaWdodHNlYWdyZWVuOiBcIiMyMEIyQUFcIixcbiAgZm9yZXN0Z3JlZW46IFwiIzIyOEIyMlwiLFxuICBzZWFncmVlbjogXCIjMkU4QjU3XCIsXG4gIGRhcmtzbGF0ZWdyYXk6IFwiIzJGNEY0RlwiLFxuICBkYXJrc2xhdGVncmV5OiBcIiMyRjRGNEZcIixcbiAgbGltZWdyZWVuOiBcIiMzMkNEMzJcIixcbiAgbWVkaXVtc2VhZ3JlZW46IFwiIzNDQjM3MVwiLFxuICB0dXJxdW9pc2U6IFwiIzQwRTBEMFwiLFxuICByb3lhbGJsdWU6IFwiIzQxNjlFMVwiLFxuICBzdGVlbGJsdWU6IFwiIzQ2ODJCNFwiLFxuICBkYXJrc2xhdGVibHVlOiBcIiM0ODNEOEJcIixcbiAgbWVkaXVtdHVycXVvaXNlOiBcIiM0OEQxQ0NcIixcbiAgaW5kaWdvOiBcIiM0QjAwODJcIixcbiAgZGFya29saXZlZ3JlZW46IFwiIzU1NkIyRlwiLFxuICBjYWRldGJsdWU6IFwiIzVGOUVBMFwiLFxuICBjb3JuZmxvd2VyYmx1ZTogXCIjNjQ5NUVEXCIsXG4gIHJlYmVjY2FwdXJwbGU6IFwiIzY2MzM5OVwiLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBcIiM2NkNEQUFcIixcbiAgZGltZ3JheTogXCIjNjk2OTY5XCIsXG4gIGRpbWdyZXk6IFwiIzY5Njk2OVwiLFxuICBzbGF0ZWJsdWU6IFwiIzZBNUFDRFwiLFxuICBvbGl2ZWRyYWI6IFwiIzZCOEUyM1wiLFxuICBzbGF0ZWdyYXk6IFwiIzcwODA5MFwiLFxuICBzbGF0ZWdyZXk6IFwiIzcwODA5MFwiLFxuICBsaWdodHNsYXRlZ3JheTogXCIjNzc4ODk5XCIsXG4gIGxpZ2h0c2xhdGVncmV5OiBcIiM3Nzg4OTlcIixcbiAgbWVkaXVtc2xhdGVibHVlOiBcIiM3QjY4RUVcIixcbiAgbGF3bmdyZWVuOiBcIiM3Q0ZDMDBcIixcbiAgY2hhcnRyZXVzZTogXCIjN0ZGRjAwXCIsXG4gIGFxdWFtYXJpbmU6IFwiIzdGRkZENFwiLFxuICBza3libHVlOiBcIiM4N0NFRUJcIixcbiAgbGlnaHRza3libHVlOiBcIiM4N0NFRkFcIixcbiAgYmx1ZXZpb2xldDogXCIjOEEyQkUyXCIsXG4gIGRhcmtyZWQ6IFwiIzhCMDAwMFwiLFxuICBkYXJrbWFnZW50YTogXCIjOEIwMDhCXCIsXG4gIHNhZGRsZWJyb3duOiBcIiM4QjQ1MTNcIixcbiAgZGFya3NlYWdyZWVuOiBcIiM4RkJDOEZcIixcbiAgbGlnaHRncmVlbjogXCIjOTBFRTkwXCIsXG4gIG1lZGl1bXB1cnBsZTogXCIjOTM3MERCXCIsXG4gIGRhcmt2aW9sZXQ6IFwiIzk0MDBEM1wiLFxuICBwYWxlZ3JlZW46IFwiIzk4RkI5OFwiLFxuICBkYXJrb3JjaGlkOiBcIiM5OTMyQ0NcIixcbiAgeWVsbG93Z3JlZW46IFwiIzlBQ0QzMlwiLFxuICBzaWVubmE6IFwiI0EwNTIyRFwiLFxuICBicm93bjogXCIjQTUyQTJBXCIsXG4gIGRhcmtncmF5OiBcIiNBOUE5QTlcIixcbiAgZGFya2dyZXk6IFwiI0E5QTlBOVwiLFxuICBsaWdodGJsdWU6IFwiI0FERDhFNlwiLFxuICBncmVlbnllbGxvdzogXCIjQURGRjJGXCIsXG4gIHBhbGV0dXJxdW9pc2U6IFwiI0FGRUVFRVwiLFxuICBsaWdodHN0ZWVsYmx1ZTogXCIjQjBDNERFXCIsXG4gIHBvd2RlcmJsdWU6IFwiI0IwRTBFNlwiLFxuICBmaXJlYnJpY2s6IFwiI0IyMjIyMlwiLFxuICBkYXJrZ29sZGVucm9kOiBcIiNCODg2MEJcIixcbiAgbWVkaXVtb3JjaGlkOiBcIiNCQTU1RDNcIixcbiAgcm9zeWJyb3duOiBcIiNCQzhGOEZcIixcbiAgZGFya2toYWtpOiBcIiNCREI3NkJcIixcbiAgbWVkaXVtdmlvbGV0cmVkOiBcIiNDNzE1ODVcIixcbiAgaW5kaWFucmVkOiBcIiNDRDVDNUNcIixcbiAgcGVydTogXCIjQ0Q4NTNGXCIsXG4gIGNob2NvbGF0ZTogXCIjRDI2OTFFXCIsXG4gIHRhbjogXCIjRDJCNDhDXCIsXG4gIGxpZ2h0Z3JheTogXCIjRDNEM0QzXCIsXG4gIGxpZ2h0Z3JleTogXCIjRDNEM0QzXCIsXG4gIHRoaXN0bGU6IFwiI0Q4QkZEOFwiLFxuICBvcmNoaWQ6IFwiI0RBNzBENlwiLFxuICBnb2xkZW5yb2Q6IFwiI0RBQTUyMFwiLFxuICBwYWxldmlvbGV0cmVkOiBcIiNEQjcwOTNcIixcbiAgY3JpbXNvbjogXCIjREMxNDNDXCIsXG4gIGdhaW5zYm9ybzogXCIjRENEQ0RDXCIsXG4gIHBsdW06IFwiI0REQTBERFwiLFxuICBidXJseXdvb2Q6IFwiI0RFQjg4N1wiLFxuICBsaWdodGN5YW46IFwiI0UwRkZGRlwiLFxuICBsYXZlbmRlcjogXCIjRTZFNkZBXCIsXG4gIGRhcmtzYWxtb246IFwiI0U5OTY3QVwiLFxuICB2aW9sZXQ6IFwiI0VFODJFRVwiLFxuICBwYWxlZ29sZGVucm9kOiBcIiNFRUU4QUFcIixcbiAgbGlnaHRjb3JhbDogXCIjRjA4MDgwXCIsXG4gIGtoYWtpOiBcIiNGMEU2OENcIixcbiAgYWxpY2VibHVlOiBcIiNGMEY4RkZcIixcbiAgaG9uZXlkZXc6IFwiI0YwRkZGMFwiLFxuICBhenVyZTogXCIjRjBGRkZGXCIsXG4gIHNhbmR5YnJvd246IFwiI0Y0QTQ2MFwiLFxuICB3aGVhdDogXCIjRjVERUIzXCIsXG4gIGJlaWdlOiBcIiNGNUY1RENcIixcbiAgd2hpdGVzbW9rZTogXCIjRjVGNUY1XCIsXG4gIG1pbnRjcmVhbTogXCIjRjVGRkZBXCIsXG4gIGdob3N0d2hpdGU6IFwiI0Y4RjhGRlwiLFxuICBzYWxtb246IFwiI0ZBODA3MlwiLFxuICBhbnRpcXVld2hpdGU6IFwiI0ZBRUJEN1wiLFxuICBsaW5lbjogXCIjRkFGMEU2XCIsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcIiNGQUZBRDJcIixcbiAgb2xkbGFjZTogXCIjRkRGNUU2XCIsXG4gIG1hZ2VudGE6IFwiI0ZGMDBGRlwiLFxuICBkZWVwcGluazogXCIjRkYxNDkzXCIsXG4gIG9yYW5nZXJlZDogXCIjRkY0NTAwXCIsXG4gIHRvbWF0bzogXCIjRkY2MzQ3XCIsXG4gIGhvdHBpbms6IFwiI0ZGNjlCNFwiLFxuICBjb3JhbDogXCIjRkY3RjUwXCIsXG4gIGRhcmtvcmFuZ2U6IFwiI0ZGOEMwMFwiLFxuICBsaWdodHNhbG1vbjogXCIjRkZBMDdBXCIsXG4gIG9yYW5nZTogXCIjRkZBNTAwXCIsXG4gIGxpZ2h0cGluazogXCIjRkZCNkMxXCIsXG4gIHBpbms6IFwiI0ZGQzBDQlwiLFxuICBnb2xkOiBcIiNGRkQ3MDBcIixcbiAgcGVhY2hwdWZmOiBcIiNGRkRBQjlcIixcbiAgbmF2YWpvd2hpdGU6IFwiI0ZGREVBRFwiLFxuICBtb2NjYXNpbjogXCIjRkZFNEI1XCIsXG4gIGJpc3F1ZTogXCIjRkZFNEM0XCIsXG4gIG1pc3R5cm9zZTogXCIjRkZFNEUxXCIsXG4gIGJsYW5jaGVkYWxtb25kOiBcIiNGRkVCQ0RcIixcbiAgcGFwYXlhd2hpcDogXCIjRkZFRkQ1XCIsXG4gIGxhdmVuZGVyYmx1c2g6IFwiI0ZGRjBGNVwiLFxuICBzZWFzaGVsbDogXCIjRkZGNUVFXCIsXG4gIGNvcm5zaWxrOiBcIiNGRkY4RENcIixcbiAgbGVtb25jaGlmZm9uOiBcIiNGRkZBQ0RcIixcbiAgZmxvcmFsd2hpdGU6IFwiI0ZGRkFGMFwiLFxuICBzbm93OiBcIiNGRkZBRkFcIixcbiAgbGlnaHR5ZWxsb3c6IFwiI0ZGRkZFMFwiLFxuICBpdm9yeTogXCIjRkZGRkYwXCJcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gZXh0cmFjdGluZyB0aGUgY29sb3IgYXQgdGhlIGdpdmVuIHBpeGVsLlxuICovXG5mdW5jdGlvbiBleHRyYWN0UGl4ZWwoZ2wsIHgsIHksIGFycmF5KSB7XG4gIHZhciBkYXRhID0gYXJyYXkgfHwgbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGdsLnJlYWRQaXhlbHMoeCwgeSwgMSwgMSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1lbW9pemVkIGZ1bmN0aW9uIHJldHVybmluZyBhIGZsb2F0LWVuY29kZWQgY29sb3IgZnJvbSB2YXJpb3VzIHN0cmluZ1xuICogZm9ybWF0cyBkZXNjcmliaW5nIGNvbG9ycy5cbiAqL1xudmFyIElOVDggPSBuZXcgSW50OEFycmF5KDQpO1xudmFyIElOVDMyID0gbmV3IEludDMyQXJyYXkoSU5UOC5idWZmZXIsIDAsIDEpO1xudmFyIEZMT0FUMzIgPSBuZXcgRmxvYXQzMkFycmF5KElOVDguYnVmZmVyLCAwLCAxKTtcbnZhciBSR0JBX1RFU1RfUkVHRVggPSAvXlxccypyZ2JhP1xccypcXCgvO1xudmFyIFJHQkFfRVhUUkFDVF9SRUdFWCA9IC9eXFxzKnJnYmE/XFxzKlxcKFxccyooWzAtOV0qKVxccyosXFxzKihbMC05XSopXFxzKixcXHMqKFswLTldKikoPzpcXHMqLFxccyooLiopPyk/XFwpXFxzKiQvO1xuZnVuY3Rpb24gcGFyc2VDb2xvcih2YWwpIHtcbiAgdmFyIHIgPSAwOyAvLyBieXRlXG4gIHZhciBnID0gMDsgLy8gYnl0ZVxuICB2YXIgYiA9IDA7IC8vIGJ5dGVcbiAgdmFyIGEgPSAxOyAvLyBmbG9hdFxuXG4gIC8vIEhhbmRsaW5nIGhleGFkZWNpbWFsIG5vdGF0aW9uXG4gIGlmICh2YWxbMF0gPT09IFwiI1wiKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDQpIHtcbiAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDEpICsgdmFsLmNoYXJBdCgxKSwgMTYpO1xuICAgICAgZyA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMikgKyB2YWwuY2hhckF0KDIpLCAxNik7XG4gICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCgzKSArIHZhbC5jaGFyQXQoMyksIDE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMSkgKyB2YWwuY2hhckF0KDIpLCAxNik7XG4gICAgICBnID0gcGFyc2VJbnQodmFsLmNoYXJBdCgzKSArIHZhbC5jaGFyQXQoNCksIDE2KTtcbiAgICAgIGIgPSBwYXJzZUludCh2YWwuY2hhckF0KDUpICsgdmFsLmNoYXJBdCg2KSwgMTYpO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gOSkge1xuICAgICAgYSA9IHBhcnNlSW50KHZhbC5jaGFyQXQoNykgKyB2YWwuY2hhckF0KDgpLCAxNikgLyAyNTU7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxpbmcgcmdiIG5vdGF0aW9uXG4gIGVsc2UgaWYgKFJHQkFfVEVTVF9SRUdFWC50ZXN0KHZhbCkpIHtcbiAgICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goUkdCQV9FWFRSQUNUX1JFR0VYKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHIgPSArbWF0Y2hbMV07XG4gICAgICBnID0gK21hdGNoWzJdO1xuICAgICAgYiA9ICttYXRjaFszXTtcbiAgICAgIGlmIChtYXRjaFs0XSkgYSA9ICttYXRjaFs0XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG52YXIgRkxPQVRfQ09MT1JfQ0FDSEUgPSB7fTtcbmZvciAodmFyIGh0bWxDb2xvciBpbiBIVE1MX0NPTE9SUykge1xuICBGTE9BVF9DT0xPUl9DQUNIRVtodG1sQ29sb3JdID0gZmxvYXRDb2xvcihIVE1MX0NPTE9SU1todG1sQ29sb3JdKTtcbiAgLy8gUmVwbGljYXRpbmcgY2FjaGUgZm9yIGhleCB2YWx1ZXMgZm9yIGZyZWVcbiAgRkxPQVRfQ09MT1JfQ0FDSEVbSFRNTF9DT0xPUlNbaHRtbENvbG9yXV0gPSBGTE9BVF9DT0xPUl9DQUNIRVtodG1sQ29sb3JdO1xufVxuZnVuY3Rpb24gcmdiYVRvRmxvYXQociwgZywgYiwgYSwgbWFza2luZykge1xuICBJTlQzMlswXSA9IGEgPDwgMjQgfCBiIDw8IDE2IHwgZyA8PCA4IHwgcjtcbiAgaWYgKG1hc2tpbmcpIElOVDMyWzBdID0gSU5UMzJbMF0gJiAweGZlZmZmZmZmO1xuICByZXR1cm4gRkxPQVQzMlswXTtcbn1cbmZ1bmN0aW9uIGZsb2F0Q29sb3IodmFsKSB7XG4gIC8vIFRoZSBodG1sIGNvbG9yIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG4gIHZhbCA9IHZhbC50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIElmIHRoZSBjb2xvciBpcyBhbHJlYWR5IGNvbXB1dGVkLCB3ZSB5aWVsZCBpdFxuICBpZiAodHlwZW9mIEZMT0FUX0NPTE9SX0NBQ0hFW3ZhbF0gIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBGTE9BVF9DT0xPUl9DQUNIRVt2YWxdO1xuICB2YXIgcGFyc2VkID0gcGFyc2VDb2xvcih2YWwpO1xuICB2YXIgciA9IHBhcnNlZC5yLFxuICAgIGcgPSBwYXJzZWQuZyxcbiAgICBiID0gcGFyc2VkLmI7XG4gIHZhciBhID0gcGFyc2VkLmE7XG4gIGEgPSBhICogMjU1IHwgMDtcbiAgdmFyIGNvbG9yID0gcmdiYVRvRmxvYXQociwgZywgYiwgYSwgdHJ1ZSk7XG4gIEZMT0FUX0NPTE9SX0NBQ0hFW3ZhbF0gPSBjb2xvcjtcbiAgcmV0dXJuIGNvbG9yO1xufVxuZnVuY3Rpb24gY29sb3JUb0FycmF5KHZhbCwgbWFza2luZykge1xuICBGTE9BVDMyWzBdID0gZmxvYXRDb2xvcih2YWwpO1xuICB2YXIgaW50VmFsdWUgPSBJTlQzMlswXTtcbiAgaWYgKG1hc2tpbmcpIHtcbiAgICBpbnRWYWx1ZSA9IGludFZhbHVlIHwgMHgwMTAwMDAwMDtcbiAgfVxuICB2YXIgciA9IGludFZhbHVlICYgMHhmZjtcbiAgdmFyIGcgPSBpbnRWYWx1ZSA+PiA4ICYgMHhmZjtcbiAgdmFyIGIgPSBpbnRWYWx1ZSA+PiAxNiAmIDB4ZmY7XG4gIHZhciBhID0gaW50VmFsdWUgPj4gMjQgJiAweGZmO1xuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxudmFyIEZMT0FUX0lOREVYX0NBQ0hFID0ge307XG5mdW5jdGlvbiBpbmRleFRvQ29sb3IoaW5kZXgpIHtcbiAgLy8gSWYgdGhlIGluZGV4IGlzIGFscmVhZHkgY29tcHV0ZWQsIHdlIHlpZWxkIGl0XG4gIGlmICh0eXBlb2YgRkxPQVRfSU5ERVhfQ0FDSEVbaW5kZXhdICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gRkxPQVRfSU5ERVhfQ0FDSEVbaW5kZXhdO1xuXG4gIC8vIFRvIGFkZHJlc3MgaXNzdWUgIzEzOTcsIG9uZSBzdHJhdGVneSBpcyB0byBrZWVwIGVuY29kaW5nIDQgYnl0ZXMgY29sb3JzLFxuICAvLyBidXQgd2l0aCBhbHBoYSBoYXJkLXNldCB0byAxLjAgKG9yIDI1NSk6XG4gIHZhciByID0gKGluZGV4ICYgMHgwMGZmMDAwMCkgPj4+IDE2O1xuICB2YXIgZyA9IChpbmRleCAmIDB4MDAwMGZmMDApID4+PiA4O1xuICB2YXIgYiA9IGluZGV4ICYgMHgwMDAwMDBmZjtcbiAgdmFyIGEgPSAweDAwMDAwMGZmO1xuXG4gIC8vIFRoZSBvcmlnaW5hbCA0IGJ5dGVzIGNvbG9yIGVuY29kaW5nIHdhcyB0aGUgZm9sbG93aW5nOlxuICAvLyBjb25zdCByID0gKGluZGV4ICYgMHhmZjAwMDAwMCkgPj4+IDI0O1xuICAvLyBjb25zdCBnID0gKGluZGV4ICYgMHgwMGZmMDAwMCkgPj4+IDE2O1xuICAvLyBjb25zdCBiID0gKGluZGV4ICYgMHgwMDAwZmYwMCkgPj4+IDg7XG4gIC8vIGNvbnN0IGEgPSBpbmRleCAmIDB4MDAwMDAwZmY7XG5cbiAgdmFyIGNvbG9yID0gcmdiYVRvRmxvYXQociwgZywgYiwgYSwgdHJ1ZSk7XG4gIEZMT0FUX0lOREVYX0NBQ0hFW2luZGV4XSA9IGNvbG9yO1xuICByZXR1cm4gY29sb3I7XG59XG5mdW5jdGlvbiBjb2xvclRvSW5kZXgociwgZywgYiwgX2EpIHtcbiAgLy8gQXMgZm9yIHRoZSBmdW5jdGlvbiBpbmRleFRvQ29sb3IsIGJlY2F1c2Ugb2YgIzEzOTcgYW5kIHRoZSBcImFscGhhIGlzIGFsd2F5c1xuICAvLyAxLjBcIiBzdHJhdGVneSwgd2UgbmVlZCB0byBmaXggdGhpcyBmdW5jdGlvbiBhcyB3ZWxsOlxuICByZXR1cm4gYiArIChnIDw8IDgpICsgKHIgPDwgMTYpO1xuXG4gIC8vIFRoZSBvcmlnaW5hbCA0IGJ5dGVzIGNvbG9yIGRlY29kaW5nIGlzIHRoZSBmb2xsb3dpbmc6XG4gIC8vIHJldHVybiBhICsgKGIgPDwgOCkgKyAoZyA8PCAxNikgKyAociA8PCAyNCk7XG59XG5mdW5jdGlvbiBnZXRQaXhlbENvbG9yKGdsLCBmcmFtZUJ1ZmZlciwgeCwgeSwgcGl4ZWxSYXRpbywgZG93blNpemluZ1JhdGlvKSB7XG4gIHZhciBidWZmZXJYID0gTWF0aC5mbG9vcih4IC8gZG93blNpemluZ1JhdGlvICogcGl4ZWxSYXRpbyk7XG4gIHZhciBidWZmZXJZID0gTWF0aC5mbG9vcihnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IC8gZG93blNpemluZ1JhdGlvIC0geSAvIGRvd25TaXppbmdSYXRpbyAqIHBpeGVsUmF0aW8pO1xuICB2YXIgcGl4ZWwgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gIGdsLnJlYWRQaXhlbHMoYnVmZmVyWCwgYnVmZmVyWSwgMSwgMSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWwpO1xuICB2YXIgX3BpeGVsID0gX3NsaWNlZFRvQXJyYXkocGl4ZWwsIDQpLFxuICAgIHIgPSBfcGl4ZWxbMF0sXG4gICAgZyA9IF9waXhlbFsxXSxcbiAgICBiID0gX3BpeGVsWzJdLFxuICAgIGEgPSBfcGl4ZWxbM107XG4gIHJldHVybiBbciwgZywgYiwgYV07XG59XG5cbmV4cG9ydCB7IEhUTUxfQ09MT1JTIGFzIEgsIF9zbGljZWRUb0FycmF5IGFzIF8sIF9hcnJheUxpa2VUb0FycmF5IGFzIGEsIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBhcyBiLCBjb2xvclRvSW5kZXggYXMgYywgY29sb3JUb0FycmF5IGFzIGQsIGV4dHJhY3RQaXhlbCBhcyBlLCBmbG9hdENvbG9yIGFzIGYsIGdldFBpeGVsQ29sb3IgYXMgZywgaW5kZXhUb0NvbG9yIGFzIGksIHBhcnNlQ29sb3IgYXMgcCwgcmdiYVRvRmxvYXQgYXMgciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/sigma/dist/colors-beb06eb2.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/sigma/dist/data-11df7124.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/sigma/dist/data-11df7124.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _typeof),\n/* harmony export */   a: () => (/* binding */ assign),\n/* harmony export */   b: () => (/* binding */ assignDeep),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   i: () => (/* binding */ isPlainObject)\n/* harmony export */ });\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\n/**\n * Extends the target array with the given values.\n */\nfunction extend(array, values) {\n  var l2 = values.size;\n  if (l2 === 0) return;\n  var l1 = array.length;\n  array.length += l2;\n  var i = 0;\n  values.forEach(function (value) {\n    array[l1 + i] = value;\n    i++;\n  });\n}\n\n/**\n * Checks whether the given value is a plain object.\n */\nfunction isPlainObject(value) {\n  return _typeof(value) === \"object\" && value !== null && value.constructor === Object;\n}\n\n/**\n * Helper to use `Object.assign` with more than two objects.\n */\nfunction assign(target) {\n  target = target || {};\n  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {\n    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    if (!o) continue;\n    Object.assign(target, o);\n  }\n  return target;\n}\n\n/**\n * Very simple recursive `Object.assign` like function.\n */\nfunction assignDeep(target) {\n  target = target || {};\n  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {\n    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    if (!o) continue;\n    for (var k in o) {\n      if (isPlainObject(o[k])) {\n        target[k] = assignDeep(target[k], o[k]);\n      } else {\n        target[k] = o[k];\n      }\n    }\n  }\n  return target;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zaWdtYS9kaXN0L2RhdGEtMTFkZjcxMjQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxPQUFPO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE9BQU87QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxlbm92b1xcRGVza3RvcFxcZnJvbnRlbmRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHNpZ21hXFxkaXN0XFxkYXRhLTExZGY3MTI0LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuXG4vKipcbiAqIEV4dGVuZHMgdGhlIHRhcmdldCBhcnJheSB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBsMiA9IHZhbHVlcy5zaXplO1xuICBpZiAobDIgPT09IDApIHJldHVybjtcbiAgdmFyIGwxID0gYXJyYXkubGVuZ3RoO1xuICBhcnJheS5sZW5ndGggKz0gbDI7XG4gIHZhciBpID0gMDtcbiAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgYXJyYXlbbDEgKyBpXSA9IHZhbHVlO1xuICAgIGkrKztcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBfdHlwZW9mKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byB1c2UgYE9iamVjdC5hc3NpZ25gIHdpdGggbW9yZSB0aGFuIHR3byBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyAwIDogYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgbyA9IGkgKyAxIDwgMSB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgKyAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2kgKyAxXTtcbiAgICBpZiAoIW8pIGNvbnRpbnVlO1xuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBvKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFZlcnkgc2ltcGxlIHJlY3Vyc2l2ZSBgT2JqZWN0LmFzc2lnbmAgbGlrZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduRGVlcCh0YXJnZXQpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IDAgOiBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA8IGw7IGkrKykge1xuICAgIHZhciBvID0gaSArIDEgPCAxIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSArIDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaSArIDFdO1xuICAgIGlmICghbykgY29udGludWU7XG4gICAgZm9yICh2YXIgayBpbiBvKSB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChvW2tdKSkge1xuICAgICAgICB0YXJnZXRba10gPSBhc3NpZ25EZWVwKHRhcmdldFtrXSwgb1trXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba10gPSBvW2tdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgeyBfdHlwZW9mIGFzIF8sIGFzc2lnbiBhcyBhLCBhc3NpZ25EZWVwIGFzIGIsIGV4dGVuZCBhcyBlLCBpc1BsYWluT2JqZWN0IGFzIGkgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/sigma/dist/data-11df7124.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/sigma/dist/index-236c62ad.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/sigma/dist/index-236c62ad.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ AbstractNodeProgram),\n/* harmony export */   D: () => (/* binding */ DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS),\n/* harmony export */   E: () => (/* binding */ EdgeArrowProgram$1),\n/* harmony export */   F: () => (/* binding */ FRAGMENT_SHADER_SOURCE),\n/* harmony export */   N: () => (/* binding */ NodeCircleProgram),\n/* harmony export */   P: () => (/* binding */ Program),\n/* harmony export */   _: () => (/* binding */ _objectSpread2),\n/* harmony export */   a: () => (/* binding */ _defineProperty),\n/* harmony export */   b: () => (/* binding */ drawDiscNodeLabel),\n/* harmony export */   c: () => (/* binding */ drawDiscNodeHover),\n/* harmony export */   d: () => (/* binding */ drawStraightEdgeLabel),\n/* harmony export */   e: () => (/* binding */ EdgeRectangleProgram),\n/* harmony export */   f: () => (/* binding */ NodeProgram),\n/* harmony export */   g: () => (/* binding */ EdgeProgram),\n/* harmony export */   h: () => (/* binding */ createEdgeCompoundProgram),\n/* harmony export */   i: () => (/* binding */ createEdgeArrowHeadProgram),\n/* harmony export */   j: () => (/* binding */ createNodeCompoundProgram),\n/* harmony export */   k: () => (/* binding */ AbstractEdgeProgram),\n/* harmony export */   l: () => (/* binding */ AbstractProgram),\n/* harmony export */   m: () => (/* binding */ EdgeArrowHeadProgram$1),\n/* harmony export */   n: () => (/* binding */ EdgeClampedProgram$1),\n/* harmony export */   o: () => (/* binding */ createEdgeClampedProgram),\n/* harmony export */   p: () => (/* binding */ DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS),\n/* harmony export */   q: () => (/* binding */ createEdgeArrowProgram),\n/* harmony export */   r: () => (/* binding */ getAttributeItemsCount),\n/* harmony export */   s: () => (/* binding */ getAttributesItemsCount),\n/* harmony export */   t: () => (/* binding */ loadVertexShader),\n/* harmony export */   u: () => (/* binding */ loadFragmentShader),\n/* harmony export */   v: () => (/* binding */ loadProgram),\n/* harmony export */   w: () => (/* binding */ killProgram),\n/* harmony export */   x: () => (/* binding */ numberToGLSLFloat)\n/* harmony export */ });\n/* harmony import */ var _inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inherits-d1a1e29b.esm.js */ \"(app-pages-browser)/./node_modules/sigma/dist/inherits-d1a1e29b.esm.js\");\n/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ \"(app-pages-browser)/./node_modules/sigma/dist/colors-beb06eb2.esm.js\");\n\n\n\nfunction _defineProperty(e, r, t) {\n  return (r = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nfunction _superPropBase(t, o) {\n  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(t)););\n  return t;\n}\n\nfunction _get() {\n  return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {\n    var p = _superPropBase(e, t);\n    if (p) {\n      var n = Object.getOwnPropertyDescriptor(p, t);\n      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n    }\n  }, _get.apply(null, arguments);\n}\n\nfunction _superPropGet(t, o, e, r) {\n  var p = _get((0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(1 & r ? t.prototype : t), o, e);\n  return 2 & r && \"function\" == typeof p ? function (t) {\n    return p.apply(e, t);\n  } : p;\n}\n\nfunction getAttributeItemsCount(attr) {\n  return attr.normalized ? 1 : attr.size;\n}\nfunction getAttributesItemsCount(attrs) {\n  var res = 0;\n  attrs.forEach(function (attr) {\n    return res += getAttributeItemsCount(attr);\n  });\n  return res;\n}\nfunction loadShader(type, gl, source) {\n  var glType = type === \"VERTEX\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;\n\n  // Creating the shader\n  var shader = gl.createShader(glType);\n  if (shader === null) {\n    throw new Error(\"loadShader: error while creating the shader\");\n  }\n\n  // Loading source\n  gl.shaderSource(shader, source);\n\n  // Compiling the shader\n  gl.compileShader(shader);\n\n  // Retrieving compilation status\n  var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  // Throwing if something went awry\n  if (!successfullyCompiled) {\n    var infoLog = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(\"loadShader: error while compiling the shader:\\n\".concat(infoLog, \"\\n\").concat(source));\n  }\n  return shader;\n}\nfunction loadVertexShader(gl, source) {\n  return loadShader(\"VERTEX\", gl, source);\n}\nfunction loadFragmentShader(gl, source) {\n  return loadShader(\"FRAGMENT\", gl, source);\n}\n\n/**\n * Function used to load a program.\n */\nfunction loadProgram(gl, shaders) {\n  var program = gl.createProgram();\n  if (program === null) {\n    throw new Error(\"loadProgram: error while creating the program.\");\n  }\n  var i, l;\n\n  // Attaching the shaders\n  for (i = 0, l = shaders.length; i < l; i++) gl.attachShader(program, shaders[i]);\n  gl.linkProgram(program);\n\n  // Checking status\n  var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!successfullyLinked) {\n    gl.deleteProgram(program);\n    throw new Error(\"loadProgram: error while linking the program.\");\n  }\n  return program;\n}\nfunction killProgram(_ref) {\n  var gl = _ref.gl,\n    buffer = _ref.buffer,\n    program = _ref.program,\n    vertexShader = _ref.vertexShader,\n    fragmentShader = _ref.fragmentShader;\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  gl.deleteProgram(program);\n  gl.deleteBuffer(buffer);\n}\n\n/**\n * Function use to print a float for inserting in a GLSL program.\n */\nfunction numberToGLSLFloat(n) {\n  return n % 1 === 0 ? n.toFixed(1) : n.toString();\n}\n\nvar PICKING_PREFIX = \"#define PICKING_MODE\\n\";\nvar SIZE_FACTOR_PER_ATTRIBUTE_TYPE = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, WebGL2RenderingContext.BOOL, 1), WebGL2RenderingContext.BYTE, 1), WebGL2RenderingContext.UNSIGNED_BYTE, 1), WebGL2RenderingContext.SHORT, 2), WebGL2RenderingContext.UNSIGNED_SHORT, 2), WebGL2RenderingContext.INT, 4), WebGL2RenderingContext.UNSIGNED_INT, 4), WebGL2RenderingContext.FLOAT, 4);\nvar AbstractProgram = /*#__PURE__*/(0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(function AbstractProgram(_gl, _pickGl, _renderer) {\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractProgram);\n});\nvar Program = /*#__PURE__*/function () {\n  function Program(gl, pickingBuffer, renderer) {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, Program);\n    // GLenum\n    _defineProperty(this, \"array\", new Float32Array());\n    _defineProperty(this, \"constantArray\", new Float32Array());\n    _defineProperty(this, \"capacity\", 0);\n    _defineProperty(this, \"verticesCount\", 0);\n    // Reading and caching program definition\n    var def = this.getDefinition();\n    this.VERTICES = def.VERTICES;\n    this.VERTEX_SHADER_SOURCE = def.VERTEX_SHADER_SOURCE;\n    this.FRAGMENT_SHADER_SOURCE = def.FRAGMENT_SHADER_SOURCE;\n    this.UNIFORMS = def.UNIFORMS;\n    this.ATTRIBUTES = def.ATTRIBUTES;\n    this.METHOD = def.METHOD;\n    this.CONSTANT_ATTRIBUTES = \"CONSTANT_ATTRIBUTES\" in def ? def.CONSTANT_ATTRIBUTES : [];\n    this.CONSTANT_DATA = \"CONSTANT_DATA\" in def ? def.CONSTANT_DATA : [];\n    this.isInstanced = \"CONSTANT_ATTRIBUTES\" in def;\n\n    // Computing stride\n    this.ATTRIBUTES_ITEMS_COUNT = getAttributesItemsCount(this.ATTRIBUTES);\n    this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT;\n\n    // Members\n    this.renderer = renderer;\n    this.normalProgram = this.getProgramInfo(\"normal\", gl, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);\n    this.pickProgram = pickingBuffer ? this.getProgramInfo(\"pick\", gl, PICKING_PREFIX + def.VERTEX_SHADER_SOURCE, PICKING_PREFIX + def.FRAGMENT_SHADER_SOURCE, pickingBuffer) : null;\n\n    // For instanced programs:\n    if (this.isInstanced) {\n      var constantAttributesItemsCount = getAttributesItemsCount(this.CONSTANT_ATTRIBUTES);\n      if (this.CONSTANT_DATA.length !== this.VERTICES) throw new Error(\"Program: error while getting constant data (expected \".concat(this.VERTICES, \" items, received \").concat(this.CONSTANT_DATA.length, \" instead)\"));\n      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * constantAttributesItemsCount);\n      for (var i = 0; i < this.CONSTANT_DATA.length; i++) {\n        var vector = this.CONSTANT_DATA[i];\n        if (vector.length !== constantAttributesItemsCount) throw new Error(\"Program: error while getting constant data (one vector has \".concat(vector.length, \" items instead of \").concat(constantAttributesItemsCount, \")\"));\n        for (var j = 0; j < vector.length; j++) this.constantArray[i * constantAttributesItemsCount + j] = vector[j];\n      }\n      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;\n    }\n  }\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(Program, [{\n    key: \"kill\",\n    value: function kill() {\n      killProgram(this.normalProgram);\n      if (this.pickProgram) {\n        killProgram(this.pickProgram);\n        this.pickProgram = null;\n      }\n    }\n  }, {\n    key: \"getProgramInfo\",\n    value: function getProgramInfo(name, gl, vertexShaderSource, fragmentShaderSource, frameBuffer) {\n      var def = this.getDefinition();\n\n      // WebGL buffers\n      var buffer = gl.createBuffer();\n      if (buffer === null) throw new Error(\"Program: error while creating the WebGL buffer.\");\n\n      // Shaders and program\n      var vertexShader = loadVertexShader(gl, vertexShaderSource);\n      var fragmentShader = loadFragmentShader(gl, fragmentShaderSource);\n      var program = loadProgram(gl, [vertexShader, fragmentShader]);\n\n      // Initializing locations\n      var uniformLocations = {};\n      def.UNIFORMS.forEach(function (uniformName) {\n        var location = gl.getUniformLocation(program, uniformName);\n        if (location) uniformLocations[uniformName] = location;\n      });\n      var attributeLocations = {};\n      def.ATTRIBUTES.forEach(function (attr) {\n        attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n      });\n\n      // For instanced programs:\n      var constantBuffer;\n      if (\"CONSTANT_ATTRIBUTES\" in def) {\n        def.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n        });\n        constantBuffer = gl.createBuffer();\n        if (constantBuffer === null) throw new Error(\"Program: error while creating the WebGL constant buffer.\");\n      }\n      return {\n        name: name,\n        program: program,\n        gl: gl,\n        frameBuffer: frameBuffer,\n        buffer: buffer,\n        constantBuffer: constantBuffer || {},\n        uniformLocations: uniformLocations,\n        attributeLocations: attributeLocations,\n        isPicking: name === \"pick\",\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader\n      };\n    }\n  }, {\n    key: \"bindProgram\",\n    value: function bindProgram(program) {\n      var _this = this;\n      var offset = 0;\n      var gl = program.gl,\n        buffer = program.buffer;\n      if (!this.isInstanced) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        offset = 0;\n        this.ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n      } else {\n        // Handle constant data (things that remain unchanged for all items):\n        gl.bindBuffer(gl.ARRAY_BUFFER, program.constantBuffer);\n        offset = 0;\n        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset, false);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.constantArray, gl.STATIC_DRAW);\n\n        // Handle \"instance specific\" data (things that vary for each item):\n        gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);\n        offset = 0;\n        this.ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset, true);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n      }\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n  }, {\n    key: \"unbindProgram\",\n    value: function unbindProgram(program) {\n      var _this2 = this;\n      if (!this.isInstanced) {\n        this.ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program);\n        });\n      } else {\n        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program, false);\n        });\n        this.ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program, true);\n        });\n      }\n    }\n  }, {\n    key: \"bindAttribute\",\n    value: function bindAttribute(attr, program, offset, setDivisor) {\n      var sizeFactor = SIZE_FACTOR_PER_ATTRIBUTE_TYPE[attr.type];\n      if (typeof sizeFactor !== \"number\") throw new Error(\"Program.bind: yet unsupported attribute type \\\"\".concat(attr.type, \"\\\"\"));\n      var location = program.attributeLocations[attr.name];\n      var gl = program.gl;\n      if (location !== -1) {\n        gl.enableVertexAttribArray(location);\n        var stride = !this.isInstanced ? this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT : (setDivisor ? this.ATTRIBUTES_ITEMS_COUNT : getAttributesItemsCount(this.CONSTANT_ATTRIBUTES)) * Float32Array.BYTES_PER_ELEMENT;\n        gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized || false, stride, offset);\n        if (this.isInstanced && setDivisor) {\n          if (gl instanceof WebGL2RenderingContext) {\n            gl.vertexAttribDivisor(location, 1);\n          } else {\n            var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n            if (ext) ext.vertexAttribDivisorANGLE(location, 1);\n          }\n        }\n      }\n      return attr.size * sizeFactor;\n    }\n  }, {\n    key: \"unbindAttribute\",\n    value: function unbindAttribute(attr, program, unsetDivisor) {\n      var location = program.attributeLocations[attr.name];\n      var gl = program.gl;\n      if (location !== -1) {\n        gl.disableVertexAttribArray(location);\n        if (this.isInstanced && unsetDivisor) {\n          if (gl instanceof WebGL2RenderingContext) {\n            gl.vertexAttribDivisor(location, 0);\n          } else {\n            var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n            if (ext) ext.vertexAttribDivisorANGLE(location, 0);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"reallocate\",\n    value: function reallocate(capacity) {\n      // If desired capacity has not changed we do nothing\n      // NOTE: it's possible here to implement more subtle reallocation schemes\n      // when the number of rendered items increase or decrease\n      if (capacity === this.capacity) return;\n      this.capacity = capacity;\n      this.verticesCount = this.VERTICES * capacity;\n      this.array = new Float32Array(!this.isInstanced ? this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT : this.capacity * this.ATTRIBUTES_ITEMS_COUNT);\n    }\n  }, {\n    key: \"hasNothingToRender\",\n    value: function hasNothingToRender() {\n      return this.verticesCount === 0;\n    }\n  }, {\n    key: \"renderProgram\",\n    value: function renderProgram(params, programInfo) {\n      var gl = programInfo.gl,\n        program = programInfo.program;\n\n      // With the current fix for #1397, the alpha blending is enabled for the\n      // picking layer:\n      gl.enable(gl.BLEND);\n\n      // Original code:\n      // if (!isPicking) gl.enable(gl.BLEND);\n      // else gl.disable(gl.BLEND);\n\n      gl.useProgram(program);\n      this.setUniforms(params, programInfo);\n      this.drawWebGL(this.METHOD, programInfo);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      if (this.hasNothingToRender()) return;\n      if (this.pickProgram) {\n        this.pickProgram.gl.viewport(0, 0, params.width * params.pixelRatio / params.downSizingRatio, params.height * params.pixelRatio / params.downSizingRatio);\n        this.bindProgram(this.pickProgram);\n        this.renderProgram(_objectSpread2(_objectSpread2({}, params), {}, {\n          pixelRatio: params.pixelRatio / params.downSizingRatio\n        }), this.pickProgram);\n        this.unbindProgram(this.pickProgram);\n      }\n      this.normalProgram.gl.viewport(0, 0, params.width * params.pixelRatio, params.height * params.pixelRatio);\n      this.bindProgram(this.normalProgram);\n      this.renderProgram(params, this.normalProgram);\n      this.unbindProgram(this.normalProgram);\n    }\n  }, {\n    key: \"drawWebGL\",\n    value: function drawWebGL(method, _ref) {\n      var gl = _ref.gl,\n        frameBuffer = _ref.frameBuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      if (!this.isInstanced) {\n        gl.drawArrays(method, 0, this.verticesCount);\n      } else {\n        if (gl instanceof WebGL2RenderingContext) {\n          gl.drawArraysInstanced(method, 0, this.VERTICES, this.capacity);\n        } else {\n          var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n          if (ext) ext.drawArraysInstancedANGLE(method, 0, this.VERTICES, this.capacity);\n        }\n      }\n    }\n  }]);\n}();\n\nvar AbstractNodeProgram = /*#__PURE__*/function (_AbstractProgram) {\n  function AbstractNodeProgram() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractNodeProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, AbstractNodeProgram, arguments);\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(AbstractNodeProgram, _AbstractProgram);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(AbstractNodeProgram);\n}(AbstractProgram);\nvar NodeProgram = /*#__PURE__*/function (_ref) {\n  function NodeProgram() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, NodeProgram, arguments);\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(NodeProgram, _ref);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeProgram, [{\n    key: \"kill\",\n    value: function kill() {\n      _superPropGet(NodeProgram, \"kill\", this, 3)([]);\n    }\n  }, {\n    key: \"process\",\n    value: function process(nodeIndex, offset, data) {\n      var i = offset * this.STRIDE;\n      // NOTE: dealing with hidden items automatically\n      if (data.hidden) {\n        for (var l = i + this.STRIDE; i < l; i++) {\n          this.array[i] = 0;\n        }\n        return;\n      }\n      return this.processVisibleItem((0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)(nodeIndex), i, data);\n    }\n  }]);\n}(Program);\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional node \"draw label\" function.\n * @param  {function} drawHover - An optional node \"draw hover\" function.\n * @return {function}\n */\nfunction createNodeCompoundProgram(programClasses, drawLabel, drawHover) {\n  return /*#__PURE__*/function () {\n    function NodeCompoundProgram(gl, pickingBuffer, renderer) {\n      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeCompoundProgram);\n      _defineProperty(this, \"drawLabel\", drawLabel);\n      _defineProperty(this, \"drawHover\", drawHover);\n      this.programs = programClasses.map(function (Program) {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeCompoundProgram, [{\n      key: \"reallocate\",\n      value: function reallocate(capacity) {\n        this.programs.forEach(function (program) {\n          return program.reallocate(capacity);\n        });\n      }\n    }, {\n      key: \"process\",\n      value: function process(nodeIndex, offset, data) {\n        this.programs.forEach(function (program) {\n          return program.process(nodeIndex, offset, data);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render(params) {\n        this.programs.forEach(function (program) {\n          return program.render(params);\n        });\n      }\n    }, {\n      key: \"kill\",\n      value: function kill() {\n        this.programs.forEach(function (program) {\n          return program.kill();\n        });\n      }\n    }]);\n  }();\n}\n\nvar AbstractEdgeProgram = /*#__PURE__*/function (_AbstractProgram) {\n  function AbstractEdgeProgram() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractEdgeProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, AbstractEdgeProgram, arguments);\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(AbstractEdgeProgram, _AbstractProgram);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(AbstractEdgeProgram);\n}(AbstractProgram);\nvar EdgeProgram = /*#__PURE__*/function (_ref) {\n  function EdgeProgram() {\n    var _this;\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeProgram);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeProgram, [].concat(args));\n    _defineProperty(_this, \"drawLabel\", undefined);\n    return _this;\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeProgram, _ref);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeProgram, [{\n    key: \"kill\",\n    value: function kill() {\n      _superPropGet(EdgeProgram, \"kill\", this, 3)([]);\n    }\n  }, {\n    key: \"process\",\n    value: function process(edgeIndex, offset, sourceData, targetData, data) {\n      var i = offset * this.STRIDE;\n      // NOTE: dealing with hidden items automatically\n      if (data.hidden || sourceData.hidden || targetData.hidden) {\n        for (var l = i + this.STRIDE; i < l; i++) {\n          this.array[i] = 0;\n        }\n        return;\n      }\n      return this.processVisibleItem((0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)(edgeIndex), i, sourceData, targetData, data);\n    }\n  }]);\n}(Program);\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional edge \"draw label\" function.\n * @return {function}\n */\nfunction createEdgeCompoundProgram(programClasses, drawLabel) {\n  return /*#__PURE__*/function () {\n    function EdgeCompoundProgram(gl, pickingBuffer, renderer) {\n      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeCompoundProgram);\n      _defineProperty(this, \"drawLabel\", drawLabel);\n      this.programs = programClasses.map(function (Program) {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeCompoundProgram, [{\n      key: \"reallocate\",\n      value: function reallocate(capacity) {\n        this.programs.forEach(function (program) {\n          return program.reallocate(capacity);\n        });\n      }\n    }, {\n      key: \"process\",\n      value: function process(edgeIndex, offset, sourceData, targetData, data) {\n        this.programs.forEach(function (program) {\n          return program.process(edgeIndex, offset, sourceData, targetData, data);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render(params) {\n        this.programs.forEach(function (program) {\n          return program.render(params);\n        });\n      }\n    }, {\n      key: \"kill\",\n      value: function kill() {\n        this.programs.forEach(function (program) {\n          return program.kill();\n        });\n      }\n    }]);\n  }();\n}\n\nfunction drawStraightEdgeLabel(context, edgeData, sourceData, targetData, settings) {\n  var size = settings.edgeLabelSize,\n    font = settings.edgeLabelFont,\n    weight = settings.edgeLabelWeight,\n    color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\" : settings.edgeLabelColor.color;\n  var label = edgeData.label;\n  if (!label) return;\n  context.fillStyle = color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n  // Computing positions without considering nodes sizes:\n  var sSize = sourceData.size;\n  var tSize = targetData.size;\n  var sx = sourceData.x;\n  var sy = sourceData.y;\n  var tx = targetData.x;\n  var ty = targetData.y;\n  var cx = (sx + tx) / 2;\n  var cy = (sy + ty) / 2;\n  var dx = tx - sx;\n  var dy = ty - sy;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  if (d < sSize + tSize) return;\n\n  // Adding nodes sizes:\n  sx += dx * sSize / d;\n  sy += dy * sSize / d;\n  tx -= dx * tSize / d;\n  ty -= dy * tSize / d;\n  cx = (sx + tx) / 2;\n  cy = (sy + ty) / 2;\n  dx = tx - sx;\n  dy = ty - sy;\n  d = Math.sqrt(dx * dx + dy * dy);\n\n  // Handling ellipsis\n  var textLength = context.measureText(label).width;\n  if (textLength > d) {\n    var ellipsis = \"\";\n    label = label + ellipsis;\n    textLength = context.measureText(label).width;\n    while (textLength > d && label.length > 1) {\n      label = label.slice(0, -2) + ellipsis;\n      textLength = context.measureText(label).width;\n    }\n    if (label.length < 4) return;\n  }\n  var angle;\n  if (dx > 0) {\n    if (dy > 0) angle = Math.acos(dx / d);else angle = Math.asin(dy / d);\n  } else {\n    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;else angle = Math.asin(dx / d) + Math.PI / 2;\n  }\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);\n  context.restore();\n}\n\nfunction drawDiscNodeLabel(context, data, settings) {\n  if (!data.label) return;\n  var size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight,\n    color = settings.labelColor.attribute ? data[settings.labelColor.attribute] || settings.labelColor.color || \"#000\" : settings.labelColor.color;\n  context.fillStyle = color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}\n\n/**\n * Draw an hovered node.\n * - if there is no label => display a shadow on the node\n * - if the label box is bigger than node size => display a label box that contains the node with a shadow\n * - else node with shadow and the label box\n */\nfunction drawDiscNodeHover(context, data, settings) {\n  var size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n  // Then we draw the label background\n  context.fillStyle = \"#FFF\";\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 8;\n  context.shadowColor = \"#000\";\n  var PADDING = 2;\n  if (typeof data.label === \"string\") {\n    var textWidth = context.measureText(data.label).width,\n      boxWidth = Math.round(textWidth + 5),\n      boxHeight = Math.round(size + 2 * PADDING),\n      radius = Math.max(data.size, size / 2) + PADDING;\n    var angleRadian = Math.asin(boxHeight / 2 / radius);\n    var xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));\n    context.beginPath();\n    context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);\n    context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);\n    context.arc(data.x, data.y, radius, angleRadian, -angleRadian);\n    context.closePath();\n    context.fill();\n  } else {\n    context.beginPath();\n    context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);\n    context.closePath();\n    context.fill();\n  }\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 0;\n\n  // And finally we draw the label\n  drawDiscNodeLabel(context, data, settings);\n}\n\n// language=GLSL\nvar SHADER_SOURCE$6 = /*glsl*/\"\\nprecision highp float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\n\\nuniform float u_correctionRatio;\\n\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float border = u_correctionRatio * 2.0;\\n  float dist = length(v_diffVector) - v_radius + border;\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  if (dist > border)\\n    gl_FragColor = transparent;\\n  else\\n    gl_FragColor = v_color;\\n\\n  #else\\n  float t = 0.0;\\n  if (dist > border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / border;\\n\\n  gl_FragColor = mix(v_color, transparent, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;\n\n// language=GLSL\nvar SHADER_SOURCE$5 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\nattribute float a_size;\\nattribute float a_angle;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\\n  vec2 position = a_position + diffVector;\\n  gl_Position = vec4(\\n    (u_matrix * vec3(position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  v_diffVector = diffVector;\\n  v_radius = size / 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;\n\nvar _WebGLRenderingContex$3 = WebGLRenderingContext,\n  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,\n  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;\nvar UNIFORMS$3 = [\"u_sizeRatio\", \"u_correctionRatio\", \"u_matrix\"];\nvar NodeCircleProgram = /*#__PURE__*/function (_NodeProgram) {\n  function NodeCircleProgram() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeCircleProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, NodeCircleProgram, arguments);\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(NodeCircleProgram, _NodeProgram);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeCircleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS$3,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$3\n        }, {\n          name: \"a_size\",\n          size: 1,\n          type: FLOAT$3\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [{\n          name: \"a_angle\",\n          size: 1,\n          type: FLOAT$3\n        }],\n        CONSTANT_DATA: [[NodeCircleProgram.ANGLE_1], [NodeCircleProgram.ANGLE_2], [NodeCircleProgram.ANGLE_3]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(nodeIndex, startIndex, data) {\n      var array = this.array;\n      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n      array[startIndex++] = data.x;\n      array[startIndex++] = data.y;\n      array[startIndex++] = data.size;\n      array[startIndex++] = color;\n      array[startIndex++] = nodeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_matrix = uniformLocations.u_matrix;\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    }\n  }]);\n}(NodeProgram);\n_defineProperty(NodeCircleProgram, \"ANGLE_1\", 0);\n_defineProperty(NodeCircleProgram, \"ANGLE_2\", 2 * Math.PI / 3);\n_defineProperty(NodeCircleProgram, \"ANGLE_3\", 4 * Math.PI / 3);\n\n// language=GLSL\nvar SHADER_SOURCE$4 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$4;\n\n// language=GLSL\nvar SHADER_SOURCE$3 = /*glsl*/\"\\nattribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_radius;\\nattribute vec3 a_barycentric;\\n\\n#ifdef PICKING_MODE\\nattribute vec4 a_id;\\n#else\\nattribute vec4 a_color;\\n#endif\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\nuniform float u_minEdgeThickness;\\nuniform float u_lengthToThicknessRatio;\\nuniform float u_widenessToThicknessRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  float normalLength = length(a_normal);\\n  vec2 unitNormal = a_normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl and\\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\\n  // happening:\\n  float pixelsThickness = max(normalLength / u_sizeRatio, minThickness);\\n  float webGLThickness = pixelsThickness * u_correctionRatio;\\n  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n  float webGLArrowHeadThickness = webGLThickness * u_widenessToThicknessRatio;\\n\\n  float da = a_barycentric.x;\\n  float db = a_barycentric.y;\\n  float dc = a_barycentric.z;\\n\\n  vec2 delta = vec2(\\n      da * (webGLNodeRadius * unitNormal.y)\\n    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadThickness * unitNormal.x)\\n    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadThickness * unitNormal.x),\\n\\n      da * (-webGLNodeRadius * unitNormal.x)\\n    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadThickness * unitNormal.y)\\n    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadThickness * unitNormal.y)\\n  );\\n\\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\\n\\n  gl_Position = vec4(position, 0, 1);\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$3;\n\nvar _WebGLRenderingContex$2 = WebGLRenderingContext,\n  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,\n  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;\nvar UNIFORMS$2 = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_minEdgeThickness\", \"u_lengthToThicknessRatio\", \"u_widenessToThicknessRatio\"];\nvar DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS = {\n  extremity: \"target\",\n  lengthToThicknessRatio: 2.5,\n  widenessToThicknessRatio: 2\n};\nfunction createEdgeArrowHeadProgram(inputOptions) {\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS), inputOptions || {});\n  return /*#__PURE__*/function (_EdgeProgram) {\n    function EdgeArrowHeadProgram() {\n      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeArrowHeadProgram);\n      return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeArrowHeadProgram, arguments);\n    }\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeArrowHeadProgram, _EdgeProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeArrowHeadProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 3,\n          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,\n          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS$2,\n          ATTRIBUTES: [{\n            name: \"a_position\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_normal\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_radius\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }],\n          CONSTANT_ATTRIBUTES: [{\n            name: \"a_barycentric\",\n            size: 3,\n            type: FLOAT$2\n          }],\n          CONSTANT_DATA: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n        if (options.extremity === \"source\") {\n          var _ref = [targetData, sourceData];\n          sourceData = _ref[0];\n          targetData = _ref[1];\n        }\n        var thickness = data.size || 1;\n        var radius = targetData.size || 1;\n        var x1 = sourceData.x;\n        var y1 = sourceData.y;\n        var x2 = targetData.x;\n        var y2 = targetData.y;\n        var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n\n        // Computing normals\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var len = dx * dx + dy * dy;\n        var n1 = 0;\n        var n2 = 0;\n        if (len) {\n          len = 1 / Math.sqrt(len);\n          n1 = -dy * len * thickness;\n          n2 = dx * len * thickness;\n        }\n        var array = this.array;\n        array[startIndex++] = x2;\n        array[startIndex++] = y2;\n        array[startIndex++] = -n1;\n        array[startIndex++] = -n2;\n        array[startIndex++] = radius;\n        array[startIndex++] = color;\n        array[startIndex++] = edgeIndex;\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref2) {\n        var gl = _ref2.gl,\n          uniformLocations = _ref2.uniformLocations;\n        var u_matrix = uniformLocations.u_matrix,\n          u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_correctionRatio = uniformLocations.u_correctionRatio,\n          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,\n          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio,\n          u_widenessToThicknessRatio = uniformLocations.u_widenessToThicknessRatio;\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniform1f(u_correctionRatio, params.correctionRatio);\n        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);\n        gl.uniform1f(u_widenessToThicknessRatio, options.widenessToThicknessRatio);\n      }\n    }]);\n  }(EdgeProgram);\n}\nvar EdgeArrowHeadProgram = createEdgeArrowHeadProgram();\nvar EdgeArrowHeadProgram$1 = EdgeArrowHeadProgram;\n\n// language=GLSL\nvar SHADER_SOURCE$2 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\nvarying float v_feather;\\n\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  // We only handle antialiasing for normal mode:\\n  #ifdef PICKING_MODE\\n  gl_FragColor = v_color;\\n  #else\\n  float dist = length(v_normal) * v_thickness;\\n\\n  float t = smoothstep(\\n    v_thickness - v_feather,\\n    v_thickness,\\n    dist\\n  );\\n\\n  gl_FragColor = mix(v_color, transparent, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$2;\n\n// language=GLSL\nvar SHADER_SOURCE$1 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\nattribute float a_radius;\\nattribute float a_radiusCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_zoomRatio;\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform float u_correctionRatio;\\nuniform float u_minEdgeThickness;\\nuniform float u_lengthToThicknessRatio;\\nuniform float u_feather;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\nvarying float v_feather;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  float radius = a_radius * a_radiusCoef;\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl. Please read it to\\n  // get better comments on what's happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here, we move the point to leave space for the arrow head:\\n  float direction = sign(radius);\\n  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n\\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);\\n\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$1;\n\nvar _WebGLRenderingContex$1 = WebGLRenderingContext,\n  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,\n  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;\nvar UNIFORMS$1 = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_pixelRatio\", \"u_feather\", \"u_minEdgeThickness\", \"u_lengthToThicknessRatio\"];\nvar DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS = {\n  lengthToThicknessRatio: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS.lengthToThicknessRatio\n};\nfunction createEdgeClampedProgram(inputOptions) {\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS), inputOptions || {});\n  return /*#__PURE__*/function (_EdgeProgram) {\n    function EdgeClampedProgram() {\n      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeClampedProgram);\n      return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeClampedProgram, arguments);\n    }\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeClampedProgram, _EdgeProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeClampedProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 6,\n          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,\n          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS$1,\n          ATTRIBUTES: [{\n            name: \"a_positionStart\",\n            size: 2,\n            type: FLOAT$1\n          }, {\n            name: \"a_positionEnd\",\n            size: 2,\n            type: FLOAT$1\n          }, {\n            name: \"a_normal\",\n            size: 2,\n            type: FLOAT$1\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE$1,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE$1,\n            normalized: true\n          }, {\n            name: \"a_radius\",\n            size: 1,\n            type: FLOAT$1\n          }],\n          CONSTANT_ATTRIBUTES: [\n          // If 0, then position will be a_positionStart\n          // If 1, then position will be a_positionEnd\n          {\n            name: \"a_positionCoef\",\n            size: 1,\n            type: FLOAT$1\n          }, {\n            name: \"a_normalCoef\",\n            size: 1,\n            type: FLOAT$1\n          }, {\n            name: \"a_radiusCoef\",\n            size: 1,\n            type: FLOAT$1\n          }],\n          CONSTANT_DATA: [[0, 1, 0], [0, -1, 0], [1, 1, 1], [1, 1, 1], [0, -1, 0], [1, -1, -1]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n        var thickness = data.size || 1;\n        var x1 = sourceData.x;\n        var y1 = sourceData.y;\n        var x2 = targetData.x;\n        var y2 = targetData.y;\n        var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n\n        // Computing normals\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var radius = targetData.size || 1;\n        var len = dx * dx + dy * dy;\n        var n1 = 0;\n        var n2 = 0;\n        if (len) {\n          len = 1 / Math.sqrt(len);\n          n1 = -dy * len * thickness;\n          n2 = dx * len * thickness;\n        }\n        var array = this.array;\n        array[startIndex++] = x1;\n        array[startIndex++] = y1;\n        array[startIndex++] = x2;\n        array[startIndex++] = y2;\n        array[startIndex++] = n1;\n        array[startIndex++] = n2;\n        array[startIndex++] = color;\n        array[startIndex++] = edgeIndex;\n        array[startIndex++] = radius;\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref) {\n        var gl = _ref.gl,\n          uniformLocations = _ref.uniformLocations;\n        var u_matrix = uniformLocations.u_matrix,\n          u_zoomRatio = uniformLocations.u_zoomRatio,\n          u_feather = uniformLocations.u_feather,\n          u_pixelRatio = uniformLocations.u_pixelRatio,\n          u_correctionRatio = uniformLocations.u_correctionRatio,\n          u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,\n          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio;\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1f(u_zoomRatio, params.zoomRatio);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniform1f(u_correctionRatio, params.correctionRatio);\n        gl.uniform1f(u_pixelRatio, params.pixelRatio);\n        gl.uniform1f(u_feather, params.antiAliasingFeather);\n        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);\n      }\n    }]);\n  }(EdgeProgram);\n}\nvar EdgeClampedProgram = createEdgeClampedProgram();\nvar EdgeClampedProgram$1 = EdgeClampedProgram;\n\nfunction createEdgeArrowProgram(inputOptions) {\n  return createEdgeCompoundProgram([createEdgeClampedProgram(inputOptions), createEdgeArrowHeadProgram(inputOptions)]);\n}\nvar EdgeArrowProgram = createEdgeArrowProgram();\nvar EdgeArrowProgram$1 = EdgeArrowProgram;\n\n// language=GLSL\nvar SHADER_SOURCE = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_zoomRatio;\\nuniform float u_pixelRatio;\\nuniform float u_correctionRatio;\\nuniform float u_minEdgeThickness;\\nuniform float u_feather;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\nvarying float v_feather;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // We require edges to be at least \\\"minThickness\\\" pixels thick *on screen*\\n  // (so we need to compensate the size ratio):\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n\\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\\n  // referential (in a ([0, 1], [0, 1]) space), using our \\\"magic\\\" correction\\n  // ratio:\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\\n\\n  // For the fragment shader though, we need a thickness that takes the \\\"magic\\\"\\n  // correction ratio into account (as in webGLThickness), but so that the\\n  // antialiasing effect does not depend on the zoom level. So here's yet\\n  // another thickness version:\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE = SHADER_SOURCE;\n\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nvar UNIFORMS = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_pixelRatio\", \"u_feather\", \"u_minEdgeThickness\"];\nvar EdgeRectangleProgram = /*#__PURE__*/function (_EdgeProgram) {\n  function EdgeRectangleProgram() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeRectangleProgram);\n    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeRectangleProgram, arguments);\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeRectangleProgram, _EdgeProgram);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeRectangleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 6,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 2, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_DATA: [[0, 1], [0, -1], [1, 1], [1, 1], [0, -1], [1, -1]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_zoomRatio = uniformLocations.u_zoomRatio,\n        u_feather = uniformLocations.u_feather,\n        u_pixelRatio = uniformLocations.u_pixelRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_minEdgeThickness = uniformLocations.u_minEdgeThickness;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_zoomRatio, params.zoomRatio);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_pixelRatio, params.pixelRatio);\n      gl.uniform1f(u_feather, params.antiAliasingFeather);\n      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n    }\n  }]);\n}(EdgeProgram);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zaWdtYS9kaXN0L2luZGV4LTIzNmM2MmFkLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUs7QUFDbkY7O0FBRTlFO0FBQ0EsY0FBYyw0REFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLEdBQUcsNENBQTRDLDREQUFlLEtBQUs7QUFDNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGVBQWUsNERBQWU7QUFDOUI7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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OztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFMHpCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxlbm92b1xcRGVza3RvcFxcZnJvbnRlbmRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHNpZ21hXFxkaXN0XFxpbmRleC0yMzZjNjJhZC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZCBhcyBfdG9Qcm9wZXJ0eUtleSwgZSBhcyBfZ2V0UHJvdG90eXBlT2YsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgXyBhcyBfaW5oZXJpdHMsIGMgYXMgX2NhbGxTdXBlciB9IGZyb20gJy4vaW5oZXJpdHMtZDFhMWUyOWIuZXNtLmpzJztcbmltcG9ydCB7IGkgYXMgaW5kZXhUb0NvbG9yLCBmIGFzIGZsb2F0Q29sb3IgfSBmcm9tICcuL2NvbG9ycy1iZWIwNmViMi5lc20uanMnO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICB3cml0YWJsZTogITBcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gIHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2UodCwgbykge1xuICBmb3IgKDsgIXt9Lmhhc093blByb3BlcnR5LmNhbGwodCwgbykgJiYgbnVsbCAhPT0gKHQgPSBfZ2V0UHJvdG90eXBlT2YodCkpOyk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBfZ2V0KCkge1xuICByZXR1cm4gX2dldCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5nZXQgPyBSZWZsZWN0LmdldC5iaW5kKCkgOiBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgIHZhciBwID0gX3N1cGVyUHJvcEJhc2UoZSwgdCk7XG4gICAgaWYgKHApIHtcbiAgICAgIHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwLCB0KTtcbiAgICAgIHJldHVybiBuLmdldCA/IG4uZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBlIDogcikgOiBuLnZhbHVlO1xuICAgIH1cbiAgfSwgX2dldC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wR2V0KHQsIG8sIGUsIHIpIHtcbiAgdmFyIHAgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZigxICYgciA/IHQucHJvdG90eXBlIDogdCksIG8sIGUpO1xuICByZXR1cm4gMiAmIHIgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBwID8gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gcC5hcHBseShlLCB0KTtcbiAgfSA6IHA7XG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZUl0ZW1zQ291bnQoYXR0cikge1xuICByZXR1cm4gYXR0ci5ub3JtYWxpemVkID8gMSA6IGF0dHIuc2l6ZTtcbn1cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNJdGVtc0NvdW50KGF0dHJzKSB7XG4gIHZhciByZXMgPSAwO1xuICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgcmV0dXJuIHJlcyArPSBnZXRBdHRyaWJ1dGVJdGVtc0NvdW50KGF0dHIpO1xuICB9KTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGxvYWRTaGFkZXIodHlwZSwgZ2wsIHNvdXJjZSkge1xuICB2YXIgZ2xUeXBlID0gdHlwZSA9PT0gXCJWRVJURVhcIiA/IGdsLlZFUlRFWF9TSEFERVIgOiBnbC5GUkFHTUVOVF9TSEFERVI7XG5cbiAgLy8gQ3JlYXRpbmcgdGhlIHNoYWRlclxuICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsVHlwZSk7XG4gIGlmIChzaGFkZXIgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2FkU2hhZGVyOiBlcnJvciB3aGlsZSBjcmVhdGluZyB0aGUgc2hhZGVyXCIpO1xuICB9XG5cbiAgLy8gTG9hZGluZyBzb3VyY2VcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcblxuICAvLyBDb21waWxpbmcgdGhlIHNoYWRlclxuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgLy8gUmV0cmlldmluZyBjb21waWxhdGlvbiBzdGF0dXNcbiAgdmFyIHN1Y2Nlc3NmdWxseUNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXG4gIC8vIFRocm93aW5nIGlmIHNvbWV0aGluZyB3ZW50IGF3cnlcbiAgaWYgKCFzdWNjZXNzZnVsbHlDb21waWxlZCkge1xuICAgIHZhciBpbmZvTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRTaGFkZXI6IGVycm9yIHdoaWxlIGNvbXBpbGluZyB0aGUgc2hhZGVyOlxcblwiLmNvbmNhdChpbmZvTG9nLCBcIlxcblwiKS5jb25jYXQoc291cmNlKSk7XG4gIH1cbiAgcmV0dXJuIHNoYWRlcjtcbn1cbmZ1bmN0aW9uIGxvYWRWZXJ0ZXhTaGFkZXIoZ2wsIHNvdXJjZSkge1xuICByZXR1cm4gbG9hZFNoYWRlcihcIlZFUlRFWFwiLCBnbCwgc291cmNlKTtcbn1cbmZ1bmN0aW9uIGxvYWRGcmFnbWVudFNoYWRlcihnbCwgc291cmNlKSB7XG4gIHJldHVybiBsb2FkU2hhZGVyKFwiRlJBR01FTlRcIiwgZ2wsIHNvdXJjZSk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byBsb2FkIGEgcHJvZ3JhbS5cbiAqL1xuZnVuY3Rpb24gbG9hZFByb2dyYW0oZ2wsIHNoYWRlcnMpIHtcbiAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGlmIChwcm9ncmFtID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFByb2dyYW06IGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBwcm9ncmFtLlwiKTtcbiAgfVxuICB2YXIgaSwgbDtcblxuICAvLyBBdHRhY2hpbmcgdGhlIHNoYWRlcnNcbiAgZm9yIChpID0gMCwgbCA9IHNoYWRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgc2hhZGVyc1tpXSk7XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gIC8vIENoZWNraW5nIHN0YXR1c1xuICB2YXIgc3VjY2Vzc2Z1bGx5TGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyk7XG4gIGlmICghc3VjY2Vzc2Z1bGx5TGlua2VkKSB7XG4gICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2FkUHJvZ3JhbTogZXJyb3Igd2hpbGUgbGlua2luZyB0aGUgcHJvZ3JhbS5cIik7XG4gIH1cbiAgcmV0dXJuIHByb2dyYW07XG59XG5mdW5jdGlvbiBraWxsUHJvZ3JhbShfcmVmKSB7XG4gIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgYnVmZmVyID0gX3JlZi5idWZmZXIsXG4gICAgcHJvZ3JhbSA9IF9yZWYucHJvZ3JhbSxcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBfcmVmLnZlcnRleFNoYWRlcixcbiAgICBmcmFnbWVudFNoYWRlciA9IF9yZWYuZnJhZ21lbnRTaGFkZXI7XG4gIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICBnbC5kZWxldGVCdWZmZXIoYnVmZmVyKTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2UgdG8gcHJpbnQgYSBmbG9hdCBmb3IgaW5zZXJ0aW5nIGluIGEgR0xTTCBwcm9ncmFtLlxuICovXG5mdW5jdGlvbiBudW1iZXJUb0dMU0xGbG9hdChuKSB7XG4gIHJldHVybiBuICUgMSA9PT0gMCA/IG4udG9GaXhlZCgxKSA6IG4udG9TdHJpbmcoKTtcbn1cblxudmFyIFBJQ0tJTkdfUFJFRklYID0gXCIjZGVmaW5lIFBJQ0tJTkdfTU9ERVxcblwiO1xudmFyIFNJWkVfRkFDVE9SX1BFUl9BVFRSSUJVVEVfVFlQRSA9IF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe30sIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQk9PTCwgMSksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQllURSwgMSksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURSwgMSksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU0hPUlQsIDIpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAyKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5JTlQsIDQpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0lOVCwgNCksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRkxPQVQsIDQpO1xudmFyIEFic3RyYWN0UHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gQWJzdHJhY3RQcm9ncmFtKF9nbCwgX3BpY2tHbCwgX3JlbmRlcmVyKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdFByb2dyYW0pO1xufSk7XG52YXIgUHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb2dyYW0oZ2wsIHBpY2tpbmdCdWZmZXIsIHJlbmRlcmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb2dyYW0pO1xuICAgIC8vIEdMZW51bVxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFycmF5XCIsIG5ldyBGbG9hdDMyQXJyYXkoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uc3RhbnRBcnJheVwiLCBuZXcgRmxvYXQzMkFycmF5KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhcGFjaXR5XCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnRpY2VzQ291bnRcIiwgMCk7XG4gICAgLy8gUmVhZGluZyBhbmQgY2FjaGluZyBwcm9ncmFtIGRlZmluaXRpb25cbiAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKCk7XG4gICAgdGhpcy5WRVJUSUNFUyA9IGRlZi5WRVJUSUNFUztcbiAgICB0aGlzLlZFUlRFWF9TSEFERVJfU09VUkNFID0gZGVmLlZFUlRFWF9TSEFERVJfU09VUkNFO1xuICAgIHRoaXMuRlJBR01FTlRfU0hBREVSX1NPVVJDRSA9IGRlZi5GUkFHTUVOVF9TSEFERVJfU09VUkNFO1xuICAgIHRoaXMuVU5JRk9STVMgPSBkZWYuVU5JRk9STVM7XG4gICAgdGhpcy5BVFRSSUJVVEVTID0gZGVmLkFUVFJJQlVURVM7XG4gICAgdGhpcy5NRVRIT0QgPSBkZWYuTUVUSE9EO1xuICAgIHRoaXMuQ09OU1RBTlRfQVRUUklCVVRFUyA9IFwiQ09OU1RBTlRfQVRUUklCVVRFU1wiIGluIGRlZiA/IGRlZi5DT05TVEFOVF9BVFRSSUJVVEVTIDogW107XG4gICAgdGhpcy5DT05TVEFOVF9EQVRBID0gXCJDT05TVEFOVF9EQVRBXCIgaW4gZGVmID8gZGVmLkNPTlNUQU5UX0RBVEEgOiBbXTtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gXCJDT05TVEFOVF9BVFRSSUJVVEVTXCIgaW4gZGVmO1xuXG4gICAgLy8gQ29tcHV0aW5nIHN0cmlkZVxuICAgIHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVCA9IGdldEF0dHJpYnV0ZXNJdGVtc0NvdW50KHRoaXMuQVRUUklCVVRFUyk7XG4gICAgdGhpcy5TVFJJREUgPSB0aGlzLlZFUlRJQ0VTICogdGhpcy5BVFRSSUJVVEVTX0lURU1TX0NPVU5UO1xuXG4gICAgLy8gTWVtYmVyc1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLm5vcm1hbFByb2dyYW0gPSB0aGlzLmdldFByb2dyYW1JbmZvKFwibm9ybWFsXCIsIGdsLCBkZWYuVkVSVEVYX1NIQURFUl9TT1VSQ0UsIGRlZi5GUkFHTUVOVF9TSEFERVJfU09VUkNFLCBudWxsKTtcbiAgICB0aGlzLnBpY2tQcm9ncmFtID0gcGlja2luZ0J1ZmZlciA/IHRoaXMuZ2V0UHJvZ3JhbUluZm8oXCJwaWNrXCIsIGdsLCBQSUNLSU5HX1BSRUZJWCArIGRlZi5WRVJURVhfU0hBREVSX1NPVVJDRSwgUElDS0lOR19QUkVGSVggKyBkZWYuRlJBR01FTlRfU0hBREVSX1NPVVJDRSwgcGlja2luZ0J1ZmZlcikgOiBudWxsO1xuXG4gICAgLy8gRm9yIGluc3RhbmNlZCBwcm9ncmFtczpcbiAgICBpZiAodGhpcy5pc0luc3RhbmNlZCkge1xuICAgICAgdmFyIGNvbnN0YW50QXR0cmlidXRlc0l0ZW1zQ291bnQgPSBnZXRBdHRyaWJ1dGVzSXRlbXNDb3VudCh0aGlzLkNPTlNUQU5UX0FUVFJJQlVURVMpO1xuICAgICAgaWYgKHRoaXMuQ09OU1RBTlRfREFUQS5sZW5ndGggIT09IHRoaXMuVkVSVElDRVMpIHRocm93IG5ldyBFcnJvcihcIlByb2dyYW06IGVycm9yIHdoaWxlIGdldHRpbmcgY29uc3RhbnQgZGF0YSAoZXhwZWN0ZWQgXCIuY29uY2F0KHRoaXMuVkVSVElDRVMsIFwiIGl0ZW1zLCByZWNlaXZlZCBcIikuY29uY2F0KHRoaXMuQ09OU1RBTlRfREFUQS5sZW5ndGgsIFwiIGluc3RlYWQpXCIpKTtcbiAgICAgIHRoaXMuY29uc3RhbnRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5DT05TVEFOVF9EQVRBLmxlbmd0aCAqIGNvbnN0YW50QXR0cmlidXRlc0l0ZW1zQ291bnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLkNPTlNUQU5UX0RBVEEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZlY3RvciA9IHRoaXMuQ09OU1RBTlRfREFUQVtpXTtcbiAgICAgICAgaWYgKHZlY3Rvci5sZW5ndGggIT09IGNvbnN0YW50QXR0cmlidXRlc0l0ZW1zQ291bnQpIHRocm93IG5ldyBFcnJvcihcIlByb2dyYW06IGVycm9yIHdoaWxlIGdldHRpbmcgY29uc3RhbnQgZGF0YSAob25lIHZlY3RvciBoYXMgXCIuY29uY2F0KHZlY3Rvci5sZW5ndGgsIFwiIGl0ZW1zIGluc3RlYWQgb2YgXCIpLmNvbmNhdChjb25zdGFudEF0dHJpYnV0ZXNJdGVtc0NvdW50LCBcIilcIikpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZlY3Rvci5sZW5ndGg7IGorKykgdGhpcy5jb25zdGFudEFycmF5W2kgKiBjb25zdGFudEF0dHJpYnV0ZXNJdGVtc0NvdW50ICsgal0gPSB2ZWN0b3Jbal07XG4gICAgICB9XG4gICAgICB0aGlzLlNUUklERSA9IHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQcm9ncmFtLCBbe1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICBraWxsUHJvZ3JhbSh0aGlzLm5vcm1hbFByb2dyYW0pO1xuICAgICAgaWYgKHRoaXMucGlja1Byb2dyYW0pIHtcbiAgICAgICAga2lsbFByb2dyYW0odGhpcy5waWNrUHJvZ3JhbSk7XG4gICAgICAgIHRoaXMucGlja1Byb2dyYW0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQcm9ncmFtSW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9ncmFtSW5mbyhuYW1lLCBnbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSwgZnJhbWVCdWZmZXIpIHtcbiAgICAgIHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oKTtcblxuICAgICAgLy8gV2ViR0wgYnVmZmVyc1xuICAgICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgaWYgKGJ1ZmZlciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbTogZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIFdlYkdMIGJ1ZmZlci5cIik7XG5cbiAgICAgIC8vIFNoYWRlcnMgYW5kIHByb2dyYW1cbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBsb2FkVmVydGV4U2hhZGVyKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gbG9hZEZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgICB2YXIgcHJvZ3JhbSA9IGxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICAvLyBJbml0aWFsaXppbmcgbG9jYXRpb25zXG4gICAgICB2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IHt9O1xuICAgICAgZGVmLlVOSUZPUk1TLmZvckVhY2goZnVuY3Rpb24gKHVuaWZvcm1OYW1lKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgICAgIGlmIChsb2NhdGlvbikgdW5pZm9ybUxvY2F0aW9uc1t1bmlmb3JtTmFtZV0gPSBsb2NhdGlvbjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGF0dHJpYnV0ZUxvY2F0aW9ucyA9IHt9O1xuICAgICAgZGVmLkFUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICBhdHRyaWJ1dGVMb2NhdGlvbnNbYXR0ci5uYW1lXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHIubmFtZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRm9yIGluc3RhbmNlZCBwcm9ncmFtczpcbiAgICAgIHZhciBjb25zdGFudEJ1ZmZlcjtcbiAgICAgIGlmIChcIkNPTlNUQU5UX0FUVFJJQlVURVNcIiBpbiBkZWYpIHtcbiAgICAgICAgZGVmLkNPTlNUQU5UX0FUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyLm5hbWVdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0ci5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0YW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGlmIChjb25zdGFudEJ1ZmZlciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbTogZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIFdlYkdMIGNvbnN0YW50IGJ1ZmZlci5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgICBnbDogZ2wsXG4gICAgICAgIGZyYW1lQnVmZmVyOiBmcmFtZUJ1ZmZlcixcbiAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgIGNvbnN0YW50QnVmZmVyOiBjb25zdGFudEJ1ZmZlciB8fCB7fSxcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uczogdW5pZm9ybUxvY2F0aW9ucyxcbiAgICAgICAgYXR0cmlidXRlTG9jYXRpb25zOiBhdHRyaWJ1dGVMb2NhdGlvbnMsXG4gICAgICAgIGlzUGlja2luZzogbmFtZSA9PT0gXCJwaWNrXCIsXG4gICAgICAgIHZlcnRleFNoYWRlcjogdmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnRTaGFkZXJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmRQcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRQcm9ncmFtKHByb2dyYW0pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBnbCA9IHByb2dyYW0uZ2wsXG4gICAgICAgIGJ1ZmZlciA9IHByb2dyYW0uYnVmZmVyO1xuICAgICAgaWYgKCF0aGlzLmlzSW5zdGFuY2VkKSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLkFUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBvZmZzZXQgKz0gX3RoaXMuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCBvZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYXJyYXksIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgY29uc3RhbnQgZGF0YSAodGhpbmdzIHRoYXQgcmVtYWluIHVuY2hhbmdlZCBmb3IgYWxsIGl0ZW1zKTpcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHByb2dyYW0uY29uc3RhbnRCdWZmZXIpO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLkNPTlNUQU5UX0FUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBvZmZzZXQgKz0gX3RoaXMuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCBvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNvbnN0YW50QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICAvLyBIYW5kbGUgXCJpbnN0YW5jZSBzcGVjaWZpY1wiIGRhdGEgKHRoaW5ncyB0aGF0IHZhcnkgZm9yIGVhY2ggaXRlbSk6XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwcm9ncmFtLmJ1ZmZlcik7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldCArPSBfdGhpcy5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hcnJheSwgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICAgIH1cbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRQcm9ncmFtKHByb2dyYW0pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmlzSW5zdGFuY2VkKSB7XG4gICAgICAgIHRoaXMuQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi51bmJpbmRBdHRyaWJ1dGUoYXR0ciwgcHJvZ3JhbSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5DT05TVEFOVF9BVFRSSUJVVEVTLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnVuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLkFUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIudW5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIG9mZnNldCwgc2V0RGl2aXNvcikge1xuICAgICAgdmFyIHNpemVGYWN0b3IgPSBTSVpFX0ZBQ1RPUl9QRVJfQVRUUklCVVRFX1RZUEVbYXR0ci50eXBlXTtcbiAgICAgIGlmICh0eXBlb2Ygc2l6ZUZhY3RvciAhPT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbS5iaW5kOiB5ZXQgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGUgXFxcIlwiLmNvbmNhdChhdHRyLnR5cGUsIFwiXFxcIlwiKSk7XG4gICAgICB2YXIgbG9jYXRpb24gPSBwcm9ncmFtLmF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyLm5hbWVdO1xuICAgICAgdmFyIGdsID0gcHJvZ3JhbS5nbDtcbiAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICB2YXIgc3RyaWRlID0gIXRoaXMuaXNJbnN0YW5jZWQgPyB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAoc2V0RGl2aXNvciA/IHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVCA6IGdldEF0dHJpYnV0ZXNJdGVtc0NvdW50KHRoaXMuQ09OU1RBTlRfQVRUUklCVVRFUykpICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBhdHRyLnNpemUsIGF0dHIudHlwZSwgYXR0ci5ub3JtYWxpemVkIHx8IGZhbHNlLCBzdHJpZGUsIG9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zdGFuY2VkICYmIHNldERpdmlzb3IpIHtcbiAgICAgICAgICBpZiAoZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGxvY2F0aW9uLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIik7XG4gICAgICAgICAgICBpZiAoZXh0KSBleHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGxvY2F0aW9uLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyLnNpemUgKiBzaXplRmFjdG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIHVuc2V0RGl2aXNvcikge1xuICAgICAgdmFyIGxvY2F0aW9uID0gcHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnNbYXR0ci5uYW1lXTtcbiAgICAgIHZhciBnbCA9IHByb2dyYW0uZ2w7XG4gICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zdGFuY2VkICYmIHVuc2V0RGl2aXNvcikge1xuICAgICAgICAgIGlmIChnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IobG9jYXRpb24sIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKTtcbiAgICAgICAgICAgIGlmIChleHQpIGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUobG9jYXRpb24sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWFsbG9jYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWxsb2NhdGUoY2FwYWNpdHkpIHtcbiAgICAgIC8vIElmIGRlc2lyZWQgY2FwYWNpdHkgaGFzIG5vdCBjaGFuZ2VkIHdlIGRvIG5vdGhpbmdcbiAgICAgIC8vIE5PVEU6IGl0J3MgcG9zc2libGUgaGVyZSB0byBpbXBsZW1lbnQgbW9yZSBzdWJ0bGUgcmVhbGxvY2F0aW9uIHNjaGVtZXNcbiAgICAgIC8vIHdoZW4gdGhlIG51bWJlciBvZiByZW5kZXJlZCBpdGVtcyBpbmNyZWFzZSBvciBkZWNyZWFzZVxuICAgICAgaWYgKGNhcGFjaXR5ID09PSB0aGlzLmNhcGFjaXR5KSByZXR1cm47XG4gICAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICB0aGlzLnZlcnRpY2VzQ291bnQgPSB0aGlzLlZFUlRJQ0VTICogY2FwYWNpdHk7XG4gICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSghdGhpcy5pc0luc3RhbmNlZCA/IHRoaXMudmVydGljZXNDb3VudCAqIHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVCA6IHRoaXMuY2FwYWNpdHkgKiB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNOb3RoaW5nVG9SZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzTm90aGluZ1RvUmVuZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmVydGljZXNDb3VudCA9PT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJQcm9ncmFtKHBhcmFtcywgcHJvZ3JhbUluZm8pIHtcbiAgICAgIHZhciBnbCA9IHByb2dyYW1JbmZvLmdsLFxuICAgICAgICBwcm9ncmFtID0gcHJvZ3JhbUluZm8ucHJvZ3JhbTtcblxuICAgICAgLy8gV2l0aCB0aGUgY3VycmVudCBmaXggZm9yICMxMzk3LCB0aGUgYWxwaGEgYmxlbmRpbmcgaXMgZW5hYmxlZCBmb3IgdGhlXG4gICAgICAvLyBwaWNraW5nIGxheWVyOlxuICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcblxuICAgICAgLy8gT3JpZ2luYWwgY29kZTpcbiAgICAgIC8vIGlmICghaXNQaWNraW5nKSBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgLy8gZWxzZSBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybXMocGFyYW1zLCBwcm9ncmFtSW5mbyk7XG4gICAgICB0aGlzLmRyYXdXZWJHTCh0aGlzLk1FVEhPRCwgcHJvZ3JhbUluZm8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcmFtcykge1xuICAgICAgaWYgKHRoaXMuaGFzTm90aGluZ1RvUmVuZGVyKCkpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnBpY2tQcm9ncmFtKSB7XG4gICAgICAgIHRoaXMucGlja1Byb2dyYW0uZ2wudmlld3BvcnQoMCwgMCwgcGFyYW1zLndpZHRoICogcGFyYW1zLnBpeGVsUmF0aW8gLyBwYXJhbXMuZG93blNpemluZ1JhdGlvLCBwYXJhbXMuaGVpZ2h0ICogcGFyYW1zLnBpeGVsUmF0aW8gLyBwYXJhbXMuZG93blNpemluZ1JhdGlvKTtcbiAgICAgICAgdGhpcy5iaW5kUHJvZ3JhbSh0aGlzLnBpY2tQcm9ncmFtKTtcbiAgICAgICAgdGhpcy5yZW5kZXJQcm9ncmFtKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgICAgIHBpeGVsUmF0aW86IHBhcmFtcy5waXhlbFJhdGlvIC8gcGFyYW1zLmRvd25TaXppbmdSYXRpb1xuICAgICAgICB9KSwgdGhpcy5waWNrUHJvZ3JhbSk7XG4gICAgICAgIHRoaXMudW5iaW5kUHJvZ3JhbSh0aGlzLnBpY2tQcm9ncmFtKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm9ybWFsUHJvZ3JhbS5nbC52aWV3cG9ydCgwLCAwLCBwYXJhbXMud2lkdGggKiBwYXJhbXMucGl4ZWxSYXRpbywgcGFyYW1zLmhlaWdodCAqIHBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAgIHRoaXMuYmluZFByb2dyYW0odGhpcy5ub3JtYWxQcm9ncmFtKTtcbiAgICAgIHRoaXMucmVuZGVyUHJvZ3JhbShwYXJhbXMsIHRoaXMubm9ybWFsUHJvZ3JhbSk7XG4gICAgICB0aGlzLnVuYmluZFByb2dyYW0odGhpcy5ub3JtYWxQcm9ncmFtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1dlYkdMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdXZWJHTChtZXRob2QsIF9yZWYpIHtcbiAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgIGZyYW1lQnVmZmVyID0gX3JlZi5mcmFtZUJ1ZmZlcjtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgICAgaWYgKCF0aGlzLmlzSW5zdGFuY2VkKSB7XG4gICAgICAgIGdsLmRyYXdBcnJheXMobWV0aG9kLCAwLCB0aGlzLnZlcnRpY2VzQ291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQobWV0aG9kLCAwLCB0aGlzLlZFUlRJQ0VTLCB0aGlzLmNhcGFjaXR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKTtcbiAgICAgICAgICBpZiAoZXh0KSBleHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKG1ldGhvZCwgMCwgdGhpcy5WRVJUSUNFUywgdGhpcy5jYXBhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIEFic3RyYWN0Tm9kZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdFByb2dyYW0pIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3ROb2RlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJzdHJhY3ROb2RlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgQWJzdHJhY3ROb2RlUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoQWJzdHJhY3ROb2RlUHJvZ3JhbSwgX0Fic3RyYWN0UHJvZ3JhbSk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQWJzdHJhY3ROb2RlUHJvZ3JhbSk7XG59KEFic3RyYWN0UHJvZ3JhbSk7XG52YXIgTm9kZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9yZWYpIHtcbiAgZnVuY3Rpb24gTm9kZVByb2dyYW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBOb2RlUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoTm9kZVByb2dyYW0sIF9yZWYpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE5vZGVQcm9ncmFtLCBbe1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICBfc3VwZXJQcm9wR2V0KE5vZGVQcm9ncmFtLCBcImtpbGxcIiwgdGhpcywgMykoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3Mobm9kZUluZGV4LCBvZmZzZXQsIGRhdGEpIHtcbiAgICAgIHZhciBpID0gb2Zmc2V0ICogdGhpcy5TVFJJREU7XG4gICAgICAvLyBOT1RFOiBkZWFsaW5nIHdpdGggaGlkZGVuIGl0ZW1zIGF1dG9tYXRpY2FsbHlcbiAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICBmb3IgKHZhciBsID0gaSArIHRoaXMuU1RSSURFOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hcnJheVtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Zpc2libGVJdGVtKGluZGV4VG9Db2xvcihub2RlSW5kZXgpLCBpLCBkYXRhKTtcbiAgICB9XG4gIH1dKTtcbn0oUHJvZ3JhbSk7XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBjb21iaW5pbmcgdHdvIG9yIG1vcmUgcHJvZ3JhbXMgaW50byBhIHNpbmdsZSBjb21wb3VuZCBvbmUuXG4gKiBOb3RlIHRoYXQgdGhpcyBpcyBtb3JlIGEgcXVpY2sgJiBlYXN5IHdheSB0byBjb21iaW5lIHByb2dyYW0gdGhhbiBhIHJlYWxseVxuICogcGVyZm9ybWFudCBvcHRpb24uIE1vcmUgcGVyZm9ybWFudCBwcm9ncmFtcyBjYW4gYmUgd3JpdHRlbiBlbnRpcmVseS5cbiAqXG4gKiBAcGFyYW0gIHthcnJheX0gICAgcHJvZ3JhbUNsYXNzZXMgLSBQcm9ncmFtIGNsYXNzZXMgdG8gY29tYmluZS5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBkcmF3TGFiZWwgLSBBbiBvcHRpb25hbCBub2RlIFwiZHJhdyBsYWJlbFwiIGZ1bmN0aW9uLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGRyYXdIb3ZlciAtIEFuIG9wdGlvbmFsIG5vZGUgXCJkcmF3IGhvdmVyXCIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZUNvbXBvdW5kUHJvZ3JhbShwcm9ncmFtQ2xhc3NlcywgZHJhd0xhYmVsLCBkcmF3SG92ZXIpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZUNvbXBvdW5kUHJvZ3JhbShnbCwgcGlja2luZ0J1ZmZlciwgcmVuZGVyZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlQ29tcG91bmRQcm9ncmFtKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYXdMYWJlbFwiLCBkcmF3TGFiZWwpO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhd0hvdmVyXCIsIGRyYXdIb3Zlcik7XG4gICAgICB0aGlzLnByb2dyYW1zID0gcHJvZ3JhbUNsYXNzZXMubWFwKGZ1bmN0aW9uIChQcm9ncmFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvZ3JhbShnbCwgcGlja2luZ0J1ZmZlciwgcmVuZGVyZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoTm9kZUNvbXBvdW5kUHJvZ3JhbSwgW3tcbiAgICAgIGtleTogXCJyZWFsbG9jYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVhbGxvY2F0ZShjYXBhY2l0eSkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5yZWFsbG9jYXRlKGNhcGFjaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKG5vZGVJbmRleCwgb2Zmc2V0LCBkYXRhKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLnByb2Nlc3Mobm9kZUluZGV4LCBvZmZzZXQsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcmFtcykge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5yZW5kZXIocGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImtpbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5raWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpO1xufVxuXG52YXIgQWJzdHJhY3RFZGdlUHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0UHJvZ3JhbSkge1xuICBmdW5jdGlvbiBBYnN0cmFjdEVkZ2VQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdEVkZ2VQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBBYnN0cmFjdEVkZ2VQcm9ncmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhBYnN0cmFjdEVkZ2VQcm9ncmFtLCBfQWJzdHJhY3RQcm9ncmFtKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBYnN0cmFjdEVkZ2VQcm9ncmFtKTtcbn0oQWJzdHJhY3RQcm9ncmFtKTtcbnZhciBFZGdlUHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3JlZikge1xuICBmdW5jdGlvbiBFZGdlUHJvZ3JhbSgpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VQcm9ncmFtKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBFZGdlUHJvZ3JhbSwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZHJhd0xhYmVsXCIsIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhFZGdlUHJvZ3JhbSwgX3JlZik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRWRnZVByb2dyYW0sIFt7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIF9zdXBlclByb3BHZXQoRWRnZVByb2dyYW0sIFwia2lsbFwiLCB0aGlzLCAzKShbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2VzcyhlZGdlSW5kZXgsIG9mZnNldCwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSkge1xuICAgICAgdmFyIGkgPSBvZmZzZXQgKiB0aGlzLlNUUklERTtcbiAgICAgIC8vIE5PVEU6IGRlYWxpbmcgd2l0aCBoaWRkZW4gaXRlbXMgYXV0b21hdGljYWxseVxuICAgICAgaWYgKGRhdGEuaGlkZGVuIHx8IHNvdXJjZURhdGEuaGlkZGVuIHx8IHRhcmdldERhdGEuaGlkZGVuKSB7XG4gICAgICAgIGZvciAodmFyIGwgPSBpICsgdGhpcy5TVFJJREU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmFycmF5W2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzVmlzaWJsZUl0ZW0oaW5kZXhUb0NvbG9yKGVkZ2VJbmRleCksIGksIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpO1xuICAgIH1cbiAgfV0pO1xufShQcm9ncmFtKTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGNvbWJpbmluZyB0d28gb3IgbW9yZSBwcm9ncmFtcyBpbnRvIGEgc2luZ2xlIGNvbXBvdW5kIG9uZS5cbiAqIE5vdGUgdGhhdCB0aGlzIGlzIG1vcmUgYSBxdWljayAmIGVhc3kgd2F5IHRvIGNvbWJpbmUgcHJvZ3JhbSB0aGFuIGEgcmVhbGx5XG4gKiBwZXJmb3JtYW50IG9wdGlvbi4gTW9yZSBwZXJmb3JtYW50IHByb2dyYW1zIGNhbiBiZSB3cml0dGVuIGVudGlyZWx5LlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSAgICBwcm9ncmFtQ2xhc3NlcyAtIFByb2dyYW0gY2xhc3NlcyB0byBjb21iaW5lLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGRyYXdMYWJlbCAtIEFuIG9wdGlvbmFsIGVkZ2UgXCJkcmF3IGxhYmVsXCIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUNvbXBvdW5kUHJvZ3JhbShwcm9ncmFtQ2xhc3NlcywgZHJhd0xhYmVsKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVkZ2VDb21wb3VuZFByb2dyYW0oZ2wsIHBpY2tpbmdCdWZmZXIsIHJlbmRlcmVyKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZUNvbXBvdW5kUHJvZ3JhbSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmF3TGFiZWxcIiwgZHJhd0xhYmVsKTtcbiAgICAgIHRoaXMucHJvZ3JhbXMgPSBwcm9ncmFtQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKFByb2dyYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9ncmFtKGdsLCBwaWNraW5nQnVmZmVyLCByZW5kZXJlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFZGdlQ29tcG91bmRQcm9ncmFtLCBbe1xuICAgICAga2V5OiBcInJlYWxsb2NhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWFsbG9jYXRlKGNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLnJlYWxsb2NhdGUoY2FwYWNpdHkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3MoZWRnZUluZGV4LCBvZmZzZXQsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ucHJvY2VzcyhlZGdlSW5kZXgsIG9mZnNldCwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFyYW1zKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLnJlbmRlcihwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwia2lsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLmtpbGwoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdTdHJhaWdodEVkZ2VMYWJlbChjb250ZXh0LCBlZGdlRGF0YSwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgc2V0dGluZ3MpIHtcbiAgdmFyIHNpemUgPSBzZXR0aW5ncy5lZGdlTGFiZWxTaXplLFxuICAgIGZvbnQgPSBzZXR0aW5ncy5lZGdlTGFiZWxGb250LFxuICAgIHdlaWdodCA9IHNldHRpbmdzLmVkZ2VMYWJlbFdlaWdodCxcbiAgICBjb2xvciA9IHNldHRpbmdzLmVkZ2VMYWJlbENvbG9yLmF0dHJpYnV0ZSA/IGVkZ2VEYXRhW3NldHRpbmdzLmVkZ2VMYWJlbENvbG9yLmF0dHJpYnV0ZV0gfHwgc2V0dGluZ3MuZWRnZUxhYmVsQ29sb3IuY29sb3IgfHwgXCIjMDAwXCIgOiBzZXR0aW5ncy5lZGdlTGFiZWxDb2xvci5jb2xvcjtcbiAgdmFyIGxhYmVsID0gZWRnZURhdGEubGFiZWw7XG4gIGlmICghbGFiZWwpIHJldHVybjtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgY29udGV4dC5mb250ID0gXCJcIi5jb25jYXQod2VpZ2h0LCBcIiBcIikuY29uY2F0KHNpemUsIFwicHggXCIpLmNvbmNhdChmb250KTtcblxuICAvLyBDb21wdXRpbmcgcG9zaXRpb25zIHdpdGhvdXQgY29uc2lkZXJpbmcgbm9kZXMgc2l6ZXM6XG4gIHZhciBzU2l6ZSA9IHNvdXJjZURhdGEuc2l6ZTtcbiAgdmFyIHRTaXplID0gdGFyZ2V0RGF0YS5zaXplO1xuICB2YXIgc3ggPSBzb3VyY2VEYXRhLng7XG4gIHZhciBzeSA9IHNvdXJjZURhdGEueTtcbiAgdmFyIHR4ID0gdGFyZ2V0RGF0YS54O1xuICB2YXIgdHkgPSB0YXJnZXREYXRhLnk7XG4gIHZhciBjeCA9IChzeCArIHR4KSAvIDI7XG4gIHZhciBjeSA9IChzeSArIHR5KSAvIDI7XG4gIHZhciBkeCA9IHR4IC0gc3g7XG4gIHZhciBkeSA9IHR5IC0gc3k7XG4gIHZhciBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgaWYgKGQgPCBzU2l6ZSArIHRTaXplKSByZXR1cm47XG5cbiAgLy8gQWRkaW5nIG5vZGVzIHNpemVzOlxuICBzeCArPSBkeCAqIHNTaXplIC8gZDtcbiAgc3kgKz0gZHkgKiBzU2l6ZSAvIGQ7XG4gIHR4IC09IGR4ICogdFNpemUgLyBkO1xuICB0eSAtPSBkeSAqIHRTaXplIC8gZDtcbiAgY3ggPSAoc3ggKyB0eCkgLyAyO1xuICBjeSA9IChzeSArIHR5KSAvIDI7XG4gIGR4ID0gdHggLSBzeDtcbiAgZHkgPSB0eSAtIHN5O1xuICBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAvLyBIYW5kbGluZyBlbGxpcHNpc1xuICB2YXIgdGV4dExlbmd0aCA9IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICBpZiAodGV4dExlbmd0aCA+IGQpIHtcbiAgICB2YXIgZWxsaXBzaXMgPSBcIuKAplwiO1xuICAgIGxhYmVsID0gbGFiZWwgKyBlbGxpcHNpcztcbiAgICB0ZXh0TGVuZ3RoID0gY29udGV4dC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgd2hpbGUgKHRleHRMZW5ndGggPiBkICYmIGxhYmVsLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxhYmVsID0gbGFiZWwuc2xpY2UoMCwgLTIpICsgZWxsaXBzaXM7XG4gICAgICB0ZXh0TGVuZ3RoID0gY29udGV4dC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgfVxuICAgIGlmIChsYWJlbC5sZW5ndGggPCA0KSByZXR1cm47XG4gIH1cbiAgdmFyIGFuZ2xlO1xuICBpZiAoZHggPiAwKSB7XG4gICAgaWYgKGR5ID4gMCkgYW5nbGUgPSBNYXRoLmFjb3MoZHggLyBkKTtlbHNlIGFuZ2xlID0gTWF0aC5hc2luKGR5IC8gZCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGR5ID4gMCkgYW5nbGUgPSBNYXRoLmFjb3MoZHggLyBkKSArIE1hdGguUEk7ZWxzZSBhbmdsZSA9IE1hdGguYXNpbihkeCAvIGQpICsgTWF0aC5QSSAvIDI7XG4gIH1cbiAgY29udGV4dC5zYXZlKCk7XG4gIGNvbnRleHQudHJhbnNsYXRlKGN4LCBjeSk7XG4gIGNvbnRleHQucm90YXRlKGFuZ2xlKTtcbiAgY29udGV4dC5maWxsVGV4dChsYWJlbCwgLXRleHRMZW5ndGggLyAyLCBlZGdlRGF0YS5zaXplIC8gMiArIHNpemUpO1xuICBjb250ZXh0LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gZHJhd0Rpc2NOb2RlTGFiZWwoY29udGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgaWYgKCFkYXRhLmxhYmVsKSByZXR1cm47XG4gIHZhciBzaXplID0gc2V0dGluZ3MubGFiZWxTaXplLFxuICAgIGZvbnQgPSBzZXR0aW5ncy5sYWJlbEZvbnQsXG4gICAgd2VpZ2h0ID0gc2V0dGluZ3MubGFiZWxXZWlnaHQsXG4gICAgY29sb3IgPSBzZXR0aW5ncy5sYWJlbENvbG9yLmF0dHJpYnV0ZSA/IGRhdGFbc2V0dGluZ3MubGFiZWxDb2xvci5hdHRyaWJ1dGVdIHx8IHNldHRpbmdzLmxhYmVsQ29sb3IuY29sb3IgfHwgXCIjMDAwXCIgOiBzZXR0aW5ncy5sYWJlbENvbG9yLmNvbG9yO1xuICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICBjb250ZXh0LmZvbnQgPSBcIlwiLmNvbmNhdCh3ZWlnaHQsIFwiIFwiKS5jb25jYXQoc2l6ZSwgXCJweCBcIikuY29uY2F0KGZvbnQpO1xuICBjb250ZXh0LmZpbGxUZXh0KGRhdGEubGFiZWwsIGRhdGEueCArIGRhdGEuc2l6ZSArIDMsIGRhdGEueSArIHNpemUgLyAzKTtcbn1cblxuLyoqXG4gKiBEcmF3IGFuIGhvdmVyZWQgbm9kZS5cbiAqIC0gaWYgdGhlcmUgaXMgbm8gbGFiZWwgPT4gZGlzcGxheSBhIHNoYWRvdyBvbiB0aGUgbm9kZVxuICogLSBpZiB0aGUgbGFiZWwgYm94IGlzIGJpZ2dlciB0aGFuIG5vZGUgc2l6ZSA9PiBkaXNwbGF5IGEgbGFiZWwgYm94IHRoYXQgY29udGFpbnMgdGhlIG5vZGUgd2l0aCBhIHNoYWRvd1xuICogLSBlbHNlIG5vZGUgd2l0aCBzaGFkb3cgYW5kIHRoZSBsYWJlbCBib3hcbiAqL1xuZnVuY3Rpb24gZHJhd0Rpc2NOb2RlSG92ZXIoY29udGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgdmFyIHNpemUgPSBzZXR0aW5ncy5sYWJlbFNpemUsXG4gICAgZm9udCA9IHNldHRpbmdzLmxhYmVsRm9udCxcbiAgICB3ZWlnaHQgPSBzZXR0aW5ncy5sYWJlbFdlaWdodDtcbiAgY29udGV4dC5mb250ID0gXCJcIi5jb25jYXQod2VpZ2h0LCBcIiBcIikuY29uY2F0KHNpemUsIFwicHggXCIpLmNvbmNhdChmb250KTtcblxuICAvLyBUaGVuIHdlIGRyYXcgdGhlIGxhYmVsIGJhY2tncm91bmRcbiAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNGRkZcIjtcbiAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgY29udGV4dC5zaGFkb3dCbHVyID0gODtcbiAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwiIzAwMFwiO1xuICB2YXIgUEFERElORyA9IDI7XG4gIGlmICh0eXBlb2YgZGF0YS5sYWJlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhciB0ZXh0V2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGRhdGEubGFiZWwpLndpZHRoLFxuICAgICAgYm94V2lkdGggPSBNYXRoLnJvdW5kKHRleHRXaWR0aCArIDUpLFxuICAgICAgYm94SGVpZ2h0ID0gTWF0aC5yb3VuZChzaXplICsgMiAqIFBBRERJTkcpLFxuICAgICAgcmFkaXVzID0gTWF0aC5tYXgoZGF0YS5zaXplLCBzaXplIC8gMikgKyBQQURESU5HO1xuICAgIHZhciBhbmdsZVJhZGlhbiA9IE1hdGguYXNpbihib3hIZWlnaHQgLyAyIC8gcmFkaXVzKTtcbiAgICB2YXIgeERlbHRhQ29vcmQgPSBNYXRoLnNxcnQoTWF0aC5hYnMoTWF0aC5wb3cocmFkaXVzLCAyKSAtIE1hdGgucG93KGJveEhlaWdodCAvIDIsIDIpKSk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhkYXRhLnggKyB4RGVsdGFDb29yZCwgZGF0YS55ICsgYm94SGVpZ2h0IC8gMik7XG4gICAgY29udGV4dC5saW5lVG8oZGF0YS54ICsgcmFkaXVzICsgYm94V2lkdGgsIGRhdGEueSArIGJveEhlaWdodCAvIDIpO1xuICAgIGNvbnRleHQubGluZVRvKGRhdGEueCArIHJhZGl1cyArIGJveFdpZHRoLCBkYXRhLnkgLSBib3hIZWlnaHQgLyAyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhkYXRhLnggKyB4RGVsdGFDb29yZCwgZGF0YS55IC0gYm94SGVpZ2h0IC8gMik7XG4gICAgY29udGV4dC5hcmMoZGF0YS54LCBkYXRhLnksIHJhZGl1cywgYW5nbGVSYWRpYW4sIC1hbmdsZVJhZGlhbik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQuYXJjKGRhdGEueCwgZGF0YS55LCBkYXRhLnNpemUgKyBQQURESU5HLCAwLCBNYXRoLlBJICogMik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxuICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xuICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuXG4gIC8vIEFuZCBmaW5hbGx5IHdlIGRyYXcgdGhlIGxhYmVsXG4gIGRyYXdEaXNjTm9kZUxhYmVsKGNvbnRleHQsIGRhdGEsIHNldHRpbmdzKTtcbn1cblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UkNiA9IC8qZ2xzbCovXCJcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfZGlmZlZlY3RvcjtcXG52YXJ5aW5nIGZsb2F0IHZfcmFkaXVzO1xcblxcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxuXFxuY29uc3QgdmVjNCB0cmFuc3BhcmVudCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZmxvYXQgYm9yZGVyID0gdV9jb3JyZWN0aW9uUmF0aW8gKiAyLjA7XFxuICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZfZGlmZlZlY3RvcikgLSB2X3JhZGl1cyArIGJvcmRlcjtcXG5cXG4gIC8vIE5vIGFudGlhbGlhc2luZyBmb3IgcGlja2luZyBtb2RlOlxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgaWYgKGRpc3QgPiBib3JkZXIpXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRyYW5zcGFyZW50O1xcbiAgZWxzZVxcbiAgICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xcblxcbiAgI2Vsc2VcXG4gIGZsb2F0IHQgPSAwLjA7XFxuICBpZiAoZGlzdCA+IGJvcmRlcilcXG4gICAgdCA9IDEuMDtcXG4gIGVsc2UgaWYgKGRpc3QgPiAwLjApXFxuICAgIHQgPSBkaXN0IC8gYm9yZGVyO1xcblxcbiAgZ2xfRnJhZ0NvbG9yID0gbWl4KHZfY29sb3IsIHRyYW5zcGFyZW50LCB0KTtcXG4gICNlbmRpZlxcbn1cXG5cIjtcbnZhciBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDIgPSBTSEFERVJfU09VUkNFJDY7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFJDUgPSAvKmdsc2wqL1wiXFxuYXR0cmlidXRlIHZlYzQgYV9pZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIGZsb2F0IGFfc2l6ZTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9hbmdsZTtcXG5cXG51bmlmb3JtIG1hdDMgdV9tYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3NpemVSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfY29ycmVjdGlvblJhdGlvO1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X2RpZmZWZWN0b3I7XFxudmFyeWluZyBmbG9hdCB2X3JhZGl1cztcXG52YXJ5aW5nIGZsb2F0IHZfYm9yZGVyO1xcblxcbmNvbnN0IGZsb2F0IGJpYXMgPSAyNTUuMCAvIDI1NC4wO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGZsb2F0IHNpemUgPSBhX3NpemUgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfc2l6ZVJhdGlvICogNC4wO1xcbiAgdmVjMiBkaWZmVmVjdG9yID0gc2l6ZSAqIHZlYzIoY29zKGFfYW5nbGUpLCBzaW4oYV9hbmdsZSkpO1xcbiAgdmVjMiBwb3NpdGlvbiA9IGFfcG9zaXRpb24gKyBkaWZmVmVjdG9yO1xcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KFxcbiAgICAodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxKSkueHksXFxuICAgIDAsXFxuICAgIDFcXG4gICk7XFxuXFxuICB2X2RpZmZWZWN0b3IgPSBkaWZmVmVjdG9yO1xcbiAgdl9yYWRpdXMgPSBzaXplIC8gMi4wO1xcblxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgLy8gRm9yIHBpY2tpbmcgbW9kZSwgd2UgdXNlIHRoZSBJRCBhcyB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9pZDtcXG4gICNlbHNlXFxuICAvLyBGb3Igbm9ybWFsIG1vZGUsIHdlIHVzZSB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcblxcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiO1xudmFyIFZFUlRFWF9TSEFERVJfU09VUkNFJDMgPSBTSEFERVJfU09VUkNFJDU7XG5cbnZhciBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMyA9IFdlYkdMUmVuZGVyaW5nQ29udGV4dCxcbiAgVU5TSUdORURfQllURSQzID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4JDMuVU5TSUdORURfQllURSxcbiAgRkxPQVQkMyA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQzLkZMT0FUO1xudmFyIFVOSUZPUk1TJDMgPSBbXCJ1X3NpemVSYXRpb1wiLCBcInVfY29ycmVjdGlvblJhdGlvXCIsIFwidV9tYXRyaXhcIl07XG52YXIgTm9kZUNpcmNsZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlUHJvZ3JhbSkge1xuICBmdW5jdGlvbiBOb2RlQ2lyY2xlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUNpcmNsZVByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIE5vZGVDaXJjbGVQcm9ncmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhOb2RlQ2lyY2xlUHJvZ3JhbSwgX05vZGVQcm9ncmFtKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhOb2RlQ2lyY2xlUHJvZ3JhbSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgVkVSVElDRVM6IDMsXG4gICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSQzLFxuICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDIsXG4gICAgICAgIE1FVEhPRDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUyxcbiAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TJDMsXG4gICAgICAgIEFUVFJJQlVURVM6IFt7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uXCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVCQzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfc2l6ZVwiLFxuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogRkxPQVQkM1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDMsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2lkXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDMsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgQ09OU1RBTlRfQVRUUklCVVRFUzogW3tcbiAgICAgICAgICBuYW1lOiBcImFfYW5nbGVcIixcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHR5cGU6IEZMT0FUJDNcbiAgICAgICAgfV0sXG4gICAgICAgIENPTlNUQU5UX0RBVEE6IFtbTm9kZUNpcmNsZVByb2dyYW0uQU5HTEVfMV0sIFtOb2RlQ2lyY2xlUHJvZ3JhbS5BTkdMRV8yXSwgW05vZGVDaXJjbGVQcm9ncmFtLkFOR0xFXzNdXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1Zpc2libGVJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShub2RlSW5kZXgsIHN0YXJ0SW5kZXgsIGRhdGEpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICB2YXIgY29sb3IgPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGRhdGEueDtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBkYXRhLnk7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZGF0YS5zaXplO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGNvbG9yO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IG5vZGVJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybXMocGFyYW1zLCBfcmVmKSB7XG4gICAgICB2YXIgZ2wgPSBfcmVmLmdsLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zID0gX3JlZi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgdmFyIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgdV9jb3JyZWN0aW9uUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfY29ycmVjdGlvblJhdGlvLFxuICAgICAgICB1X21hdHJpeCA9IHVuaWZvcm1Mb2NhdGlvbnMudV9tYXRyaXg7XG4gICAgICBnbC51bmlmb3JtMWYodV9jb3JyZWN0aW9uUmF0aW8sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfc2l6ZVJhdGlvLCBwYXJhbXMuc2l6ZVJhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodV9tYXRyaXgsIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICB9XG4gIH1dKTtcbn0oTm9kZVByb2dyYW0pO1xuX2RlZmluZVByb3BlcnR5KE5vZGVDaXJjbGVQcm9ncmFtLCBcIkFOR0xFXzFcIiwgMCk7XG5fZGVmaW5lUHJvcGVydHkoTm9kZUNpcmNsZVByb2dyYW0sIFwiQU5HTEVfMlwiLCAyICogTWF0aC5QSSAvIDMpO1xuX2RlZmluZVByb3BlcnR5KE5vZGVDaXJjbGVQcm9ncmFtLCBcIkFOR0xFXzNcIiwgNCAqIE1hdGguUEkgLyAzKTtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UkNCA9IC8qZ2xzbCovXCJcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcXG59XFxuXCI7XG52YXIgRlJBR01FTlRfU0hBREVSX1NPVVJDRSQxID0gU0hBREVSX1NPVVJDRSQ0O1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQzID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV9ub3JtYWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFkaXVzO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfYmFyeWNlbnRyaWM7XFxuXFxuI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuI2Vsc2VcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X21pbkVkZ2VUaGlja25lc3M7XFxudW5pZm9ybSBmbG9hdCB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X3dpZGVuZXNzVG9UaGlja25lc3NSYXRpbztcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBmbG9hdCBtaW5UaGlja25lc3MgPSB1X21pbkVkZ2VUaGlja25lc3M7XFxuXFxuICBmbG9hdCBub3JtYWxMZW5ndGggPSBsZW5ndGgoYV9ub3JtYWwpO1xcbiAgdmVjMiB1bml0Tm9ybWFsID0gYV9ub3JtYWwgLyBub3JtYWxMZW5ndGg7XFxuXFxuICAvLyBUaGVzZSBmaXJzdCBjb21wdXRhdGlvbnMgYXJlIHRha2VuIGZyb20gZWRnZS52ZXJ0Lmdsc2wgYW5kXFxuICAvLyBlZGdlLmNsYW1wZWQudmVydC5nbHNsLiBQbGVhc2UgcmVhZCBpdCB0byBnZXQgYmV0dGVyIGNvbW1lbnRzIG9uIHdoYXQnc1xcbiAgLy8gaGFwcGVuaW5nOlxcbiAgZmxvYXQgcGl4ZWxzVGhpY2tuZXNzID0gbWF4KG5vcm1hbExlbmd0aCAvIHVfc2l6ZVJhdGlvLCBtaW5UaGlja25lc3MpO1xcbiAgZmxvYXQgd2ViR0xUaGlja25lc3MgPSBwaXhlbHNUaGlja25lc3MgKiB1X2NvcnJlY3Rpb25SYXRpbztcXG4gIGZsb2F0IHdlYkdMTm9kZVJhZGl1cyA9IGFfcmFkaXVzICogMi4wICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG4gIGZsb2F0IHdlYkdMQXJyb3dIZWFkTGVuZ3RoID0gd2ViR0xUaGlja25lc3MgKiB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8gKiAyLjA7XFxuICBmbG9hdCB3ZWJHTEFycm93SGVhZFRoaWNrbmVzcyA9IHdlYkdMVGhpY2tuZXNzICogdV93aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW87XFxuXFxuICBmbG9hdCBkYSA9IGFfYmFyeWNlbnRyaWMueDtcXG4gIGZsb2F0IGRiID0gYV9iYXJ5Y2VudHJpYy55O1xcbiAgZmxvYXQgZGMgPSBhX2JhcnljZW50cmljLno7XFxuXFxuICB2ZWMyIGRlbHRhID0gdmVjMihcXG4gICAgICBkYSAqICh3ZWJHTE5vZGVSYWRpdXMgKiB1bml0Tm9ybWFsLnkpXFxuICAgICsgZGIgKiAoKHdlYkdMTm9kZVJhZGl1cyArIHdlYkdMQXJyb3dIZWFkTGVuZ3RoKSAqIHVuaXROb3JtYWwueSArIHdlYkdMQXJyb3dIZWFkVGhpY2tuZXNzICogdW5pdE5vcm1hbC54KVxcbiAgICArIGRjICogKCh3ZWJHTE5vZGVSYWRpdXMgKyB3ZWJHTEFycm93SGVhZExlbmd0aCkgKiB1bml0Tm9ybWFsLnkgLSB3ZWJHTEFycm93SGVhZFRoaWNrbmVzcyAqIHVuaXROb3JtYWwueCksXFxuXFxuICAgICAgZGEgKiAoLXdlYkdMTm9kZVJhZGl1cyAqIHVuaXROb3JtYWwueClcXG4gICAgKyBkYiAqICgtKHdlYkdMTm9kZVJhZGl1cyArIHdlYkdMQXJyb3dIZWFkTGVuZ3RoKSAqIHVuaXROb3JtYWwueCArIHdlYkdMQXJyb3dIZWFkVGhpY2tuZXNzICogdW5pdE5vcm1hbC55KVxcbiAgICArIGRjICogKC0od2ViR0xOb2RlUmFkaXVzICsgd2ViR0xBcnJvd0hlYWRMZW5ndGgpICogdW5pdE5vcm1hbC54IC0gd2ViR0xBcnJvd0hlYWRUaGlja25lc3MgKiB1bml0Tm9ybWFsLnkpXFxuICApO1xcblxcbiAgdmVjMiBwb3NpdGlvbiA9ICh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiArIGRlbHRhLCAxKSkueHk7XFxuXFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAsIDEpO1xcblxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgLy8gRm9yIHBpY2tpbmcgbW9kZSwgd2UgdXNlIHRoZSBJRCBhcyB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9pZDtcXG4gICNlbHNlXFxuICAvLyBGb3Igbm9ybWFsIG1vZGUsIHdlIHVzZSB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcblxcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiO1xudmFyIFZFUlRFWF9TSEFERVJfU09VUkNFJDIgPSBTSEFERVJfU09VUkNFJDM7XG5cbnZhciBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMiA9IFdlYkdMUmVuZGVyaW5nQ29udGV4dCxcbiAgVU5TSUdORURfQllURSQyID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4JDIuVU5TSUdORURfQllURSxcbiAgRkxPQVQkMiA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQyLkZMT0FUO1xudmFyIFVOSUZPUk1TJDIgPSBbXCJ1X21hdHJpeFwiLCBcInVfc2l6ZVJhdGlvXCIsIFwidV9jb3JyZWN0aW9uUmF0aW9cIiwgXCJ1X21pbkVkZ2VUaGlja25lc3NcIiwgXCJ1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW9cIiwgXCJ1X3dpZGVuZXNzVG9UaGlja25lc3NSYXRpb1wiXTtcbnZhciBERUZBVUxUX0VER0VfQVJST1dfSEVBRF9QUk9HUkFNX09QVElPTlMgPSB7XG4gIGV4dHJlbWl0eTogXCJ0YXJnZXRcIixcbiAgbGVuZ3RoVG9UaGlja25lc3NSYXRpbzogMi41LFxuICB3aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW86IDJcbn07XG5mdW5jdGlvbiBjcmVhdGVFZGdlQXJyb3dIZWFkUHJvZ3JhbShpbnB1dE9wdGlvbnMpIHtcbiAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9FREdFX0FSUk9XX0hFQURfUFJPR1JBTV9PUFRJT05TKSwgaW5wdXRPcHRpb25zIHx8IHt9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkZ2VQcm9ncmFtKSB7XG4gICAgZnVuY3Rpb24gRWRnZUFycm93SGVhZFByb2dyYW0oKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZUFycm93SGVhZFByb2dyYW0pO1xuICAgICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgRWRnZUFycm93SGVhZFByb2dyYW0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9pbmhlcml0cyhFZGdlQXJyb3dIZWFkUHJvZ3JhbSwgX0VkZ2VQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVkZ2VBcnJvd0hlYWRQcm9ncmFtLCBbe1xuICAgICAga2V5OiBcImdldERlZmluaXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFZFUlRJQ0VTOiAzLFxuICAgICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSQyLFxuICAgICAgICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UkMSxcbiAgICAgICAgICBNRVRIT0Q6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsXG4gICAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TJDIsXG4gICAgICAgICAgQVRUUklCVVRFUzogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvblwiLFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsXCIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9yYWRpdXNcIixcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQyXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQyLFxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9pZFwiLFxuICAgICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMixcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJhX2JhcnljZW50cmljXCIsXG4gICAgICAgICAgICBzaXplOiAzLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMlxuICAgICAgICAgIH1dLFxuICAgICAgICAgIENPTlNUQU5UX0RBVEE6IFtbMSwgMCwgMF0sIFswLCAxLCAwXSwgWzAsIDAsIDFdXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcm9jZXNzVmlzaWJsZUl0ZW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlzaWJsZUl0ZW0oZWRnZUluZGV4LCBzdGFydEluZGV4LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmV4dHJlbWl0eSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgIHZhciBfcmVmID0gW3RhcmdldERhdGEsIHNvdXJjZURhdGFdO1xuICAgICAgICAgIHNvdXJjZURhdGEgPSBfcmVmWzBdO1xuICAgICAgICAgIHRhcmdldERhdGEgPSBfcmVmWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlja25lc3MgPSBkYXRhLnNpemUgfHwgMTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRhcmdldERhdGEuc2l6ZSB8fCAxO1xuICAgICAgICB2YXIgeDEgPSBzb3VyY2VEYXRhLng7XG4gICAgICAgIHZhciB5MSA9IHNvdXJjZURhdGEueTtcbiAgICAgICAgdmFyIHgyID0gdGFyZ2V0RGF0YS54O1xuICAgICAgICB2YXIgeTIgPSB0YXJnZXREYXRhLnk7XG4gICAgICAgIHZhciBjb2xvciA9IGZsb2F0Q29sb3IoZGF0YS5jb2xvcik7XG5cbiAgICAgICAgLy8gQ29tcHV0aW5nIG5vcm1hbHNcbiAgICAgICAgdmFyIGR4ID0geDIgLSB4MTtcbiAgICAgICAgdmFyIGR5ID0geTIgLSB5MTtcbiAgICAgICAgdmFyIGxlbiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICB2YXIgbjEgPSAwO1xuICAgICAgICB2YXIgbjIgPSAwO1xuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICAgIG4xID0gLWR5ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgICAgIG4yID0gZHggKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgyO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTI7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSAtbjE7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSAtbjI7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSByYWRpdXM7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGVkZ2VJbmRleDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVbmlmb3JtcyhwYXJhbXMsIF9yZWYyKSB7XG4gICAgICAgIHZhciBnbCA9IF9yZWYyLmdsLFxuICAgICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMgPSBfcmVmMi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgICB2YXIgdV9tYXRyaXggPSB1bmlmb3JtTG9jYXRpb25zLnVfbWF0cml4LFxuICAgICAgICAgIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgICB1X2NvcnJlY3Rpb25SYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9jb3JyZWN0aW9uUmF0aW8sXG4gICAgICAgICAgdV9taW5FZGdlVGhpY2tuZXNzID0gdW5pZm9ybUxvY2F0aW9ucy51X21pbkVkZ2VUaGlja25lc3MsXG4gICAgICAgICAgdV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8sXG4gICAgICAgICAgdV93aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVfbWF0cml4LCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X3NpemVSYXRpbywgcGFyYW1zLnNpemVSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X2NvcnJlY3Rpb25SYXRpbywgcGFyYW1zLmNvcnJlY3Rpb25SYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X21pbkVkZ2VUaGlja25lc3MsIHBhcmFtcy5taW5FZGdlVGhpY2tuZXNzKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbywgb3B0aW9ucy5sZW5ndGhUb1RoaWNrbmVzc1JhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvLCBvcHRpb25zLndpZGVuZXNzVG9UaGlja25lc3NSYXRpbyk7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KEVkZ2VQcm9ncmFtKTtcbn1cbnZhciBFZGdlQXJyb3dIZWFkUHJvZ3JhbSA9IGNyZWF0ZUVkZ2VBcnJvd0hlYWRQcm9ncmFtKCk7XG52YXIgRWRnZUFycm93SGVhZFByb2dyYW0kMSA9IEVkZ2VBcnJvd0hlYWRQcm9ncmFtO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQyID0gLypnbHNsKi9cIlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGZsb2F0IHZfdGhpY2tuZXNzO1xcbnZhcnlpbmcgZmxvYXQgdl9mZWF0aGVyO1xcblxcbmNvbnN0IHZlYzQgdHJhbnNwYXJlbnQgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIC8vIFdlIG9ubHkgaGFuZGxlIGFudGlhbGlhc2luZyBmb3Igbm9ybWFsIG1vZGU6XFxuICAjaWZkZWYgUElDS0lOR19NT0RFXFxuICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xcbiAgI2Vsc2VcXG4gIGZsb2F0IGRpc3QgPSBsZW5ndGgodl9ub3JtYWwpICogdl90aGlja25lc3M7XFxuXFxuICBmbG9hdCB0ID0gc21vb3Roc3RlcChcXG4gICAgdl90aGlja25lc3MgLSB2X2ZlYXRoZXIsXFxuICAgIHZfdGhpY2tuZXNzLFxcbiAgICBkaXN0XFxuICApO1xcblxcbiAgZ2xfRnJhZ0NvbG9yID0gbWl4KHZfY29sb3IsIHRyYW5zcGFyZW50LCB0KTtcXG4gICNlbmRpZlxcbn1cXG5cIjtcbnZhciBGUkFHTUVOVF9TSEFERVJfU09VUkNFID0gU0hBREVSX1NPVVJDRSQyO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQxID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX25vcm1hbDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9ub3JtYWxDb2VmO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb25TdGFydDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uRW5kO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3Bvc2l0aW9uQ29lZjtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9yYWRpdXM7XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFkaXVzQ29lZjtcXG5cXG51bmlmb3JtIG1hdDMgdV9tYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3pvb21SYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9waXhlbFJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X21pbkVkZ2VUaGlja25lc3M7XFxudW5pZm9ybSBmbG9hdCB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2ZlYXRoZXI7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgZmxvYXQgdl90aGlja25lc3M7XFxudmFyeWluZyBmbG9hdCB2X2ZlYXRoZXI7XFxuXFxuY29uc3QgZmxvYXQgYmlhcyA9IDI1NS4wIC8gMjU0LjA7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgbWluVGhpY2tuZXNzID0gdV9taW5FZGdlVGhpY2tuZXNzO1xcblxcbiAgZmxvYXQgcmFkaXVzID0gYV9yYWRpdXMgKiBhX3JhZGl1c0NvZWY7XFxuICB2ZWMyIG5vcm1hbCA9IGFfbm9ybWFsICogYV9ub3JtYWxDb2VmO1xcbiAgdmVjMiBwb3NpdGlvbiA9IGFfcG9zaXRpb25TdGFydCAqICgxLjAgLSBhX3Bvc2l0aW9uQ29lZikgKyBhX3Bvc2l0aW9uRW5kICogYV9wb3NpdGlvbkNvZWY7XFxuXFxuICBmbG9hdCBub3JtYWxMZW5ndGggPSBsZW5ndGgobm9ybWFsKTtcXG4gIHZlYzIgdW5pdE5vcm1hbCA9IG5vcm1hbCAvIG5vcm1hbExlbmd0aDtcXG5cXG4gIC8vIFRoZXNlIGZpcnN0IGNvbXB1dGF0aW9ucyBhcmUgdGFrZW4gZnJvbSBlZGdlLnZlcnQuZ2xzbC4gUGxlYXNlIHJlYWQgaXQgdG9cXG4gIC8vIGdldCBiZXR0ZXIgY29tbWVudHMgb24gd2hhdCdzIGhhcHBlbmluZzpcXG4gIGZsb2F0IHBpeGVsc1RoaWNrbmVzcyA9IG1heChub3JtYWxMZW5ndGgsIG1pblRoaWNrbmVzcyAqIHVfc2l6ZVJhdGlvKTtcXG4gIGZsb2F0IHdlYkdMVGhpY2tuZXNzID0gcGl4ZWxzVGhpY2tuZXNzICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG5cXG4gIC8vIEhlcmUsIHdlIG1vdmUgdGhlIHBvaW50IHRvIGxlYXZlIHNwYWNlIGZvciB0aGUgYXJyb3cgaGVhZDpcXG4gIGZsb2F0IGRpcmVjdGlvbiA9IHNpZ24ocmFkaXVzKTtcXG4gIGZsb2F0IHdlYkdMTm9kZVJhZGl1cyA9IGRpcmVjdGlvbiAqIHJhZGl1cyAqIDIuMCAqIHVfY29ycmVjdGlvblJhdGlvIC8gdV9zaXplUmF0aW87XFxuICBmbG9hdCB3ZWJHTEFycm93SGVhZExlbmd0aCA9IHdlYkdMVGhpY2tuZXNzICogdV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvICogMi4wO1xcblxcbiAgdmVjMiBjb21wZW5zYXRpb25WZWN0b3IgPSB2ZWMyKC1kaXJlY3Rpb24gKiB1bml0Tm9ybWFsLnksIGRpcmVjdGlvbiAqIHVuaXROb3JtYWwueCkgKiAod2ViR0xOb2RlUmFkaXVzICsgd2ViR0xBcnJvd0hlYWRMZW5ndGgpO1xcblxcbiAgLy8gSGVyZSBpcyB0aGUgcHJvcGVyIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uICsgdW5pdE5vcm1hbCAqIHdlYkdMVGhpY2tuZXNzICsgY29tcGVuc2F0aW9uVmVjdG9yLCAxKSkueHksIDAsIDEpO1xcblxcbiAgdl90aGlja25lc3MgPSB3ZWJHTFRoaWNrbmVzcyAvIHVfem9vbVJhdGlvO1xcblxcbiAgdl9ub3JtYWwgPSB1bml0Tm9ybWFsO1xcblxcbiAgdl9mZWF0aGVyID0gdV9mZWF0aGVyICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3pvb21SYXRpbyAvIHVfcGl4ZWxSYXRpbyAqIDIuMDtcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG5cXG4gIHZfY29sb3IuYSAqPSBiaWFzO1xcbn1cXG5cIjtcbnZhciBWRVJURVhfU0hBREVSX1NPVVJDRSQxID0gU0hBREVSX1NPVVJDRSQxO1xuXG52YXIgX1dlYkdMUmVuZGVyaW5nQ29udGV4JDEgPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUkMSA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQxLlVOU0lHTkVEX0JZVEUsXG4gIEZMT0FUJDEgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMS5GTE9BVDtcbnZhciBVTklGT1JNUyQxID0gW1widV9tYXRyaXhcIiwgXCJ1X3pvb21SYXRpb1wiLCBcInVfc2l6ZVJhdGlvXCIsIFwidV9jb3JyZWN0aW9uUmF0aW9cIiwgXCJ1X3BpeGVsUmF0aW9cIiwgXCJ1X2ZlYXRoZXJcIiwgXCJ1X21pbkVkZ2VUaGlja25lc3NcIiwgXCJ1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW9cIl07XG52YXIgREVGQVVMVF9FREdFX0NMQU1QRURfUFJPR1JBTV9PUFRJT05TID0ge1xuICBsZW5ndGhUb1RoaWNrbmVzc1JhdGlvOiBERUZBVUxUX0VER0VfQVJST1dfSEVBRF9QUk9HUkFNX09QVElPTlMubGVuZ3RoVG9UaGlja25lc3NSYXRpb1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VDbGFtcGVkUHJvZ3JhbShpbnB1dE9wdGlvbnMpIHtcbiAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9FREdFX0NMQU1QRURfUFJPR1JBTV9PUFRJT05TKSwgaW5wdXRPcHRpb25zIHx8IHt9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkZ2VQcm9ncmFtKSB7XG4gICAgZnVuY3Rpb24gRWRnZUNsYW1wZWRQcm9ncmFtKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VDbGFtcGVkUHJvZ3JhbSk7XG4gICAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBFZGdlQ2xhbXBlZFByb2dyYW0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9pbmhlcml0cyhFZGdlQ2xhbXBlZFByb2dyYW0sIF9FZGdlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFZGdlQ2xhbXBlZFByb2dyYW0sIFt7XG4gICAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgVkVSVElDRVM6IDYsXG4gICAgICAgICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZFUlRFWF9TSEFERVJfU09VUkNFJDEsXG4gICAgICAgICAgRlJBR01FTlRfU0hBREVSX1NPVVJDRTogRlJBR01FTlRfU0hBREVSX1NPVVJDRSxcbiAgICAgICAgICBNRVRIT0Q6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsXG4gICAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TJDEsXG4gICAgICAgICAgQVRUUklCVVRFUzogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvblN0YXJ0XCIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvbkVuZFwiLFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsXCIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9jb2xvclwiLFxuICAgICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfaWRcIixcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDEsXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX3JhZGl1c1wiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbXG4gICAgICAgICAgLy8gSWYgMCwgdGhlbiBwb3NpdGlvbiB3aWxsIGJlIGFfcG9zaXRpb25TdGFydFxuICAgICAgICAgIC8vIElmIDEsIHRoZW4gcG9zaXRpb24gd2lsbCBiZSBhX3Bvc2l0aW9uRW5kXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uQ29lZlwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsQ29lZlwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfcmFkaXVzQ29lZlwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBDT05TVEFOVF9EQVRBOiBbWzAsIDEsIDBdLCBbMCwgLTEsIDBdLCBbMSwgMSwgMV0sIFsxLCAxLCAxXSwgWzAsIC0xLCAwXSwgWzEsIC0xLCAtMV1dXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NWaXNpYmxlSXRlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShlZGdlSW5kZXgsIHN0YXJ0SW5kZXgsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpIHtcbiAgICAgICAgdmFyIHRoaWNrbmVzcyA9IGRhdGEuc2l6ZSB8fCAxO1xuICAgICAgICB2YXIgeDEgPSBzb3VyY2VEYXRhLng7XG4gICAgICAgIHZhciB5MSA9IHNvdXJjZURhdGEueTtcbiAgICAgICAgdmFyIHgyID0gdGFyZ2V0RGF0YS54O1xuICAgICAgICB2YXIgeTIgPSB0YXJnZXREYXRhLnk7XG4gICAgICAgIHZhciBjb2xvciA9IGZsb2F0Q29sb3IoZGF0YS5jb2xvcik7XG5cbiAgICAgICAgLy8gQ29tcHV0aW5nIG5vcm1hbHNcbiAgICAgICAgdmFyIGR4ID0geDIgLSB4MTtcbiAgICAgICAgdmFyIGR5ID0geTIgLSB5MTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRhcmdldERhdGEuc2l6ZSB8fCAxO1xuICAgICAgICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIHZhciBuMSA9IDA7XG4gICAgICAgIHZhciBuMiA9IDA7XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgICAgbjEgPSAtZHkgKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICAgICAgbjIgPSBkeCAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDE7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgyO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTI7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBuMTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IG4yO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gY29sb3I7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBlZGdlSW5kZXg7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSByYWRpdXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFVuaWZvcm1zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybXMocGFyYW1zLCBfcmVmKSB7XG4gICAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgICAgdW5pZm9ybUxvY2F0aW9ucyA9IF9yZWYudW5pZm9ybUxvY2F0aW9ucztcbiAgICAgICAgdmFyIHVfbWF0cml4ID0gdW5pZm9ybUxvY2F0aW9ucy51X21hdHJpeCxcbiAgICAgICAgICB1X3pvb21SYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV96b29tUmF0aW8sXG4gICAgICAgICAgdV9mZWF0aGVyID0gdW5pZm9ybUxvY2F0aW9ucy51X2ZlYXRoZXIsXG4gICAgICAgICAgdV9waXhlbFJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3BpeGVsUmF0aW8sXG4gICAgICAgICAgdV9jb3JyZWN0aW9uUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfY29ycmVjdGlvblJhdGlvLFxuICAgICAgICAgIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgICB1X21pbkVkZ2VUaGlja25lc3MgPSB1bmlmb3JtTG9jYXRpb25zLnVfbWluRWRnZVRoaWNrbmVzcyxcbiAgICAgICAgICB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbztcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1X21hdHJpeCwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtMWYodV96b29tUmF0aW8sIHBhcmFtcy56b29tUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9zaXplUmF0aW8sIHBhcmFtcy5zaXplUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9jb3JyZWN0aW9uUmF0aW8sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9waXhlbFJhdGlvLCBwYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X2ZlYXRoZXIsIHBhcmFtcy5hbnRpQWxpYXNpbmdGZWF0aGVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfbWluRWRnZVRoaWNrbmVzcywgcGFyYW1zLm1pbkVkZ2VUaGlja25lc3MpO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvLCBvcHRpb25zLmxlbmd0aFRvVGhpY2tuZXNzUmF0aW8pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShFZGdlUHJvZ3JhbSk7XG59XG52YXIgRWRnZUNsYW1wZWRQcm9ncmFtID0gY3JlYXRlRWRnZUNsYW1wZWRQcm9ncmFtKCk7XG52YXIgRWRnZUNsYW1wZWRQcm9ncmFtJDEgPSBFZGdlQ2xhbXBlZFByb2dyYW07XG5cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VBcnJvd1Byb2dyYW0oaW5wdXRPcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVFZGdlQ29tcG91bmRQcm9ncmFtKFtjcmVhdGVFZGdlQ2xhbXBlZFByb2dyYW0oaW5wdXRPcHRpb25zKSwgY3JlYXRlRWRnZUFycm93SGVhZFByb2dyYW0oaW5wdXRPcHRpb25zKV0pO1xufVxudmFyIEVkZ2VBcnJvd1Byb2dyYW0gPSBjcmVhdGVFZGdlQXJyb3dQcm9ncmFtKCk7XG52YXIgRWRnZUFycm93UHJvZ3JhbSQxID0gRWRnZUFycm93UHJvZ3JhbTtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UgPSAvKmdsc2wqL1wiXFxuYXR0cmlidXRlIHZlYzQgYV9pZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfbm9ybWFsO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX25vcm1hbENvZWY7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvblN0YXJ0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb25FbmQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfcG9zaXRpb25Db2VmO1xcblxcbnVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV96b29tUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X3BpeGVsUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2NvcnJlY3Rpb25SYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfbWluRWRnZVRoaWNrbmVzcztcXG51bmlmb3JtIGZsb2F0IHVfZmVhdGhlcjtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X3RoaWNrbmVzcztcXG52YXJ5aW5nIGZsb2F0IHZfZmVhdGhlcjtcXG5cXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBmbG9hdCBtaW5UaGlja25lc3MgPSB1X21pbkVkZ2VUaGlja25lc3M7XFxuXFxuICB2ZWMyIG5vcm1hbCA9IGFfbm9ybWFsICogYV9ub3JtYWxDb2VmO1xcbiAgdmVjMiBwb3NpdGlvbiA9IGFfcG9zaXRpb25TdGFydCAqICgxLjAgLSBhX3Bvc2l0aW9uQ29lZikgKyBhX3Bvc2l0aW9uRW5kICogYV9wb3NpdGlvbkNvZWY7XFxuXFxuICBmbG9hdCBub3JtYWxMZW5ndGggPSBsZW5ndGgobm9ybWFsKTtcXG4gIHZlYzIgdW5pdE5vcm1hbCA9IG5vcm1hbCAvIG5vcm1hbExlbmd0aDtcXG5cXG4gIC8vIFdlIHJlcXVpcmUgZWRnZXMgdG8gYmUgYXQgbGVhc3QgXFxcIm1pblRoaWNrbmVzc1xcXCIgcGl4ZWxzIHRoaWNrICpvbiBzY3JlZW4qXFxuICAvLyAoc28gd2UgbmVlZCB0byBjb21wZW5zYXRlIHRoZSBzaXplIHJhdGlvKTpcXG4gIGZsb2F0IHBpeGVsc1RoaWNrbmVzcyA9IG1heChub3JtYWxMZW5ndGgsIG1pblRoaWNrbmVzcyAqIHVfc2l6ZVJhdGlvKTtcXG5cXG4gIC8vIFRoZW4sIHdlIG5lZWQgdG8gcmV0cmlldmUgdGhlIG5vcm1hbGl6ZWQgdGhpY2tuZXNzIG9mIHRoZSBlZGdlIGluIHRoZSBXZWJHTFxcbiAgLy8gcmVmZXJlbnRpYWwgKGluIGEgKFswLCAxXSwgWzAsIDFdKSBzcGFjZSksIHVzaW5nIG91ciBcXFwibWFnaWNcXFwiIGNvcnJlY3Rpb25cXG4gIC8vIHJhdGlvOlxcbiAgZmxvYXQgd2ViR0xUaGlja25lc3MgPSBwaXhlbHNUaGlja25lc3MgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfc2l6ZVJhdGlvO1xcblxcbiAgLy8gSGVyZSBpcyB0aGUgcHJvcGVyIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uICsgdW5pdE5vcm1hbCAqIHdlYkdMVGhpY2tuZXNzLCAxKSkueHksIDAsIDEpO1xcblxcbiAgLy8gRm9yIHRoZSBmcmFnbWVudCBzaGFkZXIgdGhvdWdoLCB3ZSBuZWVkIGEgdGhpY2tuZXNzIHRoYXQgdGFrZXMgdGhlIFxcXCJtYWdpY1xcXCJcXG4gIC8vIGNvcnJlY3Rpb24gcmF0aW8gaW50byBhY2NvdW50IChhcyBpbiB3ZWJHTFRoaWNrbmVzcyksIGJ1dCBzbyB0aGF0IHRoZVxcbiAgLy8gYW50aWFsaWFzaW5nIGVmZmVjdCBkb2VzIG5vdCBkZXBlbmQgb24gdGhlIHpvb20gbGV2ZWwuIFNvIGhlcmUncyB5ZXRcXG4gIC8vIGFub3RoZXIgdGhpY2tuZXNzIHZlcnNpb246XFxuICB2X3RoaWNrbmVzcyA9IHdlYkdMVGhpY2tuZXNzIC8gdV96b29tUmF0aW87XFxuXFxuICB2X25vcm1hbCA9IHVuaXROb3JtYWw7XFxuXFxuICB2X2ZlYXRoZXIgPSB1X2ZlYXRoZXIgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfem9vbVJhdGlvIC8gdV9waXhlbFJhdGlvICogMi4wO1xcblxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgLy8gRm9yIHBpY2tpbmcgbW9kZSwgd2UgdXNlIHRoZSBJRCBhcyB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9pZDtcXG4gICNlbHNlXFxuICAvLyBGb3Igbm9ybWFsIG1vZGUsIHdlIHVzZSB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcblxcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiO1xudmFyIFZFUlRFWF9TSEFERVJfU09VUkNFID0gU0hBREVSX1NPVVJDRTtcblxudmFyIF9XZWJHTFJlbmRlcmluZ0NvbnRleCA9IFdlYkdMUmVuZGVyaW5nQ29udGV4dCxcbiAgVU5TSUdORURfQllURSA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleC5VTlNJR05FRF9CWVRFLFxuICBGTE9BVCA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleC5GTE9BVDtcbnZhciBVTklGT1JNUyA9IFtcInVfbWF0cml4XCIsIFwidV96b29tUmF0aW9cIiwgXCJ1X3NpemVSYXRpb1wiLCBcInVfY29ycmVjdGlvblJhdGlvXCIsIFwidV9waXhlbFJhdGlvXCIsIFwidV9mZWF0aGVyXCIsIFwidV9taW5FZGdlVGhpY2tuZXNzXCJdO1xudmFyIEVkZ2VSZWN0YW5nbGVQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZVByb2dyYW0pIHtcbiAgZnVuY3Rpb24gRWRnZVJlY3RhbmdsZVByb2dyYW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VSZWN0YW5nbGVQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBFZGdlUmVjdGFuZ2xlUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoRWRnZVJlY3RhbmdsZVByb2dyYW0sIF9FZGdlUHJvZ3JhbSk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRWRnZVJlY3RhbmdsZVByb2dyYW0sIFt7XG4gICAga2V5OiBcImdldERlZmluaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFZFUlRJQ0VTOiA2LFxuICAgICAgICBWRVJURVhfU0hBREVSX1NPVVJDRTogVkVSVEVYX1NIQURFUl9TT1VSQ0UsXG4gICAgICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UsXG4gICAgICAgIE1FVEhPRDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUyxcbiAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TLFxuICAgICAgICBBVFRSSUJVVEVTOiBbe1xuICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvblN0YXJ0XCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uRW5kXCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX25vcm1hbFwiLFxuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9jb2xvclwiLFxuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSxcbiAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfaWRcIixcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgQ09OU1RBTlRfQVRUUklCVVRFUzogW1xuICAgICAgICAvLyBJZiAwLCB0aGVuIHBvc2l0aW9uIHdpbGwgYmUgYV9wb3NpdGlvblN0YXJ0XG4gICAgICAgIC8vIElmIDIsIHRoZW4gcG9zaXRpb24gd2lsbCBiZSBhX3Bvc2l0aW9uRW5kXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25Db2VmXCIsXG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX25vcm1hbENvZWZcIixcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH1dLFxuICAgICAgICBDT05TVEFOVF9EQVRBOiBbWzAsIDFdLCBbMCwgLTFdLCBbMSwgMV0sIFsxLCAxXSwgWzAsIC0xXSwgWzEsIC0xXV1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NWaXNpYmxlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlzaWJsZUl0ZW0oZWRnZUluZGV4LCBzdGFydEluZGV4LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICB2YXIgdGhpY2tuZXNzID0gZGF0YS5zaXplIHx8IDE7XG4gICAgICB2YXIgeDEgPSBzb3VyY2VEYXRhLng7XG4gICAgICB2YXIgeTEgPSBzb3VyY2VEYXRhLnk7XG4gICAgICB2YXIgeDIgPSB0YXJnZXREYXRhLng7XG4gICAgICB2YXIgeTIgPSB0YXJnZXREYXRhLnk7XG4gICAgICB2YXIgY29sb3IgPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuXG4gICAgICAvLyBDb21wdXRpbmcgbm9ybWFsc1xuICAgICAgdmFyIGR4ID0geDIgLSB4MTtcbiAgICAgIHZhciBkeSA9IHkyIC0geTE7XG4gICAgICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICB2YXIgbjEgPSAwO1xuICAgICAgdmFyIG4yID0gMDtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBuMSA9IC1keSAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgbjIgPSBkeCAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgIH1cbiAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gbjE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gbjI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gY29sb3I7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZWRnZUluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRVbmlmb3Jtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVbmlmb3JtcyhwYXJhbXMsIF9yZWYpIHtcbiAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMgPSBfcmVmLnVuaWZvcm1Mb2NhdGlvbnM7XG4gICAgICB2YXIgdV9tYXRyaXggPSB1bmlmb3JtTG9jYXRpb25zLnVfbWF0cml4LFxuICAgICAgICB1X3pvb21SYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV96b29tUmF0aW8sXG4gICAgICAgIHVfZmVhdGhlciA9IHVuaWZvcm1Mb2NhdGlvbnMudV9mZWF0aGVyLFxuICAgICAgICB1X3BpeGVsUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfcGl4ZWxSYXRpbyxcbiAgICAgICAgdV9jb3JyZWN0aW9uUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfY29ycmVjdGlvblJhdGlvLFxuICAgICAgICB1X3NpemVSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9zaXplUmF0aW8sXG4gICAgICAgIHVfbWluRWRnZVRoaWNrbmVzcyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9taW5FZGdlVGhpY2tuZXNzO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1X21hdHJpeCwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfem9vbVJhdGlvLCBwYXJhbXMuem9vbVJhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm0xZih1X3NpemVSYXRpbywgcGFyYW1zLnNpemVSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtMWYodV9jb3JyZWN0aW9uUmF0aW8sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfcGl4ZWxSYXRpbywgcGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfZmVhdGhlciwgcGFyYW1zLmFudGlBbGlhc2luZ0ZlYXRoZXIpO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfbWluRWRnZVRoaWNrbmVzcywgcGFyYW1zLm1pbkVkZ2VUaGlja25lc3MpO1xuICAgIH1cbiAgfV0pO1xufShFZGdlUHJvZ3JhbSk7XG5cbmV4cG9ydCB7IEFic3RyYWN0Tm9kZVByb2dyYW0gYXMgQSwgREVGQVVMVF9FREdFX0FSUk9XX0hFQURfUFJPR1JBTV9PUFRJT05TIGFzIEQsIEVkZ2VBcnJvd1Byb2dyYW0kMSBhcyBFLCBGUkFHTUVOVF9TSEFERVJfU09VUkNFIGFzIEYsIE5vZGVDaXJjbGVQcm9ncmFtIGFzIE4sIFByb2dyYW0gYXMgUCwgX29iamVjdFNwcmVhZDIgYXMgXywgX2RlZmluZVByb3BlcnR5IGFzIGEsIGRyYXdEaXNjTm9kZUxhYmVsIGFzIGIsIGRyYXdEaXNjTm9kZUhvdmVyIGFzIGMsIGRyYXdTdHJhaWdodEVkZ2VMYWJlbCBhcyBkLCBFZGdlUmVjdGFuZ2xlUHJvZ3JhbSBhcyBlLCBOb2RlUHJvZ3JhbSBhcyBmLCBFZGdlUHJvZ3JhbSBhcyBnLCBjcmVhdGVFZGdlQ29tcG91bmRQcm9ncmFtIGFzIGgsIGNyZWF0ZUVkZ2VBcnJvd0hlYWRQcm9ncmFtIGFzIGksIGNyZWF0ZU5vZGVDb21wb3VuZFByb2dyYW0gYXMgaiwgQWJzdHJhY3RFZGdlUHJvZ3JhbSBhcyBrLCBBYnN0cmFjdFByb2dyYW0gYXMgbCwgRWRnZUFycm93SGVhZFByb2dyYW0kMSBhcyBtLCBFZGdlQ2xhbXBlZFByb2dyYW0kMSBhcyBuLCBjcmVhdGVFZGdlQ2xhbXBlZFByb2dyYW0gYXMgbywgREVGQVVMVF9FREdFX0NMQU1QRURfUFJPR1JBTV9PUFRJT05TIGFzIHAsIGNyZWF0ZUVkZ2VBcnJvd1Byb2dyYW0gYXMgcSwgZ2V0QXR0cmlidXRlSXRlbXNDb3VudCBhcyByLCBnZXRBdHRyaWJ1dGVzSXRlbXNDb3VudCBhcyBzLCBsb2FkVmVydGV4U2hhZGVyIGFzIHQsIGxvYWRGcmFnbWVudFNoYWRlciBhcyB1LCBsb2FkUHJvZ3JhbSBhcyB2LCBraWxsUHJvZ3JhbSBhcyB3LCBudW1iZXJUb0dMU0xGbG9hdCBhcyB4IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/sigma/dist/index-236c62ad.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/sigma/dist/inherits-d1a1e29b.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/sigma/dist/inherits-d1a1e29b.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _inherits),\n/* harmony export */   a: () => (/* binding */ _createClass),\n/* harmony export */   b: () => (/* binding */ _classCallCheck),\n/* harmony export */   c: () => (/* binding */ _callSuper),\n/* harmony export */   d: () => (/* binding */ _toPropertyKey),\n/* harmony export */   e: () => (/* binding */ _getPrototypeOf)\n/* harmony export */ });\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\n\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\n\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\n\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\n\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\n\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\n\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zaWdtYS9kaXN0L2luaGVyaXRzLWQxYTFlMjliLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RixJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFK0giLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGVub3ZvXFxEZXNrdG9wXFxmcm9udGVuZFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcc2lnbWFcXGRpc3RcXGluaGVyaXRzLWQxYTFlMjliLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgIHZhciBvID0gclt0XTtcbiAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKHQpIHtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7XG4gIH0sIF9nZXRQcm90b3R5cGVPZih0KTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0O1xuICB9KSgpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkge1xuICBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbn1cblxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7XG4gIHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyh0LCBlKSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogdCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9XG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZSAmJiBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5cbmV4cG9ydCB7IF9pbmhlcml0cyBhcyBfLCBfY3JlYXRlQ2xhc3MgYXMgYSwgX2NsYXNzQ2FsbENoZWNrIGFzIGIsIF9jYWxsU3VwZXIgYXMgYywgX3RvUHJvcGVydHlLZXkgYXMgZCwgX2dldFByb3RvdHlwZU9mIGFzIGUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/sigma/dist/inherits-d1a1e29b.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/sigma/dist/normalization-be445518.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/sigma/dist/normalization-be445518.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ ANIMATE_DEFAULTS),\n/* harmony export */   a: () => (/* binding */ getMatrixImpact),\n/* harmony export */   b: () => (/* binding */ createElement),\n/* harmony export */   c: () => (/* binding */ createNormalizationFunction),\n/* harmony export */   d: () => (/* binding */ getPixelRatio),\n/* harmony export */   e: () => (/* binding */ easings),\n/* harmony export */   f: () => (/* binding */ multiplyVec2),\n/* harmony export */   g: () => (/* binding */ graphExtent),\n/* harmony export */   h: () => (/* binding */ animateNodes),\n/* harmony export */   i: () => (/* binding */ identity),\n/* harmony export */   j: () => (/* binding */ getCorrectionRatio),\n/* harmony export */   k: () => (/* binding */ quadraticOut),\n/* harmony export */   l: () => (/* binding */ linear),\n/* harmony export */   m: () => (/* binding */ matrixFromCamera),\n/* harmony export */   n: () => (/* binding */ quadraticInOut),\n/* harmony export */   o: () => (/* binding */ cubicIn),\n/* harmony export */   p: () => (/* binding */ cubicOut),\n/* harmony export */   q: () => (/* binding */ quadraticIn),\n/* harmony export */   r: () => (/* binding */ cubicInOut),\n/* harmony export */   s: () => (/* binding */ scale),\n/* harmony export */   t: () => (/* binding */ rotate),\n/* harmony export */   u: () => (/* binding */ translate),\n/* harmony export */   v: () => (/* binding */ validateGraph),\n/* harmony export */   w: () => (/* binding */ multiply),\n/* harmony export */   z: () => (/* binding */ zIndexOrdering)\n/* harmony export */ });\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphology-utils/is-graph */ \"(app-pages-browser)/./node_modules/graphology-utils/is-graph.js\");\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ \"(app-pages-browser)/./node_modules/sigma/dist/colors-beb06eb2.esm.js\");\n\n\n\nvar linear = function linear(k) {\n  return k;\n};\nvar quadraticIn = function quadraticIn(k) {\n  return k * k;\n};\nvar quadraticOut = function quadraticOut(k) {\n  return k * (2 - k);\n};\nvar quadraticInOut = function quadraticInOut(k) {\n  if ((k *= 2) < 1) return 0.5 * k * k;\n  return -0.5 * (--k * (k - 2) - 1);\n};\nvar cubicIn = function cubicIn(k) {\n  return k * k * k;\n};\nvar cubicOut = function cubicOut(k) {\n  return --k * k * k + 1;\n};\nvar cubicInOut = function cubicInOut(k) {\n  if ((k *= 2) < 1) return 0.5 * k * k * k;\n  return 0.5 * ((k -= 2) * k * k + 2);\n};\nvar easings = {\n  linear: linear,\n  quadraticIn: quadraticIn,\n  quadraticOut: quadraticOut,\n  quadraticInOut: quadraticInOut,\n  cubicIn: cubicIn,\n  cubicOut: cubicOut,\n  cubicInOut: cubicInOut\n};\n\n/**\n * Defaults.\n */\n\nvar ANIMATE_DEFAULTS = {\n  easing: \"quadraticInOut\",\n  duration: 150\n};\n\n/**\n * Function used to animate the nodes.\n */\nfunction animateNodes(graph, targets, opts, callback) {\n  var options = Object.assign({}, ANIMATE_DEFAULTS, opts);\n  var easing = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n  var start = Date.now();\n  var startPositions = {};\n  for (var node in targets) {\n    var attrs = targets[node];\n    startPositions[node] = {};\n    for (var _k in attrs) startPositions[node][_k] = graph.getNodeAttribute(node, _k);\n  }\n  var frame = null;\n  var _step = function step() {\n    frame = null;\n    var p = (Date.now() - start) / options.duration;\n    if (p >= 1) {\n      // Animation is done\n      for (var _node in targets) {\n        var _attrs = targets[_node];\n\n        // We use given values to avoid precision issues and for convenience\n        for (var _k2 in _attrs) graph.setNodeAttribute(_node, _k2, _attrs[_k2]);\n      }\n      if (typeof callback === \"function\") callback();\n      return;\n    }\n    p = easing(p);\n    for (var _node2 in targets) {\n      var _attrs2 = targets[_node2];\n      var s = startPositions[_node2];\n      for (var _k3 in _attrs2) graph.setNodeAttribute(_node2, _k3, _attrs2[_k3] * p + s[_k3] * (1 - p));\n    }\n    frame = requestAnimationFrame(_step);\n  };\n  _step();\n  return function () {\n    if (frame) cancelAnimationFrame(frame);\n  };\n}\n\nfunction identity() {\n  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);\n}\n\n// TODO: optimize\nfunction scale(m, x, y) {\n  m[0] = x;\n  m[4] = typeof y === \"number\" ? y : x;\n  return m;\n}\nfunction rotate(m, r) {\n  var s = Math.sin(r),\n    c = Math.cos(r);\n  m[0] = c;\n  m[1] = s;\n  m[3] = -s;\n  m[4] = c;\n  return m;\n}\nfunction translate(m, x, y) {\n  m[6] = x;\n  m[7] = y;\n  return m;\n}\nfunction multiply(a, b) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  var a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  var a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n  var b00 = b[0],\n    b01 = b[1],\n    b02 = b[2];\n  var b10 = b[3],\n    b11 = b[4],\n    b12 = b[5];\n  var b20 = b[6],\n    b21 = b[7],\n    b22 = b[8];\n  a[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  a[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  a[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  a[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  a[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  a[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  a[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  a[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  a[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return a;\n}\nfunction multiplyVec2(a, b) {\n  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var a00 = a[0];\n  var a01 = a[1];\n  var a10 = a[3];\n  var a11 = a[4];\n  var a20 = a[6];\n  var a21 = a[7];\n  var b0 = b.x;\n  var b1 = b.y;\n  return {\n    x: b0 * a00 + b1 * a10 + a20 * z,\n    y: b0 * a01 + b1 * a11 + a21 * z\n  };\n}\n\n/**\n * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This\n * helps to deal with quadtree in particular.\n * But at some point, we need to rescale it so that it takes the best place in the screen, i.e. we always want to see two\n * nodes \"touching\" opposite sides of the graph, with the camera being at its default state.\n *\n * This function determines this ratio.\n */\nfunction getCorrectionRatio(viewportDimensions, graphDimensions) {\n  var viewportRatio = viewportDimensions.height / viewportDimensions.width;\n  var graphRatio = graphDimensions.height / graphDimensions.width;\n\n  // If the stage and the graphs are in different directions (such as the graph being wider that tall while the stage\n  // is taller than wide), we can stop here to have indeed nodes touching opposite sides:\n  if (viewportRatio < 1 && graphRatio > 1 || viewportRatio > 1 && graphRatio < 1) {\n    return 1;\n  }\n\n  // Else, we need to fit the graph inside the stage:\n  // 1. If the graph is \"squarer\" (i.e. with a ratio closer to 1), we need to make the largest sides touch;\n  // 2. If the stage is \"squarer\", we need to make the smallest sides touch.\n  return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));\n}\n\n/**\n * Function returning a matrix from the current state of the camera.\n */\nfunction matrixFromCamera(state, viewportDimensions, graphDimensions, padding, inverse) {\n  // TODO: it's possible to optimize this drastically!\n  var angle = state.angle,\n    ratio = state.ratio,\n    x = state.x,\n    y = state.y;\n  var width = viewportDimensions.width,\n    height = viewportDimensions.height;\n  var matrix = identity();\n  var smallestDimension = Math.min(width, height) - 2 * padding;\n  var correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);\n  if (!inverse) {\n    multiply(matrix, scale(identity(), 2 * (smallestDimension / width) * correctionRatio, 2 * (smallestDimension / height) * correctionRatio));\n    multiply(matrix, rotate(identity(), -angle));\n    multiply(matrix, scale(identity(), 1 / ratio));\n    multiply(matrix, translate(identity(), -x, -y));\n  } else {\n    multiply(matrix, translate(identity(), x, y));\n    multiply(matrix, scale(identity(), ratio));\n    multiply(matrix, rotate(identity(), angle));\n    multiply(matrix, scale(identity(), width / smallestDimension / 2 / correctionRatio, height / smallestDimension / 2 / correctionRatio));\n  }\n  return matrix;\n}\n\n/**\n * All these transformations we apply on the matrix to get it rescale the graph\n * as we want make it very hard to get pixel-perfect distances in WebGL. This\n * function returns a factor that properly cancels the matrix effect on lengths.\n *\n * [jacomyal]\n * To be fully honest, I can't really explain happens here... I notice that the\n * following ratio works (i.e. it correctly compensates the matrix impact on all\n * camera states I could try):\n * > `R = size(V) / size(M * V) / W`\n * as long as `M * V` is in the direction of W (ie. parallel to (Ox)). It works\n * as well with H and a vector that transforms into something parallel to (Oy).\n *\n * Also, note that we use `angle` and not `-angle` (that would seem logical,\n * since we want to anticipate the rotation), because the image is vertically\n * swapped in WebGL.\n */\nfunction getMatrixImpact(matrix, cameraState, viewportDimensions) {\n  var _multiplyVec = multiplyVec2(matrix, {\n      x: Math.cos(cameraState.angle),\n      y: Math.sin(cameraState.angle)\n    }, 0),\n    x = _multiplyVec.x,\n    y = _multiplyVec.y;\n  return 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / viewportDimensions.width;\n}\n\n/**\n * Function returning the graph's node extent in x & y.\n */\nfunction graphExtent(graph) {\n  if (!graph.order) return {\n    x: [0, 1],\n    y: [0, 1]\n  };\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  graph.forEachNode(function (_, attr) {\n    var x = attr.x,\n      y = attr.y;\n    if (x < xMin) xMin = x;\n    if (x > xMax) xMax = x;\n    if (y < yMin) yMin = y;\n    if (y > yMax) yMax = y;\n  });\n  return {\n    x: [xMin, xMax],\n    y: [yMin, yMax]\n  };\n}\n\n/**\n * Check if the graph variable is a valid graph, and if sigma can render it.\n */\nfunction validateGraph(graph) {\n  // check if it's a valid graphology instance\n  if (!graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0___default()(graph)) throw new Error(\"Sigma: invalid graph instance.\");\n\n  // check if nodes have x/y attributes\n  graph.forEachNode(function (key, attributes) {\n    if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {\n      throw new Error(\"Sigma: Coordinates of node \".concat(key, \" are invalid. A node must have a numeric 'x' and 'y' attribute.\"));\n    }\n  });\n}\n\n/**\n * Function used to create DOM elements easily.\n */\nfunction createElement(tag, style, attributes) {\n  var element = document.createElement(tag);\n  if (style) {\n    for (var k in style) {\n      element.style[k] = style[k];\n    }\n  }\n  if (attributes) {\n    for (var _k in attributes) {\n      element.setAttribute(_k, attributes[_k]);\n    }\n  }\n  return element;\n}\n\n/**\n * Function returning the browser's pixel ratio.\n */\nfunction getPixelRatio() {\n  if (typeof window.devicePixelRatio !== \"undefined\") return window.devicePixelRatio;\n  return 1;\n}\n\n/**\n * Function ordering the given elements in reverse z-order so they drawn\n * the correct way.\n */\nfunction zIndexOrdering(_extent, getter, elements) {\n  // If k is > n, we'll use a standard sort\n  return elements.sort(function (a, b) {\n    var zA = getter(a) || 0,\n      zB = getter(b) || 0;\n    if (zA < zB) return -1;\n    if (zA > zB) return 1;\n    return 0;\n  });\n\n  // TODO: counting sort optimization\n}\n\n/**\n * Factory returning a function normalizing the given node's position & size.\n */\n\nfunction createNormalizationFunction(extent) {\n  var _extent$x = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(extent.x, 2),\n    minX = _extent$x[0],\n    maxX = _extent$x[1],\n    _extent$y = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(extent.y, 2),\n    minY = _extent$y[0],\n    maxY = _extent$y[1];\n  var ratio = Math.max(maxX - minX, maxY - minY),\n    dX = (maxX + minX) / 2,\n    dY = (maxY + minY) / 2;\n  if (ratio === 0 || Math.abs(ratio) === Infinity || isNaN(ratio)) ratio = 1;\n  if (isNaN(dX)) dX = 0;\n  if (isNaN(dY)) dY = 0;\n  var fn = function fn(data) {\n    return {\n      x: 0.5 + (data.x - dX) / ratio,\n      y: 0.5 + (data.y - dY) / ratio\n    };\n  };\n\n  // TODO: possibility to apply this in batch over array of indices\n  fn.applyTo = function (data) {\n    data.x = 0.5 + (data.x - dX) / ratio;\n    data.y = 0.5 + (data.y - dY) / ratio;\n  };\n  fn.inverse = function (data) {\n    return {\n      x: dX + ratio * (data.x - 0.5),\n      y: dY + ratio * (data.y - 0.5)\n    };\n  };\n  fn.ratio = ratio;\n  return fn;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zaWdtYS9kaXN0L25vcm1hbGl6YXRpb24tYmU0NDU1MTguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDZTs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0VBQU87O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMERBQWM7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQiwwREFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRkIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxlbm92b1xcRGVza3RvcFxcZnJvbnRlbmRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHNpZ21hXFxkaXN0XFxub3JtYWxpemF0aW9uLWJlNDQ1NTE4LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaXNHcmFwaCBmcm9tICdncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoJztcbmltcG9ydCB7IF8gYXMgX3NsaWNlZFRvQXJyYXkgfSBmcm9tICcuL2NvbG9ycy1iZWIwNmViMi5lc20uanMnO1xuXG52YXIgbGluZWFyID0gZnVuY3Rpb24gbGluZWFyKGspIHtcbiAgcmV0dXJuIGs7XG59O1xudmFyIHF1YWRyYXRpY0luID0gZnVuY3Rpb24gcXVhZHJhdGljSW4oaykge1xuICByZXR1cm4gayAqIGs7XG59O1xudmFyIHF1YWRyYXRpY091dCA9IGZ1bmN0aW9uIHF1YWRyYXRpY091dChrKSB7XG4gIHJldHVybiBrICogKDIgLSBrKTtcbn07XG52YXIgcXVhZHJhdGljSW5PdXQgPSBmdW5jdGlvbiBxdWFkcmF0aWNJbk91dChrKSB7XG4gIGlmICgoayAqPSAyKSA8IDEpIHJldHVybiAwLjUgKiBrICogaztcbiAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xufTtcbnZhciBjdWJpY0luID0gZnVuY3Rpb24gY3ViaWNJbihrKSB7XG4gIHJldHVybiBrICogayAqIGs7XG59O1xudmFyIGN1YmljT3V0ID0gZnVuY3Rpb24gY3ViaWNPdXQoaykge1xuICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xufTtcbnZhciBjdWJpY0luT3V0ID0gZnVuY3Rpb24gY3ViaWNJbk91dChrKSB7XG4gIGlmICgoayAqPSAyKSA8IDEpIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xufTtcbnZhciBlYXNpbmdzID0ge1xuICBsaW5lYXI6IGxpbmVhcixcbiAgcXVhZHJhdGljSW46IHF1YWRyYXRpY0luLFxuICBxdWFkcmF0aWNPdXQ6IHF1YWRyYXRpY091dCxcbiAgcXVhZHJhdGljSW5PdXQ6IHF1YWRyYXRpY0luT3V0LFxuICBjdWJpY0luOiBjdWJpY0luLFxuICBjdWJpY091dDogY3ViaWNPdXQsXG4gIGN1YmljSW5PdXQ6IGN1YmljSW5PdXRcbn07XG5cbi8qKlxuICogRGVmYXVsdHMuXG4gKi9cblxudmFyIEFOSU1BVEVfREVGQVVMVFMgPSB7XG4gIGVhc2luZzogXCJxdWFkcmF0aWNJbk91dFwiLFxuICBkdXJhdGlvbjogMTUwXG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gYW5pbWF0ZSB0aGUgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGVOb2RlcyhncmFwaCwgdGFyZ2V0cywgb3B0cywgY2FsbGJhY2spIHtcbiAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBBTklNQVRFX0RFRkFVTFRTLCBvcHRzKTtcbiAgdmFyIGVhc2luZyA9IHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5lYXNpbmcgOiBlYXNpbmdzW29wdGlvbnMuZWFzaW5nXTtcbiAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgdmFyIHN0YXJ0UG9zaXRpb25zID0ge307XG4gIGZvciAodmFyIG5vZGUgaW4gdGFyZ2V0cykge1xuICAgIHZhciBhdHRycyA9IHRhcmdldHNbbm9kZV07XG4gICAgc3RhcnRQb3NpdGlvbnNbbm9kZV0gPSB7fTtcbiAgICBmb3IgKHZhciBfayBpbiBhdHRycykgc3RhcnRQb3NpdGlvbnNbbm9kZV1bX2tdID0gZ3JhcGguZ2V0Tm9kZUF0dHJpYnV0ZShub2RlLCBfayk7XG4gIH1cbiAgdmFyIGZyYW1lID0gbnVsbDtcbiAgdmFyIF9zdGVwID0gZnVuY3Rpb24gc3RlcCgpIHtcbiAgICBmcmFtZSA9IG51bGw7XG4gICAgdmFyIHAgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIG9wdGlvbnMuZHVyYXRpb247XG4gICAgaWYgKHAgPj0gMSkge1xuICAgICAgLy8gQW5pbWF0aW9uIGlzIGRvbmVcbiAgICAgIGZvciAodmFyIF9ub2RlIGluIHRhcmdldHMpIHtcbiAgICAgICAgdmFyIF9hdHRycyA9IHRhcmdldHNbX25vZGVdO1xuXG4gICAgICAgIC8vIFdlIHVzZSBnaXZlbiB2YWx1ZXMgdG8gYXZvaWQgcHJlY2lzaW9uIGlzc3VlcyBhbmQgZm9yIGNvbnZlbmllbmNlXG4gICAgICAgIGZvciAodmFyIF9rMiBpbiBfYXR0cnMpIGdyYXBoLnNldE5vZGVBdHRyaWJ1dGUoX25vZGUsIF9rMiwgX2F0dHJzW19rMl0pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwID0gZWFzaW5nKHApO1xuICAgIGZvciAodmFyIF9ub2RlMiBpbiB0YXJnZXRzKSB7XG4gICAgICB2YXIgX2F0dHJzMiA9IHRhcmdldHNbX25vZGUyXTtcbiAgICAgIHZhciBzID0gc3RhcnRQb3NpdGlvbnNbX25vZGUyXTtcbiAgICAgIGZvciAodmFyIF9rMyBpbiBfYXR0cnMyKSBncmFwaC5zZXROb2RlQXR0cmlidXRlKF9ub2RlMiwgX2szLCBfYXR0cnMyW19rM10gKiBwICsgc1tfazNdICogKDEgLSBwKSk7XG4gICAgfVxuICAgIGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9zdGVwKTtcbiAgfTtcbiAgX3N0ZXAoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZnJhbWUpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoKSB7XG4gIHJldHVybiBGbG9hdDMyQXJyYXkub2YoMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSk7XG59XG5cbi8vIFRPRE86IG9wdGltaXplXG5mdW5jdGlvbiBzY2FsZShtLCB4LCB5KSB7XG4gIG1bMF0gPSB4O1xuICBtWzRdID0gdHlwZW9mIHkgPT09IFwibnVtYmVyXCIgPyB5IDogeDtcbiAgcmV0dXJuIG07XG59XG5mdW5jdGlvbiByb3RhdGUobSwgcikge1xuICB2YXIgcyA9IE1hdGguc2luKHIpLFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcbiAgbVswXSA9IGM7XG4gIG1bMV0gPSBzO1xuICBtWzNdID0gLXM7XG4gIG1bNF0gPSBjO1xuICByZXR1cm4gbTtcbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZShtLCB4LCB5KSB7XG4gIG1bNl0gPSB4O1xuICBtWzddID0geTtcbiAgcmV0dXJuIG07XG59XG5mdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgIGEwMSA9IGFbMV0sXG4gICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgYTExID0gYVs0XSxcbiAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICBhMjEgPSBhWzddLFxuICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDAgPSBiWzBdLFxuICAgIGIwMSA9IGJbMV0sXG4gICAgYjAyID0gYlsyXTtcbiAgdmFyIGIxMCA9IGJbM10sXG4gICAgYjExID0gYls0XSxcbiAgICBiMTIgPSBiWzVdO1xuICB2YXIgYjIwID0gYls2XSxcbiAgICBiMjEgPSBiWzddLFxuICAgIGIyMiA9IGJbOF07XG4gIGFbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gIGFbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gIGFbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG4gIGFbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gIGFbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gIGFbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG4gIGFbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gIGFbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gIGFbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gbXVsdGlwbHlWZWMyKGEsIGIpIHtcbiAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHZhciBhMDAgPSBhWzBdO1xuICB2YXIgYTAxID0gYVsxXTtcbiAgdmFyIGExMCA9IGFbM107XG4gIHZhciBhMTEgPSBhWzRdO1xuICB2YXIgYTIwID0gYVs2XTtcbiAgdmFyIGEyMSA9IGFbN107XG4gIHZhciBiMCA9IGIueDtcbiAgdmFyIGIxID0gYi55O1xuICByZXR1cm4ge1xuICAgIHg6IGIwICogYTAwICsgYjEgKiBhMTAgKyBhMjAgKiB6LFxuICAgIHk6IGIwICogYTAxICsgYjEgKiBhMTEgKyBhMjEgKiB6XG4gIH07XG59XG5cbi8qKlxuICogSW4gc2lnbWEsIHRoZSBncmFwaCBpcyBub3JtYWxpemVkIGludG8gYSBbMCwgMV0sIFswLCAxXSBzcXVhcmUsIGJlZm9yZSBiZWluZyBnaXZlbiB0byB0aGUgdmFyaW91cyByZW5kZXJlcnMuIFRoaXNcbiAqIGhlbHBzIHRvIGRlYWwgd2l0aCBxdWFkdHJlZSBpbiBwYXJ0aWN1bGFyLlxuICogQnV0IGF0IHNvbWUgcG9pbnQsIHdlIG5lZWQgdG8gcmVzY2FsZSBpdCBzbyB0aGF0IGl0IHRha2VzIHRoZSBiZXN0IHBsYWNlIGluIHRoZSBzY3JlZW4sIGkuZS4gd2UgYWx3YXlzIHdhbnQgdG8gc2VlIHR3b1xuICogbm9kZXMgXCJ0b3VjaGluZ1wiIG9wcG9zaXRlIHNpZGVzIG9mIHRoZSBncmFwaCwgd2l0aCB0aGUgY2FtZXJhIGJlaW5nIGF0IGl0cyBkZWZhdWx0IHN0YXRlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyB0aGlzIHJhdGlvLlxuICovXG5mdW5jdGlvbiBnZXRDb3JyZWN0aW9uUmF0aW8odmlld3BvcnREaW1lbnNpb25zLCBncmFwaERpbWVuc2lvbnMpIHtcbiAgdmFyIHZpZXdwb3J0UmF0aW8gPSB2aWV3cG9ydERpbWVuc2lvbnMuaGVpZ2h0IC8gdmlld3BvcnREaW1lbnNpb25zLndpZHRoO1xuICB2YXIgZ3JhcGhSYXRpbyA9IGdyYXBoRGltZW5zaW9ucy5oZWlnaHQgLyBncmFwaERpbWVuc2lvbnMud2lkdGg7XG5cbiAgLy8gSWYgdGhlIHN0YWdlIGFuZCB0aGUgZ3JhcGhzIGFyZSBpbiBkaWZmZXJlbnQgZGlyZWN0aW9ucyAoc3VjaCBhcyB0aGUgZ3JhcGggYmVpbmcgd2lkZXIgdGhhdCB0YWxsIHdoaWxlIHRoZSBzdGFnZVxuICAvLyBpcyB0YWxsZXIgdGhhbiB3aWRlKSwgd2UgY2FuIHN0b3AgaGVyZSB0byBoYXZlIGluZGVlZCBub2RlcyB0b3VjaGluZyBvcHBvc2l0ZSBzaWRlczpcbiAgaWYgKHZpZXdwb3J0UmF0aW8gPCAxICYmIGdyYXBoUmF0aW8gPiAxIHx8IHZpZXdwb3J0UmF0aW8gPiAxICYmIGdyYXBoUmF0aW8gPCAxKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvLyBFbHNlLCB3ZSBuZWVkIHRvIGZpdCB0aGUgZ3JhcGggaW5zaWRlIHRoZSBzdGFnZTpcbiAgLy8gMS4gSWYgdGhlIGdyYXBoIGlzIFwic3F1YXJlclwiIChpLmUuIHdpdGggYSByYXRpbyBjbG9zZXIgdG8gMSksIHdlIG5lZWQgdG8gbWFrZSB0aGUgbGFyZ2VzdCBzaWRlcyB0b3VjaDtcbiAgLy8gMi4gSWYgdGhlIHN0YWdlIGlzIFwic3F1YXJlclwiLCB3ZSBuZWVkIHRvIG1ha2UgdGhlIHNtYWxsZXN0IHNpZGVzIHRvdWNoLlxuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZ3JhcGhSYXRpbywgMSAvIGdyYXBoUmF0aW8pLCBNYXRoLm1heCgxIC8gdmlld3BvcnRSYXRpbywgdmlld3BvcnRSYXRpbykpO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyBhIG1hdHJpeCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjYW1lcmEuXG4gKi9cbmZ1bmN0aW9uIG1hdHJpeEZyb21DYW1lcmEoc3RhdGUsIHZpZXdwb3J0RGltZW5zaW9ucywgZ3JhcGhEaW1lbnNpb25zLCBwYWRkaW5nLCBpbnZlcnNlKSB7XG4gIC8vIFRPRE86IGl0J3MgcG9zc2libGUgdG8gb3B0aW1pemUgdGhpcyBkcmFzdGljYWxseSFcbiAgdmFyIGFuZ2xlID0gc3RhdGUuYW5nbGUsXG4gICAgcmF0aW8gPSBzdGF0ZS5yYXRpbyxcbiAgICB4ID0gc3RhdGUueCxcbiAgICB5ID0gc3RhdGUueTtcbiAgdmFyIHdpZHRoID0gdmlld3BvcnREaW1lbnNpb25zLndpZHRoLFxuICAgIGhlaWdodCA9IHZpZXdwb3J0RGltZW5zaW9ucy5oZWlnaHQ7XG4gIHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuICB2YXIgc21hbGxlc3REaW1lbnNpb24gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAtIDIgKiBwYWRkaW5nO1xuICB2YXIgY29ycmVjdGlvblJhdGlvID0gZ2V0Q29ycmVjdGlvblJhdGlvKHZpZXdwb3J0RGltZW5zaW9ucywgZ3JhcGhEaW1lbnNpb25zKTtcbiAgaWYgKCFpbnZlcnNlKSB7XG4gICAgbXVsdGlwbHkobWF0cml4LCBzY2FsZShpZGVudGl0eSgpLCAyICogKHNtYWxsZXN0RGltZW5zaW9uIC8gd2lkdGgpICogY29ycmVjdGlvblJhdGlvLCAyICogKHNtYWxsZXN0RGltZW5zaW9uIC8gaGVpZ2h0KSAqIGNvcnJlY3Rpb25SYXRpbykpO1xuICAgIG11bHRpcGx5KG1hdHJpeCwgcm90YXRlKGlkZW50aXR5KCksIC1hbmdsZSkpO1xuICAgIG11bHRpcGx5KG1hdHJpeCwgc2NhbGUoaWRlbnRpdHkoKSwgMSAvIHJhdGlvKSk7XG4gICAgbXVsdGlwbHkobWF0cml4LCB0cmFuc2xhdGUoaWRlbnRpdHkoKSwgLXgsIC15KSk7XG4gIH0gZWxzZSB7XG4gICAgbXVsdGlwbHkobWF0cml4LCB0cmFuc2xhdGUoaWRlbnRpdHkoKSwgeCwgeSkpO1xuICAgIG11bHRpcGx5KG1hdHJpeCwgc2NhbGUoaWRlbnRpdHkoKSwgcmF0aW8pKTtcbiAgICBtdWx0aXBseShtYXRyaXgsIHJvdGF0ZShpZGVudGl0eSgpLCBhbmdsZSkpO1xuICAgIG11bHRpcGx5KG1hdHJpeCwgc2NhbGUoaWRlbnRpdHkoKSwgd2lkdGggLyBzbWFsbGVzdERpbWVuc2lvbiAvIDIgLyBjb3JyZWN0aW9uUmF0aW8sIGhlaWdodCAvIHNtYWxsZXN0RGltZW5zaW9uIC8gMiAvIGNvcnJlY3Rpb25SYXRpbykpO1xuICB9XG4gIHJldHVybiBtYXRyaXg7XG59XG5cbi8qKlxuICogQWxsIHRoZXNlIHRyYW5zZm9ybWF0aW9ucyB3ZSBhcHBseSBvbiB0aGUgbWF0cml4IHRvIGdldCBpdCByZXNjYWxlIHRoZSBncmFwaFxuICogYXMgd2Ugd2FudCBtYWtlIGl0IHZlcnkgaGFyZCB0byBnZXQgcGl4ZWwtcGVyZmVjdCBkaXN0YW5jZXMgaW4gV2ViR0wuIFRoaXNcbiAqIGZ1bmN0aW9uIHJldHVybnMgYSBmYWN0b3IgdGhhdCBwcm9wZXJseSBjYW5jZWxzIHRoZSBtYXRyaXggZWZmZWN0IG9uIGxlbmd0aHMuXG4gKlxuICogW2phY29teWFsXVxuICogVG8gYmUgZnVsbHkgaG9uZXN0LCBJIGNhbid0IHJlYWxseSBleHBsYWluIGhhcHBlbnMgaGVyZS4uLiBJIG5vdGljZSB0aGF0IHRoZVxuICogZm9sbG93aW5nIHJhdGlvIHdvcmtzIChpLmUuIGl0IGNvcnJlY3RseSBjb21wZW5zYXRlcyB0aGUgbWF0cml4IGltcGFjdCBvbiBhbGxcbiAqIGNhbWVyYSBzdGF0ZXMgSSBjb3VsZCB0cnkpOlxuICogPiBgUiA9IHNpemUoVikgLyBzaXplKE0gKiBWKSAvIFdgXG4gKiBhcyBsb25nIGFzIGBNICogVmAgaXMgaW4gdGhlIGRpcmVjdGlvbiBvZiBXIChpZS4gcGFyYWxsZWwgdG8gKE94KSkuIEl0IHdvcmtzXG4gKiBhcyB3ZWxsIHdpdGggSCBhbmQgYSB2ZWN0b3IgdGhhdCB0cmFuc2Zvcm1zIGludG8gc29tZXRoaW5nIHBhcmFsbGVsIHRvIChPeSkuXG4gKlxuICogQWxzbywgbm90ZSB0aGF0IHdlIHVzZSBgYW5nbGVgIGFuZCBub3QgYC1hbmdsZWAgKHRoYXQgd291bGQgc2VlbSBsb2dpY2FsLFxuICogc2luY2Ugd2Ugd2FudCB0byBhbnRpY2lwYXRlIHRoZSByb3RhdGlvbiksIGJlY2F1c2UgdGhlIGltYWdlIGlzIHZlcnRpY2FsbHlcbiAqIHN3YXBwZWQgaW4gV2ViR0wuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdHJpeEltcGFjdChtYXRyaXgsIGNhbWVyYVN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMpIHtcbiAgdmFyIF9tdWx0aXBseVZlYyA9IG11bHRpcGx5VmVjMihtYXRyaXgsIHtcbiAgICAgIHg6IE1hdGguY29zKGNhbWVyYVN0YXRlLmFuZ2xlKSxcbiAgICAgIHk6IE1hdGguc2luKGNhbWVyYVN0YXRlLmFuZ2xlKVxuICAgIH0sIDApLFxuICAgIHggPSBfbXVsdGlwbHlWZWMueCxcbiAgICB5ID0gX211bHRpcGx5VmVjLnk7XG4gIHJldHVybiAxIC8gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpIC8gdmlld3BvcnREaW1lbnNpb25zLndpZHRoO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyB0aGUgZ3JhcGgncyBub2RlIGV4dGVudCBpbiB4ICYgeS5cbiAqL1xuZnVuY3Rpb24gZ3JhcGhFeHRlbnQoZ3JhcGgpIHtcbiAgaWYgKCFncmFwaC5vcmRlcikgcmV0dXJuIHtcbiAgICB4OiBbMCwgMV0sXG4gICAgeTogWzAsIDFdXG4gIH07XG4gIHZhciB4TWluID0gSW5maW5pdHk7XG4gIHZhciB4TWF4ID0gLUluZmluaXR5O1xuICB2YXIgeU1pbiA9IEluZmluaXR5O1xuICB2YXIgeU1heCA9IC1JbmZpbml0eTtcbiAgZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKF8sIGF0dHIpIHtcbiAgICB2YXIgeCA9IGF0dHIueCxcbiAgICAgIHkgPSBhdHRyLnk7XG4gICAgaWYgKHggPCB4TWluKSB4TWluID0geDtcbiAgICBpZiAoeCA+IHhNYXgpIHhNYXggPSB4O1xuICAgIGlmICh5IDwgeU1pbikgeU1pbiA9IHk7XG4gICAgaWYgKHkgPiB5TWF4KSB5TWF4ID0geTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgeDogW3hNaW4sIHhNYXhdLFxuICAgIHk6IFt5TWluLCB5TWF4XVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBncmFwaCB2YXJpYWJsZSBpcyBhIHZhbGlkIGdyYXBoLCBhbmQgaWYgc2lnbWEgY2FuIHJlbmRlciBpdC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVHcmFwaChncmFwaCkge1xuICAvLyBjaGVjayBpZiBpdCdzIGEgdmFsaWQgZ3JhcGhvbG9neSBpbnN0YW5jZVxuICBpZiAoIWlzR3JhcGgoZ3JhcGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogaW52YWxpZCBncmFwaCBpbnN0YW5jZS5cIik7XG5cbiAgLy8gY2hlY2sgaWYgbm9kZXMgaGF2ZSB4L3kgYXR0cmlidXRlc1xuICBncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAoa2V5LCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYXR0cmlidXRlcy54KSB8fCAhTnVtYmVyLmlzRmluaXRlKGF0dHJpYnV0ZXMueSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBDb29yZGluYXRlcyBvZiBub2RlIFwiLmNvbmNhdChrZXksIFwiIGFyZSBpbnZhbGlkLiBBIG5vZGUgbXVzdCBoYXZlIGEgbnVtZXJpYyAneCcgYW5kICd5JyBhdHRyaWJ1dGUuXCIpKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIERPTSBlbGVtZW50cyBlYXNpbHkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBzdHlsZSwgYXR0cmlidXRlcykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHN0eWxlKSB7XG4gICAgZm9yICh2YXIgayBpbiBzdHlsZSkge1xuICAgICAgZWxlbWVudC5zdHlsZVtrXSA9IHN0eWxlW2tdO1xuICAgIH1cbiAgfVxuICBpZiAoYXR0cmlidXRlcykge1xuICAgIGZvciAodmFyIF9rIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKF9rLCBhdHRyaWJ1dGVzW19rXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyB0aGUgYnJvd3NlcidzIHBpeGVsIHJhdGlvLlxuICovXG5mdW5jdGlvbiBnZXRQaXhlbFJhdGlvKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIHJldHVybiAxO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIG9yZGVyaW5nIHRoZSBnaXZlbiBlbGVtZW50cyBpbiByZXZlcnNlIHotb3JkZXIgc28gdGhleSBkcmF3blxuICogdGhlIGNvcnJlY3Qgd2F5LlxuICovXG5mdW5jdGlvbiB6SW5kZXhPcmRlcmluZyhfZXh0ZW50LCBnZXR0ZXIsIGVsZW1lbnRzKSB7XG4gIC8vIElmIGsgaXMgPiBuLCB3ZSdsbCB1c2UgYSBzdGFuZGFyZCBzb3J0XG4gIHJldHVybiBlbGVtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHpBID0gZ2V0dGVyKGEpIHx8IDAsXG4gICAgICB6QiA9IGdldHRlcihiKSB8fCAwO1xuICAgIGlmICh6QSA8IHpCKSByZXR1cm4gLTE7XG4gICAgaWYgKHpBID4gekIpIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xuICB9KTtcblxuICAvLyBUT0RPOiBjb3VudGluZyBzb3J0IG9wdGltaXphdGlvblxufVxuXG4vKipcbiAqIEZhY3RvcnkgcmV0dXJuaW5nIGEgZnVuY3Rpb24gbm9ybWFsaXppbmcgdGhlIGdpdmVuIG5vZGUncyBwb3NpdGlvbiAmIHNpemUuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uKGV4dGVudCkge1xuICB2YXIgX2V4dGVudCR4ID0gX3NsaWNlZFRvQXJyYXkoZXh0ZW50LngsIDIpLFxuICAgIG1pblggPSBfZXh0ZW50JHhbMF0sXG4gICAgbWF4WCA9IF9leHRlbnQkeFsxXSxcbiAgICBfZXh0ZW50JHkgPSBfc2xpY2VkVG9BcnJheShleHRlbnQueSwgMiksXG4gICAgbWluWSA9IF9leHRlbnQkeVswXSxcbiAgICBtYXhZID0gX2V4dGVudCR5WzFdO1xuICB2YXIgcmF0aW8gPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpLFxuICAgIGRYID0gKG1heFggKyBtaW5YKSAvIDIsXG4gICAgZFkgPSAobWF4WSArIG1pblkpIC8gMjtcbiAgaWYgKHJhdGlvID09PSAwIHx8IE1hdGguYWJzKHJhdGlvKSA9PT0gSW5maW5pdHkgfHwgaXNOYU4ocmF0aW8pKSByYXRpbyA9IDE7XG4gIGlmIChpc05hTihkWCkpIGRYID0gMDtcbiAgaWYgKGlzTmFOKGRZKSkgZFkgPSAwO1xuICB2YXIgZm4gPSBmdW5jdGlvbiBmbihkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAuNSArIChkYXRhLnggLSBkWCkgLyByYXRpbyxcbiAgICAgIHk6IDAuNSArIChkYXRhLnkgLSBkWSkgLyByYXRpb1xuICAgIH07XG4gIH07XG5cbiAgLy8gVE9ETzogcG9zc2liaWxpdHkgdG8gYXBwbHkgdGhpcyBpbiBiYXRjaCBvdmVyIGFycmF5IG9mIGluZGljZXNcbiAgZm4uYXBwbHlUbyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGF0YS54ID0gMC41ICsgKGRhdGEueCAtIGRYKSAvIHJhdGlvO1xuICAgIGRhdGEueSA9IDAuNSArIChkYXRhLnkgLSBkWSkgLyByYXRpbztcbiAgfTtcbiAgZm4uaW52ZXJzZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGRYICsgcmF0aW8gKiAoZGF0YS54IC0gMC41KSxcbiAgICAgIHk6IGRZICsgcmF0aW8gKiAoZGF0YS55IC0gMC41KVxuICAgIH07XG4gIH07XG4gIGZuLnJhdGlvID0gcmF0aW87XG4gIHJldHVybiBmbjtcbn1cblxuZXhwb3J0IHsgQU5JTUFURV9ERUZBVUxUUyBhcyBBLCBnZXRNYXRyaXhJbXBhY3QgYXMgYSwgY3JlYXRlRWxlbWVudCBhcyBiLCBjcmVhdGVOb3JtYWxpemF0aW9uRnVuY3Rpb24gYXMgYywgZ2V0UGl4ZWxSYXRpbyBhcyBkLCBlYXNpbmdzIGFzIGUsIG11bHRpcGx5VmVjMiBhcyBmLCBncmFwaEV4dGVudCBhcyBnLCBhbmltYXRlTm9kZXMgYXMgaCwgaWRlbnRpdHkgYXMgaSwgZ2V0Q29ycmVjdGlvblJhdGlvIGFzIGosIHF1YWRyYXRpY091dCBhcyBrLCBsaW5lYXIgYXMgbCwgbWF0cml4RnJvbUNhbWVyYSBhcyBtLCBxdWFkcmF0aWNJbk91dCBhcyBuLCBjdWJpY0luIGFzIG8sIGN1YmljT3V0IGFzIHAsIHF1YWRyYXRpY0luIGFzIHEsIGN1YmljSW5PdXQgYXMgciwgc2NhbGUgYXMgcywgcm90YXRlIGFzIHQsIHRyYW5zbGF0ZSBhcyB1LCB2YWxpZGF0ZUdyYXBoIGFzIHYsIG11bHRpcGx5IGFzIHcsIHpJbmRleE9yZGVyaW5nIGFzIHogfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/sigma/dist/normalization-be445518.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/sigma/dist/sigma.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/sigma/dist/sigma.esm.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: () => (/* binding */ Camera),\n/* harmony export */   MouseCaptor: () => (/* binding */ MouseCaptor),\n/* harmony export */   Sigma: () => (/* binding */ Sigma$1),\n/* harmony export */   TouchCaptor: () => (/* binding */ TouchCaptor),\n/* harmony export */   \"default\": () => (/* binding */ Sigma)\n/* harmony export */ });\n/* harmony import */ var _index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-236c62ad.esm.js */ \"(app-pages-browser)/./node_modules/sigma/dist/index-236c62ad.esm.js\");\n/* harmony import */ var _inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./inherits-d1a1e29b.esm.js */ \"(app-pages-browser)/./node_modules/sigma/dist/inherits-d1a1e29b.esm.js\");\n/* harmony import */ var _types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/dist/sigma-types.esm.js */ \"(app-pages-browser)/./node_modules/sigma/types/dist/sigma-types.esm.js\");\n/* harmony import */ var _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./normalization-be445518.esm.js */ \"(app-pages-browser)/./node_modules/sigma/dist/normalization-be445518.esm.js\");\n/* harmony import */ var _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings/dist/sigma-settings.esm.js */ \"(app-pages-browser)/./node_modules/sigma/settings/dist/sigma-settings.esm.js\");\n/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ \"(app-pages-browser)/./node_modules/sigma/dist/colors-beb06eb2.esm.js\");\n/* harmony import */ var _data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./data-11df7124.esm.js */ \"(app-pages-browser)/./node_modules/sigma/dist/data-11df7124.esm.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"(app-pages-browser)/./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! graphology-utils/is-graph */ \"(app-pages-browser)/./node_modules/graphology-utils/is-graph.js\");\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n\n\n\n\n\n/**\n * Defaults.\n */\nvar DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\n/**\n * Camera class\n */\nvar Camera = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Camera() {\n    var _this;\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Camera);\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Camera);\n\n    // State\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"x\", 0.5);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"y\", 0.5);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"angle\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"ratio\", 1);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"minRatio\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"maxRatio\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabledZooming\", true);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabledPanning\", true);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabledRotation\", true);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"clean\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nextFrame\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"previousState\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabled\", true);\n    _this.previousState = _this.getState();\n    return _this;\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   */\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Camera, _TypedEventEmitter);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Camera, [{\n    key: \"enable\",\n    value:\n    /**\n     * Method used to enable the camera.\n     */\n    function enable() {\n      this.enabled = true;\n      return this;\n    }\n\n    /**\n     * Method used to disable the camera.\n     */\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n\n    /**\n     * Method used to retrieve the camera's current state.\n     */\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return {\n        x: this.x,\n        y: this.y,\n        angle: this.angle,\n        ratio: this.ratio\n      };\n    }\n\n    /**\n     * Method used to check whether the camera has the given state.\n     */\n  }, {\n    key: \"hasState\",\n    value: function hasState(state) {\n      return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n    }\n\n    /**\n     * Method used to retrieve the camera's previous state.\n     */\n  }, {\n    key: \"getPreviousState\",\n    value: function getPreviousState() {\n      var state = this.previousState;\n      if (!state) return null;\n      return {\n        x: state.x,\n        y: state.y,\n        angle: state.angle,\n        ratio: state.ratio\n      };\n    }\n\n    /**\n     * Method used to check minRatio and maxRatio values.\n     */\n  }, {\n    key: \"getBoundedRatio\",\n    value: function getBoundedRatio(ratio) {\n      var r = ratio;\n      if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n      if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n      return r;\n    }\n\n    /**\n     * Method used to check various things to return a legit state candidate.\n     */\n  }, {\n    key: \"validateState\",\n    value: function validateState(state) {\n      var validatedState = {};\n      if (this.enabledPanning && typeof state.x === \"number\") validatedState.x = state.x;\n      if (this.enabledPanning && typeof state.y === \"number\") validatedState.y = state.y;\n      if (this.enabledZooming && typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n      if (this.enabledRotation && typeof state.angle === \"number\") validatedState.angle = state.angle;\n      return this.clean ? this.clean((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.getState()), validatedState)) : validatedState;\n    }\n\n    /**\n     * Method used to check whether the camera is currently being animated.\n     */\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return !!this.nextFrame;\n    }\n\n    /**\n     * Method used to set the camera's state.\n     */\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      if (!this.enabled) return this;\n\n      // Keeping track of last state\n      this.previousState = this.getState();\n      var validState = this.validateState(state);\n      if (typeof validState.x === \"number\") this.x = validState.x;\n      if (typeof validState.y === \"number\") this.y = validState.y;\n      if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n      if (typeof validState.angle === \"number\") this.angle = validState.angle;\n\n      // Emitting\n      if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n      return this;\n    }\n\n    /**\n     * Method used to update the camera's state using a function.\n     */\n  }, {\n    key: \"updateState\",\n    value: function updateState(updater) {\n      this.setState(updater(this.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to animate the camera.\n     */\n  }, {\n    key: \"animate\",\n    value: function animate(state) {\n      var _this2 = this;\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      if (!callback) return new Promise(function (resolve) {\n        return _this2.animate(state, opts, resolve);\n      });\n      if (!this.enabled) return;\n      var options = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.A), opts);\n      var validState = this.validateState(state);\n      var easing = typeof options.easing === \"function\" ? options.easing : _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.e[options.easing];\n\n      // State\n      var start = Date.now(),\n        initialState = this.getState();\n\n      // Function performing the animation\n      var _fn = function fn() {\n        var t = (Date.now() - start) / options.duration;\n\n        // The animation is over:\n        if (t >= 1) {\n          _this2.nextFrame = null;\n          _this2.setState(validState);\n          if (_this2.animationCallback) {\n            _this2.animationCallback.call(null);\n            _this2.animationCallback = undefined;\n          }\n          return;\n        }\n        var coefficient = easing(t);\n        var newState = {};\n        if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n        if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n        if (_this2.enabledRotation && typeof validState.angle === \"number\") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n        if (typeof validState.ratio === \"number\") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n        _this2.setState(newState);\n        _this2.nextFrame = requestAnimationFrame(_fn);\n      };\n      if (this.nextFrame) {\n        cancelAnimationFrame(this.nextFrame);\n        if (this.animationCallback) this.animationCallback.call(null);\n        this.nextFrame = requestAnimationFrame(_fn);\n      } else {\n        _fn();\n      }\n      this.animationCallback = callback;\n    }\n\n    /**\n     * Method used to zoom the camera.\n     */\n  }, {\n    key: \"animatedZoom\",\n    value: function animatedZoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio / factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to unzoom the camera.\n     */\n  }, {\n    key: \"animatedUnzoom\",\n    value: function animatedUnzoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio * factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to reset the camera.\n     */\n  }, {\n    key: \"animatedReset\",\n    value: function animatedReset(options) {\n      return this.animate({\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0\n      }, options);\n    }\n\n    /**\n     * Returns a new Camera instance, with the same state as the current camera.\n     */\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return Camera.from(this.getState());\n    }\n  }], [{\n    key: \"from\",\n    value: function from(state) {\n      var camera = new Camera();\n      return camera.setState(state);\n    }\n  }]);\n}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nfunction getPosition(e, dom) {\n  var bbox = dom.getBoundingClientRect();\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getMouseCoords(e, dom) {\n  var res = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, getPosition(e, dom)), {}, {\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  });\n  return res;\n}\n\n/**\n * Takes a touch coords or a mouse coords, and always returns a clean mouse coords object.\n */\nfunction cleanMouseCoords(e) {\n  var res = \"x\" in e ? e : (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, e.touches[0] || e.previousTouches[0]), {}, {\n    original: e.original,\n    sigmaDefaultPrevented: e.sigmaDefaultPrevented,\n    preventSigmaDefault: function preventSigmaDefault() {\n      e.sigmaDefaultPrevented = true;\n      res.sigmaDefaultPrevented = true;\n    }\n  });\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getWheelCoords(e, dom) {\n  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, getMouseCoords(e, dom)), {}, {\n    delta: getWheelDelta(e)\n  });\n}\nvar MAX_TOUCHES = 2;\nfunction getTouchesArray(touches) {\n  var arr = [];\n  for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e               - A touch event.\n * @param  {Touch[]}     previousTouches - An array of the previously stored touches.\n * @param  {HTMLElement} dom             - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getTouchCoords(e, previousTouches, dom) {\n  var res = {\n    touches: getTouchesArray(e.touches).map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    previousTouches: previousTouches.map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  };\n  return res;\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nfunction getWheelDelta(e) {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return e.deltaY * -3 / 360;\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nvar Captor = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Captor(container, renderer) {\n    var _this;\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Captor);\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Captor);\n    // Properties\n    _this.container = container;\n    _this.renderer = renderer;\n    return _this;\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Captor, _TypedEventEmitter);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Captor);\n}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);\n\nvar MOUSE_SETTINGS_KEYS = [\"doubleClickTimeout\", \"doubleClickZoomingDuration\", \"doubleClickZoomingRatio\", \"dragTimeout\", \"draggedEventsTolerance\", \"inertiaDuration\", \"inertiaRatio\", \"zoomDuration\", \"zoomingRatio\"];\nvar DEFAULT_MOUSE_SETTINGS = MOUSE_SETTINGS_KEYS.reduce(function (iter, key) {\n  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, iter), {}, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, key, _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nvar MouseCaptor = /*#__PURE__*/function (_Captor) {\n  function MouseCaptor(container, renderer) {\n    var _this;\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, MouseCaptor);\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, MouseCaptor, [container, renderer]);\n\n    // Binding methods\n    // State\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabled\", true);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"draggedEvents\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"downStartTime\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"lastMouseX\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"lastMouseY\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"isMouseDown\", false);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"isMoving\", false);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"movingTimeout\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"startCameraState\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"clicks\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"doubleClickTimeout\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"currentWheelDirection\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"settings\", DEFAULT_MOUSE_SETTINGS);\n    _this.handleClick = _this.handleClick.bind(_this);\n    _this.handleRightClick = _this.handleRightClick.bind(_this);\n    _this.handleDown = _this.handleDown.bind(_this);\n    _this.handleUp = _this.handleUp.bind(_this);\n    _this.handleMove = _this.handleMove.bind(_this);\n    _this.handleWheel = _this.handleWheel.bind(_this);\n    _this.handleLeave = _this.handleLeave.bind(_this);\n    _this.handleEnter = _this.handleEnter.bind(_this);\n\n    // Binding events\n    container.addEventListener(\"click\", _this.handleClick, {\n      capture: false\n    });\n    container.addEventListener(\"contextmenu\", _this.handleRightClick, {\n      capture: false\n    });\n    container.addEventListener(\"mousedown\", _this.handleDown, {\n      capture: false\n    });\n    container.addEventListener(\"wheel\", _this.handleWheel, {\n      capture: false\n    });\n    container.addEventListener(\"mouseleave\", _this.handleLeave, {\n      capture: false\n    });\n    container.addEventListener(\"mouseenter\", _this.handleEnter, {\n      capture: false\n    });\n    document.addEventListener(\"mousemove\", _this.handleMove, {\n      capture: false\n    });\n    document.addEventListener(\"mouseup\", _this.handleUp, {\n      capture: false\n    });\n    return _this;\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(MouseCaptor, _Captor);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(MouseCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"click\", this.handleClick);\n      container.removeEventListener(\"contextmenu\", this.handleRightClick);\n      container.removeEventListener(\"mousedown\", this.handleDown);\n      container.removeEventListener(\"wheel\", this.handleWheel);\n      container.removeEventListener(\"mouseleave\", this.handleLeave);\n      container.removeEventListener(\"mouseenter\", this.handleEnter);\n      document.removeEventListener(\"mousemove\", this.handleMove);\n      document.removeEventListener(\"mouseup\", this.handleUp);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      this.clicks++;\n      if (this.clicks === 2) {\n        this.clicks = 0;\n        if (typeof this.doubleClickTimeout === \"number\") {\n          clearTimeout(this.doubleClickTimeout);\n          this.doubleClickTimeout = null;\n        }\n        return this.handleDoubleClick(e);\n      }\n      setTimeout(function () {\n        _this2.clicks = 0;\n        _this2.doubleClickTimeout = null;\n      }, this.settings.doubleClickTimeout);\n\n      // NOTE: this is here to prevent click events on drag\n      if (this.draggedEvents < this.settings.draggedEventsTolerance) this.emit(\"click\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleRightClick\",\n    value: function handleRightClick(e) {\n      if (!this.enabled) return;\n      this.emit(\"rightClick\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(e) {\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var mouseCoords = getMouseCoords(e, this.container);\n      this.emit(\"doubleClick\", mouseCoords);\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // default behavior\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticInOut\",\n        duration: this.settings.doubleClickZoomingDuration\n      });\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(e) {\n      if (!this.enabled) return;\n\n      // We only start dragging on left button\n      if (e.button === 0) {\n        this.startCameraState = this.renderer.getCamera().getState();\n        var _getPosition = getPosition(e, this.container),\n          x = _getPosition.x,\n          y = _getPosition.y;\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n        this.draggedEvents = 0;\n        this.downStartTime = Date.now();\n        this.isMouseDown = true;\n      }\n      this.emit(\"mousedown\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.isMouseDown) return;\n      var camera = this.renderer.getCamera();\n      this.isMouseDown = false;\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n        this.movingTimeout = null;\n      }\n      var _getPosition2 = getPosition(e, this.container),\n        x = _getPosition2.x,\n        y = _getPosition2.y;\n      var cameraState = camera.getState(),\n        previousCameraState = camera.getPreviousState() || {\n          x: 0,\n          y: 0\n        };\n      if (this.isMoving) {\n        camera.animate({\n          x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n        }, {\n          duration: this.settings.inertiaDuration,\n          easing: \"quadraticOut\"\n        });\n      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n        camera.setState({\n          x: cameraState.x,\n          y: cameraState.y\n        });\n      }\n      this.isMoving = false;\n      setTimeout(function () {\n        var shouldRefresh = _this3.draggedEvents > 0;\n        _this3.draggedEvents = 0;\n\n        // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n        // when someone releases camera pan drag after having stopped moving.\n        // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n        // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n        // It could be possible to render instead of scheduling a refresh but for\n        // now it seems good enough.\n        if (shouldRefresh && _this3.renderer.getSetting(\"hideEdgesOnMove\")) _this3.renderer.refresh();\n      }, 0);\n      this.emit(\"mouseup\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this4 = this;\n      if (!this.enabled) return;\n      var mouseCoords = getMouseCoords(e, this.container);\n\n      // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n      // a drag-and-drop effect that works even when the mouse is out of the\n      // container:\n      this.emit(\"mousemovebody\", mouseCoords);\n\n      // Only trigger the \"mousemove\" event when the mouse is actually hovering\n      // the container, to avoid weirdly hovering nodes and/or edges when the\n      // mouse is not hover the container:\n      if (e.target === this.container || e.composedPath()[0] === this.container) {\n        this.emit(\"mousemove\", mouseCoords);\n      }\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n      // stage while the mouse is not hover the container:\n      if (this.isMouseDown) {\n        this.isMoving = true;\n        this.draggedEvents++;\n        if (typeof this.movingTimeout === \"number\") {\n          clearTimeout(this.movingTimeout);\n        }\n        this.movingTimeout = window.setTimeout(function () {\n          _this4.movingTimeout = null;\n          _this4.isMoving = false;\n        }, this.settings.dragTimeout);\n        var camera = this.renderer.getCamera();\n        var _getPosition3 = getPosition(e, this.container),\n          eX = _getPosition3.x,\n          eY = _getPosition3.y;\n        var lastMouse = this.renderer.viewportToFramedGraph({\n          x: this.lastMouseX,\n          y: this.lastMouseY\n        });\n        var mouse = this.renderer.viewportToFramedGraph({\n          x: eX,\n          y: eY\n        });\n        var offsetX = lastMouse.x - mouse.x,\n          offsetY = lastMouse.y - mouse.y;\n        var cameraState = camera.getState();\n        var x = cameraState.x + offsetX,\n          y = cameraState.y + offsetY;\n        camera.setState({\n          x: x,\n          y: y\n        });\n        this.lastMouseX = eX;\n        this.lastMouseY = eY;\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      this.emit(\"mouseleave\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleEnter\",\n    value: function handleEnter(e) {\n      this.emit(\"mouseenter\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(e) {\n      var _this5 = this;\n      var camera = this.renderer.getCamera();\n      if (!this.enabled || !camera.enabledZooming) return;\n      var delta = getWheelDelta(e);\n      if (!delta) return;\n      var wheelCoords = getWheelCoords(e, this.container);\n      this.emit(\"wheel\", wheelCoords);\n      if (wheelCoords.sigmaDefaultPrevented) {\n        e.preventDefault();\n        e.stopPropagation();\n        return;\n      }\n\n      // Default behavior\n      var currentRatio = camera.getState().ratio;\n      var ratioDiff = delta > 0 ? 1 / this.settings.zoomingRatio : this.settings.zoomingRatio;\n      var newRatio = camera.getBoundedRatio(currentRatio * ratioDiff);\n      var wheelDirection = delta > 0 ? 1 : -1;\n      var now = Date.now();\n\n      // Exit early without preventing default behavior when ratio doesn't change:\n      if (currentRatio === newRatio) return;\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Cancel events that are too close each other and in the same direction:\n      if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < this.settings.zoomDuration / 5) {\n        return;\n      }\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticOut\",\n        duration: this.settings.zoomDuration\n      }, function () {\n        _this5.currentWheelDirection = 0;\n      });\n      this.currentWheelDirection = wheelDirection;\n      this.lastWheelTriggerTime = now;\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n}(Captor);\n\nvar TOUCH_SETTINGS_KEYS = [\"dragTimeout\", \"inertiaDuration\", \"inertiaRatio\", \"doubleClickTimeout\", \"doubleClickZoomingRatio\", \"doubleClickZoomingDuration\", \"tapMoveTolerance\"];\nvar DEFAULT_TOUCH_SETTINGS = TOUCH_SETTINGS_KEYS.reduce(function (iter, key) {\n  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, iter), {}, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, key, _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Touch captor class.\n *\n * @constructor\n */\nvar TouchCaptor = /*#__PURE__*/function (_Captor) {\n  function TouchCaptor(container, renderer) {\n    var _this;\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, TouchCaptor);\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, TouchCaptor, [container, renderer]);\n\n    // Binding methods:\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"enabled\", true);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"isMoving\", false);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"hasMoved\", false);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"touchMode\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"startTouchesPositions\", []);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"lastTouches\", []);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"lastTap\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"settings\", DEFAULT_TOUCH_SETTINGS);\n    _this.handleStart = _this.handleStart.bind(_this);\n    _this.handleLeave = _this.handleLeave.bind(_this);\n    _this.handleMove = _this.handleMove.bind(_this);\n\n    // Binding events\n    container.addEventListener(\"touchstart\", _this.handleStart, {\n      capture: false\n    });\n    container.addEventListener(\"touchcancel\", _this.handleLeave, {\n      capture: false\n    });\n    document.addEventListener(\"touchend\", _this.handleLeave, {\n      capture: false,\n      passive: false\n    });\n    document.addEventListener(\"touchmove\", _this.handleMove, {\n      capture: false,\n      passive: false\n    });\n    return _this;\n  }\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(TouchCaptor, _Captor);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(TouchCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"touchstart\", this.handleStart);\n      container.removeEventListener(\"touchcancel\", this.handleLeave);\n      document.removeEventListener(\"touchend\", this.handleLeave);\n      document.removeEventListener(\"touchmove\", this.handleMove);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n    }\n  }, {\n    key: \"handleStart\",\n    value: function handleStart(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      e.preventDefault();\n      var touches = getTouchesArray(e.touches);\n      this.touchMode = touches.length;\n      this.startCameraState = this.renderer.getCamera().getState();\n      this.startTouchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this2.container);\n      });\n\n      // When there are two touches down, let's record distance and angle as well:\n      if (this.touchMode === 2) {\n        var _this$startTouchesPos = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(this.startTouchesPositions, 2),\n          _this$startTouchesPos2 = _this$startTouchesPos[0],\n          x0 = _this$startTouchesPos2.x,\n          y0 = _this$startTouchesPos2.y,\n          _this$startTouchesPos3 = _this$startTouchesPos[1],\n          x1 = _this$startTouchesPos3.x,\n          y1 = _this$startTouchesPos3.y;\n        this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n        this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n      }\n      this.emit(\"touchdown\", getTouchCoords(e, this.lastTouches, this.container));\n      this.lastTouches = touches;\n      this.lastTouchesPositions = this.startTouchesPositions;\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      if (!this.enabled || !this.startTouchesPositions.length) return;\n      if (e.cancelable) e.preventDefault();\n      if (this.movingTimeout) {\n        this.isMoving = false;\n        clearTimeout(this.movingTimeout);\n      }\n      switch (this.touchMode) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        case 2:\n          if (e.touches.length === 1) {\n            this.handleStart(e);\n            e.preventDefault();\n            break;\n          }\n        /* falls through */\n        case 1:\n          if (this.isMoving) {\n            var camera = this.renderer.getCamera();\n            var cameraState = camera.getState(),\n              previousCameraState = camera.getPreviousState() || {\n                x: 0,\n                y: 0\n              };\n            camera.animate({\n              x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n            }, {\n              duration: this.settings.inertiaDuration,\n              easing: \"quadraticOut\"\n            });\n          }\n          this.hasMoved = false;\n          this.isMoving = false;\n          this.touchMode = 0;\n          break;\n      }\n      this.emit(\"touchup\", getTouchCoords(e, this.lastTouches, this.container));\n\n      // When the last touch ends and there hasn't been too much movement, trigger a \"tap\" or \"doubletap\" event:\n      if (!e.touches.length) {\n        var position = getPosition(this.lastTouches[0], this.container);\n        var downPosition = this.startTouchesPositions[0];\n        var dSquare = Math.pow(position.x - downPosition.x, 2) + Math.pow(position.y - downPosition.y, 2);\n        if (!e.touches.length && dSquare < Math.pow(this.settings.tapMoveTolerance, 2)) {\n          // Only trigger \"doubletap\" when the last tap is recent enough:\n          if (this.lastTap && Date.now() - this.lastTap.time < this.settings.doubleClickTimeout) {\n            var touchCoords = getTouchCoords(e, this.lastTouches, this.container);\n            this.emit(\"doubletap\", touchCoords);\n            this.lastTap = null;\n            if (!touchCoords.sigmaDefaultPrevented) {\n              var _camera = this.renderer.getCamera();\n              var newRatio = _camera.getBoundedRatio(_camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n              _camera.animate(this.renderer.getViewportZoomedState(position, newRatio), {\n                easing: \"quadraticInOut\",\n                duration: this.settings.doubleClickZoomingDuration\n              });\n            }\n          }\n          // Else, trigger a normal \"tap\" event:\n          else {\n            var _touchCoords = getTouchCoords(e, this.lastTouches, this.container);\n            this.emit(\"tap\", _touchCoords);\n            this.lastTap = {\n              time: Date.now(),\n              position: _touchCoords.touches[0] || _touchCoords.previousTouches[0]\n            };\n          }\n        }\n      }\n      this.lastTouches = getTouchesArray(e.touches);\n      this.startTouchesPositions = [];\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.startTouchesPositions.length) return;\n      e.preventDefault();\n      var touches = getTouchesArray(e.touches);\n      var touchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this3.container);\n      });\n      var lastTouches = this.lastTouches;\n      this.lastTouches = touches;\n      this.lastTouchesPositions = touchesPositions;\n      var touchCoords = getTouchCoords(e, lastTouches, this.container);\n      this.emit(\"touchmove\", touchCoords);\n      if (touchCoords.sigmaDefaultPrevented) return;\n\n      // If a move was initiated at some point, and we get back to start point,\n      // we should still consider that we did move (which also happens after a\n      // multiple touch when only one touch remains in which case handleStart\n      // is recalled within handleLeave).\n      // Now, some mobile browsers report zero-distance moves so we also check that\n      // one of the touches did actually move from the origin position.\n      this.hasMoved || (this.hasMoved = touchesPositions.some(function (position, idx) {\n        var startPosition = _this3.startTouchesPositions[idx];\n        return startPosition && (position.x !== startPosition.x || position.y !== startPosition.y);\n      }));\n\n      // If there was no move, do not trigger touch moves behavior\n      if (!this.hasMoved) {\n        return;\n      }\n      this.isMoving = true;\n      if (this.movingTimeout) clearTimeout(this.movingTimeout);\n      this.movingTimeout = window.setTimeout(function () {\n        _this3.isMoving = false;\n      }, this.settings.dragTimeout);\n      var camera = this.renderer.getCamera();\n      var startCameraState = this.startCameraState;\n      var padding = this.renderer.getSetting(\"stagePadding\");\n      switch (this.touchMode) {\n        case 1:\n          {\n            var _this$renderer$viewpo = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]),\n              xStart = _this$renderer$viewpo.x,\n              yStart = _this$renderer$viewpo.y;\n            var _this$renderer$viewpo2 = this.renderer.viewportToFramedGraph(touchesPositions[0]),\n              x = _this$renderer$viewpo2.x,\n              y = _this$renderer$viewpo2.y;\n            camera.setState({\n              x: startCameraState.x + xStart - x,\n              y: startCameraState.y + yStart - y\n            });\n            break;\n          }\n        case 2:\n          {\n            /**\n             * Here is the thinking here:\n             *\n             * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n             *    of the d'n'd and now\n             *\n             * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n             *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n             *    position of this same touch now\n             */\n            var newCameraState = {\n              x: 0.5,\n              y: 0.5,\n              angle: 0,\n              ratio: 1\n            };\n            var _touchesPositions$ = touchesPositions[0],\n              x0 = _touchesPositions$.x,\n              y0 = _touchesPositions$.y;\n            var _touchesPositions$2 = touchesPositions[1],\n              x1 = _touchesPositions$2.x,\n              y1 = _touchesPositions$2.y;\n            var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;\n            var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;\n\n            // 1.\n            var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n            newCameraState.ratio = newRatio;\n            newCameraState.angle = startCameraState.angle + angleDiff;\n\n            // 2.\n            var dimensions = this.getDimensions();\n            var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], {\n              cameraState: startCameraState\n            });\n            var smallestDimension = Math.min(dimensions.width, dimensions.height) - 2 * padding;\n            var dx = smallestDimension / dimensions.width;\n            var dy = smallestDimension / dimensions.height;\n            var ratio = newRatio / smallestDimension;\n\n            // Align with center of the graph:\n            var _x = x0 - smallestDimension / 2 / dx;\n            var _y = y0 - smallestDimension / 2 / dy;\n\n            // Rotate:\n            var _ref = [_x * Math.cos(-newCameraState.angle) - _y * Math.sin(-newCameraState.angle), _y * Math.cos(-newCameraState.angle) + _x * Math.sin(-newCameraState.angle)];\n            _x = _ref[0];\n            _y = _ref[1];\n            newCameraState.x = touchGraphPosition.x - _x * ratio;\n            newCameraState.y = touchGraphPosition.y + _y * ratio;\n            camera.setState(newCameraState);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n}(Captor);\n\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.a)(r);\n}\n\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(r) || _nonIterableSpread();\n}\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\n/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /*#__PURE__*/function () {\n  function LabelCandidate(key, size) {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, LabelCandidate);\n    this.key = key;\n    this.size = size;\n  }\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(LabelCandidate, null, [{\n    key: \"compare\",\n    value: function compare(first, second) {\n      // First we compare by size\n      if (first.size > second.size) return -1;\n      if (first.size < second.size) return 1;\n\n      // Then since no two nodes can have the same key, we use it to\n      // deterministically tie-break by key\n      if (first.key > second.key) return 1;\n\n      // NOTE: this comparator cannot return 0\n      return -1;\n    }\n  }]);\n}();\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /*#__PURE__*/function () {\n  function LabelGrid() {\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, LabelGrid);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"width\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"height\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"cellSize\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"columns\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"rows\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, \"cells\", {});\n  }\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(LabelGrid, [{\n    key: \"resizeAndClear\",\n    value: function resizeAndClear(dimensions, cellSize) {\n      this.width = dimensions.width;\n      this.height = dimensions.height;\n      this.cellSize = cellSize;\n      this.columns = Math.ceil(dimensions.width / cellSize);\n      this.rows = Math.ceil(dimensions.height / cellSize);\n      this.cells = {};\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(pos) {\n      var xIndex = Math.floor(pos.x / this.cellSize);\n      var yIndex = Math.floor(pos.y / this.cellSize);\n      return yIndex * this.columns + xIndex;\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, size, pos) {\n      var candidate = new LabelCandidate(key, size);\n      var index = this.getIndex(pos);\n      var cell = this.cells[index];\n      if (!cell) {\n        cell = [];\n        this.cells[index] = cell;\n      }\n      cell.push(candidate);\n    }\n  }, {\n    key: \"organize\",\n    value: function organize() {\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        cell.sort(LabelCandidate.compare);\n      }\n    }\n  }, {\n    key: \"getLabelsToDisplay\",\n    value: function getLabelsToDisplay(ratio, density) {\n      // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n      // TODO: adjust threshold lower, but increase cells a bit?\n      // TODO: hunt for geom issue in disguise\n      // TODO: memoize while ratio does not move. method to force recompute\n      var cellArea = this.cellSize * this.cellSize;\n      var scaledCellArea = cellArea / ratio / ratio;\n      var scaledDensity = scaledCellArea * density / cellArea;\n      var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n      var labels = [];\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n          labels.push(cell[i].key);\n        }\n      }\n      return labels;\n    }\n  }]);\n}();\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n    hoveredNode = params.hoveredNode,\n    highlightedNodes = params.highlightedNodes,\n    displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge(function (edge, _, source, target) {\n    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {\n      worthyEdges.push(edge);\n    }\n  });\n  return worthyEdges;\n}\n\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!hasOwnProperty.call(data, \"x\") || !hasOwnProperty.call(data, \"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"highlighted\")) data.highlighted = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, _key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma$1 = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Sigma(graph, container) {\n    var _this;\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Sigma);\n    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Sigma);\n\n    // Resolving settings\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"elements\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"canvasContexts\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"webGLContexts\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"pickingLayers\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"textures\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"frameBuffers\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"activeListeners\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"labelGrid\", new LabelGrid());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeDataCache\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgeDataCache\", {});\n    // Indices to keep track of the index of the item inside programs\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeProgramIndex\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgeProgramIndex\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodesWithForcedLabels\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgesWithForcedLabels\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeExtent\", {\n      x: [0, 1],\n      y: [0, 1]\n    });\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeZExtent\", [Infinity, -Infinity]);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgeZExtent\", [Infinity, -Infinity]);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"matrix\", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.i)());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"invMatrix\", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.i)());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"correctionRatio\", 1);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"customBBox\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"normalizationFunction\", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.c)({\n      x: [0, 1],\n      y: [0, 1]\n    }));\n    // Cache:\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"graphToViewportRatio\", 1);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"itemIDsIndex\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeIndices\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgeIndices\", {});\n    // Starting dimensions and pixel ratio\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"width\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"height\", 0);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"pixelRatio\", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.d)());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"pickingDownSizingRatio\", 2 * _this.pixelRatio);\n    // Graph State\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"displayedNodeLabels\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"displayedEdgeLabels\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"highlightedNodes\", new Set());\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"hoveredNode\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"hoveredEdge\", null);\n    // Internal states\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"renderFrame\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"renderHighlightedNodesFrame\", null);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"needToProcess\", false);\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"checkEdgesEventsFrame\", null);\n    // Programs\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodePrograms\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"nodeHoverPrograms\", {});\n    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, \"edgePrograms\", {});\n    _this.settings = (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.resolveSettings)(settings);\n\n    // Validating\n    (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(_this.settings);\n    (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.v)(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      picking: settings.enableEdgeEvents\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\", {\n      picking: true\n    });\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\", {\n      style: {\n        touchAction: \"none\",\n        userSelect: \"none\"\n      }\n    });\n\n    // Initial resize\n    _this.resize();\n\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      _this.registerNodeProgram(type, _this.settings.nodeProgramClasses[type], _this.settings.nodeHoverProgramClasses[type]);\n    }\n    for (var _type in _this.settings.edgeProgramClasses) {\n      _this.registerEdgeProgram(_type, _this.settings.edgeProgramClasses[_type]);\n    }\n\n    // Initializing the camera\n    _this.camera = new Camera();\n\n    // Binding camera events\n    _this.bindCameraHandlers();\n\n    // Initializing captors\n    _this.mouseCaptor = new MouseCaptor(_this.elements.mouse, _this);\n    _this.mouseCaptor.setSettings(_this.settings);\n    _this.touchCaptor = new TouchCaptor(_this.elements.mouse, _this);\n    _this.touchCaptor.setSettings(_this.settings);\n\n    // Binding event handlers\n    _this.bindEventHandlers();\n\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    _this.refresh();\n    return _this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to register a node program\n   *\n   * @param  {string}           key              - The program's key, matching the related nodes \"type\" values.\n   * @param  {NodeProgramType}  NodeProgramClass - A nodes program class.\n   * @param  {NodeProgramType?} NodeHoverProgram - A nodes program class to render hovered nodes (optional).\n   * @return {Sigma}\n   */\n  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Sigma, _TypedEventEmitter);\n  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Sigma, [{\n    key: \"registerNodeProgram\",\n    value: function registerNodeProgram(key, NodeProgramClass, NodeHoverProgram) {\n      if (this.nodePrograms[key]) this.nodePrograms[key].kill();\n      if (this.nodeHoverPrograms[key]) this.nodeHoverPrograms[key].kill();\n      this.nodePrograms[key] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);\n      this.nodeHoverPrograms[key] = new (NodeHoverProgram || NodeProgramClass)(this.webGLContexts.hoverNodes, null, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to register an edge program\n     *\n     * @param  {string}          key              - The program's key, matching the related edges \"type\" values.\n     * @param  {EdgeProgramType} EdgeProgramClass - An edges program class.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"registerEdgeProgram\",\n    value: function registerEdgeProgram(key, EdgeProgramClass) {\n      if (this.edgePrograms[key]) this.edgePrograms[key].kill();\n      this.edgePrograms[key] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister a node program\n     *\n     * @param  {string} key - The program's key, matching the related nodes \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterNodeProgram\",\n    value: function unregisterNodeProgram(key) {\n      if (this.nodePrograms[key]) {\n        var _this$nodePrograms = this.nodePrograms,\n          program = _this$nodePrograms[key],\n          programs = _objectWithoutProperties(_this$nodePrograms, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));\n        program.kill();\n        this.nodePrograms = programs;\n      }\n      if (this.nodeHoverPrograms[key]) {\n        var _this$nodeHoverProgra = this.nodeHoverPrograms,\n          _program = _this$nodeHoverProgra[key],\n          _programs = _objectWithoutProperties(_this$nodeHoverProgra, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));\n        _program.kill();\n        this.nodePrograms = _programs;\n      }\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister an edge program\n     *\n     * @param  {string} key - The program's key, matching the related edges \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterEdgeProgram\",\n    value: function unregisterEdgeProgram(key) {\n      if (this.edgePrograms[key]) {\n        var _this$edgePrograms = this.edgePrograms,\n          program = _this$edgePrograms[key],\n          programs = _objectWithoutProperties(_this$edgePrograms, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));\n        program.kill();\n        this.edgePrograms = programs;\n      }\n      return this;\n    }\n\n    /**\n     * Method (re)binding WebGL texture (for picking).\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resetWebGLTexture\",\n    value: function resetWebGLTexture(id) {\n      var gl = this.webGLContexts[id];\n      var frameBuffer = this.frameBuffers[id];\n      var currentTexture = this.textures[id];\n      if (currentTexture) gl.deleteTexture(currentTexture);\n      var pickingTexture = gl.createTexture();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n      this.textures[id] = pickingTexture;\n      return this;\n    }\n\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindCameraHandlers\",\n    value: function bindCameraHandlers() {\n      var _this2 = this;\n      this.activeListeners.camera = function () {\n        _this2.scheduleRender();\n      };\n      this.camera.on(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method unbinding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unbindCameraHandlers\",\n    value: function unbindCameraHandlers() {\n      this.camera.removeListener(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method that returns the closest node to a given position.\n     */\n  }, {\n    key: \"getNodeAtPosition\",\n    value: function getNodeAtPosition(position) {\n      var x = position.x,\n        y = position.y;\n      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.g)(this.webGLContexts.nodes, this.frameBuffers.nodes, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.c.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindEventHandlers\",\n    value: function bindEventHandlers() {\n      var _this3 = this;\n      // Handling window resize\n      this.activeListeners.handleResize = function () {\n        // need to call a refresh to rebuild the labelgrid\n        _this3.scheduleRefresh();\n      };\n      window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n      // Handling mouse move\n      this.activeListeners.handleMove = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        var nodeToHover = _this3.getNodeAtPosition(event);\n        if (nodeToHover && _this3.hoveredNode !== nodeToHover && !_this3.nodeDataCache[nodeToHover].hidden) {\n          // Handling passing from one node to the other directly\n          if (_this3.hoveredNode) _this3.emit(\"leaveNode\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.hoveredNode = nodeToHover;\n          _this3.emit(\"enterNode\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n            node: nodeToHover\n          }));\n          _this3.scheduleHighlightedNodesRender();\n          return;\n        }\n\n        // Checking if the hovered node is still hovered\n        if (_this3.hoveredNode) {\n          if (_this3.getNodeAtPosition(event) !== _this3.hoveredNode) {\n            var node = _this3.hoveredNode;\n            _this3.hoveredNode = null;\n            _this3.emit(\"leaveNode\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n              node: node\n            }));\n            _this3.scheduleHighlightedNodesRender();\n            return;\n          }\n        }\n        if (_this3.settings.enableEdgeEvents) {\n          var edgeToHover = _this3.hoveredNode ? null : _this3.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);\n          if (edgeToHover !== _this3.hoveredEdge) {\n            if (_this3.hoveredEdge) _this3.emit(\"leaveEdge\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n              edge: _this3.hoveredEdge\n            }));\n            if (edgeToHover) _this3.emit(\"enterEdge\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n              edge: edgeToHover\n            }));\n            _this3.hoveredEdge = edgeToHover;\n          }\n        }\n      };\n\n      // Handling mouse move over body (only to dispatch the proper event):\n      this.activeListeners.handleMoveBody = function (e) {\n        var event = cleanMouseCoords(e);\n        _this3.emit(\"moveBody\", {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        });\n      };\n\n      // Handling mouse leave stage:\n      this.activeListeners.handleLeave = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        if (_this3.hoveredNode) {\n          _this3.emit(\"leaveNode\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        if (_this3.settings.enableEdgeEvents && _this3.hoveredEdge) {\n          _this3.emit(\"leaveEdge\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n            edge: _this3.hoveredEdge\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        _this3.emit(\"leaveStage\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent));\n      };\n\n      // Handling mouse enter stage:\n      this.activeListeners.handleEnter = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        _this3.emit(\"enterStage\", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent));\n      };\n\n      // Handling click\n      var createInteractionListener = function createInteractionListener(eventType) {\n        return function (e) {\n          var event = cleanMouseCoords(e);\n          var baseEvent = {\n            event: event,\n            preventSigmaDefault: function preventSigmaDefault() {\n              event.preventSigmaDefault();\n            }\n          };\n          var nodeAtPosition = _this3.getNodeAtPosition(event);\n          if (nodeAtPosition) return _this3.emit(\"\".concat(eventType, \"Node\"), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n            node: nodeAtPosition\n          }));\n          if (_this3.settings.enableEdgeEvents) {\n            var edge = _this3.getEdgeAtPoint(event.x, event.y);\n            if (edge) return _this3.emit(\"\".concat(eventType, \"Edge\"), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {\n              edge: edge\n            }));\n          }\n          return _this3.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n        };\n      };\n      this.activeListeners.handleClick = createInteractionListener(\"click\");\n      this.activeListeners.handleRightClick = createInteractionListener(\"rightClick\");\n      this.activeListeners.handleDoubleClick = createInteractionListener(\"doubleClick\");\n      this.activeListeners.handleWheel = createInteractionListener(\"wheel\");\n      this.activeListeners.handleDown = createInteractionListener(\"down\");\n      this.activeListeners.handleUp = createInteractionListener(\"up\");\n      this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n      this.mouseCaptor.on(\"mousemovebody\", this.activeListeners.handleMoveBody);\n      this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n      this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n      this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n      this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n      this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n      this.mouseCaptor.on(\"mouseup\", this.activeListeners.handleUp);\n      this.mouseCaptor.on(\"mouseleave\", this.activeListeners.handleLeave);\n      this.mouseCaptor.on(\"mouseenter\", this.activeListeners.handleEnter);\n      this.touchCaptor.on(\"touchdown\", this.activeListeners.handleDown);\n      this.touchCaptor.on(\"touchdown\", this.activeListeners.handleMove);\n      this.touchCaptor.on(\"touchup\", this.activeListeners.handleUp);\n      this.touchCaptor.on(\"touchmove\", this.activeListeners.handleMove);\n      this.touchCaptor.on(\"tap\", this.activeListeners.handleClick);\n      this.touchCaptor.on(\"doubletap\", this.activeListeners.handleDoubleClick);\n      this.touchCaptor.on(\"touchmove\", this.activeListeners.handleMoveBody);\n      return this;\n    }\n\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindGraphHandlers\",\n    value: function bindGraphHandlers() {\n      var _this4 = this;\n      var graph = this.graph;\n      var LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n      this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints;\n        var updatedFields = (_e$hints = e.hints) === null || _e$hints === void 0 ? void 0 : _e$hints.attributes;\n        // we process all nodes\n        _this4.graph.forEachNode(function (node) {\n          return _this4.updateNode(node);\n        });\n\n        // if coord, type or zIndex have changed, we need to schedule a render\n        // (zIndex for the programIndex)\n        var layoutChanged = !updatedFields || updatedFields.some(function (f) {\n          return LAYOUT_IMPACTING_FIELDS.has(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            nodes: graph.nodes()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n      this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints2;\n        var updatedFields = (_e$hints2 = e.hints) === null || _e$hints2 === void 0 ? void 0 : _e$hints2.attributes;\n        // we process all edges\n        _this4.graph.forEachEdge(function (edge) {\n          return _this4.updateEdge(edge);\n        });\n        var layoutChanged = updatedFields && [\"zIndex\", \"type\"].some(function (f) {\n          return updatedFields === null || updatedFields === void 0 ? void 0 : updatedFields.includes(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            edges: graph.edges()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n\n      // On add node, we add the node in indices and then call for a render\n      this.activeListeners.addNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.addNode(node);\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On update node, we update indices and then call for a render\n      this.activeListeners.updateNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop node, we remove the node from indices and then call for a refresh\n      this.activeListeners.dropNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.removeNode(node);\n        // schedule a render for everything\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On add edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.addEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.addEdge(edge);\n        // schedule a render for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          schedule: true\n        });\n      };\n\n      // On update edge, we update indices and then call for a refresh\n      this.activeListeners.updateEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // schedule a repaint for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.dropEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.removeEdge(edge);\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On clear edges, we clear the edge indices and then call for a refresh\n      this.activeListeners.clearEdgesGraphUpdate = function () {\n        // we clear the edge data structures\n        _this4.clearEdgeState();\n        _this4.clearEdgeIndices();\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On graph clear, we clear indices and then call for a refresh\n      this.activeListeners.clearGraphUpdate = function () {\n        // clear graph state\n        _this4.clearEdgeState();\n        _this4.clearNodeState();\n\n        // clear graph indices\n        _this4.clearEdgeIndices();\n        _this4.clearNodeIndices();\n\n        // schedule a render for all\n        _this4.refresh({\n          schedule: true\n        });\n      };\n      graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n      return this;\n    }\n\n    /**\n     * Method used to unbind handlers from the graph.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"unbindGraphHandlers\",\n    value: function unbindGraphHandlers() {\n      var graph = this.graph;\n      graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    }\n\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n  }, {\n    key: \"getEdgeAtPoint\",\n    value: function getEdgeAtPoint(x, y) {\n      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.g)(this.webGLContexts.edges, this.frameBuffers.edges, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.c.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method used to process the whole graph's data.\n     *  - extent\n     *  - normalizationFunction\n     *  - compute node's coordinate\n     *  - labelgrid\n     *  - program data allocation\n     * @return {Sigma}\n     */\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this5 = this;\n      this.emit(\"beforeProcess\");\n      var graph = this.graph;\n      var settings = this.settings;\n      var dimensions = this.getDimensions();\n\n      //\n      // NODES\n      //\n      this.nodeExtent = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.graph);\n      if (!this.settings.autoRescale) {\n        var width = dimensions.width,\n          height = dimensions.height;\n        var _this$nodeExtent = this.nodeExtent,\n          x = _this$nodeExtent.x,\n          y = _this$nodeExtent.y;\n        this.nodeExtent = {\n          x: [(x[0] + x[1]) / 2 - width / 2, (x[0] + x[1]) / 2 + width / 2],\n          y: [(y[0] + y[1]) / 2 - height / 2, (y[0] + y[1]) / 2 + height / 2]\n        };\n      }\n      this.normalizationFunction = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.c)(this.customBBox || this.nodeExtent);\n\n      // NOTE: it is important to compute this matrix after computing the node's extent\n      // because #.getGraphDimensions relies on it\n      var nullCamera = new Camera();\n      var nullCameraMatrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(nullCamera.getState(), dimensions, this.getGraphDimensions(), this.getStagePadding());\n      // Resetting the label grid\n      // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n      this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n      var nodesPerPrograms = {};\n      var nodeIndices = {};\n      var edgeIndices = {};\n      var itemIDsIndex = {};\n      var incrID = 1;\n      var nodes = graph.nodes();\n\n      // Do some indexation on the whole graph\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        var data = this.nodeDataCache[node];\n\n        // Get initial coordinates\n        var attrs = graph.getNodeAttributes(node);\n        data.x = attrs.x;\n        data.y = attrs.y;\n        this.normalizationFunction.applyTo(data);\n\n        // labelgrid\n        if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n          matrix: nullCameraMatrix\n        }));\n\n        // update count per program\n        nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      }\n      this.labelGrid.organize();\n\n      // Allocate memory to programs\n      for (var type in this.nodePrograms) {\n        if (!hasOwnProperty.call(this.nodePrograms, type)) {\n          throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n        }\n        this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        nodesPerPrograms[type] = 0;\n      }\n\n      // Order nodes by zIndex before to add them to program\n      if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1]) nodes = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.z)(this.nodeZExtent, function (node) {\n        return _this5.nodeDataCache[node].zIndex;\n      }, nodes);\n\n      // Add data to programs\n      for (var _i = 0, _l = nodes.length; _i < _l; _i++) {\n        var _node = nodes[_i];\n        nodeIndices[_node] = incrID;\n        itemIDsIndex[nodeIndices[_node]] = {\n          type: \"node\",\n          id: _node\n        };\n        incrID++;\n        var _data = this.nodeDataCache[_node];\n        this.addNodeToProgram(_node, nodeIndices[_node], nodesPerPrograms[_data.type]++);\n      }\n\n      //\n      // EDGES\n      //\n\n      var edgesPerPrograms = {};\n      var edges = graph.edges();\n\n      // Allocate memory to programs\n      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {\n        var edge = edges[_i2];\n        var _data2 = this.edgeDataCache[edge];\n        edgesPerPrograms[_data2.type] = (edgesPerPrograms[_data2.type] || 0) + 1;\n      }\n\n      // Order edges by zIndex before to add them to program\n      if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1]) edges = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.z)(this.edgeZExtent, function (edge) {\n        return _this5.edgeDataCache[edge].zIndex;\n      }, edges);\n      for (var _type2 in this.edgePrograms) {\n        if (!hasOwnProperty.call(this.edgePrograms, _type2)) {\n          throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(_type2, \"\\\"!\"));\n        }\n        this.edgePrograms[_type2].reallocate(edgesPerPrograms[_type2] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        edgesPerPrograms[_type2] = 0;\n      }\n\n      // Add data to programs\n      for (var _i3 = 0, _l3 = edges.length; _i3 < _l3; _i3++) {\n        var _edge = edges[_i3];\n        edgeIndices[_edge] = incrID;\n        itemIDsIndex[edgeIndices[_edge]] = {\n          type: \"edge\",\n          id: _edge\n        };\n        incrID++;\n        var _data3 = this.edgeDataCache[_edge];\n        this.addEdgeToProgram(_edge, edgeIndices[_edge], edgesPerPrograms[_data3.type]++);\n      }\n      this.itemIDsIndex = itemIDsIndex;\n      this.nodeIndices = nodeIndices;\n      this.edgeIndices = edgeIndices;\n      this.emit(\"afterProcess\");\n      return this;\n    }\n\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n  }, {\n    key: \"handleSettingsUpdate\",\n    value: function handleSettingsUpdate(oldSettings) {\n      var _this6 = this;\n      var settings = this.settings;\n      this.camera.minRatio = settings.minCameraRatio;\n      this.camera.maxRatio = settings.maxCameraRatio;\n      this.camera.enabledZooming = settings.enableCameraZooming;\n      this.camera.enabledPanning = settings.enableCameraPanning;\n      this.camera.enabledRotation = settings.enableCameraRotation;\n      if (settings.cameraPanBoundaries) {\n        this.camera.clean = function (state) {\n          return _this6.cleanCameraState(state, settings.cameraPanBoundaries && (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__._)(settings.cameraPanBoundaries) === \"object\" ? settings.cameraPanBoundaries : {});\n        };\n      } else {\n        this.camera.clean = null;\n      }\n      this.camera.setState(this.camera.validateState(this.camera.getState()));\n      if (oldSettings) {\n        // Check edge programs:\n        if (oldSettings.edgeProgramClasses !== settings.edgeProgramClasses) {\n          for (var type in settings.edgeProgramClasses) {\n            if (settings.edgeProgramClasses[type] !== oldSettings.edgeProgramClasses[type]) {\n              this.registerEdgeProgram(type, settings.edgeProgramClasses[type]);\n            }\n          }\n          for (var _type3 in oldSettings.edgeProgramClasses) {\n            if (!settings.edgeProgramClasses[_type3]) this.unregisterEdgeProgram(_type3);\n          }\n        }\n\n        // Check node programs:\n        if (oldSettings.nodeProgramClasses !== settings.nodeProgramClasses || oldSettings.nodeHoverProgramClasses !== settings.nodeHoverProgramClasses) {\n          for (var _type4 in settings.nodeProgramClasses) {\n            if (settings.nodeProgramClasses[_type4] !== oldSettings.nodeProgramClasses[_type4] || settings.nodeHoverProgramClasses[_type4] !== oldSettings.nodeHoverProgramClasses[_type4]) {\n              this.registerNodeProgram(_type4, settings.nodeProgramClasses[_type4], settings.nodeHoverProgramClasses[_type4]);\n            }\n          }\n          for (var _type5 in oldSettings.nodeProgramClasses) {\n            if (!settings.nodeProgramClasses[_type5]) this.unregisterNodeProgram(_type5);\n          }\n        }\n      }\n\n      // Update captors settings:\n      this.mouseCaptor.setSettings(this.settings);\n      this.touchCaptor.setSettings(this.settings);\n      return this;\n    }\n  }, {\n    key: \"cleanCameraState\",\n    value: function cleanCameraState(state) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$tolerance = _ref.tolerance,\n        tolerance = _ref$tolerance === void 0 ? 0 : _ref$tolerance,\n        boundaries = _ref.boundaries;\n      var newState = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, state);\n\n      // Extract necessary properties\n      var _ref2 = boundaries || this.nodeExtent,\n        _ref2$x = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(_ref2.x, 2),\n        xMinGraph = _ref2$x[0],\n        xMaxGraph = _ref2$x[1],\n        _ref2$y = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(_ref2.y, 2),\n        yMinGraph = _ref2$y[0],\n        yMaxGraph = _ref2$y[1];\n\n      // Transform the four corners of the graph rectangle using the provided camera state\n      var corners = [this.graphToViewport({\n        x: xMinGraph,\n        y: yMinGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMaxGraph,\n        y: yMinGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMinGraph,\n        y: yMaxGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMaxGraph,\n        y: yMaxGraph\n      }, {\n        cameraState: state\n      })];\n\n      // Look for new extents, based on these four corners\n      var xMin = Infinity,\n        xMax = -Infinity,\n        yMin = Infinity,\n        yMax = -Infinity;\n      corners.forEach(function (_ref3) {\n        var x = _ref3.x,\n          y = _ref3.y;\n        xMin = Math.min(xMin, x);\n        xMax = Math.max(xMax, x);\n        yMin = Math.min(yMin, y);\n        yMax = Math.max(yMax, y);\n      });\n\n      // For each dimension, constraint the smaller element (camera or graph) to fit in the larger one:\n      var graphWidth = xMax - xMin;\n      var graphHeight = yMax - yMin;\n      var _this$getDimensions = this.getDimensions(),\n        width = _this$getDimensions.width,\n        height = _this$getDimensions.height;\n      var dx = 0;\n      var dy = 0;\n      if (graphWidth >= width) {\n        if (xMax < width - tolerance) dx = xMax - (width - tolerance);else if (xMin > tolerance) dx = xMin - tolerance;\n      } else {\n        if (xMax > width + tolerance) dx = xMax - (width + tolerance);else if (xMin < -tolerance) dx = xMin + tolerance;\n      }\n      if (graphHeight >= height) {\n        if (yMax < height - tolerance) dy = yMax - (height - tolerance);else if (yMin > tolerance) dy = yMin - tolerance;\n      } else {\n        if (yMax > height + tolerance) dy = yMax - (height + tolerance);else if (yMin < -tolerance) dy = yMin + tolerance;\n      }\n      if (dx || dy) {\n        // Transform [dx, dy] from viewport to graph (using two different point to transform that vector):\n        var origin = this.viewportToFramedGraph({\n          x: 0,\n          y: 0\n        }, {\n          cameraState: state\n        });\n        var delta = this.viewportToFramedGraph({\n          x: dx,\n          y: dy\n        }, {\n          cameraState: state\n        });\n        dx = delta.x - origin.x;\n        dy = delta.y - origin.y;\n        newState.x += dx;\n        newState.y += dy;\n      }\n      return newState;\n    }\n\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      if (!this.settings.renderLabels) return this;\n      var cameraState = this.camera.getState();\n\n      // Selecting labels to draw\n      var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n      (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__.e)(labelsToDisplay, this.nodesWithForcedLabels);\n      this.displayedNodeLabels = new Set();\n\n      // Drawing labels\n      var context = this.canvasContexts.labels;\n      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n        var node = labelsToDisplay[i];\n        var data = this.nodeDataCache[node];\n\n        // If the node was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        // NOTE: we can do better probably\n        if (this.displayedNodeLabels.has(node)) continue;\n\n        // If the node is hidden, we don't need to display its label obviously\n        if (data.hidden) continue;\n        var _this$framedGraphToVi = this.framedGraphToViewport(data),\n          x = _this$framedGraphToVi.x,\n          y = _this$framedGraphToVi.y;\n\n        // NOTE: we can cache the labels we need to render until the camera's ratio changes\n        var size = this.scaleSize(data.size);\n\n        // Is node big enough?\n        if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n        // Is node actually on screen (with some margin)\n        // NOTE: we used to rely on the quadtree for this, but the coordinates\n        // conversion make it unreliable and at that point we already converted\n        // to viewport coordinates and since the label grid already culls the\n        // number of potential labels to display this looks like a good\n        // performance compromise.\n        // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n        // considering cells obviously outside of the range of the current\n        // view rectangle.\n        if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;\n\n        // Because displayed edge labels depend directly on actually rendered node\n        // labels, we need to only add to this.displayedNodeLabels nodes whose label\n        // is rendered.\n        // This makes this.displayedNodeLabels depend on viewport, which might become\n        // an issue once we start memoizing getLabelsToDisplay.\n        this.displayedNodeLabels.add(node);\n        var defaultDrawNodeLabel = this.settings.defaultDrawNodeLabel;\n        var nodeProgram = this.nodePrograms[data.type];\n        var drawLabel = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;\n        drawLabel(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), this.settings);\n      }\n      return this;\n    }\n\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderEdgeLabels\",\n    value: function renderEdgeLabels() {\n      if (!this.settings.renderEdgeLabels) return this;\n      var context = this.canvasContexts.edgeLabels;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n      var edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n        graph: this.graph,\n        hoveredNode: this.hoveredNode,\n        displayedNodeLabels: this.displayedNodeLabels,\n        highlightedNodes: this.highlightedNodes\n      });\n      (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__.e)(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n      var displayedLabels = new Set();\n      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n        var edge = edgeLabelsToDisplay[i],\n          extremities = this.graph.extremities(edge),\n          sourceData = this.nodeDataCache[extremities[0]],\n          targetData = this.nodeDataCache[extremities[1]],\n          edgeData = this.edgeDataCache[edge];\n\n        // If the edge was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        if (displayedLabels.has(edge)) continue;\n\n        // If the edge is hidden we don't need to display its label\n        // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n        if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n          continue;\n        }\n        var defaultDrawEdgeLabel = this.settings.defaultDrawEdgeLabel;\n        var edgeProgram = this.edgePrograms[edgeData.type];\n        var drawLabel = (edgeProgram === null || edgeProgram === void 0 ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;\n        drawLabel(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n          key: edge\n        }, edgeData), {}, {\n          size: this.scaleSize(edgeData.size)\n        }), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n          key: extremities[0]\n        }, sourceData), this.framedGraphToViewport(sourceData)), {}, {\n          size: this.scaleSize(sourceData.size)\n        }), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n          key: extremities[1]\n        }, targetData), this.framedGraphToViewport(targetData)), {}, {\n          size: this.scaleSize(targetData.size)\n        }), this.settings);\n        displayedLabels.add(edge);\n      }\n      this.displayedEdgeLabels = displayedLabels;\n      return this;\n    }\n\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderHighlightedNodes\",\n    value: function renderHighlightedNodes() {\n      var _this7 = this;\n      var context = this.canvasContexts.hovers;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n\n      // Rendering\n      var render = function render(node) {\n        var data = _this7.nodeDataCache[node];\n        var _this7$framedGraphToV = _this7.framedGraphToViewport(data),\n          x = _this7$framedGraphToV.x,\n          y = _this7$framedGraphToV.y;\n        var size = _this7.scaleSize(data.size);\n        var defaultDrawNodeHover = _this7.settings.defaultDrawNodeHover;\n        var nodeProgram = _this7.nodePrograms[data.type];\n        var drawHover = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;\n        drawHover(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), _this7.settings);\n      };\n      var nodesToRender = [];\n      if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n        nodesToRender.push(this.hoveredNode);\n      }\n      this.highlightedNodes.forEach(function (node) {\n        // The hovered node has already been highlighted\n        if (node !== _this7.hoveredNode) nodesToRender.push(node);\n      });\n\n      // Draw labels:\n      nodesToRender.forEach(function (node) {\n        return render(node);\n      });\n\n      // Draw WebGL nodes on top of the labels:\n      var nodesPerPrograms = {};\n\n      // 1. Count nodes per type:\n      nodesToRender.forEach(function (node) {\n        var type = _this7.nodeDataCache[node].type;\n        nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n      });\n      // 2. Allocate for each type for the proper number of nodes\n      for (var type in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // Also reset count, to use when rendering:\n        nodesPerPrograms[type] = 0;\n      }\n      // 3. Process all nodes to render:\n      nodesToRender.forEach(function (node) {\n        var data = _this7.nodeDataCache[node];\n        _this7.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n      });\n      // 4. Clear hovered nodes layer:\n      this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n      // 5. Render:\n      var renderParams = this.getRenderParams();\n      for (var _type6 in this.nodeHoverPrograms) {\n        var program = this.nodeHoverPrograms[_type6];\n        program.render(renderParams);\n      }\n    }\n\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n  }, {\n    key: \"scheduleHighlightedNodesRender\",\n    value: function scheduleHighlightedNodesRender() {\n      var _this8 = this;\n      if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {\n        // Resetting state\n        _this8.renderHighlightedNodesFrame = null;\n\n        // Rendering\n        _this8.renderHighlightedNodes();\n        _this8.renderEdgeLabels();\n      });\n    }\n\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this9 = this;\n      this.emit(\"beforeRender\");\n      var exitRender = function exitRender() {\n        _this9.emit(\"afterRender\");\n        return _this9;\n      };\n\n      // If a render was scheduled, we cancel it\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n\n      // First we need to resize\n      this.resize();\n\n      // Do we need to reprocess data?\n      if (this.needToProcess) this.process();\n      this.needToProcess = false;\n\n      // Clearing the canvases\n      this.clear();\n\n      // Prepare the textures\n      this.pickingLayers.forEach(function (layer) {\n        return _this9.resetWebGLTexture(layer);\n      });\n\n      // If we have no nodes we can stop right there\n      if (!this.graph.order) return exitRender();\n\n      // TODO: improve this heuristic or move to the captor itself?\n      // TODO: deal with the touch captor here as well\n      var mouseCaptor = this.mouseCaptor;\n      var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n\n      // Then we need to extract a matrix from the camera\n      var cameraState = this.camera.getState();\n      var viewportDimensions = this.getDimensions();\n      var graphDimensions = this.getGraphDimensions();\n      var padding = this.getStagePadding();\n      this.matrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(cameraState, viewportDimensions, graphDimensions, padding);\n      this.invMatrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(cameraState, viewportDimensions, graphDimensions, padding, true);\n      this.correctionRatio = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.a)(this.matrix, cameraState, viewportDimensions);\n      this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n      // [jacomyal]\n      // This comment is related to the one above the `getMatrixImpact` definition:\n      // - `this.correctionRatio` is somehow not completely explained\n      // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n      //   graph\n      // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n      // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n      // when I change the graph, the viewport or the camera. It might be useful later, so I prefer to let this comment:\n      // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n      var params = this.getRenderParams();\n\n      // Drawing nodes\n      for (var type in this.nodePrograms) {\n        var program = this.nodePrograms[type];\n        program.render(params);\n      }\n\n      // Drawing edges\n      if (!this.settings.hideEdgesOnMove || !moving) {\n        for (var _type7 in this.edgePrograms) {\n          var _program2 = this.edgePrograms[_type7];\n          _program2.render(params);\n        }\n      }\n\n      // Do not display labels on move per setting\n      if (this.settings.hideLabelsOnMove && moving) return exitRender();\n      this.renderLabels();\n      this.renderEdgeLabels();\n      this.renderHighlightedNodes();\n      return exitRender();\n    }\n\n    /**\n     * Add a node in the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"addNode\",\n    value: function addNode(key) {\n      // Node display data resolution:\n      //  1. First we get the node's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //     Note that this function must return a total object and won't be merged\n      //  3. We apply our defaults, while running some vital checks\n      //  4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getNodeAttributes(key));\n      if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);\n      var data = applyNodeDefaults(this.settings, key, attr);\n      this.nodeDataCache[key] = data;\n\n      // Label:\n      // We delete and add if needed because this function is also used from\n      // update\n      this.nodesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n      // Highlighted:\n      // We remove and re add if needed because this function is also used from\n      // update\n      this.highlightedNodes[\"delete\"](key);\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n      // zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update a node the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(key) {\n      this.addNode(key);\n\n      // Re-apply normalization on the node\n      var data = this.nodeDataCache[key];\n      this.normalizationFunction.applyTo(data);\n    }\n\n    /**\n     * Remove a node from the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(key) {\n      // Remove from node cache\n      delete this.nodeDataCache[key];\n      // Remove from node program index\n      delete this.nodeProgramIndex[key];\n      // Remove from higlighted nodes\n      this.highlightedNodes[\"delete\"](key);\n      // Remove from hovered\n      if (this.hoveredNode === key) this.hoveredNode = null;\n      // Remove from forced label\n      this.nodesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Add an edge into the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(key) {\n      // Edge display data resolution:\n      //  1. First we get the edge's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //  3. Note that this function must return a total object and won't be merged\n      //  4. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getEdgeAttributes(key));\n      if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);\n      var data = applyEdgeDefaults(this.settings, key, attr);\n      this.edgeDataCache[key] = data;\n\n      // Forced label\n      // we filter and re push if needed because this function is also used from\n      // update\n      this.edgesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n      // Check zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update an edge in the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(key) {\n      this.addEdge(key);\n    }\n\n    /**\n     * Remove an edge from the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"removeEdge\",\n    value: function removeEdge(key) {\n      // Remove from edge cache\n      delete this.edgeDataCache[key];\n      // Remove from programId index\n      delete this.edgeProgramIndex[key];\n      // Remove from hovered\n      if (this.hoveredEdge === key) this.hoveredEdge = null;\n      // Remove from forced label\n      this.edgesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Clear all indices related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeIndices\",\n    value: function clearNodeIndices() {\n      // LabelGrid & nodeExtent are only manage/populated in the process function\n      this.labelGrid = new LabelGrid();\n      this.nodeExtent = {\n        x: [0, 1],\n        y: [0, 1]\n      };\n      this.nodeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.nodesWithForcedLabels = new Set();\n      this.nodeZExtent = [Infinity, -Infinity];\n      this.highlightedNodes = new Set();\n    }\n\n    /**\n     * Clear all indices related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeIndices\",\n    value: function clearEdgeIndices() {\n      this.edgeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.edgesWithForcedLabels = new Set();\n      this.edgeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices.\n     * @private\n     */\n  }, {\n    key: \"clearIndices\",\n    value: function clearIndices() {\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n    }\n\n    /**\n     * Clear all graph state related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeState\",\n    value: function clearNodeState() {\n      this.displayedNodeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredNode = null;\n    }\n\n    /**\n     * Clear all graph state related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeState\",\n    value: function clearEdgeState() {\n      this.displayedEdgeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredEdge = null;\n    }\n\n    /**\n     * Clear all graph state.\n     * @private\n     */\n  }, {\n    key: \"clearState\",\n    value: function clearState() {\n      this.clearEdgeState();\n      this.clearNodeState();\n    }\n\n    /**\n     * Add the node data to its program.\n     * @private\n     * @param node The node's graphology ID\n     * @param fingerprint A fingerprint used to identity the node with picking\n     * @param position The index where to place the node in the program\n     */\n  }, {\n    key: \"addNodeToProgram\",\n    value: function addNodeToProgram(node, fingerprint, position) {\n      var data = this.nodeDataCache[node];\n      var nodeProgram = this.nodePrograms[data.type];\n      if (!nodeProgram) throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n      nodeProgram.process(fingerprint, position, data);\n      // Saving program index\n      this.nodeProgramIndex[node] = position;\n    }\n\n    /**\n     * Add the edge data to its program.\n     * @private\n     * @param edge The edge's graphology ID\n     * @param fingerprint A fingerprint used to identity the edge with picking\n     * @param position The index where to place the edge in the program\n     */\n  }, {\n    key: \"addEdgeToProgram\",\n    value: function addEdgeToProgram(edge, fingerprint, position) {\n      var data = this.edgeDataCache[edge];\n      var edgeProgram = this.edgePrograms[data.type];\n      if (!edgeProgram) throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(data.type, \"\\\"!\"));\n      var extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n      // Saving program index\n      this.edgeProgramIndex[edge] = position;\n    }\n\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n\n    /**\n     * Function used to get the render params.\n     *\n     * @return {RenderParams}\n     */\n  }, {\n    key: \"getRenderParams\",\n    value: function getRenderParams() {\n      return {\n        matrix: this.matrix,\n        invMatrix: this.invMatrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        cameraAngle: this.camera.angle,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio,\n        downSizingRatio: this.pickingDownSizingRatio,\n        minEdgeThickness: this.settings.minEdgeThickness,\n        antiAliasingFeather: this.settings.antiAliasingFeather\n      };\n    }\n\n    /**\n     * Function used to retrieve the actual stage padding value.\n     *\n     * @return {number}\n     */\n  }, {\n    key: \"getStagePadding\",\n    value: function getStagePadding() {\n      var _this$settings = this.settings,\n        stagePadding = _this$settings.stagePadding,\n        autoRescale = _this$settings.autoRescale;\n      return autoRescale ? stagePadding || 0 : 0;\n    }\n\n    /**\n     * Function used to create a layer element.\n     *\n     * @param {string} id - Context's id.\n     * @param {string} tag - The HTML tag to use.\n     * @param options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createLayer\",\n    value: function createLayer(id, tag) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (this.elements[id]) throw new Error(\"Sigma: a layer named \\\"\".concat(id, \"\\\" already exists\"));\n      var element = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.b)(tag, {\n        position: \"absolute\"\n      }, {\n        \"class\": \"sigma-\".concat(id)\n      });\n      if (options.style) Object.assign(element.style, options.style);\n      this.elements[id] = element;\n      if (\"beforeLayer\" in options && options.beforeLayer) {\n        this.elements[options.beforeLayer].before(element);\n      } else if (\"afterLayer\" in options && options.afterLayer) {\n        this.elements[options.afterLayer].after(element);\n      } else {\n        this.container.appendChild(element);\n      }\n      return element;\n    }\n\n    /**\n     * Function used to create a canvas element.\n     *\n     * @param {string} id - Context's id.\n     * @param options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvas\",\n    value: function createCanvas(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.createLayer(id, \"canvas\", options);\n    }\n\n    /**\n     * Function used to create a canvas context and add the relevant DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @param  options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvasContext\",\n    value: function createCanvasContext(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var canvas = this.createCanvas(id, options);\n      var contextOptions = {\n        preserveDrawingBuffer: false,\n        antialias: false\n      };\n      this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n      return this;\n    }\n\n    /**\n     * Function used to create a WebGL context and add the relevant DOM\n     * elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {WebGLRenderingContext}\n     */\n  }, {\n    key: \"createWebGLContext\",\n    value: function createWebGLContext(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var canvas = (options === null || options === void 0 ? void 0 : options.canvas) || this.createCanvas(id, options);\n      if (options.hidden) canvas.remove();\n      var contextOptions = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({\n        preserveDrawingBuffer: false,\n        antialias: false\n      }, options);\n      var context;\n\n      // First we try webgl2 for an easy performance boost\n      context = canvas.getContext(\"webgl2\", contextOptions);\n\n      // Else we fall back to webgl\n      if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n      // Edge, I am looking right at you...\n      if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n      var gl = context;\n      this.webGLContexts[id] = gl;\n\n      // Blending:\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Prepare frame buffer for picking layers:\n      if (options.picking) {\n        this.pickingLayers.add(id);\n        var newFrameBuffer = gl.createFramebuffer();\n        if (!newFrameBuffer) throw new Error(\"Sigma: cannot create a new frame buffer for layer \".concat(id));\n        this.frameBuffers[id] = newFrameBuffer;\n      }\n      return gl;\n    }\n\n    /**\n     * Function used to properly kill a layer.\n     *\n     * @param  {string} id - Layer id.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"killLayer\",\n    value: function killLayer(id) {\n      var element = this.elements[id];\n      if (!element) throw new Error(\"Sigma: cannot kill layer \".concat(id, \", which does not exist\"));\n      if (this.webGLContexts[id]) {\n        var _gl$getExtension;\n        var gl = this.webGLContexts[id];\n        (_gl$getExtension = gl.getExtension(\"WEBGL_lose_context\")) === null || _gl$getExtension === void 0 || _gl$getExtension.loseContext();\n        delete this.webGLContexts[id];\n      } else if (this.canvasContexts[id]) {\n        delete this.canvasContexts[id];\n      }\n\n      // Delete layer element\n      element.remove();\n      delete this.elements[id];\n      return this;\n    }\n\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.camera;\n    }\n\n    /**\n     * Method setting the renderer's camera.\n     *\n     * @param  {Camera} camera - New camera.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCamera\",\n    value: function setCamera(camera) {\n      this.unbindCameraHandlers();\n      this.camera = camera;\n      this.bindCameraHandlers();\n    }\n\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container;\n    }\n\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"getGraph\",\n    value: function getGraph() {\n      return this.graph;\n    }\n\n    /**\n     * Method used to set the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"setGraph\",\n    value: function setGraph(graph) {\n      if (graph === this.graph) return;\n\n      // Check hoveredNode and hoveredEdge\n      if (this.hoveredNode && !graph.hasNode(this.hoveredNode)) this.hoveredNode = null;\n      if (this.hoveredEdge && !graph.hasEdge(this.hoveredEdge)) this.hoveredEdge = null;\n\n      // Unbinding handlers on the current graph\n      this.unbindGraphHandlers();\n      if (this.checkEdgesEventsFrame !== null) {\n        cancelAnimationFrame(this.checkEdgesEventsFrame);\n        this.checkEdgesEventsFrame = null;\n      }\n\n      // Installing new graph\n      this.graph = graph;\n\n      // Binding new handlers\n      this.bindGraphHandlers();\n\n      // Re-rendering now to avoid discrepancies from now to next frame\n      this.refresh();\n    }\n\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n  }, {\n    key: \"getMouseCaptor\",\n    value: function getMouseCaptor() {\n      return this.mouseCaptor;\n    }\n\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n  }, {\n    key: \"getTouchCaptor\",\n    value: function getTouchCaptor() {\n      return this.touchCaptor;\n    }\n\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getGraphDimensions\",\n    value: function getGraphDimensions() {\n      var extent = this.customBBox || this.nodeExtent;\n      return {\n        width: extent.x[1] - extent.x[0] || 1,\n        height: extent.y[1] - extent.y[0] || 1\n      };\n    }\n\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's useful for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n  }, {\n    key: \"getNodeDisplayData\",\n    value: function getNodeDisplayData(key) {\n      var node = this.nodeDataCache[key];\n      return node ? Object.assign({}, node) : undefined;\n    }\n\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's useful for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n  }, {\n    key: \"getEdgeDisplayData\",\n    value: function getEdgeDisplayData(key) {\n      var edge = this.edgeDataCache[key];\n      return edge ? Object.assign({}, edge) : undefined;\n    }\n\n    /**\n     * Method used to get the set of currently displayed node labels.\n     *\n     * @return {Set<string>} A set of node keys whose label is displayed.\n     */\n  }, {\n    key: \"getNodeDisplayedLabels\",\n    value: function getNodeDisplayedLabels() {\n      return new Set(this.displayedNodeLabels);\n    }\n\n    /**\n     * Method used to get the set of currently displayed edge labels.\n     *\n     * @return {Set<string>} A set of edge keys whose label is displayed.\n     */\n  }, {\n    key: \"getEdgeDisplayedLabels\",\n    value: function getEdgeDisplayedLabels() {\n      return new Set(this.displayedEdgeLabels);\n    }\n\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n  }, {\n    key: \"getSettings\",\n    value: function getSettings() {\n      return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);\n    }\n\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n  }, {\n    key: \"getSetting\",\n    value: function getSetting(key) {\n      return this.settings[key];\n    }\n\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSetting\",\n    value: function setSetting(key, value) {\n      var oldValues = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);\n      this.settings[key] = value;\n      (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(this.settings);\n      this.handleSettingsUpdate(oldValues);\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"updateSetting\",\n    value: function updateSetting(key, updater) {\n      this.setSetting(key, updater(this.settings[key]));\n      return this;\n    }\n\n    /**\n     * Method setting multiple settings at once.\n     *\n     * @param  {Partial<Settings>} settings - The settings to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      var oldValues = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);\n      this.settings = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings), settings);\n      (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(this.settings);\n      this.handleSettingsUpdate(oldValues);\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method used to resize the renderer.\n     *\n     * @param  {boolean} force - If true, then resize is processed even if size is unchanged (optional).\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resize\",\n    value: function resize(force) {\n      var previousWidth = this.width,\n        previousHeight = this.height;\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      this.pixelRatio = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.d)();\n      if (this.width === 0) {\n        if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n      if (this.height === 0) {\n        if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n\n      // If nothing has changed, we can stop right here\n      if (!force && previousWidth === this.width && previousHeight === this.height) return this;\n\n      // Sizing dom elements\n      for (var id in this.elements) {\n        var element = this.elements[id];\n        element.style.width = this.width + \"px\";\n        element.style.height = this.height + \"px\";\n      }\n\n      // Sizing canvas contexts\n      for (var _id in this.canvasContexts) {\n        this.elements[_id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        if (this.pixelRatio !== 1) this.canvasContexts[_id].scale(this.pixelRatio, this.pixelRatio);\n      }\n\n      // Sizing WebGL contexts\n      for (var _id2 in this.webGLContexts) {\n        this.elements[_id2].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id2].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        var gl = this.webGLContexts[_id2];\n        gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n        // Clear picking texture if needed\n        if (this.pickingLayers.has(_id2)) {\n          var currentTexture = this.textures[_id2];\n          if (currentTexture) gl.deleteTexture(currentTexture);\n        }\n      }\n      this.emit(\"resize\");\n      return this;\n    }\n\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.emit(\"beforeClear\");\n      this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n      this.emit(\"afterClear\");\n      return this;\n    }\n\n    /**\n     * Method used to refresh, i.e. force the renderer to reprocess graph\n     * data and render, but keep the state.\n     * - if a partialGraph is provided, we only reprocess those nodes & edges.\n     * - if schedule is TRUE, we schedule a render instead of sync render\n     * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh(opts) {\n      var _this10 = this;\n      var skipIndexation = (opts === null || opts === void 0 ? void 0 : opts.skipIndexation) !== undefined ? opts === null || opts === void 0 ? void 0 : opts.skipIndexation : false;\n      var schedule = (opts === null || opts === void 0 ? void 0 : opts.schedule) !== undefined ? opts.schedule : false;\n      var fullRefresh = !opts || !opts.partialGraph;\n      if (fullRefresh) {\n        // Re-index graph data\n        this.clearEdgeIndices();\n        this.clearNodeIndices();\n        this.graph.forEachNode(function (node) {\n          return _this10.addNode(node);\n        });\n        this.graph.forEachEdge(function (edge) {\n          return _this10.addEdge(edge);\n        });\n      } else {\n        var _opts$partialGraph, _opts$partialGraph2;\n        var nodes = ((_opts$partialGraph = opts.partialGraph) === null || _opts$partialGraph === void 0 ? void 0 : _opts$partialGraph.nodes) || [];\n        for (var i = 0, l = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0; i < l; i++) {\n          var node = nodes[i];\n          // Recompute node's data (ie. apply reducer)\n          this.updateNode(node);\n          // Add node to the program if layout is unchanged.\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var programIndex = this.nodeProgramIndex[node];\n            if (programIndex === undefined) throw new Error(\"Sigma: node \\\"\".concat(node, \"\\\" can't be repaint\"));\n            this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n          }\n        }\n        var edges = (opts === null || opts === void 0 || (_opts$partialGraph2 = opts.partialGraph) === null || _opts$partialGraph2 === void 0 ? void 0 : _opts$partialGraph2.edges) || [];\n        for (var _i4 = 0, _l4 = edges.length; _i4 < _l4; _i4++) {\n          var edge = edges[_i4];\n          // Recompute edge's data (ie. apply reducer)\n          this.updateEdge(edge);\n          // Add edge to the program\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var _programIndex = this.edgeProgramIndex[edge];\n            if (_programIndex === undefined) throw new Error(\"Sigma: edge \\\"\".concat(edge, \"\\\" can't be repaint\"));\n            this.addEdgeToProgram(edge, this.edgeIndices[edge], _programIndex);\n          }\n        }\n      }\n\n      // Do we need to call the process function ?\n      if (fullRefresh || !skipIndexation) this.needToProcess = true;\n      if (schedule) this.scheduleRender();else this.render();\n      return this;\n    }\n\n    /**\n     * Method used to schedule a render at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRender\",\n    value: function scheduleRender() {\n      var _this11 = this;\n      if (!this.renderFrame) {\n        this.renderFrame = requestAnimationFrame(function () {\n          _this11.render();\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n     * at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRefresh\",\n    value: function scheduleRefresh(opts) {\n      return this.refresh((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, opts), {}, {\n        schedule: true\n      }));\n    }\n\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n  }, {\n    key: \"getViewportZoomedState\",\n    value: function getViewportZoomedState(viewportTarget, newRatio) {\n      var _this$camera$getState = this.camera.getState(),\n        ratio = _this$camera$getState.ratio,\n        angle = _this$camera$getState.angle,\n        x = _this$camera$getState.x,\n        y = _this$camera$getState.y;\n      var _this$settings2 = this.settings,\n        minCameraRatio = _this$settings2.minCameraRatio,\n        maxCameraRatio = _this$settings2.maxCameraRatio;\n      if (typeof maxCameraRatio === \"number\") newRatio = Math.min(newRatio, maxCameraRatio);\n      if (typeof minCameraRatio === \"number\") newRatio = Math.max(newRatio, minCameraRatio);\n      var ratioDiff = newRatio / ratio;\n      var center = {\n        x: this.width / 2,\n        y: this.height / 2\n      };\n      var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n      var graphCenterPosition = this.viewportToFramedGraph(center);\n      return {\n        angle: angle,\n        x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n        y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n        ratio: newRatio\n      };\n    }\n\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n  }, {\n    key: \"viewRectangle\",\n    value: function viewRectangle() {\n      var p1 = this.viewportToFramedGraph({\n          x: 0,\n          y: 0\n        }),\n        p2 = this.viewportToFramedGraph({\n          x: this.width,\n          y: 0\n        }),\n        h = this.viewportToFramedGraph({\n          x: 0,\n          y: this.height\n        });\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n        height: p2.y - h.y\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"framedGraphToViewport\",\n    value: function framedGraphToViewport(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n      var matrix = override.matrix ? override.matrix : recomputeMatrix ? (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding()) : this.matrix;\n      var viewportPos = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.f)(matrix, coordinates);\n      return {\n        x: (1 + viewportPos.x) * this.width / 2,\n        y: (1 - viewportPos.y) * this.height / 2\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"viewportToFramedGraph\",\n    value: function viewportToFramedGraph(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n      var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding(), true) : this.invMatrix;\n      var res = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.f)(invMatrix, {\n        x: coordinates.x / this.width * 2 - 1,\n        y: 1 - coordinates.y / this.height * 2\n      });\n      if (isNaN(res.x)) res.x = 0;\n      if (isNaN(res.y)) res.y = 0;\n      return res;\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"viewportToGraph\",\n    value: function viewportToGraph(viewportPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"graphToViewport\",\n    value: function graphToViewport(graphPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    }\n\n    /**\n     * Method returning the distance multiplier between the graph system and the\n     * viewport system.\n     */\n  }, {\n    key: \"getGraphToViewportRatio\",\n    value: function getGraphToViewportRatio() {\n      var graphP1 = {\n        x: 0,\n        y: 0\n      };\n      var graphP2 = {\n        x: 1,\n        y: 1\n      };\n      var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n      var viewportP1 = this.graphToViewport(graphP1);\n      var viewportP2 = this.graphToViewport(graphP2);\n      var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n      return viewportD / graphD;\n    }\n\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return this.nodeExtent;\n    }\n\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n  }, {\n    key: \"getCustomBBox\",\n    value: function getCustomBBox() {\n      return this.customBBox;\n    }\n\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCustomBBox\",\n    value: function setCustomBBox(customBBox) {\n      this.customBBox = customBBox;\n      this.scheduleRender();\n      return this;\n    }\n\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      // Emitting \"kill\" events so that plugins and such can cleanup\n      this.emit(\"kill\");\n\n      // Releasing events\n      this.removeAllListeners();\n\n      // Releasing camera handlers\n      this.unbindCameraHandlers();\n\n      // Releasing DOM events & captors\n      window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n      this.mouseCaptor.kill();\n      this.touchCaptor.kill();\n\n      // Releasing graph handlers\n      this.unbindGraphHandlers();\n\n      // Releasing cache & state\n      this.clearIndices();\n      this.clearState();\n      this.nodeDataCache = {};\n      this.edgeDataCache = {};\n      this.highlightedNodes.clear();\n\n      // Clearing frames\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n      if (this.renderHighlightedNodesFrame) {\n        cancelAnimationFrame(this.renderHighlightedNodesFrame);\n        this.renderHighlightedNodesFrame = null;\n      }\n\n      // Destroying canvases\n      var container = this.container;\n      while (container.firstChild) container.removeChild(container.firstChild);\n\n      // Kill programs:\n      for (var type in this.nodePrograms) {\n        this.nodePrograms[type].kill();\n      }\n      for (var _type8 in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[_type8].kill();\n      }\n      for (var _type9 in this.edgePrograms) {\n        this.edgePrograms[_type9].kill();\n      }\n      this.nodePrograms = {};\n      this.nodeHoverPrograms = {};\n      this.edgePrograms = {};\n\n      // Kill all canvas/WebGL contexts\n      for (var id in this.elements) {\n        this.killLayer(id);\n      }\n\n      // Destroying remaining collections\n      this.canvasContexts = {};\n      this.webGLContexts = {};\n      this.elements = {};\n    }\n\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n     * @return {number}              - The scaled size.\n     */\n  }, {\n    key: \"scaleSize\",\n    value: function scaleSize() {\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var cameraRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.camera.ratio;\n      return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1);\n    }\n\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n  }, {\n    key: \"getCanvases\",\n    value: function getCanvases() {\n      var res = {};\n      for (var layer in this.elements) if (this.elements[layer] instanceof HTMLCanvasElement) res[layer] = this.elements[layer];\n      return res;\n    }\n  }]);\n}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);\n\n/**\n * Sigma.js Library Endpoint\n * =========================\n *\n * The library endpoint.\n * @module\n */\nvar Sigma = Sigma$1;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zaWdtYS9kaXN0L3NpZ21hLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9GO0FBQ3VEO0FBQ3RFO0FBQ3FPO0FBQzdMO0FBQ21EO0FBQzdGO0FBQ25EO0FBQ21COztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFlO0FBQ25CLFlBQVksNERBQVU7O0FBRXRCO0FBQ0EsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0REFBUztBQUNYLFNBQVMsNERBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseURBQWMsQ0FBQyx5REFBYyxHQUFHO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9CQUFvQix5REFBYyxDQUFDLHlEQUFjLEdBQUcsRUFBRSw2REFBZ0I7QUFDdEU7QUFDQSwyRUFBMkUsNkRBQU87O0FBRWxGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsQ0FBQyw2RUFBaUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLGFBQWE7QUFDekIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksYUFBYTtBQUN6QixZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVkseURBQWMsQ0FBQyx5REFBYyxHQUFHLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5REFBYyxDQUFDLHlEQUFjLEdBQUcsMkNBQTJDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLGFBQWE7QUFDekIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTLHlEQUFjLENBQUMseURBQWMsR0FBRyw2QkFBNkI7QUFDdEU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsT0FBTztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLGFBQWE7QUFDekIsWUFBWSxhQUFhO0FBQ3pCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBZTtBQUNuQixZQUFZLDREQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDREQUFTO0FBQ1gsU0FBUyw0REFBWTtBQUNyQixDQUFDLENBQUMsNkVBQWlCOztBQUVuQjtBQUNBO0FBQ0EsU0FBUyx5REFBYyxDQUFDLHlEQUFjLEdBQUcsV0FBVyxFQUFFLHlEQUFlLEdBQUcsT0FBTyxrRkFBZ0I7QUFDL0YsQ0FBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFlO0FBQ25CLFlBQVksNERBQVU7O0FBRXRCO0FBQ0E7QUFDQSxJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUUsNERBQVM7QUFDWCxTQUFTLDREQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxTQUFTLHlEQUFjLENBQUMseURBQWMsR0FBRyxXQUFXLEVBQUUseURBQWUsR0FBRyxPQUFPLGtGQUFnQjtBQUMvRixDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQWU7QUFDbkIsWUFBWSw0REFBVTs7QUFFdEI7QUFDQSxJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkIsSUFBSSx5REFBZTtBQUNuQixJQUFJLHlEQUFlO0FBQ25CLElBQUkseURBQWU7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUUsNERBQVM7QUFDWCxTQUFTLDREQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxvQ0FBb0MsMERBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQkFBa0IsMERB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsQ0FBQyw2RUFBaUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxlbm92b1xcRGVza3RvcFxcZnJvbnRlbmRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHNpZ21hXFxkaXN0XFxzaWdtYS5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXyBhcyBfb2JqZWN0U3ByZWFkMiwgYSBhcyBfZGVmaW5lUHJvcGVydHkgfSBmcm9tICcuL2luZGV4LTIzNmM2MmFkLmVzbS5qcyc7XG5pbXBvcnQgeyBfIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBjIGFzIF9jYWxsU3VwZXIsIGQgYXMgX3RvUHJvcGVydHlLZXkgfSBmcm9tICcuL2luaGVyaXRzLWQxYTFlMjliLmVzbS5qcyc7XG5pbXBvcnQgeyBUeXBlZEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL3R5cGVzL2Rpc3Qvc2lnbWEtdHlwZXMuZXNtLmpzJztcbmltcG9ydCB7IEEgYXMgQU5JTUFURV9ERUZBVUxUUywgZSBhcyBlYXNpbmdzLCBnIGFzIGdyYXBoRXh0ZW50LCBjIGFzIGNyZWF0ZU5vcm1hbGl6YXRpb25GdW5jdGlvbiwgbSBhcyBtYXRyaXhGcm9tQ2FtZXJhLCB6IGFzIHpJbmRleE9yZGVyaW5nLCBhIGFzIGdldE1hdHJpeEltcGFjdCwgYiBhcyBjcmVhdGVFbGVtZW50LCBkIGFzIGdldFBpeGVsUmF0aW8sIGYgYXMgbXVsdGlwbHlWZWMyLCBpIGFzIGlkZW50aXR5LCB2IGFzIHZhbGlkYXRlR3JhcGggfSBmcm9tICcuL25vcm1hbGl6YXRpb24tYmU0NDU1MTguZXNtLmpzJztcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIHZhbGlkYXRlU2V0dGluZ3MsIHJlc29sdmVTZXR0aW5ncyB9IGZyb20gJy4uL3NldHRpbmdzL2Rpc3Qvc2lnbWEtc2V0dGluZ3MuZXNtLmpzJztcbmltcG9ydCB7IF8gYXMgX3NsaWNlZFRvQXJyYXksIGEgYXMgX2FycmF5TGlrZVRvQXJyYXksIGIgYXMgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LCBnIGFzIGdldFBpeGVsQ29sb3IsIGMgYXMgY29sb3JUb0luZGV4IH0gZnJvbSAnLi9jb2xvcnMtYmViMDZlYjIuZXNtLmpzJztcbmltcG9ydCB7IF8gYXMgX3R5cGVvZiwgZSBhcyBleHRlbmQgfSBmcm9tICcuL2RhdGEtMTFkZjcxMjQuZXNtLmpzJztcbmltcG9ydCAnZXZlbnRzJztcbmltcG9ydCAnZ3JhcGhvbG9neS11dGlscy9pcy1ncmFwaCc7XG5cbi8qKlxuICogRGVmYXVsdHMuXG4gKi9cbnZhciBERUZBVUxUX1pPT01JTkdfUkFUSU8gPSAxLjU7XG5cbi8qKlxuICogRXZlbnQgdHlwZXMuXG4gKi9cbi8qKlxuICogQ2FtZXJhIGNsYXNzXG4gKi9cbnZhciBDYW1lcmEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UeXBlZEV2ZW50RW1pdHRlcikge1xuICBmdW5jdGlvbiBDYW1lcmEoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW1lcmEpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBDYW1lcmEpO1xuXG4gICAgLy8gU3RhdGVcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwieFwiLCAwLjUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ5XCIsIDAuNSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImFuZ2xlXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyYXRpb1wiLCAxKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibWluUmF0aW9cIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm1heFJhdGlvXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlbmFibGVkWm9vbWluZ1wiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZW5hYmxlZFBhbm5pbmdcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVuYWJsZWRSb3RhdGlvblwiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY2xlYW5cIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5leHRGcmFtZVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicHJldmlvdXNTdGF0ZVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZW5hYmxlZFwiLCB0cnVlKTtcbiAgICBfdGhpcy5wcmV2aW91c1N0YXRlID0gX3RoaXMuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCB1c2VkIHRvIGNyZWF0ZSBhIENhbWVyYSBvYmplY3Qgd2l0aCBhIGdpdmVuIHN0YXRlLlxuICAgKi9cbiAgX2luaGVyaXRzKENhbWVyYSwgX1R5cGVkRXZlbnRFbWl0dGVyKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDYW1lcmEsIFt7XG4gICAga2V5OiBcImVuYWJsZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGVuYWJsZSB0aGUgY2FtZXJhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBkaXNhYmxlIHRoZSBjYW1lcmEuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZXRyaWV2ZSB0aGUgY2FtZXJhJ3MgY3VycmVudCBzdGF0ZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgeTogdGhpcy55LFxuICAgICAgICBhbmdsZTogdGhpcy5hbmdsZSxcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW9cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gY2hlY2sgd2hldGhlciB0aGUgY2FtZXJhIGhhcyB0aGUgZ2l2ZW4gc3RhdGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzU3RhdGUoc3RhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnggPT09IHN0YXRlLnggJiYgdGhpcy55ID09PSBzdGF0ZS55ICYmIHRoaXMucmF0aW8gPT09IHN0YXRlLnJhdGlvICYmIHRoaXMuYW5nbGUgPT09IHN0YXRlLmFuZ2xlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJldHJpZXZlIHRoZSBjYW1lcmEncyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQcmV2aW91c1N0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByZXZpb3VzU3RhdGUoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnByZXZpb3VzU3RhdGU7XG4gICAgICBpZiAoIXN0YXRlKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHN0YXRlLngsXG4gICAgICAgIHk6IHN0YXRlLnksXG4gICAgICAgIGFuZ2xlOiBzdGF0ZS5hbmdsZSxcbiAgICAgICAgcmF0aW86IHN0YXRlLnJhdGlvXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGNoZWNrIG1pblJhdGlvIGFuZCBtYXhSYXRpbyB2YWx1ZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRlZFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kZWRSYXRpbyhyYXRpbykge1xuICAgICAgdmFyIHIgPSByYXRpbztcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5taW5SYXRpbyA9PT0gXCJudW1iZXJcIikgciA9IE1hdGgubWF4KHIsIHRoaXMubWluUmF0aW8pO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm1heFJhdGlvID09PSBcIm51bWJlclwiKSByID0gTWF0aC5taW4ociwgdGhpcy5tYXhSYXRpbyk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBjaGVjayB2YXJpb3VzIHRoaW5ncyB0byByZXR1cm4gYSBsZWdpdCBzdGF0ZSBjYW5kaWRhdGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICAgICB2YXIgdmFsaWRhdGVkU3RhdGUgPSB7fTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWRQYW5uaW5nICYmIHR5cGVvZiBzdGF0ZS54ID09PSBcIm51bWJlclwiKSB2YWxpZGF0ZWRTdGF0ZS54ID0gc3RhdGUueDtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWRQYW5uaW5nICYmIHR5cGVvZiBzdGF0ZS55ID09PSBcIm51bWJlclwiKSB2YWxpZGF0ZWRTdGF0ZS55ID0gc3RhdGUueTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWRab29taW5nICYmIHR5cGVvZiBzdGF0ZS5yYXRpbyA9PT0gXCJudW1iZXJcIikgdmFsaWRhdGVkU3RhdGUucmF0aW8gPSB0aGlzLmdldEJvdW5kZWRSYXRpbyhzdGF0ZS5yYXRpbyk7XG4gICAgICBpZiAodGhpcy5lbmFibGVkUm90YXRpb24gJiYgdHlwZW9mIHN0YXRlLmFuZ2xlID09PSBcIm51bWJlclwiKSB2YWxpZGF0ZWRTdGF0ZS5hbmdsZSA9IHN0YXRlLmFuZ2xlO1xuICAgICAgcmV0dXJuIHRoaXMuY2xlYW4gPyB0aGlzLmNsZWFuKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLmdldFN0YXRlKCkpLCB2YWxpZGF0ZWRTdGF0ZSkpIDogdmFsaWRhdGVkU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gY2hlY2sgd2hldGhlciB0aGUgY2FtZXJhIGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpc0FuaW1hdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQW5pbWF0ZWQoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLm5leHRGcmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzZXQgdGhlIGNhbWVyYSdzIHN0YXRlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIEtlZXBpbmcgdHJhY2sgb2YgbGFzdCBzdGF0ZVxuICAgICAgdGhpcy5wcmV2aW91c1N0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgdmFyIHZhbGlkU3RhdGUgPSB0aGlzLnZhbGlkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLnggPT09IFwibnVtYmVyXCIpIHRoaXMueCA9IHZhbGlkU3RhdGUueDtcbiAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS55ID09PSBcIm51bWJlclwiKSB0aGlzLnkgPSB2YWxpZFN0YXRlLnk7XG4gICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUucmF0aW8gPT09IFwibnVtYmVyXCIpIHRoaXMucmF0aW8gPSB2YWxpZFN0YXRlLnJhdGlvO1xuICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLmFuZ2xlID09PSBcIm51bWJlclwiKSB0aGlzLmFuZ2xlID0gdmFsaWRTdGF0ZS5hbmdsZTtcblxuICAgICAgLy8gRW1pdHRpbmdcbiAgICAgIGlmICghdGhpcy5oYXNTdGF0ZSh0aGlzLnByZXZpb3VzU3RhdGUpKSB0aGlzLmVtaXQoXCJ1cGRhdGVkXCIsIHRoaXMuZ2V0U3RhdGUoKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB1cGRhdGUgdGhlIGNhbWVyYSdzIHN0YXRlIHVzaW5nIGEgZnVuY3Rpb24uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3RhdGUodXBkYXRlcikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh1cGRhdGVyKHRoaXMuZ2V0U3RhdGUoKSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gYW5pbWF0ZSB0aGUgY2FtZXJhLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZShzdGF0ZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmFuaW1hdGUoc3RhdGUsIG9wdHMsIHJlc29sdmUpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgQU5JTUFURV9ERUZBVUxUUyksIG9wdHMpO1xuICAgICAgdmFyIHZhbGlkU3RhdGUgPSB0aGlzLnZhbGlkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgdmFyIGVhc2luZyA9IHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5lYXNpbmcgOiBlYXNpbmdzW29wdGlvbnMuZWFzaW5nXTtcblxuICAgICAgLy8gU3RhdGVcbiAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCksXG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gRnVuY3Rpb24gcGVyZm9ybWluZyB0aGUgYW5pbWF0aW9uXG4gICAgICB2YXIgX2ZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgIHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBvcHRpb25zLmR1cmF0aW9uO1xuXG4gICAgICAgIC8vIFRoZSBhbmltYXRpb24gaXMgb3ZlcjpcbiAgICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICAgIF90aGlzMi5uZXh0RnJhbWUgPSBudWxsO1xuICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh2YWxpZFN0YXRlKTtcbiAgICAgICAgICBpZiAoX3RoaXMyLmFuaW1hdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfdGhpczIuYW5pbWF0aW9uQ2FsbGJhY2suY2FsbChudWxsKTtcbiAgICAgICAgICAgIF90aGlzMi5hbmltYXRpb25DYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2VmZmljaWVudCA9IGVhc2luZyh0KTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS54ID09PSBcIm51bWJlclwiKSBuZXdTdGF0ZS54ID0gaW5pdGlhbFN0YXRlLnggKyAodmFsaWRTdGF0ZS54IC0gaW5pdGlhbFN0YXRlLngpICogY29lZmZpY2llbnQ7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS55ID09PSBcIm51bWJlclwiKSBuZXdTdGF0ZS55ID0gaW5pdGlhbFN0YXRlLnkgKyAodmFsaWRTdGF0ZS55IC0gaW5pdGlhbFN0YXRlLnkpICogY29lZmZpY2llbnQ7XG4gICAgICAgIGlmIChfdGhpczIuZW5hYmxlZFJvdGF0aW9uICYmIHR5cGVvZiB2YWxpZFN0YXRlLmFuZ2xlID09PSBcIm51bWJlclwiKSBuZXdTdGF0ZS5hbmdsZSA9IGluaXRpYWxTdGF0ZS5hbmdsZSArICh2YWxpZFN0YXRlLmFuZ2xlIC0gaW5pdGlhbFN0YXRlLmFuZ2xlKSAqIGNvZWZmaWNpZW50O1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUucmF0aW8gPT09IFwibnVtYmVyXCIpIG5ld1N0YXRlLnJhdGlvID0gaW5pdGlhbFN0YXRlLnJhdGlvICsgKHZhbGlkU3RhdGUucmF0aW8gLSBpbml0aWFsU3RhdGUucmF0aW8pICogY29lZmZpY2llbnQ7XG4gICAgICAgIF90aGlzMi5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIF90aGlzMi5uZXh0RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX2ZuKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5uZXh0RnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5uZXh0RnJhbWUpO1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25DYWxsYmFjaykgdGhpcy5hbmltYXRpb25DYWxsYmFjay5jYWxsKG51bGwpO1xuICAgICAgICB0aGlzLm5leHRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShfZm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2ZuKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFuaW1hdGlvbkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gem9vbSB0aGUgY2FtZXJhLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVkWm9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlZFpvb20oZmFjdG9yT3JPcHRpb25zKSB7XG4gICAgICBpZiAoIWZhY3Rvck9yT3B0aW9ucykgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvIC8gREVGQVVMVF9aT09NSU5HX1JBVElPXG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgZmFjdG9yT3JPcHRpb25zID09PSBcIm51bWJlclwiKSByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW8gLyBmYWN0b3JPck9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvIC8gKGZhY3Rvck9yT3B0aW9ucy5mYWN0b3IgfHwgREVGQVVMVF9aT09NSU5HX1JBVElPKVxuICAgICAgfSwgZmFjdG9yT3JPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB1bnpvb20gdGhlIGNhbWVyYS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlZFVuem9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlZFVuem9vbShmYWN0b3JPck9wdGlvbnMpIHtcbiAgICAgIGlmICghZmFjdG9yT3JPcHRpb25zKSByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW8gKiBERUZBVUxUX1pPT01JTkdfUkFUSU9cbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBmYWN0b3JPck9wdGlvbnMgPT09IFwibnVtYmVyXCIpIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICByYXRpbzogdGhpcy5yYXRpbyAqIGZhY3Rvck9yT3B0aW9uc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW8gKiAoZmFjdG9yT3JPcHRpb25zLmZhY3RvciB8fCBERUZBVUxUX1pPT01JTkdfUkFUSU8pXG4gICAgICB9LCBmYWN0b3JPck9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlc2V0IHRoZSBjYW1lcmEuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZWRSZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlZFJlc2V0KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICB4OiAwLjUsXG4gICAgICAgIHk6IDAuNSxcbiAgICAgICAgcmF0aW86IDEsXG4gICAgICAgIGFuZ2xlOiAwXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IENhbWVyYSBpbnN0YW5jZSwgd2l0aCB0aGUgc2FtZSBzdGF0ZSBhcyB0aGUgY3VycmVudCBjYW1lcmEuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KCkge1xuICAgICAgcmV0dXJuIENhbWVyYS5mcm9tKHRoaXMuZ2V0U3RhdGUoKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKHN0YXRlKSB7XG4gICAgICB2YXIgY2FtZXJhID0gbmV3IENhbWVyYSgpO1xuICAgICAgcmV0dXJuIGNhbWVyYS5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgfVxuICB9XSk7XG59KFR5cGVkRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBDYXB0b3IgdXRpbHMgZnVuY3Rpb25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHRoZSBsb2NhbCBYIGFuZCBZIGNvb3JkaW5hdGVzIGZyb20gYSBtb3VzZSBldmVudCBvciB0b3VjaCBvYmplY3QuIElmXG4gKiBhIERPTSBlbGVtZW50IGlzIGdpdmVuLCBpdCB1c2VzIHRoaXMgZWxlbWVudCdzIG9mZnNldCB0byBjb21wdXRlIHRoZSBwb3NpdGlvblxuICogKHRoaXMgYWxsb3dzIHVzaW5nIGV2ZW50cyB0aGF0IGFyZSBub3QgYm91bmQgdG8gdGhlIGNvbnRhaW5lciBpdHNlbGYgYW5kXG4gKiBzdGlsbCBoYXZlIGEgcHJvcGVyIHBvc2l0aW9uKS5cbiAqXG4gKiBAcGFyYW0gIHtldmVudH0gICAgICAgZSAtIEEgbW91c2UgZXZlbnQgb3IgdG91Y2ggb2JqZWN0LlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSAtIEEgRE9NIGVsZW1lbnQgdG8gY29tcHV0ZSBvZmZzZXQgcmVsYXRpdmVseSB0by5cbiAqIEByZXR1cm4ge251bWJlcn0gICAgICBUaGUgbG9jYWwgWSB2YWx1ZSBvZiB0aGUgbW91c2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGUsIGRvbSkge1xuICB2YXIgYmJveCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBlLmNsaWVudFggLSBiYm94LmxlZnQsXG4gICAgeTogZS5jbGllbnRZIC0gYmJveC50b3BcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IG1vdXNlIGNvb3JkcyB0byBzaWdtYSBjb29yZHMuXG4gKlxuICogQHBhcmFtICB7ZXZlbnR9ICAgICAgIGUgICAtIEEgbW91c2UgZXZlbnQgb3IgdG91Y2ggb2JqZWN0LlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSAtIEEgRE9NIGVsZW1lbnQgdG8gY29tcHV0ZSBvZmZzZXQgcmVsYXRpdmVseSB0by5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VDb29yZHMoZSwgZG9tKSB7XG4gIHZhciByZXMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZ2V0UG9zaXRpb24oZSwgZG9tKSksIHt9LCB7XG4gICAgc2lnbWFEZWZhdWx0UHJldmVudGVkOiBmYWxzZSxcbiAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgcmVzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfSxcbiAgICBvcmlnaW5hbDogZVxuICB9KTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHRvdWNoIGNvb3JkcyBvciBhIG1vdXNlIGNvb3JkcywgYW5kIGFsd2F5cyByZXR1cm5zIGEgY2xlYW4gbW91c2UgY29vcmRzIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xlYW5Nb3VzZUNvb3JkcyhlKSB7XG4gIHZhciByZXMgPSBcInhcIiBpbiBlID8gZSA6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBlLnRvdWNoZXNbMF0gfHwgZS5wcmV2aW91c1RvdWNoZXNbMF0pLCB7fSwge1xuICAgIG9yaWdpbmFsOiBlLm9yaWdpbmFsLFxuICAgIHNpZ21hRGVmYXVsdFByZXZlbnRlZDogZS5zaWdtYURlZmF1bHRQcmV2ZW50ZWQsXG4gICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gcHJldmVudFNpZ21hRGVmYXVsdCgpIHtcbiAgICAgIGUuc2lnbWFEZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgIHJlcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQ29udmVydCBtb3VzZSB3aGVlbCBldmVudCBjb29yZHMgdG8gc2lnbWEgY29vcmRzLlxuICpcbiAqIEBwYXJhbSAge2V2ZW50fSAgICAgICBlICAgLSBBIHdoZWVsIG1vdXNlIGV2ZW50LlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSAtIEEgRE9NIGVsZW1lbnQgdG8gY29tcHV0ZSBvZmZzZXQgcmVsYXRpdmVseSB0by5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0V2hlZWxDb29yZHMoZSwgZG9tKSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZ2V0TW91c2VDb29yZHMoZSwgZG9tKSksIHt9LCB7XG4gICAgZGVsdGE6IGdldFdoZWVsRGVsdGEoZSlcbiAgfSk7XG59XG52YXIgTUFYX1RPVUNIRVMgPSAyO1xuZnVuY3Rpb24gZ2V0VG91Y2hlc0FycmF5KHRvdWNoZXMpIHtcbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKHRvdWNoZXMubGVuZ3RoLCBNQVhfVE9VQ0hFUyk7IGkgPCBsOyBpKyspIGFyci5wdXNoKHRvdWNoZXNbaV0pO1xuICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdG91Y2ggY29vcmRzIHRvIHNpZ21hIGNvb3Jkcy5cbiAqXG4gKiBAcGFyYW0gIHtldmVudH0gICAgICAgZSAgICAgICAgICAgICAgIC0gQSB0b3VjaCBldmVudC5cbiAqIEBwYXJhbSAge1RvdWNoW119ICAgICBwcmV2aW91c1RvdWNoZXMgLSBBbiBhcnJheSBvZiB0aGUgcHJldmlvdXNseSBzdG9yZWQgdG91Y2hlcy5cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBkb20gICAgICAgICAgICAgLSBBIERPTSBlbGVtZW50IHRvIGNvbXB1dGUgb2Zmc2V0IHJlbGF0aXZlbHkgdG8uXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFRvdWNoQ29vcmRzKGUsIHByZXZpb3VzVG91Y2hlcywgZG9tKSB7XG4gIHZhciByZXMgPSB7XG4gICAgdG91Y2hlczogZ2V0VG91Y2hlc0FycmF5KGUudG91Y2hlcykubWFwKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgcmV0dXJuIGdldFBvc2l0aW9uKHRvdWNoLCBkb20pO1xuICAgIH0pLFxuICAgIHByZXZpb3VzVG91Y2hlczogcHJldmlvdXNUb3VjaGVzLm1hcChmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbih0b3VjaCwgZG9tKTtcbiAgICB9KSxcbiAgICBzaWdtYURlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlLFxuICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICByZXMuc2lnbWFEZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9yaWdpbmFsOiBlXG4gIH07XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogRXh0cmFjdCB0aGUgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNlIGV2ZW50IG9yIHRvdWNoIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtldmVudH0gIGUgLSBBIG1vdXNlIGV2ZW50IG9yIHRvdWNoIG9iamVjdC5cbiAqIEByZXR1cm4ge251bWJlcn0gICAgIFRoZSB3aGVlbCBkZWx0YSBvZiB0aGUgbW91c2UuXG4gKi9cbmZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZSkge1xuICAvLyBUT0RPOiBjaGVjayB0aG9zZSByYXRpb3MgYWdhaW4gdG8gZW5zdXJlIGEgY2xlYW4gQ2hyb21lL0ZpcmVmb3ggY29tcGF0XG4gIGlmICh0eXBlb2YgZS5kZWx0YVkgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBlLmRlbHRhWSAqIC0zIC8gMzYwO1xuICBpZiAodHlwZW9mIGUuZGV0YWlsICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZS5kZXRhaWwgLyAtOTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiQ2FwdG9yOiBjb3VsZCBub3QgZXh0cmFjdCBkZWx0YSBmcm9tIGV2ZW50LlwiKTtcbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyByZXByZXNlbnRpbmcgYSBjYXB0b3IgbGlrZSB0aGUgdXNlcidzIG1vdXNlIG9yIHRvdWNoIGNvbnRyb2xzLlxuICovXG52YXIgQ2FwdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHlwZWRFdmVudEVtaXR0ZXIpIHtcbiAgZnVuY3Rpb24gQ2FwdG9yKGNvbnRhaW5lciwgcmVuZGVyZXIpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhcHRvcik7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIENhcHRvcik7XG4gICAgLy8gUHJvcGVydGllc1xuICAgIF90aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICBfdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoQ2FwdG9yLCBfVHlwZWRFdmVudEVtaXR0ZXIpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENhcHRvcik7XG59KFR5cGVkRXZlbnRFbWl0dGVyKTtcblxudmFyIE1PVVNFX1NFVFRJTkdTX0tFWVMgPSBbXCJkb3VibGVDbGlja1RpbWVvdXRcIiwgXCJkb3VibGVDbGlja1pvb21pbmdEdXJhdGlvblwiLCBcImRvdWJsZUNsaWNrWm9vbWluZ1JhdGlvXCIsIFwiZHJhZ1RpbWVvdXRcIiwgXCJkcmFnZ2VkRXZlbnRzVG9sZXJhbmNlXCIsIFwiaW5lcnRpYUR1cmF0aW9uXCIsIFwiaW5lcnRpYVJhdGlvXCIsIFwiem9vbUR1cmF0aW9uXCIsIFwiem9vbWluZ1JhdGlvXCJdO1xudmFyIERFRkFVTFRfTU9VU0VfU0VUVElOR1MgPSBNT1VTRV9TRVRUSU5HU19LRVlTLnJlZHVjZShmdW5jdGlvbiAoaXRlciwga2V5KSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgaXRlciksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgREVGQVVMVF9TRVRUSU5HU1trZXldKSk7XG59LCB7fSk7XG5cbi8qKlxuICogRXZlbnQgdHlwZXMuXG4gKi9cbi8qKlxuICogTW91c2UgY2FwdG9yIGNsYXNzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTW91c2VDYXB0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DYXB0b3IpIHtcbiAgZnVuY3Rpb24gTW91c2VDYXB0b3IoY29udGFpbmVyLCByZW5kZXJlcikge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW91c2VDYXB0b3IpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBNb3VzZUNhcHRvciwgW2NvbnRhaW5lciwgcmVuZGVyZXJdKTtcblxuICAgIC8vIEJpbmRpbmcgbWV0aG9kc1xuICAgIC8vIFN0YXRlXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVuYWJsZWRcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImRyYWdnZWRFdmVudHNcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImRvd25TdGFydFRpbWVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImxhc3RNb3VzZVhcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImxhc3RNb3VzZVlcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImlzTW91c2VEb3duXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaXNNb3ZpbmdcIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtb3ZpbmdUaW1lb3V0XCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzdGFydENhbWVyYVN0YXRlXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjbGlja3NcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImRvdWJsZUNsaWNrVGltZW91dFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY3VycmVudFdoZWVsRGlyZWN0aW9uXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzZXR0aW5nc1wiLCBERUZBVUxUX01PVVNFX1NFVFRJTkdTKTtcbiAgICBfdGhpcy5oYW5kbGVDbGljayA9IF90aGlzLmhhbmRsZUNsaWNrLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZVJpZ2h0Q2xpY2sgPSBfdGhpcy5oYW5kbGVSaWdodENsaWNrLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZURvd24gPSBfdGhpcy5oYW5kbGVEb3duLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZVVwID0gX3RoaXMuaGFuZGxlVXAuYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlTW92ZSA9IF90aGlzLmhhbmRsZU1vdmUuYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlV2hlZWwgPSBfdGhpcy5oYW5kbGVXaGVlbC5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVMZWF2ZSA9IF90aGlzLmhhbmRsZUxlYXZlLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZUVudGVyID0gX3RoaXMuaGFuZGxlRW50ZXIuYmluZChfdGhpcyk7XG5cbiAgICAvLyBCaW5kaW5nIGV2ZW50c1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX3RoaXMuaGFuZGxlQ2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBfdGhpcy5oYW5kbGVSaWdodENsaWNrLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF90aGlzLmhhbmRsZURvd24sIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBfdGhpcy5oYW5kbGVXaGVlbCwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgX3RoaXMuaGFuZGxlTGVhdmUsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIF90aGlzLmhhbmRsZUVudGVyLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMuaGFuZGxlTW92ZSwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5oYW5kbGVVcCwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKE1vdXNlQ2FwdG9yLCBfQ2FwdG9yKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhNb3VzZUNhcHRvciwgW3tcbiAgICBrZXk6IFwia2lsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgdGhpcy5oYW5kbGVSaWdodENsaWNrKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuaGFuZGxlRG93bik7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMuaGFuZGxlV2hlZWwpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuaGFuZGxlTGVhdmUpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuaGFuZGxlRW50ZXIpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLmhhbmRsZU1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5oYW5kbGVVcCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHRoaXMuY2xpY2tzKys7XG4gICAgICBpZiAodGhpcy5jbGlja3MgPT09IDIpIHtcbiAgICAgICAgdGhpcy5jbGlja3MgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZG91YmxlQ2xpY2tUaW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlQ2xpY2tUaW1lb3V0KTtcbiAgICAgICAgICB0aGlzLmRvdWJsZUNsaWNrVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRG91YmxlQ2xpY2soZSk7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmNsaWNrcyA9IDA7XG4gICAgICAgIF90aGlzMi5kb3VibGVDbGlja1RpbWVvdXQgPSBudWxsO1xuICAgICAgfSwgdGhpcy5zZXR0aW5ncy5kb3VibGVDbGlja1RpbWVvdXQpO1xuXG4gICAgICAvLyBOT1RFOiB0aGlzIGlzIGhlcmUgdG8gcHJldmVudCBjbGljayBldmVudHMgb24gZHJhZ1xuICAgICAgaWYgKHRoaXMuZHJhZ2dlZEV2ZW50cyA8IHRoaXMuc2V0dGluZ3MuZHJhZ2dlZEV2ZW50c1RvbGVyYW5jZSkgdGhpcy5lbWl0KFwiY2xpY2tcIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlUmlnaHRDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVSaWdodENsaWNrKGUpIHtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgICB0aGlzLmVtaXQoXCJyaWdodENsaWNrXCIsIGdldE1vdXNlQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURvdWJsZUNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKGUpIHtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdmFyIG1vdXNlQ29vcmRzID0gZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpO1xuICAgICAgdGhpcy5lbWl0KFwiZG91YmxlQ2xpY2tcIiwgbW91c2VDb29yZHMpO1xuICAgICAgaWYgKG1vdXNlQ29vcmRzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgIHZhciBuZXdSYXRpbyA9IGNhbWVyYS5nZXRCb3VuZGVkUmF0aW8oY2FtZXJhLmdldFN0YXRlKCkucmF0aW8gLyB0aGlzLnNldHRpbmdzLmRvdWJsZUNsaWNrWm9vbWluZ1JhdGlvKTtcbiAgICAgIGNhbWVyYS5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0Vmlld3BvcnRab29tZWRTdGF0ZShnZXRQb3NpdGlvbihlLCB0aGlzLmNvbnRhaW5lciksIG5ld1JhdGlvKSwge1xuICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljSW5PdXRcIixcbiAgICAgICAgZHVyYXRpb246IHRoaXMuc2V0dGluZ3MuZG91YmxlQ2xpY2tab29taW5nRHVyYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZURvd24oZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcblxuICAgICAgLy8gV2Ugb25seSBzdGFydCBkcmFnZ2luZyBvbiBsZWZ0IGJ1dHRvblxuICAgICAgaWYgKGUuYnV0dG9uID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RhcnRDYW1lcmFTdGF0ZSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCkuZ2V0U3RhdGUoKTtcbiAgICAgICAgdmFyIF9nZXRQb3NpdGlvbiA9IGdldFBvc2l0aW9uKGUsIHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgICB4ID0gX2dldFBvc2l0aW9uLngsXG4gICAgICAgICAgeSA9IF9nZXRQb3NpdGlvbi55O1xuICAgICAgICB0aGlzLmxhc3RNb3VzZVggPSB4O1xuICAgICAgICB0aGlzLmxhc3RNb3VzZVkgPSB5O1xuICAgICAgICB0aGlzLmRyYWdnZWRFdmVudHMgPSAwO1xuICAgICAgICB0aGlzLmRvd25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmlzTW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcIm1vdXNlZG93blwiLCBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVVcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVVcChlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLmlzTW91c2VEb3duKSByZXR1cm47XG4gICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgIHRoaXMuaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5tb3ZpbmdUaW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdmluZ1RpbWVvdXQpO1xuICAgICAgICB0aGlzLm1vdmluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIF9nZXRQb3NpdGlvbjIgPSBnZXRQb3NpdGlvbihlLCB0aGlzLmNvbnRhaW5lciksXG4gICAgICAgIHggPSBfZ2V0UG9zaXRpb24yLngsXG4gICAgICAgIHkgPSBfZ2V0UG9zaXRpb24yLnk7XG4gICAgICB2YXIgY2FtZXJhU3RhdGUgPSBjYW1lcmEuZ2V0U3RhdGUoKSxcbiAgICAgICAgcHJldmlvdXNDYW1lcmFTdGF0ZSA9IGNhbWVyYS5nZXRQcmV2aW91c1N0YXRlKCkgfHwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgaWYgKHRoaXMuaXNNb3ZpbmcpIHtcbiAgICAgICAgY2FtZXJhLmFuaW1hdGUoe1xuICAgICAgICAgIHg6IGNhbWVyYVN0YXRlLnggKyB0aGlzLnNldHRpbmdzLmluZXJ0aWFSYXRpbyAqIChjYW1lcmFTdGF0ZS54IC0gcHJldmlvdXNDYW1lcmFTdGF0ZS54KSxcbiAgICAgICAgICB5OiBjYW1lcmFTdGF0ZS55ICsgdGhpcy5zZXR0aW5ncy5pbmVydGlhUmF0aW8gKiAoY2FtZXJhU3RhdGUueSAtIHByZXZpb3VzQ2FtZXJhU3RhdGUueSlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLnNldHRpbmdzLmluZXJ0aWFEdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljT3V0XCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGFzdE1vdXNlWCAhPT0geCB8fCB0aGlzLmxhc3RNb3VzZVkgIT09IHkpIHtcbiAgICAgICAgY2FtZXJhLnNldFN0YXRlKHtcbiAgICAgICAgICB4OiBjYW1lcmFTdGF0ZS54LFxuICAgICAgICAgIHk6IGNhbWVyYVN0YXRlLnlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmlzTW92aW5nID0gZmFsc2U7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNob3VsZFJlZnJlc2ggPSBfdGhpczMuZHJhZ2dlZEV2ZW50cyA+IDA7XG4gICAgICAgIF90aGlzMy5kcmFnZ2VkRXZlbnRzID0gMDtcblxuICAgICAgICAvLyBOT1RFOiB0aGlzIHJlZnJlc2ggaXMgaGVyZSB0byBtYWtlIHN1cmUgYGhpZGVFZGdlc09uTW92ZWAgY2FuIHdvcmtcbiAgICAgICAgLy8gd2hlbiBzb21lb25lIHJlbGVhc2VzIGNhbWVyYSBwYW4gZHJhZyBhZnRlciBoYXZpbmcgc3RvcHBlZCBtb3ZpbmcuXG4gICAgICAgIC8vIFNlZSBjb21taXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYWNvbXlhbC9zaWdtYS5qcy9jb21taXQvY2ZkOTE5N2Y3MDMxOTEwOWRiNmI2NzVkZDdjODJiZTQ5M2NhOTVhMlxuICAgICAgICAvLyBTZWUgYWxzbyBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2phY29teWFsL3NpZ21hLmpzL2lzc3Vlcy8xMjkwXG4gICAgICAgIC8vIEl0IGNvdWxkIGJlIHBvc3NpYmxlIHRvIHJlbmRlciBpbnN0ZWFkIG9mIHNjaGVkdWxpbmcgYSByZWZyZXNoIGJ1dCBmb3JcbiAgICAgICAgLy8gbm93IGl0IHNlZW1zIGdvb2QgZW5vdWdoLlxuICAgICAgICBpZiAoc2hvdWxkUmVmcmVzaCAmJiBfdGhpczMucmVuZGVyZXIuZ2V0U2V0dGluZyhcImhpZGVFZGdlc09uTW92ZVwiKSkgX3RoaXMzLnJlbmRlcmVyLnJlZnJlc2goKTtcbiAgICAgIH0sIDApO1xuICAgICAgdGhpcy5lbWl0KFwibW91c2V1cFwiLCBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdmUoZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgdmFyIG1vdXNlQ29vcmRzID0gZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpO1xuXG4gICAgICAvLyBBbHdheXMgdHJpZ2dlciBhIFwibW91c2Vtb3ZlYm9keVwiIGV2ZW50LCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGRldmVsb3BcbiAgICAgIC8vIGEgZHJhZy1hbmQtZHJvcCBlZmZlY3QgdGhhdCB3b3JrcyBldmVuIHdoZW4gdGhlIG1vdXNlIGlzIG91dCBvZiB0aGVcbiAgICAgIC8vIGNvbnRhaW5lcjpcbiAgICAgIHRoaXMuZW1pdChcIm1vdXNlbW92ZWJvZHlcIiwgbW91c2VDb29yZHMpO1xuXG4gICAgICAvLyBPbmx5IHRyaWdnZXIgdGhlIFwibW91c2Vtb3ZlXCIgZXZlbnQgd2hlbiB0aGUgbW91c2UgaXMgYWN0dWFsbHkgaG92ZXJpbmdcbiAgICAgIC8vIHRoZSBjb250YWluZXIsIHRvIGF2b2lkIHdlaXJkbHkgaG92ZXJpbmcgbm9kZXMgYW5kL29yIGVkZ2VzIHdoZW4gdGhlXG4gICAgICAvLyBtb3VzZSBpcyBub3QgaG92ZXIgdGhlIGNvbnRhaW5lcjpcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy5jb250YWluZXIgfHwgZS5jb21wb3NlZFBhdGgoKVswXSA9PT0gdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwibW91c2Vtb3ZlXCIsIG1vdXNlQ29vcmRzKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb3VzZUNvb3Jkcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZW4gXCJpc01vdXNlRG93blwiIGFsbCB0aGUgdGltZSwgdG8gYWxsb3cgZHJhZ2dpbmcgdGhlXG4gICAgICAvLyBzdGFnZSB3aGlsZSB0aGUgbW91c2UgaXMgbm90IGhvdmVyIHRoZSBjb250YWluZXI6XG4gICAgICBpZiAodGhpcy5pc01vdXNlRG93bikge1xuICAgICAgICB0aGlzLmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kcmFnZ2VkRXZlbnRzKys7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tb3ZpbmdUaW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubW92aW5nVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZpbmdUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC5tb3ZpbmdUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICBfdGhpczQuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgdGhpcy5zZXR0aW5ncy5kcmFnVGltZW91dCk7XG4gICAgICAgIHZhciBjYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgICB2YXIgX2dldFBvc2l0aW9uMyA9IGdldFBvc2l0aW9uKGUsIHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgICBlWCA9IF9nZXRQb3NpdGlvbjMueCxcbiAgICAgICAgICBlWSA9IF9nZXRQb3NpdGlvbjMueTtcbiAgICAgICAgdmFyIGxhc3RNb3VzZSA9IHRoaXMucmVuZGVyZXIudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICB4OiB0aGlzLmxhc3RNb3VzZVgsXG4gICAgICAgICAgeTogdGhpcy5sYXN0TW91c2VZXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbW91c2UgPSB0aGlzLnJlbmRlcmVyLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogZVgsXG4gICAgICAgICAgeTogZVlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvZmZzZXRYID0gbGFzdE1vdXNlLnggLSBtb3VzZS54LFxuICAgICAgICAgIG9mZnNldFkgPSBsYXN0TW91c2UueSAtIG1vdXNlLnk7XG4gICAgICAgIHZhciBjYW1lcmFTdGF0ZSA9IGNhbWVyYS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgeCA9IGNhbWVyYVN0YXRlLnggKyBvZmZzZXRYLFxuICAgICAgICAgIHkgPSBjYW1lcmFTdGF0ZS55ICsgb2Zmc2V0WTtcbiAgICAgICAgY2FtZXJhLnNldFN0YXRlKHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGFzdE1vdXNlWCA9IGVYO1xuICAgICAgICB0aGlzLmxhc3RNb3VzZVkgPSBlWTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVMZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVMZWF2ZShlKSB7XG4gICAgICB0aGlzLmVtaXQoXCJtb3VzZWxlYXZlXCIsIGdldE1vdXNlQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUVudGVyKGUpIHtcbiAgICAgIHRoaXMuZW1pdChcIm1vdXNlZW50ZXJcIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlV2hlZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlV2hlZWwoZSkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICFjYW1lcmEuZW5hYmxlZFpvb21pbmcpIHJldHVybjtcbiAgICAgIHZhciBkZWx0YSA9IGdldFdoZWVsRGVsdGEoZSk7XG4gICAgICBpZiAoIWRlbHRhKSByZXR1cm47XG4gICAgICB2YXIgd2hlZWxDb29yZHMgPSBnZXRXaGVlbENvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmVtaXQoXCJ3aGVlbFwiLCB3aGVlbENvb3Jkcyk7XG4gICAgICBpZiAod2hlZWxDb29yZHMuc2lnbWFEZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yXG4gICAgICB2YXIgY3VycmVudFJhdGlvID0gY2FtZXJhLmdldFN0YXRlKCkucmF0aW87XG4gICAgICB2YXIgcmF0aW9EaWZmID0gZGVsdGEgPiAwID8gMSAvIHRoaXMuc2V0dGluZ3Muem9vbWluZ1JhdGlvIDogdGhpcy5zZXR0aW5ncy56b29taW5nUmF0aW87XG4gICAgICB2YXIgbmV3UmF0aW8gPSBjYW1lcmEuZ2V0Qm91bmRlZFJhdGlvKGN1cnJlbnRSYXRpbyAqIHJhdGlvRGlmZik7XG4gICAgICB2YXIgd2hlZWxEaXJlY3Rpb24gPSBkZWx0YSA+IDAgPyAxIDogLTE7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSB3aXRob3V0IHByZXZlbnRpbmcgZGVmYXVsdCBiZWhhdmlvciB3aGVuIHJhdGlvIGRvZXNuJ3QgY2hhbmdlOlxuICAgICAgaWYgKGN1cnJlbnRSYXRpbyA9PT0gbmV3UmF0aW8pIHJldHVybjtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIC8vIENhbmNlbCBldmVudHMgdGhhdCBhcmUgdG9vIGNsb3NlIGVhY2ggb3RoZXIgYW5kIGluIHRoZSBzYW1lIGRpcmVjdGlvbjpcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRXaGVlbERpcmVjdGlvbiA9PT0gd2hlZWxEaXJlY3Rpb24gJiYgdGhpcy5sYXN0V2hlZWxUcmlnZ2VyVGltZSAmJiBub3cgLSB0aGlzLmxhc3RXaGVlbFRyaWdnZXJUaW1lIDwgdGhpcy5zZXR0aW5ncy56b29tRHVyYXRpb24gLyA1KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbWVyYS5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0Vmlld3BvcnRab29tZWRTdGF0ZShnZXRQb3NpdGlvbihlLCB0aGlzLmNvbnRhaW5lciksIG5ld1JhdGlvKSwge1xuICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljT3V0XCIsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLnNldHRpbmdzLnpvb21EdXJhdGlvblxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczUuY3VycmVudFdoZWVsRGlyZWN0aW9uID0gMDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50V2hlZWxEaXJlY3Rpb24gPSB3aGVlbERpcmVjdGlvbjtcbiAgICAgIHRoaXMubGFzdFdoZWVsVHJpZ2dlclRpbWUgPSBub3c7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfVxuICB9XSk7XG59KENhcHRvcik7XG5cbnZhciBUT1VDSF9TRVRUSU5HU19LRVlTID0gW1wiZHJhZ1RpbWVvdXRcIiwgXCJpbmVydGlhRHVyYXRpb25cIiwgXCJpbmVydGlhUmF0aW9cIiwgXCJkb3VibGVDbGlja1RpbWVvdXRcIiwgXCJkb3VibGVDbGlja1pvb21pbmdSYXRpb1wiLCBcImRvdWJsZUNsaWNrWm9vbWluZ0R1cmF0aW9uXCIsIFwidGFwTW92ZVRvbGVyYW5jZVwiXTtcbnZhciBERUZBVUxUX1RPVUNIX1NFVFRJTkdTID0gVE9VQ0hfU0VUVElOR1NfS0VZUy5yZWR1Y2UoZnVuY3Rpb24gKGl0ZXIsIGtleSkge1xuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGl0ZXIpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIERFRkFVTFRfU0VUVElOR1Nba2V5XSkpO1xufSwge30pO1xuXG4vKipcbiAqIEV2ZW50IHR5cGVzLlxuICovXG4vKipcbiAqIFRvdWNoIGNhcHRvciBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFRvdWNoQ2FwdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2FwdG9yKSB7XG4gIGZ1bmN0aW9uIFRvdWNoQ2FwdG9yKGNvbnRhaW5lciwgcmVuZGVyZXIpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvdWNoQ2FwdG9yKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgVG91Y2hDYXB0b3IsIFtjb250YWluZXIsIHJlbmRlcmVyXSk7XG5cbiAgICAvLyBCaW5kaW5nIG1ldGhvZHM6XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVuYWJsZWRcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImlzTW92aW5nXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFzTW92ZWRcIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0b3VjaE1vZGVcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInN0YXJ0VG91Y2hlc1Bvc2l0aW9uc1wiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImxhc3RUb3VjaGVzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibGFzdFRhcFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic2V0dGluZ3NcIiwgREVGQVVMVF9UT1VDSF9TRVRUSU5HUyk7XG4gICAgX3RoaXMuaGFuZGxlU3RhcnQgPSBfdGhpcy5oYW5kbGVTdGFydC5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVMZWF2ZSA9IF90aGlzLmhhbmRsZUxlYXZlLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZU1vdmUgPSBfdGhpcy5oYW5kbGVNb3ZlLmJpbmQoX3RoaXMpO1xuXG4gICAgLy8gQmluZGluZyBldmVudHNcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX3RoaXMuaGFuZGxlU3RhcnQsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBfdGhpcy5oYW5kbGVMZWF2ZSwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgX3RoaXMuaGFuZGxlTGVhdmUsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLmhhbmRsZU1vdmUsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKFRvdWNoQ2FwdG9yLCBfQ2FwdG9yKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUb3VjaENhcHRvciwgW3tcbiAgICBrZXk6IFwia2lsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuaGFuZGxlU3RhcnQpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLmhhbmRsZUxlYXZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLmhhbmRsZUxlYXZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5oYW5kbGVNb3ZlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlU3RhcnQoZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzQXJyYXkoZS50b3VjaGVzKTtcbiAgICAgIHRoaXMudG91Y2hNb2RlID0gdG91Y2hlcy5sZW5ndGg7XG4gICAgICB0aGlzLnN0YXJ0Q2FtZXJhU3RhdGUgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpLmdldFN0YXRlKCk7XG4gICAgICB0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9ucyA9IHRvdWNoZXMubWFwKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICByZXR1cm4gZ2V0UG9zaXRpb24odG91Y2gsIF90aGlzMi5jb250YWluZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIHR3byB0b3VjaGVzIGRvd24sIGxldCdzIHJlY29yZCBkaXN0YW5jZSBhbmQgYW5nbGUgYXMgd2VsbDpcbiAgICAgIGlmICh0aGlzLnRvdWNoTW9kZSA9PT0gMikge1xuICAgICAgICB2YXIgX3RoaXMkc3RhcnRUb3VjaGVzUG9zID0gX3NsaWNlZFRvQXJyYXkodGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMsIDIpLFxuICAgICAgICAgIF90aGlzJHN0YXJ0VG91Y2hlc1BvczIgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3NbMF0sXG4gICAgICAgICAgeDAgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3MyLngsXG4gICAgICAgICAgeTAgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3MyLnksXG4gICAgICAgICAgX3RoaXMkc3RhcnRUb3VjaGVzUG9zMyA9IF90aGlzJHN0YXJ0VG91Y2hlc1Bvc1sxXSxcbiAgICAgICAgICB4MSA9IF90aGlzJHN0YXJ0VG91Y2hlc1BvczMueCxcbiAgICAgICAgICB5MSA9IF90aGlzJHN0YXJ0VG91Y2hlc1BvczMueTtcbiAgICAgICAgdGhpcy5zdGFydFRvdWNoZXNBbmdsZSA9IE1hdGguYXRhbjIoeTEgLSB5MCwgeDEgLSB4MCk7XG4gICAgICAgIHRoaXMuc3RhcnRUb3VjaGVzRGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MCwgMikgKyBNYXRoLnBvdyh5MSAtIHkwLCAyKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJ0b3VjaGRvd25cIiwgZ2V0VG91Y2hDb29yZHMoZSwgdGhpcy5sYXN0VG91Y2hlcywgdGhpcy5jb250YWluZXIpKTtcbiAgICAgIHRoaXMubGFzdFRvdWNoZXMgPSB0b3VjaGVzO1xuICAgICAgdGhpcy5sYXN0VG91Y2hlc1Bvc2l0aW9ucyA9IHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVMZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVMZWF2ZShlKSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMubGVuZ3RoKSByZXR1cm47XG4gICAgICBpZiAoZS5jYW5jZWxhYmxlKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAodGhpcy5tb3ZpbmdUaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubW92aW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRoaXMudG91Y2hNb2RlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3RhcnQoZSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmICh0aGlzLmlzTW92aW5nKSB7XG4gICAgICAgICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgICAgICAgIHZhciBjYW1lcmFTdGF0ZSA9IGNhbWVyYS5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgICBwcmV2aW91c0NhbWVyYVN0YXRlID0gY2FtZXJhLmdldFByZXZpb3VzU3RhdGUoKSB8fCB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYW1lcmEuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgIHg6IGNhbWVyYVN0YXRlLnggKyB0aGlzLnNldHRpbmdzLmluZXJ0aWFSYXRpbyAqIChjYW1lcmFTdGF0ZS54IC0gcHJldmlvdXNDYW1lcmFTdGF0ZS54KSxcbiAgICAgICAgICAgICAgeTogY2FtZXJhU3RhdGUueSArIHRoaXMuc2V0dGluZ3MuaW5lcnRpYVJhdGlvICogKGNhbWVyYVN0YXRlLnkgLSBwcmV2aW91c0NhbWVyYVN0YXRlLnkpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLnNldHRpbmdzLmluZXJ0aWFEdXJhdGlvbixcbiAgICAgICAgICAgICAgZWFzaW5nOiBcInF1YWRyYXRpY091dFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnRvdWNoTW9kZSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJ0b3VjaHVwXCIsIGdldFRvdWNoQ29vcmRzKGUsIHRoaXMubGFzdFRvdWNoZXMsIHRoaXMuY29udGFpbmVyKSk7XG5cbiAgICAgIC8vIFdoZW4gdGhlIGxhc3QgdG91Y2ggZW5kcyBhbmQgdGhlcmUgaGFzbid0IGJlZW4gdG9vIG11Y2ggbW92ZW1lbnQsIHRyaWdnZXIgYSBcInRhcFwiIG9yIFwiZG91YmxldGFwXCIgZXZlbnQ6XG4gICAgICBpZiAoIWUudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24odGhpcy5sYXN0VG91Y2hlc1swXSwgdGhpcy5jb250YWluZXIpO1xuICAgICAgICB2YXIgZG93blBvc2l0aW9uID0gdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnNbMF07XG4gICAgICAgIHZhciBkU3F1YXJlID0gTWF0aC5wb3cocG9zaXRpb24ueCAtIGRvd25Qb3NpdGlvbi54LCAyKSArIE1hdGgucG93KHBvc2l0aW9uLnkgLSBkb3duUG9zaXRpb24ueSwgMik7XG4gICAgICAgIGlmICghZS50b3VjaGVzLmxlbmd0aCAmJiBkU3F1YXJlIDwgTWF0aC5wb3codGhpcy5zZXR0aW5ncy50YXBNb3ZlVG9sZXJhbmNlLCAyKSkge1xuICAgICAgICAgIC8vIE9ubHkgdHJpZ2dlciBcImRvdWJsZXRhcFwiIHdoZW4gdGhlIGxhc3QgdGFwIGlzIHJlY2VudCBlbm91Z2g6XG4gICAgICAgICAgaWYgKHRoaXMubGFzdFRhcCAmJiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0VGFwLnRpbWUgPCB0aGlzLnNldHRpbmdzLmRvdWJsZUNsaWNrVGltZW91dCkge1xuICAgICAgICAgICAgdmFyIHRvdWNoQ29vcmRzID0gZ2V0VG91Y2hDb29yZHMoZSwgdGhpcy5sYXN0VG91Y2hlcywgdGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZG91YmxldGFwXCIsIHRvdWNoQ29vcmRzKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFRhcCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIXRvdWNoQ29vcmRzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICB2YXIgX2NhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICAgICAgICAgIHZhciBuZXdSYXRpbyA9IF9jYW1lcmEuZ2V0Qm91bmRlZFJhdGlvKF9jYW1lcmEuZ2V0U3RhdGUoKS5yYXRpbyAvIHRoaXMuc2V0dGluZ3MuZG91YmxlQ2xpY2tab29taW5nUmF0aW8pO1xuICAgICAgICAgICAgICBfY2FtZXJhLmFuaW1hdGUodGhpcy5yZW5kZXJlci5nZXRWaWV3cG9ydFpvb21lZFN0YXRlKHBvc2l0aW9uLCBuZXdSYXRpbyksIHtcbiAgICAgICAgICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljSW5PdXRcIixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5zZXR0aW5ncy5kb3VibGVDbGlja1pvb21pbmdEdXJhdGlvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRWxzZSwgdHJpZ2dlciBhIG5vcm1hbCBcInRhcFwiIGV2ZW50OlxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIF90b3VjaENvb3JkcyA9IGdldFRvdWNoQ29vcmRzKGUsIHRoaXMubGFzdFRvdWNoZXMsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInRhcFwiLCBfdG91Y2hDb29yZHMpO1xuICAgICAgICAgICAgdGhpcy5sYXN0VGFwID0ge1xuICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogX3RvdWNoQ29vcmRzLnRvdWNoZXNbMF0gfHwgX3RvdWNoQ29vcmRzLnByZXZpb3VzVG91Y2hlc1swXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFRvdWNoZXMgPSBnZXRUb3VjaGVzQXJyYXkoZS50b3VjaGVzKTtcbiAgICAgIHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zID0gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW92ZShlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9ucy5sZW5ndGgpIHJldHVybjtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlc0FycmF5KGUudG91Y2hlcyk7XG4gICAgICB2YXIgdG91Y2hlc1Bvc2l0aW9ucyA9IHRvdWNoZXMubWFwKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICByZXR1cm4gZ2V0UG9zaXRpb24odG91Y2gsIF90aGlzMy5jb250YWluZXIpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbGFzdFRvdWNoZXMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgdGhpcy5sYXN0VG91Y2hlcyA9IHRvdWNoZXM7XG4gICAgICB0aGlzLmxhc3RUb3VjaGVzUG9zaXRpb25zID0gdG91Y2hlc1Bvc2l0aW9ucztcbiAgICAgIHZhciB0b3VjaENvb3JkcyA9IGdldFRvdWNoQ29vcmRzKGUsIGxhc3RUb3VjaGVzLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmVtaXQoXCJ0b3VjaG1vdmVcIiwgdG91Y2hDb29yZHMpO1xuICAgICAgaWYgKHRvdWNoQ29vcmRzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBJZiBhIG1vdmUgd2FzIGluaXRpYXRlZCBhdCBzb21lIHBvaW50LCBhbmQgd2UgZ2V0IGJhY2sgdG8gc3RhcnQgcG9pbnQsXG4gICAgICAvLyB3ZSBzaG91bGQgc3RpbGwgY29uc2lkZXIgdGhhdCB3ZSBkaWQgbW92ZSAod2hpY2ggYWxzbyBoYXBwZW5zIGFmdGVyIGFcbiAgICAgIC8vIG11bHRpcGxlIHRvdWNoIHdoZW4gb25seSBvbmUgdG91Y2ggcmVtYWlucyBpbiB3aGljaCBjYXNlIGhhbmRsZVN0YXJ0XG4gICAgICAvLyBpcyByZWNhbGxlZCB3aXRoaW4gaGFuZGxlTGVhdmUpLlxuICAgICAgLy8gTm93LCBzb21lIG1vYmlsZSBicm93c2VycyByZXBvcnQgemVyby1kaXN0YW5jZSBtb3ZlcyBzbyB3ZSBhbHNvIGNoZWNrIHRoYXRcbiAgICAgIC8vIG9uZSBvZiB0aGUgdG91Y2hlcyBkaWQgYWN0dWFsbHkgbW92ZSBmcm9tIHRoZSBvcmlnaW4gcG9zaXRpb24uXG4gICAgICB0aGlzLmhhc01vdmVkIHx8ICh0aGlzLmhhc01vdmVkID0gdG91Y2hlc1Bvc2l0aW9ucy5zb21lKGZ1bmN0aW9uIChwb3NpdGlvbiwgaWR4KSB7XG4gICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gX3RoaXMzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9uc1tpZHhdO1xuICAgICAgICByZXR1cm4gc3RhcnRQb3NpdGlvbiAmJiAocG9zaXRpb24ueCAhPT0gc3RhcnRQb3NpdGlvbi54IHx8IHBvc2l0aW9uLnkgIT09IHN0YXJ0UG9zaXRpb24ueSk7XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIElmIHRoZXJlIHdhcyBubyBtb3ZlLCBkbyBub3QgdHJpZ2dlciB0b3VjaCBtb3ZlcyBiZWhhdmlvclxuICAgICAgaWYgKCF0aGlzLmhhc01vdmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMubW92aW5nVGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMubW92aW5nVGltZW91dCk7XG4gICAgICB0aGlzLm1vdmluZ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgfSwgdGhpcy5zZXR0aW5ncy5kcmFnVGltZW91dCk7XG4gICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgIHZhciBzdGFydENhbWVyYVN0YXRlID0gdGhpcy5zdGFydENhbWVyYVN0YXRlO1xuICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLnJlbmRlcmVyLmdldFNldHRpbmcoXCJzdGFnZVBhZGRpbmdcIik7XG4gICAgICBzd2l0Y2ggKHRoaXMudG91Y2hNb2RlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkcmVuZGVyZXIkdmlld3BvID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgoKHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zIHx8IFtdKVswXSksXG4gICAgICAgICAgICAgIHhTdGFydCA9IF90aGlzJHJlbmRlcmVyJHZpZXdwby54LFxuICAgICAgICAgICAgICB5U3RhcnQgPSBfdGhpcyRyZW5kZXJlciR2aWV3cG8ueTtcbiAgICAgICAgICAgIHZhciBfdGhpcyRyZW5kZXJlciR2aWV3cG8yID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgodG91Y2hlc1Bvc2l0aW9uc1swXSksXG4gICAgICAgICAgICAgIHggPSBfdGhpcyRyZW5kZXJlciR2aWV3cG8yLngsXG4gICAgICAgICAgICAgIHkgPSBfdGhpcyRyZW5kZXJlciR2aWV3cG8yLnk7XG4gICAgICAgICAgICBjYW1lcmEuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICB4OiBzdGFydENhbWVyYVN0YXRlLnggKyB4U3RhcnQgLSB4LFxuICAgICAgICAgICAgICB5OiBzdGFydENhbWVyYVN0YXRlLnkgKyB5U3RhcnQgLSB5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSGVyZSBpcyB0aGUgdGhpbmtpbmcgaGVyZTpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAxLiBXZSBjYW4gZmluZCB0aGUgbmV3IGFuZ2xlIGFuZCByYXRpbywgYnkgY29tcGFyaW5nIHRoZSB2ZWN0b3IgZnJvbSBcInRvdWNoIG9uZVwiIHRvIFwidG91Y2ggdHdvXCIgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgKiAgICBvZiB0aGUgZCduJ2QgYW5kIG5vd1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIDIuIFdlIGNhbiB1c2UgYENhbWVyYSN2aWV3cG9ydFRvR3JhcGhgIGluc2lkZSBmb3JtdWxhIHRvIHJldHJpZXZlIHRoZSBuZXcgY2FtZXJhIHBvc2l0aW9uLCB1c2luZyB0aGUgZ3JhcGhcbiAgICAgICAgICAgICAqICAgIHBvc2l0aW9uIG9mIGEgdG91Y2ggYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZCduJ2QgKHVzaW5nIGBzdGFydENhbWVyYS52aWV3cG9ydFRvR3JhcGhgKSBhbmQgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICAgKiAgICBwb3NpdGlvbiBvZiB0aGlzIHNhbWUgdG91Y2ggbm93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBuZXdDYW1lcmFTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgeDogMC41LFxuICAgICAgICAgICAgICB5OiAwLjUsXG4gICAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICAgICAgICByYXRpbzogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfdG91Y2hlc1Bvc2l0aW9ucyQgPSB0b3VjaGVzUG9zaXRpb25zWzBdLFxuICAgICAgICAgICAgICB4MCA9IF90b3VjaGVzUG9zaXRpb25zJC54LFxuICAgICAgICAgICAgICB5MCA9IF90b3VjaGVzUG9zaXRpb25zJC55O1xuICAgICAgICAgICAgdmFyIF90b3VjaGVzUG9zaXRpb25zJDIgPSB0b3VjaGVzUG9zaXRpb25zWzFdLFxuICAgICAgICAgICAgICB4MSA9IF90b3VjaGVzUG9zaXRpb25zJDIueCxcbiAgICAgICAgICAgICAgeTEgPSBfdG91Y2hlc1Bvc2l0aW9ucyQyLnk7XG4gICAgICAgICAgICB2YXIgYW5nbGVEaWZmID0gTWF0aC5hdGFuMih5MSAtIHkwLCB4MSAtIHgwKSAtIHRoaXMuc3RhcnRUb3VjaGVzQW5nbGU7XG4gICAgICAgICAgICB2YXIgcmF0aW9EaWZmID0gTWF0aC5oeXBvdCh5MSAtIHkwLCB4MSAtIHgwKSAvIHRoaXMuc3RhcnRUb3VjaGVzRGlzdGFuY2U7XG5cbiAgICAgICAgICAgIC8vIDEuXG4gICAgICAgICAgICB2YXIgbmV3UmF0aW8gPSBjYW1lcmEuZ2V0Qm91bmRlZFJhdGlvKHN0YXJ0Q2FtZXJhU3RhdGUucmF0aW8gLyByYXRpb0RpZmYpO1xuICAgICAgICAgICAgbmV3Q2FtZXJhU3RhdGUucmF0aW8gPSBuZXdSYXRpbztcbiAgICAgICAgICAgIG5ld0NhbWVyYVN0YXRlLmFuZ2xlID0gc3RhcnRDYW1lcmFTdGF0ZS5hbmdsZSArIGFuZ2xlRGlmZjtcblxuICAgICAgICAgICAgLy8gMi5cbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zKCk7XG4gICAgICAgICAgICB2YXIgdG91Y2hHcmFwaFBvc2l0aW9uID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgoKHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zIHx8IFtdKVswXSwge1xuICAgICAgICAgICAgICBjYW1lcmFTdGF0ZTogc3RhcnRDYW1lcmFTdGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgc21hbGxlc3REaW1lbnNpb24gPSBNYXRoLm1pbihkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCkgLSAyICogcGFkZGluZztcbiAgICAgICAgICAgIHZhciBkeCA9IHNtYWxsZXN0RGltZW5zaW9uIC8gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgIHZhciBkeSA9IHNtYWxsZXN0RGltZW5zaW9uIC8gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBuZXdSYXRpbyAvIHNtYWxsZXN0RGltZW5zaW9uO1xuXG4gICAgICAgICAgICAvLyBBbGlnbiB3aXRoIGNlbnRlciBvZiB0aGUgZ3JhcGg6XG4gICAgICAgICAgICB2YXIgX3ggPSB4MCAtIHNtYWxsZXN0RGltZW5zaW9uIC8gMiAvIGR4O1xuICAgICAgICAgICAgdmFyIF95ID0geTAgLSBzbWFsbGVzdERpbWVuc2lvbiAvIDIgLyBkeTtcblxuICAgICAgICAgICAgLy8gUm90YXRlOlxuICAgICAgICAgICAgdmFyIF9yZWYgPSBbX3ggKiBNYXRoLmNvcygtbmV3Q2FtZXJhU3RhdGUuYW5nbGUpIC0gX3kgKiBNYXRoLnNpbigtbmV3Q2FtZXJhU3RhdGUuYW5nbGUpLCBfeSAqIE1hdGguY29zKC1uZXdDYW1lcmFTdGF0ZS5hbmdsZSkgKyBfeCAqIE1hdGguc2luKC1uZXdDYW1lcmFTdGF0ZS5hbmdsZSldO1xuICAgICAgICAgICAgX3ggPSBfcmVmWzBdO1xuICAgICAgICAgICAgX3kgPSBfcmVmWzFdO1xuICAgICAgICAgICAgbmV3Q2FtZXJhU3RhdGUueCA9IHRvdWNoR3JhcGhQb3NpdGlvbi54IC0gX3ggKiByYXRpbztcbiAgICAgICAgICAgIG5ld0NhbWVyYVN0YXRlLnkgPSB0b3VjaEdyYXBoUG9zaXRpb24ueSArIF95ICogcmF0aW87XG4gICAgICAgICAgICBjYW1lcmEuc2V0U3RhdGUobmV3Q2FtZXJhU3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIH1cbiAgfV0pO1xufShDYXB0b3IpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHtcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkge1xuICBpZiAobnVsbCA9PSByKSByZXR1cm4ge307XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHtcbiAgICBpZiAoLTEgIT09IGUuaW5kZXhPZihuKSkgY29udGludWU7XG4gICAgdFtuXSA9IHJbbl07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlLCB0KSB7XG4gIGlmIChudWxsID09IGUpIHJldHVybiB7fTtcbiAgdmFyIG8sXG4gICAgcixcbiAgICBpID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAociA9IDA7IHIgPCBuLmxlbmd0aDsgcisrKSBvID0gbltyXSwgLTEgPT09IHQuaW5kZXhPZihvKSAmJiB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbi8qKlxuICogU2lnbWEuanMgTGFiZWxzIEhldXJpc3RpY3NcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIE1pc2NlbGxhbmVvdXMgaGV1cmlzdGljcyByZWxhdGVkIHRvIGxhYmVsIGRpc3BsYXkuXG4gKiBAbW9kdWxlXG4gKi9cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgc2luZ2xlIGNhbmRpZGF0ZSBmb3IgdGhlIGxhYmVsIGdyaWQgc2VsZWN0aW9uLlxuICpcbiAqIEl0IGFsc28gZGVzY3JpYmVzIGEgZGV0ZXJtaW5pc3RpYyB3YXkgdG8gY29tcGFyZSB0d28gY2FuZGlkYXRlcyB0byBhc3Nlc3NcbiAqIHdoaWNoIG9uZSBpcyBiZXR0ZXIuXG4gKi9cbnZhciBMYWJlbENhbmRpZGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExhYmVsQ2FuZGlkYXRlKGtleSwgc2l6ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbENhbmRpZGF0ZSk7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKExhYmVsQ2FuZGlkYXRlLCBudWxsLCBbe1xuICAgIGtleTogXCJjb21wYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUoZmlyc3QsIHNlY29uZCkge1xuICAgICAgLy8gRmlyc3Qgd2UgY29tcGFyZSBieSBzaXplXG4gICAgICBpZiAoZmlyc3Quc2l6ZSA+IHNlY29uZC5zaXplKSByZXR1cm4gLTE7XG4gICAgICBpZiAoZmlyc3Quc2l6ZSA8IHNlY29uZC5zaXplKSByZXR1cm4gMTtcblxuICAgICAgLy8gVGhlbiBzaW5jZSBubyB0d28gbm9kZXMgY2FuIGhhdmUgdGhlIHNhbWUga2V5LCB3ZSB1c2UgaXQgdG9cbiAgICAgIC8vIGRldGVybWluaXN0aWNhbGx5IHRpZS1icmVhayBieSBrZXlcbiAgICAgIGlmIChmaXJzdC5rZXkgPiBzZWNvbmQua2V5KSByZXR1cm4gMTtcblxuICAgICAgLy8gTk9URTogdGhpcyBjb21wYXJhdG9yIGNhbm5vdCByZXR1cm4gMFxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSAyRCBzcGF0aWFsIGdyaWQgZGl2aWRlZCBpbnRvIGNvbnN0YW50LXNpemUgY2VsbHMuXG4gKi9cbnZhciBMYWJlbEdyaWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYWJlbEdyaWQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsR3JpZCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2lkdGhcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGVpZ2h0XCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNlbGxTaXplXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbHVtbnNcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicm93c1wiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjZWxsc1wiLCB7fSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMYWJlbEdyaWQsIFt7XG4gICAga2V5OiBcInJlc2l6ZUFuZENsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZUFuZENsZWFyKGRpbWVuc2lvbnMsIGNlbGxTaXplKSB7XG4gICAgICB0aGlzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICB0aGlzLmNlbGxTaXplID0gY2VsbFNpemU7XG4gICAgICB0aGlzLmNvbHVtbnMgPSBNYXRoLmNlaWwoZGltZW5zaW9ucy53aWR0aCAvIGNlbGxTaXplKTtcbiAgICAgIHRoaXMucm93cyA9IE1hdGguY2VpbChkaW1lbnNpb25zLmhlaWdodCAvIGNlbGxTaXplKTtcbiAgICAgIHRoaXMuY2VsbHMgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXgocG9zKSB7XG4gICAgICB2YXIgeEluZGV4ID0gTWF0aC5mbG9vcihwb3MueCAvIHRoaXMuY2VsbFNpemUpO1xuICAgICAgdmFyIHlJbmRleCA9IE1hdGguZmxvb3IocG9zLnkgLyB0aGlzLmNlbGxTaXplKTtcbiAgICAgIHJldHVybiB5SW5kZXggKiB0aGlzLmNvbHVtbnMgKyB4SW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoa2V5LCBzaXplLCBwb3MpIHtcbiAgICAgIHZhciBjYW5kaWRhdGUgPSBuZXcgTGFiZWxDYW5kaWRhdGUoa2V5LCBzaXplKTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgocG9zKTtcbiAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1tpbmRleF07XG4gICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgY2VsbCA9IFtdO1xuICAgICAgICB0aGlzLmNlbGxzW2luZGV4XSA9IGNlbGw7XG4gICAgICB9XG4gICAgICBjZWxsLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3JnYW5pemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3JnYW5pemUoKSB7XG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMuY2VsbHMpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzW2tdO1xuICAgICAgICBjZWxsLnNvcnQoTGFiZWxDYW5kaWRhdGUuY29tcGFyZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsc1RvRGlzcGxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbHNUb0Rpc3BsYXkocmF0aW8sIGRlbnNpdHkpIHtcbiAgICAgIC8vIFRPRE86IHdvcmsgb24gdmlzaWJsZSBub2RlcyB0byBvcHRpbWl6ZT8gXiAtPiB0aHJlc2hvbGQgb3V0c2lkZSBzbyB0aGF0IG1lbW9pemF0aW9uIHdvcmtzP1xuICAgICAgLy8gVE9ETzogYWRqdXN0IHRocmVzaG9sZCBsb3dlciwgYnV0IGluY3JlYXNlIGNlbGxzIGEgYml0P1xuICAgICAgLy8gVE9ETzogaHVudCBmb3IgZ2VvbSBpc3N1ZSBpbiBkaXNndWlzZVxuICAgICAgLy8gVE9ETzogbWVtb2l6ZSB3aGlsZSByYXRpbyBkb2VzIG5vdCBtb3ZlLiBtZXRob2QgdG8gZm9yY2UgcmVjb21wdXRlXG4gICAgICB2YXIgY2VsbEFyZWEgPSB0aGlzLmNlbGxTaXplICogdGhpcy5jZWxsU2l6ZTtcbiAgICAgIHZhciBzY2FsZWRDZWxsQXJlYSA9IGNlbGxBcmVhIC8gcmF0aW8gLyByYXRpbztcbiAgICAgIHZhciBzY2FsZWREZW5zaXR5ID0gc2NhbGVkQ2VsbEFyZWEgKiBkZW5zaXR5IC8gY2VsbEFyZWE7XG4gICAgICB2YXIgbGFiZWxzVG9EaXNwbGF5UGVyQ2VsbCA9IE1hdGguY2VpbChzY2FsZWREZW5zaXR5KTtcbiAgICAgIHZhciBsYWJlbHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5jZWxscykge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbHNba107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5taW4obGFiZWxzVG9EaXNwbGF5UGVyQ2VsbCwgY2VsbC5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICBsYWJlbHMucHVzaChjZWxsW2ldLmtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbi8qKlxuICogTGFiZWwgaGV1cmlzdGljIHNlbGVjdGluZyBlZGdlIGxhYmVscyB0byBkaXNwbGF5LCBiYXNlZCBvbiBkaXNwbGF5ZWQgbm9kZVxuICogbGFiZWxzXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbXMgICAgICAgICAgICAgICAgIC0gUGFyYW1ldGVyczpcbiAqIEBwYXJhbSAge1NldH0gICAgICBkaXNwbGF5ZWROb2RlTGFiZWxzICAtIEN1cnJlbnRseSBkaXNwbGF5ZWQgbm9kZSBsYWJlbHMuXG4gKiBAcGFyYW0gIHtTZXR9ICAgICAgaGlnaGxpZ2h0ZWROb2RlcyAgICAgLSBIaWdobGlnaHRlZCBub2Rlcy5cbiAqIEBwYXJhbSAge0dyYXBofSAgICBncmFwaCAgICAgICAgICAgICAgICAtIFRoZSByZW5kZXJlZCBncmFwaC5cbiAqIEBwYXJhbSAge3N0cmluZ30gICBob3ZlcmVkTm9kZSAgICAgICAgICAtIEhvdmVyZWQgbm9kZSAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgc2VsZWN0ZWQgbGFiZWxzLlxuICovXG5mdW5jdGlvbiBlZGdlTGFiZWxzVG9EaXNwbGF5RnJvbU5vZGVzKHBhcmFtcykge1xuICB2YXIgZ3JhcGggPSBwYXJhbXMuZ3JhcGgsXG4gICAgaG92ZXJlZE5vZGUgPSBwYXJhbXMuaG92ZXJlZE5vZGUsXG4gICAgaGlnaGxpZ2h0ZWROb2RlcyA9IHBhcmFtcy5oaWdobGlnaHRlZE5vZGVzLFxuICAgIGRpc3BsYXllZE5vZGVMYWJlbHMgPSBwYXJhbXMuZGlzcGxheWVkTm9kZUxhYmVscztcbiAgdmFyIHdvcnRoeUVkZ2VzID0gW107XG5cbiAgLy8gVE9ETzogdGhlIGNvZGUgYmVsb3cgY2FuIGJlIG9wdGltaXplZCB1c2luZyAjLmZvckVhY2ggYW5kIGJhdGNoaW5nIHRoZSBjb2RlIHBlciBhZGpcblxuICAvLyBXZSBzaG91bGQgZGlzcGxheSBhbiBlZGdlJ3MgbGFiZWwgaWY6XG4gIC8vICAgLSBBbnkgb2YgaXRzIGV4dHJlbWl0aWVzIGlzIGhpZ2hsaWdodGVkIG9yIGhvdmVyZWRcbiAgLy8gICAtIEJvdGggb2YgaXRzIGV4dHJlbWl0aWVzIGhhcyBpdHMgbGFiZWwgc2hvd25cbiAgZ3JhcGguZm9yRWFjaEVkZ2UoZnVuY3Rpb24gKGVkZ2UsIF8sIHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKHNvdXJjZSA9PT0gaG92ZXJlZE5vZGUgfHwgdGFyZ2V0ID09PSBob3ZlcmVkTm9kZSB8fCBoaWdobGlnaHRlZE5vZGVzLmhhcyhzb3VyY2UpIHx8IGhpZ2hsaWdodGVkTm9kZXMuaGFzKHRhcmdldCkgfHwgZGlzcGxheWVkTm9kZUxhYmVscy5oYXMoc291cmNlKSAmJiBkaXNwbGF5ZWROb2RlTGFiZWxzLmhhcyh0YXJnZXQpKSB7XG4gICAgICB3b3J0aHlFZGdlcy5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB3b3J0aHlFZGdlcztcbn1cblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cbnZhciBYX0xBQkVMX01BUkdJTiA9IDE1MDtcbnZhciBZX0xBQkVMX01BUkdJTiA9IDUwO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbXBvcnRhbnQgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBhcHBseU5vZGVEZWZhdWx0cyhzZXR0aW5ncywga2V5LCBkYXRhKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcInhcIikgfHwgIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJ5XCIpKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY291bGQgbm90IGZpbmQgYSB2YWxpZCBwb3NpdGlvbiAoeCwgeSkgZm9yIG5vZGUgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIi4gQWxsIHlvdXIgbm9kZXMgbXVzdCBoYXZlIGEgbnVtYmVyIFxcXCJ4XFxcIiBhbmQgXFxcInlcXFwiLiBNYXliZSB5b3VyIGZvcmdvdCB0byBhcHBseSBhIGxheW91dCBvciB5b3VyIFxcXCJub2RlUmVkdWNlclxcXCIgaXMgbm90IHJldHVybmluZyB0aGUgY29ycmVjdCBkYXRhP1wiKSk7XG4gIGlmICghZGF0YS5jb2xvcikgZGF0YS5jb2xvciA9IHNldHRpbmdzLmRlZmF1bHROb2RlQ29sb3I7XG4gIGlmICghZGF0YS5sYWJlbCAmJiBkYXRhLmxhYmVsICE9PSBcIlwiKSBkYXRhLmxhYmVsID0gbnVsbDtcbiAgaWYgKGRhdGEubGFiZWwgIT09IHVuZGVmaW5lZCAmJiBkYXRhLmxhYmVsICE9PSBudWxsKSBkYXRhLmxhYmVsID0gXCJcIiArIGRhdGEubGFiZWw7ZWxzZSBkYXRhLmxhYmVsID0gbnVsbDtcbiAgaWYgKCFkYXRhLnNpemUpIGRhdGEuc2l6ZSA9IDI7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcImhpZGRlblwiKSkgZGF0YS5oaWRkZW4gPSBmYWxzZTtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwiaGlnaGxpZ2h0ZWRcIikpIGRhdGEuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwiZm9yY2VMYWJlbFwiKSkgZGF0YS5mb3JjZUxhYmVsID0gZmFsc2U7XG4gIGlmICghZGF0YS50eXBlIHx8IGRhdGEudHlwZSA9PT0gXCJcIikgZGF0YS50eXBlID0gc2V0dGluZ3MuZGVmYXVsdE5vZGVUeXBlO1xuICBpZiAoIWRhdGEuekluZGV4KSBkYXRhLnpJbmRleCA9IDA7XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gYXBwbHlFZGdlRGVmYXVsdHMoc2V0dGluZ3MsIF9rZXksIGRhdGEpIHtcbiAgaWYgKCFkYXRhLmNvbG9yKSBkYXRhLmNvbG9yID0gc2V0dGluZ3MuZGVmYXVsdEVkZ2VDb2xvcjtcbiAgaWYgKCFkYXRhLmxhYmVsKSBkYXRhLmxhYmVsID0gXCJcIjtcbiAgaWYgKCFkYXRhLnNpemUpIGRhdGEuc2l6ZSA9IDAuNTtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwiaGlkZGVuXCIpKSBkYXRhLmhpZGRlbiA9IGZhbHNlO1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJmb3JjZUxhYmVsXCIpKSBkYXRhLmZvcmNlTGFiZWwgPSBmYWxzZTtcbiAgaWYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSBcIlwiKSBkYXRhLnR5cGUgPSBzZXR0aW5ncy5kZWZhdWx0RWRnZVR5cGU7XG4gIGlmICghZGF0YS56SW5kZXgpIGRhdGEuekluZGV4ID0gMDtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTWFpbiBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7R3JhcGh9ICAgICAgIGdyYXBoICAgICAtIEdyYXBoIHRvIHJlbmRlci5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIERPTSBjb250YWluZXIgaW4gd2hpY2ggdG8gcmVuZGVyLlxuICogQHBhcmFtIHtvYmplY3R9ICAgICAgc2V0dGluZ3MgIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gKi9cbnZhciBTaWdtYSQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHlwZWRFdmVudEVtaXR0ZXIpIHtcbiAgZnVuY3Rpb24gU2lnbWEoZ3JhcGgsIGNvbnRhaW5lcikge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgc2V0dGluZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaWdtYSk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFNpZ21hKTtcblxuICAgIC8vIFJlc29sdmluZyBzZXR0aW5nc1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlbGVtZW50c1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImNhbnZhc0NvbnRleHRzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwid2ViR0xDb250ZXh0c1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInBpY2tpbmdMYXllcnNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwidGV4dHVyZXNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmcmFtZUJ1ZmZlcnNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJhY3RpdmVMaXN0ZW5lcnNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJsYWJlbEdyaWRcIiwgbmV3IExhYmVsR3JpZCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9kZURhdGFDYWNoZVwiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVkZ2VEYXRhQ2FjaGVcIiwge30pO1xuICAgIC8vIEluZGljZXMgdG8ga2VlcCB0cmFjayBvZiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gaW5zaWRlIHByb2dyYW1zXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVQcm9ncmFtSW5kZXhcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlZGdlUHJvZ3JhbUluZGV4XCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9kZXNXaXRoRm9yY2VkTGFiZWxzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVkZ2VzV2l0aEZvcmNlZExhYmVsc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub2RlRXh0ZW50XCIsIHtcbiAgICAgIHg6IFswLCAxXSxcbiAgICAgIHk6IFswLCAxXVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub2RlWkV4dGVudFwiLCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlZGdlWkV4dGVudFwiLCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtYXRyaXhcIiwgaWRlbnRpdHkoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImludk1hdHJpeFwiLCBpZGVudGl0eSgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY29ycmVjdGlvblJhdGlvXCIsIDEpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjdXN0b21CQm94XCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub3JtYWxpemF0aW9uRnVuY3Rpb25cIiwgY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uKHtcbiAgICAgIHg6IFswLCAxXSxcbiAgICAgIHk6IFswLCAxXVxuICAgIH0pKTtcbiAgICAvLyBDYWNoZTpcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZ3JhcGhUb1ZpZXdwb3J0UmF0aW9cIiwgMSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIml0ZW1JRHNJbmRleFwiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVJbmRpY2VzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZWRnZUluZGljZXNcIiwge30pO1xuICAgIC8vIFN0YXJ0aW5nIGRpbWVuc2lvbnMgYW5kIHBpeGVsIHJhdGlvXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIndpZHRoXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoZWlnaHRcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInBpeGVsUmF0aW9cIiwgZ2V0UGl4ZWxSYXRpbygpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicGlja2luZ0Rvd25TaXppbmdSYXRpb1wiLCAyICogX3RoaXMucGl4ZWxSYXRpbyk7XG4gICAgLy8gR3JhcGggU3RhdGVcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZGlzcGxheWVkTm9kZUxhYmVsc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJkaXNwbGF5ZWRFZGdlTGFiZWxzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhpZ2hsaWdodGVkTm9kZXNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaG92ZXJlZE5vZGVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhvdmVyZWRFZGdlXCIsIG51bGwpO1xuICAgIC8vIEludGVybmFsIHN0YXRlc1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJGcmFtZVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJuZWVkVG9Qcm9jZXNzXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY2hlY2tFZGdlc0V2ZW50c0ZyYW1lXCIsIG51bGwpO1xuICAgIC8vIFByb2dyYW1zXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVQcm9ncmFtc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVIb3ZlclByb2dyYW1zXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZWRnZVByb2dyYW1zXCIsIHt9KTtcbiAgICBfdGhpcy5zZXR0aW5ncyA9IHJlc29sdmVTZXR0aW5ncyhzZXR0aW5ncyk7XG5cbiAgICAvLyBWYWxpZGF0aW5nXG4gICAgdmFsaWRhdGVTZXR0aW5ncyhfdGhpcy5zZXR0aW5ncyk7XG4gICAgdmFsaWRhdGVHcmFwaChncmFwaCk7XG4gICAgaWYgKCEoY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY29udGFpbmVyIHNob3VsZCBiZSBhbiBodG1sIGVsZW1lbnQuXCIpO1xuXG4gICAgLy8gUHJvcGVydGllc1xuICAgIF90aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgLy8gSW5pdGlhbGl6aW5nIGNvbnRleHRzXG4gICAgX3RoaXMuY3JlYXRlV2ViR0xDb250ZXh0KFwiZWRnZXNcIiwge1xuICAgICAgcGlja2luZzogc2V0dGluZ3MuZW5hYmxlRWRnZUV2ZW50c1xuICAgIH0pO1xuICAgIF90aGlzLmNyZWF0ZUNhbnZhc0NvbnRleHQoXCJlZGdlTGFiZWxzXCIpO1xuICAgIF90aGlzLmNyZWF0ZVdlYkdMQ29udGV4dChcIm5vZGVzXCIsIHtcbiAgICAgIHBpY2tpbmc6IHRydWVcbiAgICB9KTtcbiAgICBfdGhpcy5jcmVhdGVDYW52YXNDb250ZXh0KFwibGFiZWxzXCIpO1xuICAgIF90aGlzLmNyZWF0ZUNhbnZhc0NvbnRleHQoXCJob3ZlcnNcIik7XG4gICAgX3RoaXMuY3JlYXRlV2ViR0xDb250ZXh0KFwiaG92ZXJOb2Rlc1wiKTtcbiAgICBfdGhpcy5jcmVhdGVDYW52YXNDb250ZXh0KFwibW91c2VcIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdG91Y2hBY3Rpb246IFwibm9uZVwiLFxuICAgICAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIlxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbCByZXNpemVcbiAgICBfdGhpcy5yZXNpemUoKTtcblxuICAgIC8vIExvYWRpbmcgcHJvZ3JhbXNcbiAgICBmb3IgKHZhciB0eXBlIGluIF90aGlzLnNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgX3RoaXMucmVnaXN0ZXJOb2RlUHJvZ3JhbSh0eXBlLCBfdGhpcy5zZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXNbdHlwZV0sIF90aGlzLnNldHRpbmdzLm5vZGVIb3ZlclByb2dyYW1DbGFzc2VzW3R5cGVdKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX3R5cGUgaW4gX3RoaXMuc2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICBfdGhpcy5yZWdpc3RlckVkZ2VQcm9ncmFtKF90eXBlLCBfdGhpcy5zZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXNbX3R5cGVdKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIGNhbWVyYVxuICAgIF90aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmEoKTtcblxuICAgIC8vIEJpbmRpbmcgY2FtZXJhIGV2ZW50c1xuICAgIF90aGlzLmJpbmRDYW1lcmFIYW5kbGVycygpO1xuXG4gICAgLy8gSW5pdGlhbGl6aW5nIGNhcHRvcnNcbiAgICBfdGhpcy5tb3VzZUNhcHRvciA9IG5ldyBNb3VzZUNhcHRvcihfdGhpcy5lbGVtZW50cy5tb3VzZSwgX3RoaXMpO1xuICAgIF90aGlzLm1vdXNlQ2FwdG9yLnNldFNldHRpbmdzKF90aGlzLnNldHRpbmdzKTtcbiAgICBfdGhpcy50b3VjaENhcHRvciA9IG5ldyBUb3VjaENhcHRvcihfdGhpcy5lbGVtZW50cy5tb3VzZSwgX3RoaXMpO1xuICAgIF90aGlzLnRvdWNoQ2FwdG9yLnNldFNldHRpbmdzKF90aGlzLnNldHRpbmdzKTtcblxuICAgIC8vIEJpbmRpbmcgZXZlbnQgaGFuZGxlcnNcbiAgICBfdGhpcy5iaW5kRXZlbnRIYW5kbGVycygpO1xuXG4gICAgLy8gQmluZGluZyBncmFwaCBoYW5kbGVyc1xuICAgIF90aGlzLmJpbmRHcmFwaEhhbmRsZXJzKCk7XG5cbiAgICAvLyBUcmlnZ2VyIGV2ZW50dWFsIHNldHRpbmdzLXJlbGF0ZWQgdGhpbmdzXG4gICAgX3RoaXMuaGFuZGxlU2V0dGluZ3NVcGRhdGUoKTtcblxuICAgIC8vIFByb2Nlc3NpbmcgZGF0YSBmb3IgdGhlIGZpcnN0IHRpbWUgJiByZW5kZXJcbiAgICBfdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEludGVybmFsIG1ldGhvZHMuXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byByZWdpc3RlciBhIG5vZGUgcHJvZ3JhbVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICBrZXkgICAgICAgICAgICAgIC0gVGhlIHByb2dyYW0ncyBrZXksIG1hdGNoaW5nIHRoZSByZWxhdGVkIG5vZGVzIFwidHlwZVwiIHZhbHVlcy5cbiAgICogQHBhcmFtICB7Tm9kZVByb2dyYW1UeXBlfSAgTm9kZVByb2dyYW1DbGFzcyAtIEEgbm9kZXMgcHJvZ3JhbSBjbGFzcy5cbiAgICogQHBhcmFtICB7Tm9kZVByb2dyYW1UeXBlP30gTm9kZUhvdmVyUHJvZ3JhbSAtIEEgbm9kZXMgcHJvZ3JhbSBjbGFzcyB0byByZW5kZXIgaG92ZXJlZCBub2RlcyAob3B0aW9uYWwpLlxuICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICovXG4gIF9pbmhlcml0cyhTaWdtYSwgX1R5cGVkRXZlbnRFbWl0dGVyKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTaWdtYSwgW3tcbiAgICBrZXk6IFwicmVnaXN0ZXJOb2RlUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlck5vZGVQcm9ncmFtKGtleSwgTm9kZVByb2dyYW1DbGFzcywgTm9kZUhvdmVyUHJvZ3JhbSkge1xuICAgICAgaWYgKHRoaXMubm9kZVByb2dyYW1zW2tleV0pIHRoaXMubm9kZVByb2dyYW1zW2tleV0ua2lsbCgpO1xuICAgICAgaWYgKHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNba2V5XSkgdGhpcy5ub2RlSG92ZXJQcm9ncmFtc1trZXldLmtpbGwoKTtcbiAgICAgIHRoaXMubm9kZVByb2dyYW1zW2tleV0gPSBuZXcgTm9kZVByb2dyYW1DbGFzcyh0aGlzLndlYkdMQ29udGV4dHMubm9kZXMsIHRoaXMuZnJhbWVCdWZmZXJzLm5vZGVzLCB0aGlzKTtcbiAgICAgIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNba2V5XSA9IG5ldyAoTm9kZUhvdmVyUHJvZ3JhbSB8fCBOb2RlUHJvZ3JhbUNsYXNzKSh0aGlzLndlYkdMQ29udGV4dHMuaG92ZXJOb2RlcywgbnVsbCwgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHJlZ2lzdGVyIGFuIGVkZ2UgcHJvZ3JhbVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICBrZXkgICAgICAgICAgICAgIC0gVGhlIHByb2dyYW0ncyBrZXksIG1hdGNoaW5nIHRoZSByZWxhdGVkIGVkZ2VzIFwidHlwZVwiIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gIHtFZGdlUHJvZ3JhbVR5cGV9IEVkZ2VQcm9ncmFtQ2xhc3MgLSBBbiBlZGdlcyBwcm9ncmFtIGNsYXNzLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyRWRnZVByb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJFZGdlUHJvZ3JhbShrZXksIEVkZ2VQcm9ncmFtQ2xhc3MpIHtcbiAgICAgIGlmICh0aGlzLmVkZ2VQcm9ncmFtc1trZXldKSB0aGlzLmVkZ2VQcm9ncmFtc1trZXldLmtpbGwoKTtcbiAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2tleV0gPSBuZXcgRWRnZVByb2dyYW1DbGFzcyh0aGlzLndlYkdMQ29udGV4dHMuZWRnZXMsIHRoaXMuZnJhbWVCdWZmZXJzLmVkZ2VzLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gdW5yZWdpc3RlciBhIG5vZGUgcHJvZ3JhbVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgcHJvZ3JhbSdzIGtleSwgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgbm9kZXMgXCJ0eXBlXCIgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVucmVnaXN0ZXJOb2RlUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnJlZ2lzdGVyTm9kZVByb2dyYW0oa2V5KSB7XG4gICAgICBpZiAodGhpcy5ub2RlUHJvZ3JhbXNba2V5XSkge1xuICAgICAgICB2YXIgX3RoaXMkbm9kZVByb2dyYW1zID0gdGhpcy5ub2RlUHJvZ3JhbXMsXG4gICAgICAgICAgcHJvZ3JhbSA9IF90aGlzJG5vZGVQcm9ncmFtc1trZXldLFxuICAgICAgICAgIHByb2dyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJG5vZGVQcm9ncmFtcywgW2tleV0ubWFwKF90b1Byb3BlcnR5S2V5KSk7XG4gICAgICAgIHByb2dyYW0ua2lsbCgpO1xuICAgICAgICB0aGlzLm5vZGVQcm9ncmFtcyA9IHByb2dyYW1zO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNba2V5XSkge1xuICAgICAgICB2YXIgX3RoaXMkbm9kZUhvdmVyUHJvZ3JhID0gdGhpcy5ub2RlSG92ZXJQcm9ncmFtcyxcbiAgICAgICAgICBfcHJvZ3JhbSA9IF90aGlzJG5vZGVIb3ZlclByb2dyYVtrZXldLFxuICAgICAgICAgIF9wcm9ncmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRub2RlSG92ZXJQcm9ncmEsIFtrZXldLm1hcChfdG9Qcm9wZXJ0eUtleSkpO1xuICAgICAgICBfcHJvZ3JhbS5raWxsKCk7XG4gICAgICAgIHRoaXMubm9kZVByb2dyYW1zID0gX3Byb2dyYW1zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byB1bnJlZ2lzdGVyIGFuIGVkZ2UgcHJvZ3JhbVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgcHJvZ3JhbSdzIGtleSwgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgZWRnZXMgXCJ0eXBlXCIgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVucmVnaXN0ZXJFZGdlUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnJlZ2lzdGVyRWRnZVByb2dyYW0oa2V5KSB7XG4gICAgICBpZiAodGhpcy5lZGdlUHJvZ3JhbXNba2V5XSkge1xuICAgICAgICB2YXIgX3RoaXMkZWRnZVByb2dyYW1zID0gdGhpcy5lZGdlUHJvZ3JhbXMsXG4gICAgICAgICAgcHJvZ3JhbSA9IF90aGlzJGVkZ2VQcm9ncmFtc1trZXldLFxuICAgICAgICAgIHByb2dyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJGVkZ2VQcm9ncmFtcywgW2tleV0ubWFwKF90b1Byb3BlcnR5S2V5KSk7XG4gICAgICAgIHByb2dyYW0ua2lsbCgpO1xuICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtcyA9IHByb2dyYW1zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIChyZSliaW5kaW5nIFdlYkdMIHRleHR1cmUgKGZvciBwaWNraW5nKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlc2V0V2ViR0xUZXh0dXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0V2ViR0xUZXh0dXJlKGlkKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLndlYkdMQ29udGV4dHNbaWRdO1xuICAgICAgdmFyIGZyYW1lQnVmZmVyID0gdGhpcy5mcmFtZUJ1ZmZlcnNbaWRdO1xuICAgICAgdmFyIGN1cnJlbnRUZXh0dXJlID0gdGhpcy50ZXh0dXJlc1tpZF07XG4gICAgICBpZiAoY3VycmVudFRleHR1cmUpIGdsLmRlbGV0ZVRleHR1cmUoY3VycmVudFRleHR1cmUpO1xuICAgICAgdmFyIHBpY2tpbmdUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBwaWNraW5nVGV4dHVyZSk7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgcGlja2luZ1RleHR1cmUsIDApO1xuICAgICAgdGhpcy50ZXh0dXJlc1tpZF0gPSBwaWNraW5nVGV4dHVyZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBiaW5kaW5nIGNhbWVyYSBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImJpbmRDYW1lcmFIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kQ2FtZXJhSGFuZGxlcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5jYW1lcmEub24oXCJ1cGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNhbWVyYSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdW5iaW5kaW5nIGNhbWVyYSBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVuYmluZENhbWVyYUhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZENhbWVyYUhhbmRsZXJzKCkge1xuICAgICAgdGhpcy5jYW1lcmEucmVtb3ZlTGlzdGVuZXIoXCJ1cGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNhbWVyYSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIHRoZSBjbG9zZXN0IG5vZGUgdG8gYSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXROb2RlQXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlQXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgdmFyIHggPSBwb3NpdGlvbi54LFxuICAgICAgICB5ID0gcG9zaXRpb24ueTtcbiAgICAgIHZhciBjb2xvciA9IGdldFBpeGVsQ29sb3IodGhpcy53ZWJHTENvbnRleHRzLm5vZGVzLCB0aGlzLmZyYW1lQnVmZmVycy5ub2RlcywgeCwgeSwgdGhpcy5waXhlbFJhdGlvLCB0aGlzLnBpY2tpbmdEb3duU2l6aW5nUmF0aW8pO1xuICAgICAgdmFyIGluZGV4ID0gY29sb3JUb0luZGV4LmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGNvbG9yKSk7XG4gICAgICB2YXIgaXRlbUF0ID0gdGhpcy5pdGVtSURzSW5kZXhbaW5kZXhdO1xuICAgICAgcmV0dXJuIGl0ZW1BdCAmJiBpdGVtQXQudHlwZSA9PT0gXCJub2RlXCIgPyBpdGVtQXQuaWQgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBiaW5kaW5nIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEV2ZW50SGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIC8vIEhhbmRsaW5nIHdpbmRvdyByZXNpemVcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbmVlZCB0byBjYWxsIGEgcmVmcmVzaCB0byByZWJ1aWxkIHRoZSBsYWJlbGdyaWRcbiAgICAgICAgX3RoaXMzLnNjaGVkdWxlUmVmcmVzaCgpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVJlc2l6ZSk7XG5cbiAgICAgIC8vIEhhbmRsaW5nIG1vdXNlIG1vdmVcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjbGVhbk1vdXNlQ29vcmRzKGUpO1xuICAgICAgICB2YXIgYmFzZUV2ZW50ID0ge1xuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudFNpZ21hRGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5vZGVUb0hvdmVyID0gX3RoaXMzLmdldE5vZGVBdFBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgaWYgKG5vZGVUb0hvdmVyICYmIF90aGlzMy5ob3ZlcmVkTm9kZSAhPT0gbm9kZVRvSG92ZXIgJiYgIV90aGlzMy5ub2RlRGF0YUNhY2hlW25vZGVUb0hvdmVyXS5oaWRkZW4pIHtcbiAgICAgICAgICAvLyBIYW5kbGluZyBwYXNzaW5nIGZyb20gb25lIG5vZGUgdG8gdGhlIG90aGVyIGRpcmVjdGx5XG4gICAgICAgICAgaWYgKF90aGlzMy5ob3ZlcmVkTm9kZSkgX3RoaXMzLmVtaXQoXCJsZWF2ZU5vZGVcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICBub2RlOiBfdGhpczMuaG92ZXJlZE5vZGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgX3RoaXMzLmhvdmVyZWROb2RlID0gbm9kZVRvSG92ZXI7XG4gICAgICAgICAgX3RoaXMzLmVtaXQoXCJlbnRlck5vZGVcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICBub2RlOiBub2RlVG9Ib3ZlclxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBfdGhpczMuc2NoZWR1bGVIaWdobGlnaHRlZE5vZGVzUmVuZGVyKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tpbmcgaWYgdGhlIGhvdmVyZWQgbm9kZSBpcyBzdGlsbCBob3ZlcmVkXG4gICAgICAgIGlmIChfdGhpczMuaG92ZXJlZE5vZGUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMzLmdldE5vZGVBdFBvc2l0aW9uKGV2ZW50KSAhPT0gX3RoaXMzLmhvdmVyZWROb2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzMy5ob3ZlcmVkTm9kZTtcbiAgICAgICAgICAgIF90aGlzMy5ob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpczMuZW1pdChcImxlYXZlTm9kZVwiLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgX3RoaXMzLnNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMzLnNldHRpbmdzLmVuYWJsZUVkZ2VFdmVudHMpIHtcbiAgICAgICAgICB2YXIgZWRnZVRvSG92ZXIgPSBfdGhpczMuaG92ZXJlZE5vZGUgPyBudWxsIDogX3RoaXMzLmdldEVkZ2VBdFBvaW50KGJhc2VFdmVudC5ldmVudC54LCBiYXNlRXZlbnQuZXZlbnQueSk7XG4gICAgICAgICAgaWYgKGVkZ2VUb0hvdmVyICE9PSBfdGhpczMuaG92ZXJlZEVkZ2UpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczMuaG92ZXJlZEVkZ2UpIF90aGlzMy5lbWl0KFwibGVhdmVFZGdlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgICBlZGdlOiBfdGhpczMuaG92ZXJlZEVkZ2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChlZGdlVG9Ib3ZlcikgX3RoaXMzLmVtaXQoXCJlbnRlckVkZ2VcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICAgIGVkZ2U6IGVkZ2VUb0hvdmVyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBfdGhpczMuaG92ZXJlZEVkZ2UgPSBlZGdlVG9Ib3ZlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsaW5nIG1vdXNlIG1vdmUgb3ZlciBib2R5IChvbmx5IHRvIGRpc3BhdGNoIHRoZSBwcm9wZXIgZXZlbnQpOlxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTW92ZUJvZHkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjbGVhbk1vdXNlQ29vcmRzKGUpO1xuICAgICAgICBfdGhpczMuZW1pdChcIm1vdmVCb2R5XCIsIHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gcHJldmVudFNpZ21hRGVmYXVsdCgpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnRTaWdtYURlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gSGFuZGxpbmcgbW91c2UgbGVhdmUgc3RhZ2U6XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVMZWF2ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBldmVudCA9IGNsZWFuTW91c2VDb29yZHMoZSk7XG4gICAgICAgIHZhciBiYXNlRXZlbnQgPSB7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50U2lnbWFEZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoX3RoaXMzLmhvdmVyZWROb2RlKSB7XG4gICAgICAgICAgX3RoaXMzLmVtaXQoXCJsZWF2ZU5vZGVcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICBub2RlOiBfdGhpczMuaG92ZXJlZE5vZGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgX3RoaXMzLnNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczMuc2V0dGluZ3MuZW5hYmxlRWRnZUV2ZW50cyAmJiBfdGhpczMuaG92ZXJlZEVkZ2UpIHtcbiAgICAgICAgICBfdGhpczMuZW1pdChcImxlYXZlRWRnZVwiLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgIGVkZ2U6IF90aGlzMy5ob3ZlcmVkRWRnZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBfdGhpczMuc2NoZWR1bGVIaWdobGlnaHRlZE5vZGVzUmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMzLmVtaXQoXCJsZWF2ZVN0YWdlXCIsIF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsaW5nIG1vdXNlIGVudGVyIHN0YWdlOlxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRW50ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjbGVhbk1vdXNlQ29vcmRzKGUpO1xuICAgICAgICB2YXIgYmFzZUV2ZW50ID0ge1xuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudFNpZ21hRGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMzLmVtaXQoXCJlbnRlclN0YWdlXCIsIF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsaW5nIGNsaWNrXG4gICAgICB2YXIgY3JlYXRlSW50ZXJhY3Rpb25MaXN0ZW5lciA9IGZ1bmN0aW9uIGNyZWF0ZUludGVyYWN0aW9uTGlzdGVuZXIoZXZlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBldmVudCA9IGNsZWFuTW91c2VDb29yZHMoZSk7XG4gICAgICAgICAgdmFyIGJhc2VFdmVudCA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnRTaWdtYURlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBub2RlQXRQb3NpdGlvbiA9IF90aGlzMy5nZXROb2RlQXRQb3NpdGlvbihldmVudCk7XG4gICAgICAgICAgaWYgKG5vZGVBdFBvc2l0aW9uKSByZXR1cm4gX3RoaXMzLmVtaXQoXCJcIi5jb25jYXQoZXZlbnRUeXBlLCBcIk5vZGVcIiksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgbm9kZTogbm9kZUF0UG9zaXRpb25cbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgaWYgKF90aGlzMy5zZXR0aW5ncy5lbmFibGVFZGdlRXZlbnRzKSB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IF90aGlzMy5nZXRFZGdlQXRQb2ludChldmVudC54LCBldmVudC55KTtcbiAgICAgICAgICAgIGlmIChlZGdlKSByZXR1cm4gX3RoaXMzLmVtaXQoXCJcIi5jb25jYXQoZXZlbnRUeXBlLCBcIkVkZ2VcIiksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgICBlZGdlOiBlZGdlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpczMuZW1pdChcIlwiLmNvbmNhdChldmVudFR5cGUsIFwiU3RhZ2VcIiksIGJhc2VFdmVudCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlQ2xpY2sgPSBjcmVhdGVJbnRlcmFjdGlvbkxpc3RlbmVyKFwiY2xpY2tcIik7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVSaWdodENsaWNrID0gY3JlYXRlSW50ZXJhY3Rpb25MaXN0ZW5lcihcInJpZ2h0Q2xpY2tcIik7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVEb3VibGVDbGljayA9IGNyZWF0ZUludGVyYWN0aW9uTGlzdGVuZXIoXCJkb3VibGVDbGlja1wiKTtcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVdoZWVsID0gY3JlYXRlSW50ZXJhY3Rpb25MaXN0ZW5lcihcIndoZWVsXCIpO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRG93biA9IGNyZWF0ZUludGVyYWN0aW9uTGlzdGVuZXIoXCJkb3duXCIpO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlVXAgPSBjcmVhdGVJbnRlcmFjdGlvbkxpc3RlbmVyKFwidXBcIik7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwibW91c2Vtb3ZlXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZU1vdmUpO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNlbW92ZWJvZHlcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTW92ZUJvZHkpO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcImNsaWNrXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZUNsaWNrKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJyaWdodENsaWNrXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVJpZ2h0Q2xpY2spO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcImRvdWJsZUNsaWNrXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvdWJsZUNsaWNrKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJ3aGVlbFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVXaGVlbCk7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwibW91c2Vkb3duXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvd24pO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNldXBcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlVXApO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNlbGVhdmVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTGVhdmUpO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNlZW50ZXJcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRW50ZXIpO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5vbihcInRvdWNoZG93blwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVEb3duKTtcbiAgICAgIHRoaXMudG91Y2hDYXB0b3Iub24oXCJ0b3VjaGRvd25cIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTW92ZSk7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLm9uKFwidG91Y2h1cFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVVcCk7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLm9uKFwidG91Y2htb3ZlXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZU1vdmUpO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5vbihcInRhcFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVDbGljayk7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLm9uKFwiZG91YmxldGFwXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvdWJsZUNsaWNrKTtcbiAgICAgIHRoaXMudG91Y2hDYXB0b3Iub24oXCJ0b3VjaG1vdmVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTW92ZUJvZHkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGJpbmRpbmcgZ3JhcGggaGFuZGxlcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImJpbmRHcmFwaEhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRHcmFwaEhhbmRsZXJzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgdmFyIExBWU9VVF9JTVBBQ1RJTkdfRklFTERTID0gbmV3IFNldChbXCJ4XCIsIFwieVwiLCBcInpJbmRleFwiLCBcInR5cGVcIl0pO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZWFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlZEdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9lJGhpbnRzO1xuICAgICAgICB2YXIgdXBkYXRlZEZpZWxkcyA9IChfZSRoaW50cyA9IGUuaGludHMpID09PSBudWxsIHx8IF9lJGhpbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZSRoaW50cy5hdHRyaWJ1dGVzO1xuICAgICAgICAvLyB3ZSBwcm9jZXNzIGFsbCBub2Rlc1xuICAgICAgICBfdGhpczQuZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LnVwZGF0ZU5vZGUobm9kZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIGNvb3JkLCB0eXBlIG9yIHpJbmRleCBoYXZlIGNoYW5nZWQsIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSByZW5kZXJcbiAgICAgICAgLy8gKHpJbmRleCBmb3IgdGhlIHByb2dyYW1JbmRleClcbiAgICAgICAgdmFyIGxheW91dENoYW5nZWQgPSAhdXBkYXRlZEZpZWxkcyB8fCB1cGRhdGVkRmllbGRzLnNvbWUoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gTEFZT1VUX0lNUEFDVElOR19GSUVMRFMuaGFzKGYpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHBhcnRpYWxHcmFwaDoge1xuICAgICAgICAgICAgbm9kZXM6IGdyYXBoLm5vZGVzKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNraXBJbmRleGF0aW9uOiAhbGF5b3V0Q2hhbmdlZCxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5lYWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVkR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2UkaGludHMyO1xuICAgICAgICB2YXIgdXBkYXRlZEZpZWxkcyA9IChfZSRoaW50czIgPSBlLmhpbnRzKSA9PT0gbnVsbCB8fCBfZSRoaW50czIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lJGhpbnRzMi5hdHRyaWJ1dGVzO1xuICAgICAgICAvLyB3ZSBwcm9jZXNzIGFsbCBlZGdlc1xuICAgICAgICBfdGhpczQuZ3JhcGguZm9yRWFjaEVkZ2UoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LnVwZGF0ZUVkZ2UoZWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbGF5b3V0Q2hhbmdlZCA9IHVwZGF0ZWRGaWVsZHMgJiYgW1wiekluZGV4XCIsIFwidHlwZVwiXS5zb21lKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZWRGaWVsZHMgPT09IG51bGwgfHwgdXBkYXRlZEZpZWxkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXBkYXRlZEZpZWxkcy5pbmNsdWRlcyhmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBwYXJ0aWFsR3JhcGg6IHtcbiAgICAgICAgICAgIGVkZ2VzOiBncmFwaC5lZGdlcygpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBza2lwSW5kZXhhdGlvbjogIWxheW91dENoYW5nZWQsXG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiBhZGQgbm9kZSwgd2UgYWRkIHRoZSBub2RlIGluIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZW5kZXJcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmFkZE5vZGVHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBub2RlID0gcGF5bG9hZC5rZXk7XG4gICAgICAgIC8vIHdlIHByb2Nlc3MgdGhlIG5vZGVcbiAgICAgICAgX3RoaXM0LmFkZE5vZGUobm9kZSk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciB0aGUgbm9kZVxuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgcGFydGlhbEdyYXBoOiB7XG4gICAgICAgICAgICBub2RlczogW25vZGVdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBza2lwSW5kZXhhdGlvbjogZmFsc2UsXG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiB1cGRhdGUgbm9kZSwgd2UgdXBkYXRlIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZW5kZXJcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnVwZGF0ZU5vZGVHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBub2RlID0gcGF5bG9hZC5rZXk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciB0aGUgbm9kZVxuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgcGFydGlhbEdyYXBoOiB7XG4gICAgICAgICAgICBub2RlczogW25vZGVdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBza2lwSW5kZXhhdGlvbjogZmFsc2UsXG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiBkcm9wIG5vZGUsIHdlIHJlbW92ZSB0aGUgbm9kZSBmcm9tIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZWZyZXNoXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5kcm9wTm9kZUdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwYXlsb2FkLmtleTtcbiAgICAgICAgLy8gd2UgcHJvY2VzcyB0aGUgbm9kZVxuICAgICAgICBfdGhpczQucmVtb3ZlTm9kZShub2RlKTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIGV2ZXJ5dGhpbmdcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gYWRkIGVkZ2UsIHdlIHJlbW92ZSB0aGUgZWRnZSBmcm9tIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZWZyZXNoXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5hZGRFZGdlR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgZWRnZSA9IHBheWxvYWQua2V5O1xuICAgICAgICAvLyB3ZSBwcm9jZXNzIHRoZSBlZGdlXG4gICAgICAgIF90aGlzNC5hZGRFZGdlKGVkZ2UpO1xuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlbmRlciBmb3IgdGhlIGVkZ2VcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHBhcnRpYWxHcmFwaDoge1xuICAgICAgICAgICAgZWRnZXM6IFtlZGdlXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiB1cGRhdGUgZWRnZSwgd2UgdXBkYXRlIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZWZyZXNoXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy51cGRhdGVFZGdlR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgZWRnZSA9IHBheWxvYWQua2V5O1xuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlcGFpbnQgZm9yIHRoZSBlZGdlXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBwYXJ0aWFsR3JhcGg6IHtcbiAgICAgICAgICAgIGVkZ2VzOiBbZWRnZV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNraXBJbmRleGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIGRyb3AgZWRnZSwgd2UgcmVtb3ZlIHRoZSBlZGdlIGZyb20gaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlZnJlc2hcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BFZGdlR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgZWRnZSA9IHBheWxvYWQua2V5O1xuICAgICAgICAvLyB3ZSBwcm9jZXNzIHRoZSBlZGdlXG4gICAgICAgIF90aGlzNC5yZW1vdmVFZGdlKGVkZ2UpO1xuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlbmRlciBmb3IgYWxsIGVkZ2VzXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIGNsZWFyIGVkZ2VzLCB3ZSBjbGVhciB0aGUgZWRnZSBpbmRpY2VzIGFuZCB0aGVuIGNhbGwgZm9yIGEgcmVmcmVzaFxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2xlYXJFZGdlc0dyYXBoVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3ZSBjbGVhciB0aGUgZWRnZSBkYXRhIHN0cnVjdHVyZXNcbiAgICAgICAgX3RoaXM0LmNsZWFyRWRnZVN0YXRlKCk7XG4gICAgICAgIF90aGlzNC5jbGVhckVkZ2VJbmRpY2VzKCk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciBhbGwgZWRnZXNcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gZ3JhcGggY2xlYXIsIHdlIGNsZWFyIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZWZyZXNoXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjbGVhciBncmFwaCBzdGF0ZVxuICAgICAgICBfdGhpczQuY2xlYXJFZGdlU3RhdGUoKTtcbiAgICAgICAgX3RoaXM0LmNsZWFyTm9kZVN0YXRlKCk7XG5cbiAgICAgICAgLy8gY2xlYXIgZ3JhcGggaW5kaWNlc1xuICAgICAgICBfdGhpczQuY2xlYXJFZGdlSW5kaWNlcygpO1xuICAgICAgICBfdGhpczQuY2xlYXJOb2RlSW5kaWNlcygpO1xuXG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciBhbGxcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGdyYXBoLm9uKFwibm9kZUFkZGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmFkZE5vZGVHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcIm5vZGVEcm9wcGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BOb2RlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJub2RlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMudXBkYXRlTm9kZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwiZWFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5lYWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVkR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJlZGdlQWRkZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuYWRkRWRnZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwiZWRnZURyb3BwZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcEVkZ2VHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImVkZ2VBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy51cGRhdGVFZGdlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJlYWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmVhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZWRHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImVkZ2VzQ2xlYXJlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckVkZ2VzR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJjbGVhcmVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyR3JhcGhVcGRhdGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gdW5iaW5kIGhhbmRsZXJzIGZyb20gdGhlIGdyYXBoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEdyYXBoSGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kR3JhcGhIYW5kbGVycygpIHtcbiAgICAgIHZhciBncmFwaCA9IHRoaXMuZ3JhcGg7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcIm5vZGVBZGRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5hZGROb2RlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJub2RlRHJvcHBlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5kcm9wTm9kZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwibm9kZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnVwZGF0ZU5vZGVHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcImVhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZWFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlZEdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWRnZUFkZGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmFkZEVkZ2VHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcImVkZ2VEcm9wcGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BFZGdlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlZGdlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMudXBkYXRlRWRnZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5lYWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVkR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlZGdlc0NsZWFyZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2xlYXJFZGdlc0dyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiY2xlYXJlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckdyYXBoVXBkYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgbG9va2luZyBmb3IgYW4gZWRnZSBjb2xsaWRpbmcgd2l0aCBhIGdpdmVuIHBvaW50IGF0ICh4LCB5KS4gUmV0dXJuc1xuICAgICAqIHRoZSBrZXkgb2YgdGhlIGVkZ2UgaWYgYW55LCBvciBudWxsIGVsc2UuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWRnZUF0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZUF0UG9pbnQoeCwgeSkge1xuICAgICAgdmFyIGNvbG9yID0gZ2V0UGl4ZWxDb2xvcih0aGlzLndlYkdMQ29udGV4dHMuZWRnZXMsIHRoaXMuZnJhbWVCdWZmZXJzLmVkZ2VzLCB4LCB5LCB0aGlzLnBpeGVsUmF0aW8sIHRoaXMucGlja2luZ0Rvd25TaXppbmdSYXRpbyk7XG4gICAgICB2YXIgaW5kZXggPSBjb2xvclRvSW5kZXguYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoY29sb3IpKTtcbiAgICAgIHZhciBpdGVtQXQgPSB0aGlzLml0ZW1JRHNJbmRleFtpbmRleF07XG4gICAgICByZXR1cm4gaXRlbUF0ICYmIGl0ZW1BdC50eXBlID09PSBcImVkZ2VcIiA/IGl0ZW1BdC5pZCA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcHJvY2VzcyB0aGUgd2hvbGUgZ3JhcGgncyBkYXRhLlxuICAgICAqICAtIGV4dGVudFxuICAgICAqICAtIG5vcm1hbGl6YXRpb25GdW5jdGlvblxuICAgICAqICAtIGNvbXB1dGUgbm9kZSdzIGNvb3JkaW5hdGVcbiAgICAgKiAgLSBsYWJlbGdyaWRcbiAgICAgKiAgLSBwcm9ncmFtIGRhdGEgYWxsb2NhdGlvblxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgdGhpcy5lbWl0KFwiYmVmb3JlUHJvY2Vzc1wiKTtcbiAgICAgIHZhciBncmFwaCA9IHRoaXMuZ3JhcGg7XG4gICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnMoKTtcblxuICAgICAgLy9cbiAgICAgIC8vIE5PREVTXG4gICAgICAvL1xuICAgICAgdGhpcy5ub2RlRXh0ZW50ID0gZ3JhcGhFeHRlbnQodGhpcy5ncmFwaCk7XG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuYXV0b1Jlc2NhbGUpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gZGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgdmFyIF90aGlzJG5vZGVFeHRlbnQgPSB0aGlzLm5vZGVFeHRlbnQsXG4gICAgICAgICAgeCA9IF90aGlzJG5vZGVFeHRlbnQueCxcbiAgICAgICAgICB5ID0gX3RoaXMkbm9kZUV4dGVudC55O1xuICAgICAgICB0aGlzLm5vZGVFeHRlbnQgPSB7XG4gICAgICAgICAgeDogWyh4WzBdICsgeFsxXSkgLyAyIC0gd2lkdGggLyAyLCAoeFswXSArIHhbMV0pIC8gMiArIHdpZHRoIC8gMl0sXG4gICAgICAgICAgeTogWyh5WzBdICsgeVsxXSkgLyAyIC0gaGVpZ2h0IC8gMiwgKHlbMF0gKyB5WzFdKSAvIDIgKyBoZWlnaHQgLyAyXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24gPSBjcmVhdGVOb3JtYWxpemF0aW9uRnVuY3Rpb24odGhpcy5jdXN0b21CQm94IHx8IHRoaXMubm9kZUV4dGVudCk7XG5cbiAgICAgIC8vIE5PVEU6IGl0IGlzIGltcG9ydGFudCB0byBjb21wdXRlIHRoaXMgbWF0cml4IGFmdGVyIGNvbXB1dGluZyB0aGUgbm9kZSdzIGV4dGVudFxuICAgICAgLy8gYmVjYXVzZSAjLmdldEdyYXBoRGltZW5zaW9ucyByZWxpZXMgb24gaXRcbiAgICAgIHZhciBudWxsQ2FtZXJhID0gbmV3IENhbWVyYSgpO1xuICAgICAgdmFyIG51bGxDYW1lcmFNYXRyaXggPSBtYXRyaXhGcm9tQ2FtZXJhKG51bGxDYW1lcmEuZ2V0U3RhdGUoKSwgZGltZW5zaW9ucywgdGhpcy5nZXRHcmFwaERpbWVuc2lvbnMoKSwgdGhpcy5nZXRTdGFnZVBhZGRpbmcoKSk7XG4gICAgICAvLyBSZXNldHRpbmcgdGhlIGxhYmVsIGdyaWRcbiAgICAgIC8vIFRPRE86IGl0J3MgcHJvYmFibHkgYmV0dGVyIHRvIGRvIHRoaXMgZXhwbGljaXRseSBvciBvbiByZXNpemVzIGZvciBsYXlvdXQgYW5kIGFuaW1zXG4gICAgICB0aGlzLmxhYmVsR3JpZC5yZXNpemVBbmRDbGVhcihkaW1lbnNpb25zLCBzZXR0aW5ncy5sYWJlbEdyaWRDZWxsU2l6ZSk7XG4gICAgICB2YXIgbm9kZXNQZXJQcm9ncmFtcyA9IHt9O1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0ge307XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB7fTtcbiAgICAgIHZhciBpdGVtSURzSW5kZXggPSB7fTtcbiAgICAgIHZhciBpbmNySUQgPSAxO1xuICAgICAgdmFyIG5vZGVzID0gZ3JhcGgubm9kZXMoKTtcblxuICAgICAgLy8gRG8gc29tZSBpbmRleGF0aW9uIG9uIHRoZSB3aG9sZSBncmFwaFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbbm9kZV07XG5cbiAgICAgICAgLy8gR2V0IGluaXRpYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgdmFyIGF0dHJzID0gZ3JhcGguZ2V0Tm9kZUF0dHJpYnV0ZXMobm9kZSk7XG4gICAgICAgIGRhdGEueCA9IGF0dHJzLng7XG4gICAgICAgIGRhdGEueSA9IGF0dHJzLnk7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uLmFwcGx5VG8oZGF0YSk7XG5cbiAgICAgICAgLy8gbGFiZWxncmlkXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5sYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiAhZGF0YS5oaWRkZW4pIHRoaXMubGFiZWxHcmlkLmFkZChub2RlLCBkYXRhLnNpemUsIHRoaXMuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KGRhdGEsIHtcbiAgICAgICAgICBtYXRyaXg6IG51bGxDYW1lcmFNYXRyaXhcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBjb3VudCBwZXIgcHJvZ3JhbVxuICAgICAgICBub2Rlc1BlclByb2dyYW1zW2RhdGEudHlwZV0gPSAobm9kZXNQZXJQcm9ncmFtc1tkYXRhLnR5cGVdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFiZWxHcmlkLm9yZ2FuaXplKCk7XG5cbiAgICAgIC8vIEFsbG9jYXRlIG1lbW9yeSB0byBwcm9ncmFtc1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLm5vZGVQcm9ncmFtcykge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcy5ub2RlUHJvZ3JhbXMsIHR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvdWxkIG5vdCBmaW5kIGEgc3VpdGFibGUgcHJvZ3JhbSBmb3Igbm9kZSB0eXBlIFxcXCJcIi5jb25jYXQodHlwZSwgXCJcXFwiIVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNbdHlwZV0ucmVhbGxvY2F0ZShub2Rlc1BlclByb2dyYW1zW3R5cGVdIHx8IDApO1xuICAgICAgICAvLyBXZSByZXNldCB0aGF0IGNvdW50IGhlcmUsIHNvIHRoYXQgd2UgY2FuIHJldXNlIGl0IHdoaWxlIGNhbGxpbmcgdGhlIFByb2dyYW0jcHJvY2VzcyBtZXRob2RzOlxuICAgICAgICBub2Rlc1BlclByb2dyYW1zW3R5cGVdID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gT3JkZXIgbm9kZXMgYnkgekluZGV4IGJlZm9yZSB0byBhZGQgdGhlbSB0byBwcm9ncmFtXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy56SW5kZXggJiYgdGhpcy5ub2RlWkV4dGVudFswXSAhPT0gdGhpcy5ub2RlWkV4dGVudFsxXSkgbm9kZXMgPSB6SW5kZXhPcmRlcmluZyh0aGlzLm5vZGVaRXh0ZW50LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gX3RoaXM1Lm5vZGVEYXRhQ2FjaGVbbm9kZV0uekluZGV4O1xuICAgICAgfSwgbm9kZXMpO1xuXG4gICAgICAvLyBBZGQgZGF0YSB0byBwcm9ncmFtc1xuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfbCA9IG5vZGVzLmxlbmd0aDsgX2kgPCBfbDsgX2krKykge1xuICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgICAgIG5vZGVJbmRpY2VzW19ub2RlXSA9IGluY3JJRDtcbiAgICAgICAgaXRlbUlEc0luZGV4W25vZGVJbmRpY2VzW19ub2RlXV0gPSB7XG4gICAgICAgICAgdHlwZTogXCJub2RlXCIsXG4gICAgICAgICAgaWQ6IF9ub2RlXG4gICAgICAgIH07XG4gICAgICAgIGluY3JJRCsrO1xuICAgICAgICB2YXIgX2RhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbX25vZGVdO1xuICAgICAgICB0aGlzLmFkZE5vZGVUb1Byb2dyYW0oX25vZGUsIG5vZGVJbmRpY2VzW19ub2RlXSwgbm9kZXNQZXJQcm9ncmFtc1tfZGF0YS50eXBlXSsrKTtcbiAgICAgIH1cblxuICAgICAgLy9cbiAgICAgIC8vIEVER0VTXG4gICAgICAvL1xuXG4gICAgICB2YXIgZWRnZXNQZXJQcm9ncmFtcyA9IHt9O1xuICAgICAgdmFyIGVkZ2VzID0gZ3JhcGguZWRnZXMoKTtcblxuICAgICAgLy8gQWxsb2NhdGUgbWVtb3J5IHRvIHByb2dyYW1zXG4gICAgICBmb3IgKHZhciBfaTIgPSAwLCBfbDIgPSBlZGdlcy5sZW5ndGg7IF9pMiA8IF9sMjsgX2kyKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tfaTJdO1xuICAgICAgICB2YXIgX2RhdGEyID0gdGhpcy5lZGdlRGF0YUNhY2hlW2VkZ2VdO1xuICAgICAgICBlZGdlc1BlclByb2dyYW1zW19kYXRhMi50eXBlXSA9IChlZGdlc1BlclByb2dyYW1zW19kYXRhMi50eXBlXSB8fCAwKSArIDE7XG4gICAgICB9XG5cbiAgICAgIC8vIE9yZGVyIGVkZ2VzIGJ5IHpJbmRleCBiZWZvcmUgdG8gYWRkIHRoZW0gdG8gcHJvZ3JhbVxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuekluZGV4ICYmIHRoaXMuZWRnZVpFeHRlbnRbMF0gIT09IHRoaXMuZWRnZVpFeHRlbnRbMV0pIGVkZ2VzID0gekluZGV4T3JkZXJpbmcodGhpcy5lZGdlWkV4dGVudCwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNS5lZGdlRGF0YUNhY2hlW2VkZ2VdLnpJbmRleDtcbiAgICAgIH0sIGVkZ2VzKTtcbiAgICAgIGZvciAodmFyIF90eXBlMiBpbiB0aGlzLmVkZ2VQcm9ncmFtcykge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcy5lZGdlUHJvZ3JhbXMsIF90eXBlMikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY291bGQgbm90IGZpbmQgYSBzdWl0YWJsZSBwcm9ncmFtIGZvciBlZGdlIHR5cGUgXFxcIlwiLmNvbmNhdChfdHlwZTIsIFwiXFxcIiFcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW190eXBlMl0ucmVhbGxvY2F0ZShlZGdlc1BlclByb2dyYW1zW190eXBlMl0gfHwgMCk7XG4gICAgICAgIC8vIFdlIHJlc2V0IHRoYXQgY291bnQgaGVyZSwgc28gdGhhdCB3ZSBjYW4gcmV1c2UgaXQgd2hpbGUgY2FsbGluZyB0aGUgUHJvZ3JhbSNwcm9jZXNzIG1ldGhvZHM6XG4gICAgICAgIGVkZ2VzUGVyUHJvZ3JhbXNbX3R5cGUyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBkYXRhIHRvIHByb2dyYW1zXG4gICAgICBmb3IgKHZhciBfaTMgPSAwLCBfbDMgPSBlZGdlcy5sZW5ndGg7IF9pMyA8IF9sMzsgX2kzKyspIHtcbiAgICAgICAgdmFyIF9lZGdlID0gZWRnZXNbX2kzXTtcbiAgICAgICAgZWRnZUluZGljZXNbX2VkZ2VdID0gaW5jcklEO1xuICAgICAgICBpdGVtSURzSW5kZXhbZWRnZUluZGljZXNbX2VkZ2VdXSA9IHtcbiAgICAgICAgICB0eXBlOiBcImVkZ2VcIixcbiAgICAgICAgICBpZDogX2VkZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaW5jcklEKys7XG4gICAgICAgIHZhciBfZGF0YTMgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVbX2VkZ2VdO1xuICAgICAgICB0aGlzLmFkZEVkZ2VUb1Byb2dyYW0oX2VkZ2UsIGVkZ2VJbmRpY2VzW19lZGdlXSwgZWRnZXNQZXJQcm9ncmFtc1tfZGF0YTMudHlwZV0rKyk7XG4gICAgICB9XG4gICAgICB0aGlzLml0ZW1JRHNJbmRleCA9IGl0ZW1JRHNJbmRleDtcbiAgICAgIHRoaXMubm9kZUluZGljZXMgPSBub2RlSW5kaWNlcztcbiAgICAgIHRoaXMuZWRnZUluZGljZXMgPSBlZGdlSW5kaWNlcztcbiAgICAgIHRoaXMuZW1pdChcImFmdGVyUHJvY2Vzc1wiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGJhY2twb3J0cyBwb3RlbnRpYWwgc2V0dGluZ3MgdXBkYXRlcyB3aGVyZSBpdCdzIG5lZWRlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVNldHRpbmdzVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVNldHRpbmdzVXBkYXRlKG9sZFNldHRpbmdzKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICB0aGlzLmNhbWVyYS5taW5SYXRpbyA9IHNldHRpbmdzLm1pbkNhbWVyYVJhdGlvO1xuICAgICAgdGhpcy5jYW1lcmEubWF4UmF0aW8gPSBzZXR0aW5ncy5tYXhDYW1lcmFSYXRpbztcbiAgICAgIHRoaXMuY2FtZXJhLmVuYWJsZWRab29taW5nID0gc2V0dGluZ3MuZW5hYmxlQ2FtZXJhWm9vbWluZztcbiAgICAgIHRoaXMuY2FtZXJhLmVuYWJsZWRQYW5uaW5nID0gc2V0dGluZ3MuZW5hYmxlQ2FtZXJhUGFubmluZztcbiAgICAgIHRoaXMuY2FtZXJhLmVuYWJsZWRSb3RhdGlvbiA9IHNldHRpbmdzLmVuYWJsZUNhbWVyYVJvdGF0aW9uO1xuICAgICAgaWYgKHNldHRpbmdzLmNhbWVyYVBhbkJvdW5kYXJpZXMpIHtcbiAgICAgICAgdGhpcy5jYW1lcmEuY2xlYW4gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM2LmNsZWFuQ2FtZXJhU3RhdGUoc3RhdGUsIHNldHRpbmdzLmNhbWVyYVBhbkJvdW5kYXJpZXMgJiYgX3R5cGVvZihzZXR0aW5ncy5jYW1lcmFQYW5Cb3VuZGFyaWVzKSA9PT0gXCJvYmplY3RcIiA/IHNldHRpbmdzLmNhbWVyYVBhbkJvdW5kYXJpZXMgOiB7fSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhbWVyYS5jbGVhbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbWVyYS5zZXRTdGF0ZSh0aGlzLmNhbWVyYS52YWxpZGF0ZVN0YXRlKHRoaXMuY2FtZXJhLmdldFN0YXRlKCkpKTtcbiAgICAgIGlmIChvbGRTZXR0aW5ncykge1xuICAgICAgICAvLyBDaGVjayBlZGdlIHByb2dyYW1zOlxuICAgICAgICBpZiAob2xkU2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzICE9PSBzZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXMpIHtcbiAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlc1t0eXBlXSAhPT0gb2xkU2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzW3R5cGVdKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJFZGdlUHJvZ3JhbSh0eXBlLCBzZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXNbdHlwZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBfdHlwZTMgaW4gb2xkU2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlc1tfdHlwZTNdKSB0aGlzLnVucmVnaXN0ZXJFZGdlUHJvZ3JhbShfdHlwZTMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIG5vZGUgcHJvZ3JhbXM6XG4gICAgICAgIGlmIChvbGRTZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXMgIT09IHNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3NlcyB8fCBvbGRTZXR0aW5ncy5ub2RlSG92ZXJQcm9ncmFtQ2xhc3NlcyAhPT0gc2V0dGluZ3Mubm9kZUhvdmVyUHJvZ3JhbUNsYXNzZXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBfdHlwZTQgaW4gc2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzW190eXBlNF0gIT09IG9sZFNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlc1tfdHlwZTRdIHx8IHNldHRpbmdzLm5vZGVIb3ZlclByb2dyYW1DbGFzc2VzW190eXBlNF0gIT09IG9sZFNldHRpbmdzLm5vZGVIb3ZlclByb2dyYW1DbGFzc2VzW190eXBlNF0pIHtcbiAgICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck5vZGVQcm9ncmFtKF90eXBlNCwgc2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzW190eXBlNF0sIHNldHRpbmdzLm5vZGVIb3ZlclByb2dyYW1DbGFzc2VzW190eXBlNF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBfdHlwZTUgaW4gb2xkU2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlc1tfdHlwZTVdKSB0aGlzLnVucmVnaXN0ZXJOb2RlUHJvZ3JhbShfdHlwZTUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgY2FwdG9ycyBzZXR0aW5nczpcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iuc2V0U2V0dGluZ3ModGhpcy5zZXR0aW5ncyk7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLnNldFNldHRpbmdzKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFuQ2FtZXJhU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW5DYW1lcmFTdGF0ZShzdGF0ZSkge1xuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBfcmVmJHRvbGVyYW5jZSA9IF9yZWYudG9sZXJhbmNlLFxuICAgICAgICB0b2xlcmFuY2UgPSBfcmVmJHRvbGVyYW5jZSA9PT0gdm9pZCAwID8gMCA6IF9yZWYkdG9sZXJhbmNlLFxuICAgICAgICBib3VuZGFyaWVzID0gX3JlZi5ib3VuZGFyaWVzO1xuICAgICAgdmFyIG5ld1N0YXRlID0gX29iamVjdFNwcmVhZDIoe30sIHN0YXRlKTtcblxuICAgICAgLy8gRXh0cmFjdCBuZWNlc3NhcnkgcHJvcGVydGllc1xuICAgICAgdmFyIF9yZWYyID0gYm91bmRhcmllcyB8fCB0aGlzLm5vZGVFeHRlbnQsXG4gICAgICAgIF9yZWYyJHggPSBfc2xpY2VkVG9BcnJheShfcmVmMi54LCAyKSxcbiAgICAgICAgeE1pbkdyYXBoID0gX3JlZjIkeFswXSxcbiAgICAgICAgeE1heEdyYXBoID0gX3JlZjIkeFsxXSxcbiAgICAgICAgX3JlZjIkeSA9IF9zbGljZWRUb0FycmF5KF9yZWYyLnksIDIpLFxuICAgICAgICB5TWluR3JhcGggPSBfcmVmMiR5WzBdLFxuICAgICAgICB5TWF4R3JhcGggPSBfcmVmMiR5WzFdO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gdGhlIGZvdXIgY29ybmVycyBvZiB0aGUgZ3JhcGggcmVjdGFuZ2xlIHVzaW5nIHRoZSBwcm92aWRlZCBjYW1lcmEgc3RhdGVcbiAgICAgIHZhciBjb3JuZXJzID0gW3RoaXMuZ3JhcGhUb1ZpZXdwb3J0KHtcbiAgICAgICAgeDogeE1pbkdyYXBoLFxuICAgICAgICB5OiB5TWluR3JhcGhcbiAgICAgIH0sIHtcbiAgICAgICAgY2FtZXJhU3RhdGU6IHN0YXRlXG4gICAgICB9KSwgdGhpcy5ncmFwaFRvVmlld3BvcnQoe1xuICAgICAgICB4OiB4TWF4R3JhcGgsXG4gICAgICAgIHk6IHlNaW5HcmFwaFxuICAgICAgfSwge1xuICAgICAgICBjYW1lcmFTdGF0ZTogc3RhdGVcbiAgICAgIH0pLCB0aGlzLmdyYXBoVG9WaWV3cG9ydCh7XG4gICAgICAgIHg6IHhNaW5HcmFwaCxcbiAgICAgICAgeTogeU1heEdyYXBoXG4gICAgICB9LCB7XG4gICAgICAgIGNhbWVyYVN0YXRlOiBzdGF0ZVxuICAgICAgfSksIHRoaXMuZ3JhcGhUb1ZpZXdwb3J0KHtcbiAgICAgICAgeDogeE1heEdyYXBoLFxuICAgICAgICB5OiB5TWF4R3JhcGhcbiAgICAgIH0sIHtcbiAgICAgICAgY2FtZXJhU3RhdGU6IHN0YXRlXG4gICAgICB9KV07XG5cbiAgICAgIC8vIExvb2sgZm9yIG5ldyBleHRlbnRzLCBiYXNlZCBvbiB0aGVzZSBmb3VyIGNvcm5lcnNcbiAgICAgIHZhciB4TWluID0gSW5maW5pdHksXG4gICAgICAgIHhNYXggPSAtSW5maW5pdHksXG4gICAgICAgIHlNaW4gPSBJbmZpbml0eSxcbiAgICAgICAgeU1heCA9IC1JbmZpbml0eTtcbiAgICAgIGNvcm5lcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIHggPSBfcmVmMy54LFxuICAgICAgICAgIHkgPSBfcmVmMy55O1xuICAgICAgICB4TWluID0gTWF0aC5taW4oeE1pbiwgeCk7XG4gICAgICAgIHhNYXggPSBNYXRoLm1heCh4TWF4LCB4KTtcbiAgICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIHkpO1xuICAgICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCwgeSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRm9yIGVhY2ggZGltZW5zaW9uLCBjb25zdHJhaW50IHRoZSBzbWFsbGVyIGVsZW1lbnQgKGNhbWVyYSBvciBncmFwaCkgdG8gZml0IGluIHRoZSBsYXJnZXIgb25lOlxuICAgICAgdmFyIGdyYXBoV2lkdGggPSB4TWF4IC0geE1pbjtcbiAgICAgIHZhciBncmFwaEhlaWdodCA9IHlNYXggLSB5TWluO1xuICAgICAgdmFyIF90aGlzJGdldERpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnMoKSxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRnZXREaW1lbnNpb25zLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRnZXREaW1lbnNpb25zLmhlaWdodDtcbiAgICAgIHZhciBkeCA9IDA7XG4gICAgICB2YXIgZHkgPSAwO1xuICAgICAgaWYgKGdyYXBoV2lkdGggPj0gd2lkdGgpIHtcbiAgICAgICAgaWYgKHhNYXggPCB3aWR0aCAtIHRvbGVyYW5jZSkgZHggPSB4TWF4IC0gKHdpZHRoIC0gdG9sZXJhbmNlKTtlbHNlIGlmICh4TWluID4gdG9sZXJhbmNlKSBkeCA9IHhNaW4gLSB0b2xlcmFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoeE1heCA+IHdpZHRoICsgdG9sZXJhbmNlKSBkeCA9IHhNYXggLSAod2lkdGggKyB0b2xlcmFuY2UpO2Vsc2UgaWYgKHhNaW4gPCAtdG9sZXJhbmNlKSBkeCA9IHhNaW4gKyB0b2xlcmFuY2U7XG4gICAgICB9XG4gICAgICBpZiAoZ3JhcGhIZWlnaHQgPj0gaGVpZ2h0KSB7XG4gICAgICAgIGlmICh5TWF4IDwgaGVpZ2h0IC0gdG9sZXJhbmNlKSBkeSA9IHlNYXggLSAoaGVpZ2h0IC0gdG9sZXJhbmNlKTtlbHNlIGlmICh5TWluID4gdG9sZXJhbmNlKSBkeSA9IHlNaW4gLSB0b2xlcmFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoeU1heCA+IGhlaWdodCArIHRvbGVyYW5jZSkgZHkgPSB5TWF4IC0gKGhlaWdodCArIHRvbGVyYW5jZSk7ZWxzZSBpZiAoeU1pbiA8IC10b2xlcmFuY2UpIGR5ID0geU1pbiArIHRvbGVyYW5jZTtcbiAgICAgIH1cbiAgICAgIGlmIChkeCB8fCBkeSkge1xuICAgICAgICAvLyBUcmFuc2Zvcm0gW2R4LCBkeV0gZnJvbSB2aWV3cG9ydCB0byBncmFwaCAodXNpbmcgdHdvIGRpZmZlcmVudCBwb2ludCB0byB0cmFuc2Zvcm0gdGhhdCB2ZWN0b3IpOlxuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgoe1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2FtZXJhU3RhdGU6IHN0YXRlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogZHgsXG4gICAgICAgICAgeTogZHlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNhbWVyYVN0YXRlOiBzdGF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgZHggPSBkZWx0YS54IC0gb3JpZ2luLng7XG4gICAgICAgIGR5ID0gZGVsdGEueSAtIG9yaWdpbi55O1xuICAgICAgICBuZXdTdGF0ZS54ICs9IGR4O1xuICAgICAgICBuZXdTdGF0ZS55ICs9IGR5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlbmRlciBsYWJlbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGFiZWxzKCkge1xuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnJlbmRlckxhYmVscykgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgY2FtZXJhU3RhdGUgPSB0aGlzLmNhbWVyYS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBTZWxlY3RpbmcgbGFiZWxzIHRvIGRyYXdcbiAgICAgIHZhciBsYWJlbHNUb0Rpc3BsYXkgPSB0aGlzLmxhYmVsR3JpZC5nZXRMYWJlbHNUb0Rpc3BsYXkoY2FtZXJhU3RhdGUucmF0aW8sIHRoaXMuc2V0dGluZ3MubGFiZWxEZW5zaXR5KTtcbiAgICAgIGV4dGVuZChsYWJlbHNUb0Rpc3BsYXksIHRoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzKTtcbiAgICAgIHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gRHJhd2luZyBsYWJlbHNcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jYW52YXNDb250ZXh0cy5sYWJlbHM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxhYmVsc1RvRGlzcGxheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBsYWJlbHNUb0Rpc3BsYXlbaV07XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW25vZGVdO1xuXG4gICAgICAgIC8vIElmIHRoZSBub2RlIHdhcyBhbHJlYWR5IGRyYXduIChsaWtlIGlmIGl0IGlzIGVsaWdpYmxlIEFORCBoYXNcbiAgICAgICAgLy8gYGZvcmNlTGFiZWxgKSwgd2UgZG9uJ3Qgd2FudCB0byBkcmF3IGl0IGFnYWluXG4gICAgICAgIC8vIE5PVEU6IHdlIGNhbiBkbyBiZXR0ZXIgcHJvYmFibHlcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscy5oYXMobm9kZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIElmIHRoZSBub2RlIGlzIGhpZGRlbiwgd2UgZG9uJ3QgbmVlZCB0byBkaXNwbGF5IGl0cyBsYWJlbCBvYnZpb3VzbHlcbiAgICAgICAgaWYgKGRhdGEuaGlkZGVuKSBjb250aW51ZTtcbiAgICAgICAgdmFyIF90aGlzJGZyYW1lZEdyYXBoVG9WaSA9IHRoaXMuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KGRhdGEpLFxuICAgICAgICAgIHggPSBfdGhpcyRmcmFtZWRHcmFwaFRvVmkueCxcbiAgICAgICAgICB5ID0gX3RoaXMkZnJhbWVkR3JhcGhUb1ZpLnk7XG5cbiAgICAgICAgLy8gTk9URTogd2UgY2FuIGNhY2hlIHRoZSBsYWJlbHMgd2UgbmVlZCB0byByZW5kZXIgdW50aWwgdGhlIGNhbWVyYSdzIHJhdGlvIGNoYW5nZXNcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNjYWxlU2l6ZShkYXRhLnNpemUpO1xuXG4gICAgICAgIC8vIElzIG5vZGUgYmlnIGVub3VnaD9cbiAgICAgICAgaWYgKCFkYXRhLmZvcmNlTGFiZWwgJiYgc2l6ZSA8IHRoaXMuc2V0dGluZ3MubGFiZWxSZW5kZXJlZFNpemVUaHJlc2hvbGQpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIElzIG5vZGUgYWN0dWFsbHkgb24gc2NyZWVuICh3aXRoIHNvbWUgbWFyZ2luKVxuICAgICAgICAvLyBOT1RFOiB3ZSB1c2VkIHRvIHJlbHkgb24gdGhlIHF1YWR0cmVlIGZvciB0aGlzLCBidXQgdGhlIGNvb3JkaW5hdGVzXG4gICAgICAgIC8vIGNvbnZlcnNpb24gbWFrZSBpdCB1bnJlbGlhYmxlIGFuZCBhdCB0aGF0IHBvaW50IHdlIGFscmVhZHkgY29udmVydGVkXG4gICAgICAgIC8vIHRvIHZpZXdwb3J0IGNvb3JkaW5hdGVzIGFuZCBzaW5jZSB0aGUgbGFiZWwgZ3JpZCBhbHJlYWR5IGN1bGxzIHRoZVxuICAgICAgICAvLyBudW1iZXIgb2YgcG90ZW50aWFsIGxhYmVscyB0byBkaXNwbGF5IHRoaXMgbG9va3MgbGlrZSBhIGdvb2RcbiAgICAgICAgLy8gcGVyZm9ybWFuY2UgY29tcHJvbWlzZS5cbiAgICAgICAgLy8gTk9URTogbGFiZWxHcmlkLmdldExhYmVsc1RvRGlzcGxheSBjb3VsZCBwcm9iYWJseSBvcHRpbWl6ZSBieSBub3RcbiAgICAgICAgLy8gY29uc2lkZXJpbmcgY2VsbHMgb2J2aW91c2x5IG91dHNpZGUgb2YgdGhlIHJhbmdlIG9mIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHZpZXcgcmVjdGFuZ2xlLlxuICAgICAgICBpZiAoeCA8IC1YX0xBQkVMX01BUkdJTiB8fCB4ID4gdGhpcy53aWR0aCArIFhfTEFCRUxfTUFSR0lOIHx8IHkgPCAtWV9MQUJFTF9NQVJHSU4gfHwgeSA+IHRoaXMuaGVpZ2h0ICsgWV9MQUJFTF9NQVJHSU4pIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZGlzcGxheWVkIGVkZ2UgbGFiZWxzIGRlcGVuZCBkaXJlY3RseSBvbiBhY3R1YWxseSByZW5kZXJlZCBub2RlXG4gICAgICAgIC8vIGxhYmVscywgd2UgbmVlZCB0byBvbmx5IGFkZCB0byB0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMgbm9kZXMgd2hvc2UgbGFiZWxcbiAgICAgICAgLy8gaXMgcmVuZGVyZWQuXG4gICAgICAgIC8vIFRoaXMgbWFrZXMgdGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzIGRlcGVuZCBvbiB2aWV3cG9ydCwgd2hpY2ggbWlnaHQgYmVjb21lXG4gICAgICAgIC8vIGFuIGlzc3VlIG9uY2Ugd2Ugc3RhcnQgbWVtb2l6aW5nIGdldExhYmVsc1RvRGlzcGxheS5cbiAgICAgICAgdGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzLmFkZChub2RlKTtcbiAgICAgICAgdmFyIGRlZmF1bHREcmF3Tm9kZUxhYmVsID0gdGhpcy5zZXR0aW5ncy5kZWZhdWx0RHJhd05vZGVMYWJlbDtcbiAgICAgICAgdmFyIG5vZGVQcm9ncmFtID0gdGhpcy5ub2RlUHJvZ3JhbXNbZGF0YS50eXBlXTtcbiAgICAgICAgdmFyIGRyYXdMYWJlbCA9IChub2RlUHJvZ3JhbSA9PT0gbnVsbCB8fCBub2RlUHJvZ3JhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZVByb2dyYW0uZHJhd0xhYmVsKSB8fCBkZWZhdWx0RHJhd05vZGVMYWJlbDtcbiAgICAgICAgZHJhd0xhYmVsKGNvbnRleHQsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBrZXk6IG5vZGVcbiAgICAgICAgfSwgZGF0YSksIHt9LCB7XG4gICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSksIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVuZGVyIGVkZ2UgbGFiZWxzLCBiYXNlZCBvbiB3aGljaCBub2RlIGxhYmVscyB3ZXJlXG4gICAgICogcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJFZGdlTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckVkZ2VMYWJlbHMoKSB7XG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmVuZGVyRWRnZUxhYmVscykgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY2FudmFzQ29udGV4dHMuZWRnZUxhYmVscztcblxuICAgICAgLy8gQ2xlYXJpbmdcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHZhciBlZGdlTGFiZWxzVG9EaXNwbGF5ID0gZWRnZUxhYmVsc1RvRGlzcGxheUZyb21Ob2Rlcyh7XG4gICAgICAgIGdyYXBoOiB0aGlzLmdyYXBoLFxuICAgICAgICBob3ZlcmVkTm9kZTogdGhpcy5ob3ZlcmVkTm9kZSxcbiAgICAgICAgZGlzcGxheWVkTm9kZUxhYmVsczogdGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzLFxuICAgICAgICBoaWdobGlnaHRlZE5vZGVzOiB0aGlzLmhpZ2hsaWdodGVkTm9kZXNcbiAgICAgIH0pO1xuICAgICAgZXh0ZW5kKGVkZ2VMYWJlbHNUb0Rpc3BsYXksIHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzKTtcbiAgICAgIHZhciBkaXNwbGF5ZWRMYWJlbHMgPSBuZXcgU2V0KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVkZ2VMYWJlbHNUb0Rpc3BsYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZUxhYmVsc1RvRGlzcGxheVtpXSxcbiAgICAgICAgICBleHRyZW1pdGllcyA9IHRoaXMuZ3JhcGguZXh0cmVtaXRpZXMoZWRnZSksXG4gICAgICAgICAgc291cmNlRGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtleHRyZW1pdGllc1swXV0sXG4gICAgICAgICAgdGFyZ2V0RGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtleHRyZW1pdGllc1sxXV0sXG4gICAgICAgICAgZWRnZURhdGEgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVbZWRnZV07XG5cbiAgICAgICAgLy8gSWYgdGhlIGVkZ2Ugd2FzIGFscmVhZHkgZHJhd24gKGxpa2UgaWYgaXQgaXMgZWxpZ2libGUgQU5EIGhhc1xuICAgICAgICAvLyBgZm9yY2VMYWJlbGApLCB3ZSBkb24ndCB3YW50IHRvIGRyYXcgaXQgYWdhaW5cbiAgICAgICAgaWYgKGRpc3BsYXllZExhYmVscy5oYXMoZWRnZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIElmIHRoZSBlZGdlIGlzIGhpZGRlbiB3ZSBkb24ndCBuZWVkIHRvIGRpc3BsYXkgaXRzIGxhYmVsXG4gICAgICAgIC8vIE5PVEU6IHRoZSB0ZXN0IG9uIHNvdXJjZURhdGEgJiB0YXJnZXREYXRhIGlzIHByb2JhYmx5IHBhcmFub2lkIGF0IHRoaXMgcG9pbnQ/XG4gICAgICAgIGlmIChlZGdlRGF0YS5oaWRkZW4gfHwgc291cmNlRGF0YS5oaWRkZW4gfHwgdGFyZ2V0RGF0YS5oaWRkZW4pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmYXVsdERyYXdFZGdlTGFiZWwgPSB0aGlzLnNldHRpbmdzLmRlZmF1bHREcmF3RWRnZUxhYmVsO1xuICAgICAgICB2YXIgZWRnZVByb2dyYW0gPSB0aGlzLmVkZ2VQcm9ncmFtc1tlZGdlRGF0YS50eXBlXTtcbiAgICAgICAgdmFyIGRyYXdMYWJlbCA9IChlZGdlUHJvZ3JhbSA9PT0gbnVsbCB8fCBlZGdlUHJvZ3JhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRnZVByb2dyYW0uZHJhd0xhYmVsKSB8fCBkZWZhdWx0RHJhd0VkZ2VMYWJlbDtcbiAgICAgICAgZHJhd0xhYmVsKGNvbnRleHQsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBrZXk6IGVkZ2VcbiAgICAgICAgfSwgZWRnZURhdGEpLCB7fSwge1xuICAgICAgICAgIHNpemU6IHRoaXMuc2NhbGVTaXplKGVkZ2VEYXRhLnNpemUpXG4gICAgICAgIH0pLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAga2V5OiBleHRyZW1pdGllc1swXVxuICAgICAgICB9LCBzb3VyY2VEYXRhKSwgdGhpcy5mcmFtZWRHcmFwaFRvVmlld3BvcnQoc291cmNlRGF0YSkpLCB7fSwge1xuICAgICAgICAgIHNpemU6IHRoaXMuc2NhbGVTaXplKHNvdXJjZURhdGEuc2l6ZSlcbiAgICAgICAgfSksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBrZXk6IGV4dHJlbWl0aWVzWzFdXG4gICAgICAgIH0sIHRhcmdldERhdGEpLCB0aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydCh0YXJnZXREYXRhKSksIHt9LCB7XG4gICAgICAgICAgc2l6ZTogdGhpcy5zY2FsZVNpemUodGFyZ2V0RGF0YS5zaXplKVxuICAgICAgICB9KSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIGRpc3BsYXllZExhYmVscy5hZGQoZWRnZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRpc3BsYXllZEVkZ2VMYWJlbHMgPSBkaXNwbGF5ZWRMYWJlbHM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZW5kZXIgdGhlIGhpZ2hsaWdodGVkIG5vZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVySGlnaGxpZ2h0ZWROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJIaWdobGlnaHRlZE5vZGVzKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY2FudmFzQ29udGV4dHMuaG92ZXJzO1xuXG4gICAgICAvLyBDbGVhcmluZ1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAvLyBSZW5kZXJpbmdcbiAgICAgIHZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIobm9kZSkge1xuICAgICAgICB2YXIgZGF0YSA9IF90aGlzNy5ub2RlRGF0YUNhY2hlW25vZGVdO1xuICAgICAgICB2YXIgX3RoaXM3JGZyYW1lZEdyYXBoVG9WID0gX3RoaXM3LmZyYW1lZEdyYXBoVG9WaWV3cG9ydChkYXRhKSxcbiAgICAgICAgICB4ID0gX3RoaXM3JGZyYW1lZEdyYXBoVG9WLngsXG4gICAgICAgICAgeSA9IF90aGlzNyRmcmFtZWRHcmFwaFRvVi55O1xuICAgICAgICB2YXIgc2l6ZSA9IF90aGlzNy5zY2FsZVNpemUoZGF0YS5zaXplKTtcbiAgICAgICAgdmFyIGRlZmF1bHREcmF3Tm9kZUhvdmVyID0gX3RoaXM3LnNldHRpbmdzLmRlZmF1bHREcmF3Tm9kZUhvdmVyO1xuICAgICAgICB2YXIgbm9kZVByb2dyYW0gPSBfdGhpczcubm9kZVByb2dyYW1zW2RhdGEudHlwZV07XG4gICAgICAgIHZhciBkcmF3SG92ZXIgPSAobm9kZVByb2dyYW0gPT09IG51bGwgfHwgbm9kZVByb2dyYW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVQcm9ncmFtLmRyYXdIb3ZlcikgfHwgZGVmYXVsdERyYXdOb2RlSG92ZXI7XG4gICAgICAgIGRyYXdIb3Zlcihjb250ZXh0LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAga2V5OiBub2RlXG4gICAgICAgIH0sIGRhdGEpLCB7fSwge1xuICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH0pLCBfdGhpczcuc2V0dGluZ3MpO1xuICAgICAgfTtcbiAgICAgIHZhciBub2Rlc1RvUmVuZGVyID0gW107XG4gICAgICBpZiAodGhpcy5ob3ZlcmVkTm9kZSAmJiAhdGhpcy5ub2RlRGF0YUNhY2hlW3RoaXMuaG92ZXJlZE5vZGVdLmhpZGRlbikge1xuICAgICAgICBub2Rlc1RvUmVuZGVyLnB1c2godGhpcy5ob3ZlcmVkTm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvLyBUaGUgaG92ZXJlZCBub2RlIGhhcyBhbHJlYWR5IGJlZW4gaGlnaGxpZ2h0ZWRcbiAgICAgICAgaWYgKG5vZGUgIT09IF90aGlzNy5ob3ZlcmVkTm9kZSkgbm9kZXNUb1JlbmRlci5wdXNoKG5vZGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIERyYXcgbGFiZWxzOlxuICAgICAgbm9kZXNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiByZW5kZXIobm9kZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRHJhdyBXZWJHTCBub2RlcyBvbiB0b3Agb2YgdGhlIGxhYmVsczpcbiAgICAgIHZhciBub2Rlc1BlclByb2dyYW1zID0ge307XG5cbiAgICAgIC8vIDEuIENvdW50IG5vZGVzIHBlciB0eXBlOlxuICAgICAgbm9kZXNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciB0eXBlID0gX3RoaXM3Lm5vZGVEYXRhQ2FjaGVbbm9kZV0udHlwZTtcbiAgICAgICAgbm9kZXNQZXJQcm9ncmFtc1t0eXBlXSA9IChub2Rlc1BlclByb2dyYW1zW3R5cGVdIHx8IDApICsgMTtcbiAgICAgIH0pO1xuICAgICAgLy8gMi4gQWxsb2NhdGUgZm9yIGVhY2ggdHlwZSBmb3IgdGhlIHByb3BlciBudW1iZXIgb2Ygbm9kZXNcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5ub2RlSG92ZXJQcm9ncmFtcykge1xuICAgICAgICB0aGlzLm5vZGVIb3ZlclByb2dyYW1zW3R5cGVdLnJlYWxsb2NhdGUobm9kZXNQZXJQcm9ncmFtc1t0eXBlXSB8fCAwKTtcbiAgICAgICAgLy8gQWxzbyByZXNldCBjb3VudCwgdG8gdXNlIHdoZW4gcmVuZGVyaW5nOlxuICAgICAgICBub2Rlc1BlclByb2dyYW1zW3R5cGVdID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIDMuIFByb2Nlc3MgYWxsIG5vZGVzIHRvIHJlbmRlcjpcbiAgICAgIG5vZGVzVG9SZW5kZXIuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgZGF0YSA9IF90aGlzNy5ub2RlRGF0YUNhY2hlW25vZGVdO1xuICAgICAgICBfdGhpczcubm9kZUhvdmVyUHJvZ3JhbXNbZGF0YS50eXBlXS5wcm9jZXNzKDAsIG5vZGVzUGVyUHJvZ3JhbXNbZGF0YS50eXBlXSsrLCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgLy8gNC4gQ2xlYXIgaG92ZXJlZCBub2RlcyBsYXllcjpcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cy5ob3Zlck5vZGVzLmNsZWFyKHRoaXMud2ViR0xDb250ZXh0cy5ob3Zlck5vZGVzLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgLy8gNS4gUmVuZGVyOlxuICAgICAgdmFyIHJlbmRlclBhcmFtcyA9IHRoaXMuZ2V0UmVuZGVyUGFyYW1zKCk7XG4gICAgICBmb3IgKHZhciBfdHlwZTYgaW4gdGhpcy5ub2RlSG92ZXJQcm9ncmFtcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNbX3R5cGU2XTtcbiAgICAgICAgcHJvZ3JhbS5yZW5kZXIocmVuZGVyUGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzY2hlZHVsZSBhIGhvdmVyIHJlbmRlci5cbiAgICAgKlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlZHVsZUhpZ2hsaWdodGVkTm9kZXNSZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSB8fCB0aGlzLnJlbmRlckZyYW1lKSByZXR1cm47XG4gICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJlc2V0dGluZyBzdGF0ZVxuICAgICAgICBfdGhpczgucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lID0gbnVsbDtcblxuICAgICAgICAvLyBSZW5kZXJpbmdcbiAgICAgICAgX3RoaXM4LnJlbmRlckhpZ2hsaWdodGVkTm9kZXMoKTtcbiAgICAgICAgX3RoaXM4LnJlbmRlckVkZ2VMYWJlbHMoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlbmRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcbiAgICAgIHRoaXMuZW1pdChcImJlZm9yZVJlbmRlclwiKTtcbiAgICAgIHZhciBleGl0UmVuZGVyID0gZnVuY3Rpb24gZXhpdFJlbmRlcigpIHtcbiAgICAgICAgX3RoaXM5LmVtaXQoXCJhZnRlclJlbmRlclwiKTtcbiAgICAgICAgcmV0dXJuIF90aGlzOTtcbiAgICAgIH07XG5cbiAgICAgIC8vIElmIGEgcmVuZGVyIHdhcyBzY2hlZHVsZWQsIHdlIGNhbmNlbCBpdFxuICAgICAgaWYgKHRoaXMucmVuZGVyRnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXJGcmFtZSk7XG4gICAgICAgIHRoaXMucmVuZGVyRnJhbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIHJlc2l6ZVxuICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgLy8gRG8gd2UgbmVlZCB0byByZXByb2Nlc3MgZGF0YT9cbiAgICAgIGlmICh0aGlzLm5lZWRUb1Byb2Nlc3MpIHRoaXMucHJvY2VzcygpO1xuICAgICAgdGhpcy5uZWVkVG9Qcm9jZXNzID0gZmFsc2U7XG5cbiAgICAgIC8vIENsZWFyaW5nIHRoZSBjYW52YXNlc1xuICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAvLyBQcmVwYXJlIHRoZSB0ZXh0dXJlc1xuICAgICAgdGhpcy5waWNraW5nTGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIHJldHVybiBfdGhpczkucmVzZXRXZWJHTFRleHR1cmUobGF5ZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgbm8gbm9kZXMgd2UgY2FuIHN0b3AgcmlnaHQgdGhlcmVcbiAgICAgIGlmICghdGhpcy5ncmFwaC5vcmRlcikgcmV0dXJuIGV4aXRSZW5kZXIoKTtcblxuICAgICAgLy8gVE9ETzogaW1wcm92ZSB0aGlzIGhldXJpc3RpYyBvciBtb3ZlIHRvIHRoZSBjYXB0b3IgaXRzZWxmP1xuICAgICAgLy8gVE9ETzogZGVhbCB3aXRoIHRoZSB0b3VjaCBjYXB0b3IgaGVyZSBhcyB3ZWxsXG4gICAgICB2YXIgbW91c2VDYXB0b3IgPSB0aGlzLm1vdXNlQ2FwdG9yO1xuICAgICAgdmFyIG1vdmluZyA9IHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQoKSB8fCBtb3VzZUNhcHRvci5pc01vdmluZyB8fCBtb3VzZUNhcHRvci5kcmFnZ2VkRXZlbnRzIHx8IG1vdXNlQ2FwdG9yLmN1cnJlbnRXaGVlbERpcmVjdGlvbjtcblxuICAgICAgLy8gVGhlbiB3ZSBuZWVkIHRvIGV4dHJhY3QgYSBtYXRyaXggZnJvbSB0aGUgY2FtZXJhXG4gICAgICB2YXIgY2FtZXJhU3RhdGUgPSB0aGlzLmNhbWVyYS5nZXRTdGF0ZSgpO1xuICAgICAgdmFyIHZpZXdwb3J0RGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9ucygpO1xuICAgICAgdmFyIGdyYXBoRGltZW5zaW9ucyA9IHRoaXMuZ2V0R3JhcGhEaW1lbnNpb25zKCk7XG4gICAgICB2YXIgcGFkZGluZyA9IHRoaXMuZ2V0U3RhZ2VQYWRkaW5nKCk7XG4gICAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeEZyb21DYW1lcmEoY2FtZXJhU3RhdGUsIHZpZXdwb3J0RGltZW5zaW9ucywgZ3JhcGhEaW1lbnNpb25zLCBwYWRkaW5nKTtcbiAgICAgIHRoaXMuaW52TWF0cml4ID0gbWF0cml4RnJvbUNhbWVyYShjYW1lcmFTdGF0ZSwgdmlld3BvcnREaW1lbnNpb25zLCBncmFwaERpbWVuc2lvbnMsIHBhZGRpbmcsIHRydWUpO1xuICAgICAgdGhpcy5jb3JyZWN0aW9uUmF0aW8gPSBnZXRNYXRyaXhJbXBhY3QodGhpcy5tYXRyaXgsIGNhbWVyYVN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMpO1xuICAgICAgdGhpcy5ncmFwaFRvVmlld3BvcnRSYXRpbyA9IHRoaXMuZ2V0R3JhcGhUb1ZpZXdwb3J0UmF0aW8oKTtcblxuICAgICAgLy8gW2phY29teWFsXVxuICAgICAgLy8gVGhpcyBjb21tZW50IGlzIHJlbGF0ZWQgdG8gdGhlIG9uZSBhYm92ZSB0aGUgYGdldE1hdHJpeEltcGFjdGAgZGVmaW5pdGlvbjpcbiAgICAgIC8vIC0gYHRoaXMuY29ycmVjdGlvblJhdGlvYCBpcyBzb21laG93IG5vdCBjb21wbGV0ZWx5IGV4cGxhaW5lZFxuICAgICAgLy8gLSBgdGhpcy5ncmFwaFRvVmlld3BvcnRSYXRpb2AgaXMgdGhlIHJhdGlvIG9mIGEgZGlzdGFuY2UgaW4gdGhlIHZpZXdwb3J0IGRpdmlkZWQgYnkgdGhlIHNhbWUgZGlzdGFuY2UgaW4gdGhlXG4gICAgICAvLyAgIGdyYXBoXG4gICAgICAvLyAtIGB0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbi5yYXRpb2AgaXMgYmFzaWNhbGx5IGBNYXRoLm1heChncmFwaERYLCBncmFwaERZKWBcbiAgICAgIC8vIEFuZCBub3csIEkgb2JzZXJ2ZSB0aGF0IGlmIEkgbXVsdGlwbHkgdGhlc2UgdGhyZWUgcmF0aW9zLCBJIGhhdmUgc29tZXRoaW5nIGNvbnN0YW50LCB3aGljaCB2YWx1ZSByZW1haW5zIDIsIGV2ZW5cbiAgICAgIC8vIHdoZW4gSSBjaGFuZ2UgdGhlIGdyYXBoLCB0aGUgdmlld3BvcnQgb3IgdGhlIGNhbWVyYS4gSXQgbWlnaHQgYmUgdXNlZnVsIGxhdGVyLCBzbyBJIHByZWZlciB0byBsZXQgdGhpcyBjb21tZW50OlxuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5ncmFwaFRvVmlld3BvcnRSYXRpbyAqIHRoaXMuY29ycmVjdGlvblJhdGlvICogdGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24ucmF0aW8gKiAyKTtcblxuICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0UmVuZGVyUGFyYW1zKCk7XG5cbiAgICAgIC8vIERyYXdpbmcgbm9kZXNcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5ub2RlUHJvZ3JhbXMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLm5vZGVQcm9ncmFtc1t0eXBlXTtcbiAgICAgICAgcHJvZ3JhbS5yZW5kZXIocGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgLy8gRHJhd2luZyBlZGdlc1xuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmhpZGVFZGdlc09uTW92ZSB8fCAhbW92aW5nKSB7XG4gICAgICAgIGZvciAodmFyIF90eXBlNyBpbiB0aGlzLmVkZ2VQcm9ncmFtcykge1xuICAgICAgICAgIHZhciBfcHJvZ3JhbTIgPSB0aGlzLmVkZ2VQcm9ncmFtc1tfdHlwZTddO1xuICAgICAgICAgIF9wcm9ncmFtMi5yZW5kZXIocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEbyBub3QgZGlzcGxheSBsYWJlbHMgb24gbW92ZSBwZXIgc2V0dGluZ1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaGlkZUxhYmVsc09uTW92ZSAmJiBtb3ZpbmcpIHJldHVybiBleGl0UmVuZGVyKCk7XG4gICAgICB0aGlzLnJlbmRlckxhYmVscygpO1xuICAgICAgdGhpcy5yZW5kZXJFZGdlTGFiZWxzKCk7XG4gICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXMoKTtcbiAgICAgIHJldHVybiBleGl0UmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbm9kZSBpbiB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgbm9kZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vZGUoa2V5KSB7XG4gICAgICAvLyBOb2RlIGRpc3BsYXkgZGF0YSByZXNvbHV0aW9uOlxuICAgICAgLy8gIDEuIEZpcnN0IHdlIGdldCB0aGUgbm9kZSdzIGF0dHJpYnV0ZXNcbiAgICAgIC8vICAyLiBXZSBvcHRpb25hbGx5IHJlZHVjZSB0aGVtIHVzaW5nIHRoZSBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlclxuICAgICAgLy8gICAgIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgdG90YWwgb2JqZWN0IGFuZCB3b24ndCBiZSBtZXJnZWRcbiAgICAgIC8vICAzLiBXZSBhcHBseSBvdXIgZGVmYXVsdHMsIHdoaWxlIHJ1bm5pbmcgc29tZSB2aXRhbCBjaGVja3NcbiAgICAgIC8vICA0LiBXZSBhcHBseSB0aGUgbm9ybWFsaXphdGlvbiBmdW5jdGlvblxuICAgICAgLy8gV2Ugc2hhbGxvdyBjb3B5IG5vZGUgZGF0YSB0byBhdm9pZCBkYW5nZXJvdXMgYmVoYXZpb3JzIGZyb20gcmVkdWNlcnNcbiAgICAgIHZhciBhdHRyID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ncmFwaC5nZXROb2RlQXR0cmlidXRlcyhrZXkpKTtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5vZGVSZWR1Y2VyKSBhdHRyID0gdGhpcy5zZXR0aW5ncy5ub2RlUmVkdWNlcihrZXksIGF0dHIpO1xuICAgICAgdmFyIGRhdGEgPSBhcHBseU5vZGVEZWZhdWx0cyh0aGlzLnNldHRpbmdzLCBrZXksIGF0dHIpO1xuICAgICAgdGhpcy5ub2RlRGF0YUNhY2hlW2tleV0gPSBkYXRhO1xuXG4gICAgICAvLyBMYWJlbDpcbiAgICAgIC8vIFdlIGRlbGV0ZSBhbmQgYWRkIGlmIG5lZWRlZCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyB1c2VkIGZyb21cbiAgICAgIC8vIHVwZGF0ZVxuICAgICAgdGhpcy5ub2Rlc1dpdGhGb3JjZWRMYWJlbHNbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIGlmIChkYXRhLmZvcmNlTGFiZWwgJiYgIWRhdGEuaGlkZGVuKSB0aGlzLm5vZGVzV2l0aEZvcmNlZExhYmVscy5hZGQoa2V5KTtcblxuICAgICAgLy8gSGlnaGxpZ2h0ZWQ6XG4gICAgICAvLyBXZSByZW1vdmUgYW5kIHJlIGFkZCBpZiBuZWVkZWQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIGFsc28gdXNlZCBmcm9tXG4gICAgICAvLyB1cGRhdGVcbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2Rlc1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgaWYgKGRhdGEuaGlnaGxpZ2h0ZWQgJiYgIWRhdGEuaGlkZGVuKSB0aGlzLmhpZ2hsaWdodGVkTm9kZXMuYWRkKGtleSk7XG5cbiAgICAgIC8vIHpJbmRleFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuekluZGV4KSB7XG4gICAgICAgIGlmIChkYXRhLnpJbmRleCA8IHRoaXMubm9kZVpFeHRlbnRbMF0pIHRoaXMubm9kZVpFeHRlbnRbMF0gPSBkYXRhLnpJbmRleDtcbiAgICAgICAgaWYgKGRhdGEuekluZGV4ID4gdGhpcy5ub2RlWkV4dGVudFsxXSkgdGhpcy5ub2RlWkV4dGVudFsxXSA9IGRhdGEuekluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIG5vZGUgdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5vZGUncyBncmFwaG9sb2d5IElEXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVOb2RlKGtleSkge1xuICAgICAgdGhpcy5hZGROb2RlKGtleSk7XG5cbiAgICAgIC8vIFJlLWFwcGx5IG5vcm1hbGl6YXRpb24gb24gdGhlIG5vZGVcbiAgICAgIHZhciBkYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW2tleV07XG4gICAgICB0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbi5hcHBseVRvKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIG5vZGUgZnJvbSB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgbm9kZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZU5vZGUoa2V5KSB7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBub2RlIGNhY2hlXG4gICAgICBkZWxldGUgdGhpcy5ub2RlRGF0YUNhY2hlW2tleV07XG4gICAgICAvLyBSZW1vdmUgZnJvbSBub2RlIHByb2dyYW0gaW5kZXhcbiAgICAgIGRlbGV0ZSB0aGlzLm5vZGVQcm9ncmFtSW5kZXhba2V5XTtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGhpZ2xpZ2h0ZWQgbm9kZXNcbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2Rlc1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gaG92ZXJlZFxuICAgICAgaWYgKHRoaXMuaG92ZXJlZE5vZGUgPT09IGtleSkgdGhpcy5ob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBmb3JjZWQgbGFiZWxcbiAgICAgIHRoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGVkZ2UgaW50byB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgZWRnZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVkZ2Uoa2V5KSB7XG4gICAgICAvLyBFZGdlIGRpc3BsYXkgZGF0YSByZXNvbHV0aW9uOlxuICAgICAgLy8gIDEuIEZpcnN0IHdlIGdldCB0aGUgZWRnZSdzIGF0dHJpYnV0ZXNcbiAgICAgIC8vICAyLiBXZSBvcHRpb25hbGx5IHJlZHVjZSB0aGVtIHVzaW5nIHRoZSBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlclxuICAgICAgLy8gIDMuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgdG90YWwgb2JqZWN0IGFuZCB3b24ndCBiZSBtZXJnZWRcbiAgICAgIC8vICA0LiBXZSBhcHBseSBvdXIgZGVmYXVsdHMsIHdoaWxlIHJ1bm5pbmcgc29tZSB2aXRhbCBjaGVja3NcbiAgICAgIC8vIFdlIHNoYWxsb3cgY29weSBlZGdlIGRhdGEgdG8gYXZvaWQgZGFuZ2Vyb3VzIGJlaGF2aW9ycyBmcm9tIHJlZHVjZXJzXG4gICAgICB2YXIgYXR0ciA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ3JhcGguZ2V0RWRnZUF0dHJpYnV0ZXMoa2V5KSk7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5lZGdlUmVkdWNlcikgYXR0ciA9IHRoaXMuc2V0dGluZ3MuZWRnZVJlZHVjZXIoa2V5LCBhdHRyKTtcbiAgICAgIHZhciBkYXRhID0gYXBwbHlFZGdlRGVmYXVsdHModGhpcy5zZXR0aW5ncywga2V5LCBhdHRyKTtcbiAgICAgIHRoaXMuZWRnZURhdGFDYWNoZVtrZXldID0gZGF0YTtcblxuICAgICAgLy8gRm9yY2VkIGxhYmVsXG4gICAgICAvLyB3ZSBmaWx0ZXIgYW5kIHJlIHB1c2ggaWYgbmVlZGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBhbHNvIHVzZWQgZnJvbVxuICAgICAgLy8gdXBkYXRlXG4gICAgICB0aGlzLmVkZ2VzV2l0aEZvcmNlZExhYmVsc1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgaWYgKGRhdGEuZm9yY2VMYWJlbCAmJiAhZGF0YS5oaWRkZW4pIHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzLmFkZChrZXkpO1xuXG4gICAgICAvLyBDaGVjayB6SW5kZXhcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnpJbmRleCkge1xuICAgICAgICBpZiAoZGF0YS56SW5kZXggPCB0aGlzLmVkZ2VaRXh0ZW50WzBdKSB0aGlzLmVkZ2VaRXh0ZW50WzBdID0gZGF0YS56SW5kZXg7XG4gICAgICAgIGlmIChkYXRhLnpJbmRleCA+IHRoaXMuZWRnZVpFeHRlbnRbMV0pIHRoaXMuZWRnZVpFeHRlbnRbMV0gPSBkYXRhLnpJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gZWRnZSBpbiB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgZWRnZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkZ2Uoa2V5KSB7XG4gICAgICB0aGlzLmFkZEVkZ2Uoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZWRnZSBmcm9tIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBlZGdlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRWRnZShrZXkpIHtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGVkZ2UgY2FjaGVcbiAgICAgIGRlbGV0ZSB0aGlzLmVkZ2VEYXRhQ2FjaGVba2V5XTtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIHByb2dyYW1JZCBpbmRleFxuICAgICAgZGVsZXRlIHRoaXMuZWRnZVByb2dyYW1JbmRleFtrZXldO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gaG92ZXJlZFxuICAgICAgaWYgKHRoaXMuaG92ZXJlZEVkZ2UgPT09IGtleSkgdGhpcy5ob3ZlcmVkRWRnZSA9IG51bGw7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBmb3JjZWQgbGFiZWxcbiAgICAgIHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGluZGljZXMgcmVsYXRlZCB0byBub2Rlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFyTm9kZUluZGljZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJOb2RlSW5kaWNlcygpIHtcbiAgICAgIC8vIExhYmVsR3JpZCAmIG5vZGVFeHRlbnQgYXJlIG9ubHkgbWFuYWdlL3BvcHVsYXRlZCBpbiB0aGUgcHJvY2VzcyBmdW5jdGlvblxuICAgICAgdGhpcy5sYWJlbEdyaWQgPSBuZXcgTGFiZWxHcmlkKCk7XG4gICAgICB0aGlzLm5vZGVFeHRlbnQgPSB7XG4gICAgICAgIHg6IFswLCAxXSxcbiAgICAgICAgeTogWzAsIDFdXG4gICAgICB9O1xuICAgICAgdGhpcy5ub2RlRGF0YUNhY2hlID0ge307XG4gICAgICB0aGlzLmVkZ2VQcm9ncmFtSW5kZXggPSB7fTtcbiAgICAgIHRoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5ub2RlWkV4dGVudCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgaW5kaWNlcyByZWxhdGVkIHRvIGVkZ2VzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJFZGdlSW5kaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckVkZ2VJbmRpY2VzKCkge1xuICAgICAgdGhpcy5lZGdlRGF0YUNhY2hlID0ge307XG4gICAgICB0aGlzLmVkZ2VQcm9ncmFtSW5kZXggPSB7fTtcbiAgICAgIHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5lZGdlWkV4dGVudCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgaW5kaWNlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFySW5kaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckluZGljZXMoKSB7XG4gICAgICB0aGlzLmNsZWFyRWRnZUluZGljZXMoKTtcbiAgICAgIHRoaXMuY2xlYXJOb2RlSW5kaWNlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBncmFwaCBzdGF0ZSByZWxhdGVkIHRvIG5vZGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJOb2RlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJOb2RlU3RhdGUoKSB7XG4gICAgICB0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmhvdmVyZWROb2RlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZ3JhcGggc3RhdGUgcmVsYXRlZCB0byBlZGdlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFyRWRnZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyRWRnZVN0YXRlKCkge1xuICAgICAgdGhpcy5kaXNwbGF5ZWRFZGdlTGFiZWxzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5ob3ZlcmVkRWRnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGdyYXBoIHN0YXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclN0YXRlKCkge1xuICAgICAgdGhpcy5jbGVhckVkZ2VTdGF0ZSgpO1xuICAgICAgdGhpcy5jbGVhck5vZGVTdGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgbm9kZSBkYXRhIHRvIGl0cyBwcm9ncmFtLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUncyBncmFwaG9sb2d5IElEXG4gICAgICogQHBhcmFtIGZpbmdlcnByaW50IEEgZmluZ2VycHJpbnQgdXNlZCB0byBpZGVudGl0eSB0aGUgbm9kZSB3aXRoIHBpY2tpbmdcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIGluZGV4IHdoZXJlIHRvIHBsYWNlIHRoZSBub2RlIGluIHRoZSBwcm9ncmFtXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTm9kZVRvUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGROb2RlVG9Qcm9ncmFtKG5vZGUsIGZpbmdlcnByaW50LCBwb3NpdGlvbikge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbbm9kZV07XG4gICAgICB2YXIgbm9kZVByb2dyYW0gPSB0aGlzLm5vZGVQcm9ncmFtc1tkYXRhLnR5cGVdO1xuICAgICAgaWYgKCFub2RlUHJvZ3JhbSkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvdWxkIG5vdCBmaW5kIGEgc3VpdGFibGUgcHJvZ3JhbSBmb3Igbm9kZSB0eXBlIFxcXCJcIi5jb25jYXQoZGF0YS50eXBlLCBcIlxcXCIhXCIpKTtcbiAgICAgIG5vZGVQcm9ncmFtLnByb2Nlc3MoZmluZ2VycHJpbnQsIHBvc2l0aW9uLCBkYXRhKTtcbiAgICAgIC8vIFNhdmluZyBwcm9ncmFtIGluZGV4XG4gICAgICB0aGlzLm5vZGVQcm9ncmFtSW5kZXhbbm9kZV0gPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGVkZ2UgZGF0YSB0byBpdHMgcHJvZ3JhbS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBlZGdlIFRoZSBlZGdlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqIEBwYXJhbSBmaW5nZXJwcmludCBBIGZpbmdlcnByaW50IHVzZWQgdG8gaWRlbnRpdHkgdGhlIGVkZ2Ugd2l0aCBwaWNraW5nXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBpbmRleCB3aGVyZSB0byBwbGFjZSB0aGUgZWRnZSBpbiB0aGUgcHJvZ3JhbVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZEVkZ2VUb1Byb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWRnZVRvUHJvZ3JhbShlZGdlLCBmaW5nZXJwcmludCwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5lZGdlRGF0YUNhY2hlW2VkZ2VdO1xuICAgICAgdmFyIGVkZ2VQcm9ncmFtID0gdGhpcy5lZGdlUHJvZ3JhbXNbZGF0YS50eXBlXTtcbiAgICAgIGlmICghZWRnZVByb2dyYW0pIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjb3VsZCBub3QgZmluZCBhIHN1aXRhYmxlIHByb2dyYW0gZm9yIGVkZ2UgdHlwZSBcXFwiXCIuY29uY2F0KGRhdGEudHlwZSwgXCJcXFwiIVwiKSk7XG4gICAgICB2YXIgZXh0cmVtaXRpZXMgPSB0aGlzLmdyYXBoLmV4dHJlbWl0aWVzKGVkZ2UpLFxuICAgICAgICBzb3VyY2VEYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW2V4dHJlbWl0aWVzWzBdXSxcbiAgICAgICAgdGFyZ2V0RGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtleHRyZW1pdGllc1sxXV07XG4gICAgICBlZGdlUHJvZ3JhbS5wcm9jZXNzKGZpbmdlcnByaW50LCBwb3NpdGlvbiwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSk7XG4gICAgICAvLyBTYXZpbmcgcHJvZ3JhbSBpbmRleFxuICAgICAgdGhpcy5lZGdlUHJvZ3JhbUluZGV4W2VkZ2VdID0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogUHVibGljIEFQSS5cbiAgICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gZ2V0IHRoZSByZW5kZXIgcGFyYW1zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UmVuZGVyUGFyYW1zfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFJlbmRlclBhcmFtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZW5kZXJQYXJhbXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4LFxuICAgICAgICBpbnZNYXRyaXg6IHRoaXMuaW52TWF0cml4LFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgcGl4ZWxSYXRpbzogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICB6b29tUmF0aW86IHRoaXMuY2FtZXJhLnJhdGlvLFxuICAgICAgICBjYW1lcmFBbmdsZTogdGhpcy5jYW1lcmEuYW5nbGUsXG4gICAgICAgIHNpemVSYXRpbzogMSAvIHRoaXMuc2NhbGVTaXplKCksXG4gICAgICAgIGNvcnJlY3Rpb25SYXRpbzogdGhpcy5jb3JyZWN0aW9uUmF0aW8sXG4gICAgICAgIGRvd25TaXppbmdSYXRpbzogdGhpcy5waWNraW5nRG93blNpemluZ1JhdGlvLFxuICAgICAgICBtaW5FZGdlVGhpY2tuZXNzOiB0aGlzLnNldHRpbmdzLm1pbkVkZ2VUaGlja25lc3MsXG4gICAgICAgIGFudGlBbGlhc2luZ0ZlYXRoZXI6IHRoaXMuc2V0dGluZ3MuYW50aUFsaWFzaW5nRmVhdGhlclxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIHJldHJpZXZlIHRoZSBhY3R1YWwgc3RhZ2UgcGFkZGluZyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGFnZVBhZGRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhZ2VQYWRkaW5nKCkge1xuICAgICAgdmFyIF90aGlzJHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgc3RhZ2VQYWRkaW5nID0gX3RoaXMkc2V0dGluZ3Muc3RhZ2VQYWRkaW5nLFxuICAgICAgICBhdXRvUmVzY2FsZSA9IF90aGlzJHNldHRpbmdzLmF1dG9SZXNjYWxlO1xuICAgICAgcmV0dXJuIGF1dG9SZXNjYWxlID8gc3RhZ2VQYWRkaW5nIHx8IDAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIGEgbGF5ZXIgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIENvbnRleHQncyBpZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIC0gVGhlIEhUTUwgdGFnIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUxheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUxheWVyKGlkLCB0YWcpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2lkXSkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGEgbGF5ZXIgbmFtZWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiIGFscmVhZHkgZXhpc3RzXCIpKTtcbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0YWcsIHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgICAgfSwge1xuICAgICAgICBcImNsYXNzXCI6IFwic2lnbWEtXCIuY29uY2F0KGlkKVxuICAgICAgfSk7XG4gICAgICBpZiAob3B0aW9ucy5zdHlsZSkgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBvcHRpb25zLnN0eWxlKTtcbiAgICAgIHRoaXMuZWxlbWVudHNbaWRdID0gZWxlbWVudDtcbiAgICAgIGlmIChcImJlZm9yZUxheWVyXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmJlZm9yZUxheWVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbb3B0aW9ucy5iZWZvcmVMYXllcl0uYmVmb3JlKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChcImFmdGVyTGF5ZXJcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuYWZ0ZXJMYXllcikge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW29wdGlvbnMuYWZ0ZXJMYXllcl0uYWZ0ZXIoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIGEgY2FudmFzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBDb250ZXh0J3MgaWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVDYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ2FudmFzKGlkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYXllcihpZCwgXCJjYW52YXNcIiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgYSBjYW52YXMgY29udGV4dCBhbmQgYWRkIHRoZSByZWxldmFudCBET00gZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIC0gQ29udGV4dCdzIGlkLlxuICAgICAqIEBwYXJhbSAgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUNhbnZhc0NvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ2FudmFzQ29udGV4dChpZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKGlkLCBvcHRpb25zKTtcbiAgICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHtcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dHNbaWRdID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBhIFdlYkdMIGNvbnRleHQgYW5kIGFkZCB0aGUgcmVsZXZhbnQgRE9NXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBpZCAgICAgIC0gQ29udGV4dCdzIGlkLlxuICAgICAqIEBwYXJhbSAge29iamVjdD99IG9wdGlvbnMgLSAjZ2V0Q29udGV4dCBwYXJhbXMgdG8gb3ZlcnJpZGUgKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVXZWJHTENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlV2ViR0xDb250ZXh0KGlkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgY2FudmFzID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYW52YXMpIHx8IHRoaXMuY3JlYXRlQ2FudmFzKGlkLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmhpZGRlbikgY2FudmFzLnJlbW92ZSgpO1xuICAgICAgdmFyIGNvbnRleHRPcHRpb25zID0gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICAgICAgICBhbnRpYWxpYXM6IGZhbHNlXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICAgIHZhciBjb250ZXh0O1xuXG4gICAgICAvLyBGaXJzdCB3ZSB0cnkgd2ViZ2wyIGZvciBhbiBlYXN5IHBlcmZvcm1hbmNlIGJvb3N0XG4gICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgY29udGV4dE9wdGlvbnMpO1xuXG4gICAgICAvLyBFbHNlIHdlIGZhbGwgYmFjayB0byB3ZWJnbFxuICAgICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBjb250ZXh0T3B0aW9ucyk7XG5cbiAgICAgIC8vIEVkZ2UsIEkgYW0gbG9va2luZyByaWdodCBhdCB5b3UuLi5cbiAgICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgIHZhciBnbCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHNbaWRdID0gZ2w7XG5cbiAgICAgIC8vIEJsZW5kaW5nOlxuICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cbiAgICAgIC8vIFByZXBhcmUgZnJhbWUgYnVmZmVyIGZvciBwaWNraW5nIGxheWVyczpcbiAgICAgIGlmIChvcHRpb25zLnBpY2tpbmcpIHtcbiAgICAgICAgdGhpcy5waWNraW5nTGF5ZXJzLmFkZChpZCk7XG4gICAgICAgIHZhciBuZXdGcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgIGlmICghbmV3RnJhbWVCdWZmZXIpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjYW5ub3QgY3JlYXRlIGEgbmV3IGZyYW1lIGJ1ZmZlciBmb3IgbGF5ZXIgXCIuY29uY2F0KGlkKSk7XG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXJzW2lkXSA9IG5ld0ZyYW1lQnVmZmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gcHJvcGVybHkga2lsbCBhIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBpZCAtIExheWVyIGlkLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImtpbGxMYXllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsTGF5ZXIoaWQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1tpZF07XG4gICAgICBpZiAoIWVsZW1lbnQpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjYW5ub3Qga2lsbCBsYXllciBcIi5jb25jYXQoaWQsIFwiLCB3aGljaCBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICBpZiAodGhpcy53ZWJHTENvbnRleHRzW2lkXSkge1xuICAgICAgICB2YXIgX2dsJGdldEV4dGVuc2lvbjtcbiAgICAgICAgdmFyIGdsID0gdGhpcy53ZWJHTENvbnRleHRzW2lkXTtcbiAgICAgICAgKF9nbCRnZXRFeHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIikpID09PSBudWxsIHx8IF9nbCRnZXRFeHRlbnNpb24gPT09IHZvaWQgMCB8fCBfZ2wkZ2V0RXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLndlYkdMQ29udGV4dHNbaWRdO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbnZhc0NvbnRleHRzW2lkXSkge1xuICAgICAgICBkZWxldGUgdGhpcy5jYW52YXNDb250ZXh0c1tpZF07XG4gICAgICB9XG5cbiAgICAgIC8vIERlbGV0ZSBsYXllciBlbGVtZW50XG4gICAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuZWxlbWVudHNbaWRdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgcmVuZGVyZXIncyBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtDYW1lcmF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FtZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhbWVyYSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Qgc2V0dGluZyB0aGUgcmVuZGVyZXIncyBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtDYW1lcmF9IGNhbWVyYSAtIE5ldyBjYW1lcmEuXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2FtZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENhbWVyYShjYW1lcmEpIHtcbiAgICAgIHRoaXMudW5iaW5kQ2FtZXJhSGFuZGxlcnMoKTtcbiAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgICAgdGhpcy5iaW5kQ2FtZXJhSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250YWluZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGFpbmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIHJlbmRlcmVyJ3MgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRHcmFwaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmFwaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdyYXBoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNldCB0aGUgcmVuZGVyZXIncyBncmFwaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0dyYXBofVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldEdyYXBoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEdyYXBoKGdyYXBoKSB7XG4gICAgICBpZiAoZ3JhcGggPT09IHRoaXMuZ3JhcGgpIHJldHVybjtcblxuICAgICAgLy8gQ2hlY2sgaG92ZXJlZE5vZGUgYW5kIGhvdmVyZWRFZGdlXG4gICAgICBpZiAodGhpcy5ob3ZlcmVkTm9kZSAmJiAhZ3JhcGguaGFzTm9kZSh0aGlzLmhvdmVyZWROb2RlKSkgdGhpcy5ob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5ob3ZlcmVkRWRnZSAmJiAhZ3JhcGguaGFzRWRnZSh0aGlzLmhvdmVyZWRFZGdlKSkgdGhpcy5ob3ZlcmVkRWRnZSA9IG51bGw7XG5cbiAgICAgIC8vIFVuYmluZGluZyBoYW5kbGVycyBvbiB0aGUgY3VycmVudCBncmFwaFxuICAgICAgdGhpcy51bmJpbmRHcmFwaEhhbmRsZXJzKCk7XG4gICAgICBpZiAodGhpcy5jaGVja0VkZ2VzRXZlbnRzRnJhbWUgIT09IG51bGwpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5jaGVja0VkZ2VzRXZlbnRzRnJhbWUpO1xuICAgICAgICB0aGlzLmNoZWNrRWRnZXNFdmVudHNGcmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEluc3RhbGxpbmcgbmV3IGdyYXBoXG4gICAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG5cbiAgICAgIC8vIEJpbmRpbmcgbmV3IGhhbmRsZXJzXG4gICAgICB0aGlzLmJpbmRHcmFwaEhhbmRsZXJzKCk7XG5cbiAgICAgIC8vIFJlLXJlbmRlcmluZyBub3cgdG8gYXZvaWQgZGlzY3JlcGFuY2llcyBmcm9tIG5vdyB0byBuZXh0IGZyYW1lXG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBtb3VzZSBjYXB0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNb3VzZUNhcHRvcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRNb3VzZUNhcHRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb3VzZUNhcHRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vdXNlQ2FwdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIHRvdWNoIGNhcHRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1RvdWNoQ2FwdG9yfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRvdWNoQ2FwdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvdWNoQ2FwdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG91Y2hDYXB0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgY3VycmVudCByZW5kZXJlcidzIGRpbWVuc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldERpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGltZW5zaW9ucygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGN1cnJlbnQgZ3JhcGgncyBkaW1lbnNpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RGltZW5zaW9uc31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRHcmFwaERpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R3JhcGhEaW1lbnNpb25zKCkge1xuICAgICAgdmFyIGV4dGVudCA9IHRoaXMuY3VzdG9tQkJveCB8fCB0aGlzLm5vZGVFeHRlbnQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogZXh0ZW50LnhbMV0gLSBleHRlbnQueFswXSB8fCAxLFxuICAgICAgICBoZWlnaHQ6IGV4dGVudC55WzFdIC0gZXh0ZW50LnlbMF0gfHwgMVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYWxsIHRoZSBzaWdtYSBub2RlIGF0dHJpYnV0ZXMuXG4gICAgICogSXQncyB1c2VmdWwgZm9yIGV4YW1wbGUgdG8gZ2V0IHRoZSBwb3NpdGlvbiBvZiBhIG5vZGVcbiAgICAgKiBhbmQgdG8gZ2V0IHZhbHVlcyB0aGF0IGFyZSBzZXQgYnkgdGhlIG5vZGVSZWR1Y2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgICAqIEByZXR1cm4ge05vZGVEaXNwbGF5RGF0YSB8IHVuZGVmaW5lZH0gQSBjb3B5IG9mIHRoZSBkZXNpcmVkIG5vZGUncyBhdHRyaWJ1dGUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVEaXNwbGF5RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlRGlzcGxheURhdGEoa2V5KSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZURhdGFDYWNoZVtrZXldO1xuICAgICAgcmV0dXJuIG5vZGUgPyBPYmplY3QuYXNzaWduKHt9LCBub2RlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYWxsIHRoZSBzaWdtYSBlZGdlIGF0dHJpYnV0ZXMuXG4gICAgICogSXQncyB1c2VmdWwgZm9yIGV4YW1wbGUgdG8gZ2V0IHZhbHVlcyB0aGF0IGFyZSBzZXQgYnkgdGhlIGVkZ2VSZWR1Y2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgZWRnZSdzIGtleS5cbiAgICAgKiBAcmV0dXJuIHtFZGdlRGlzcGxheURhdGEgfCB1bmRlZmluZWR9IEEgY29weSBvZiB0aGUgZGVzaXJlZCBlZGdlJ3MgYXR0cmlidXRlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZGdlRGlzcGxheURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZURpc3BsYXlEYXRhKGtleSkge1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVba2V5XTtcbiAgICAgIHJldHVybiBlZGdlID8gT2JqZWN0LmFzc2lnbih7fSwgZWRnZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IGRpc3BsYXllZCBub2RlIGxhYmVscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NldDxzdHJpbmc+fSBBIHNldCBvZiBub2RlIGtleXMgd2hvc2UgbGFiZWwgaXMgZGlzcGxheWVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVEaXNwbGF5ZWRMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZURpc3BsYXllZExhYmVscygpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IGRpc3BsYXllZCBlZGdlIGxhYmVscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NldDxzdHJpbmc+fSBBIHNldCBvZiBlZGdlIGtleXMgd2hvc2UgbGFiZWwgaXMgZGlzcGxheWVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEVkZ2VEaXNwbGF5ZWRMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZURpc3BsYXllZExhYmVscygpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuZGlzcGxheWVkRWRnZUxhYmVscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyBhIGNvcHkgb2YgdGhlIHNldHRpbmdzIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTZXR0aW5nc30gQSBjb3B5IG9mIHRoZSBzZXR0aW5ncyBjb2xsZWN0aW9uLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNldHRpbmdzKCkge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnNldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHZhbHVlIGZvciBhIGdpdmVuIHNldHRpbmcga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgc2V0dGluZyBrZXkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm4ge2FueX0gVGhlIHZhbHVlIGF0dGFjaGVkIHRvIHRoaXMgc2V0dGluZyBrZXkgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNldHRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2V0dGluZyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gc2V0dGluZyBrZXkuIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2NoZWR1bGVcbiAgICAgKiBhIG5ldyByZW5kZXIgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IC0gVGhlIHNldHRpbmcga2V5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0gIHthbnl9ICAgIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZXR0aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNldHRpbmcoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9sZFZhbHVlcyA9IF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnNldHRpbmdzKTtcbiAgICAgIHRoaXMuc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuICAgICAgdmFsaWRhdGVTZXR0aW5ncyh0aGlzLnNldHRpbmdzKTtcbiAgICAgIHRoaXMuaGFuZGxlU2V0dGluZ3NVcGRhdGUob2xkVmFsdWVzKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXBkYXRpbmcgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gc2V0dGluZyBrZXkgdXNpbmcgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2NoZWR1bGUgYSBuZXcgcmVuZGVyIG5leHQgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAga2V5ICAgICAtIFRoZSBzZXR0aW5nIGtleSB0byBzZXQuXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IHVwZGF0ZXIgLSBUaGUgdXBkYXRlIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNldHRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2V0dGluZyhrZXksIHVwZGF0ZXIpIHtcbiAgICAgIHRoaXMuc2V0U2V0dGluZyhrZXksIHVwZGF0ZXIodGhpcy5zZXR0aW5nc1trZXldKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Qgc2V0dGluZyBtdWx0aXBsZSBzZXR0aW5ncyBhdCBvbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7UGFydGlhbDxTZXR0aW5ncz59IHNldHRpbmdzIC0gVGhlIHNldHRpbmdzIHRvIHNldC5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgdmFyIG9sZFZhbHVlcyA9IF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnNldHRpbmdzKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5zZXR0aW5ncyksIHNldHRpbmdzKTtcbiAgICAgIHZhbGlkYXRlU2V0dGluZ3ModGhpcy5zZXR0aW5ncyk7XG4gICAgICB0aGlzLmhhbmRsZVNldHRpbmdzVXBkYXRlKG9sZFZhbHVlcyk7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVzaXplIHRoZSByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGZvcmNlIC0gSWYgdHJ1ZSwgdGhlbiByZXNpemUgaXMgcHJvY2Vzc2VkIGV2ZW4gaWYgc2l6ZSBpcyB1bmNoYW5nZWQgKG9wdGlvbmFsKS5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGZvcmNlKSB7XG4gICAgICB2YXIgcHJldmlvdXNXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIHByZXZpb3VzSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IGdldFBpeGVsUmF0aW8oKTtcbiAgICAgIGlmICh0aGlzLndpZHRoID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmFsbG93SW52YWxpZENvbnRhaW5lcikgdGhpcy53aWR0aCA9IDE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogQ29udGFpbmVyIGhhcyBubyB3aWR0aC4gWW91IGNhbiBzZXQgdGhlIGFsbG93SW52YWxpZENvbnRhaW5lciBzZXR0aW5nIHRvIHRydWUgdG8gc3RvcCBzZWVpbmcgdGhpcyBlcnJvci5cIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYWxsb3dJbnZhbGlkQ29udGFpbmVyKSB0aGlzLmhlaWdodCA9IDE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogQ29udGFpbmVyIGhhcyBubyBoZWlnaHQuIFlvdSBjYW4gc2V0IHRoZSBhbGxvd0ludmFsaWRDb250YWluZXIgc2V0dGluZyB0byB0cnVlIHRvIHN0b3Agc2VlaW5nIHRoaXMgZXJyb3IuXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCB3ZSBjYW4gc3RvcCByaWdodCBoZXJlXG4gICAgICBpZiAoIWZvcmNlICYmIHByZXZpb3VzV2lkdGggPT09IHRoaXMud2lkdGggJiYgcHJldmlvdXNIZWlnaHQgPT09IHRoaXMuaGVpZ2h0KSByZXR1cm4gdGhpcztcblxuICAgICAgLy8gU2l6aW5nIGRvbSBlbGVtZW50c1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5lbGVtZW50cykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbaWRdO1xuICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgIH1cblxuICAgICAgLy8gU2l6aW5nIGNhbnZhcyBjb250ZXh0c1xuICAgICAgZm9yICh2YXIgX2lkIGluIHRoaXMuY2FudmFzQ29udGV4dHMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tfaWRdLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8gKyBcInB4XCIpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzW19pZF0uc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHRoaXMuaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvICsgXCJweFwiKTtcbiAgICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpbyAhPT0gMSkgdGhpcy5jYW52YXNDb250ZXh0c1tfaWRdLnNjYWxlKHRoaXMucGl4ZWxSYXRpbywgdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2l6aW5nIFdlYkdMIGNvbnRleHRzXG4gICAgICBmb3IgKHZhciBfaWQyIGluIHRoaXMud2ViR0xDb250ZXh0cykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW19pZDJdLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8gKyBcInB4XCIpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzW19pZDJdLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyArIFwicHhcIik7XG4gICAgICAgIHZhciBnbCA9IHRoaXMud2ViR0xDb250ZXh0c1tfaWQyXTtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbywgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuXG4gICAgICAgIC8vIENsZWFyIHBpY2tpbmcgdGV4dHVyZSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHRoaXMucGlja2luZ0xheWVycy5oYXMoX2lkMikpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFRleHR1cmUgPSB0aGlzLnRleHR1cmVzW19pZDJdO1xuICAgICAgICAgIGlmIChjdXJyZW50VGV4dHVyZSkgZ2wuZGVsZXRlVGV4dHVyZShjdXJyZW50VGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcInJlc2l6ZVwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGNsZWFyIGFsbCB0aGUgY2FudmFzZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuZW1pdChcImJlZm9yZUNsZWFyXCIpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzLm5vZGVzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTFJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzLm5vZGVzLmNsZWFyKFdlYkdMUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cy5lZGdlcy5iaW5kRnJhbWVidWZmZXIoV2ViR0xSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cy5lZGdlcy5jbGVhcihXZWJHTFJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHMuaG92ZXJOb2Rlcy5jbGVhcihXZWJHTFJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHRzLmxhYmVscy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0cy5ob3ZlcnMuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dHMuZWRnZUxhYmVscy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5lbWl0KFwiYWZ0ZXJDbGVhclwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlZnJlc2gsIGkuZS4gZm9yY2UgdGhlIHJlbmRlcmVyIHRvIHJlcHJvY2VzcyBncmFwaFxuICAgICAqIGRhdGEgYW5kIHJlbmRlciwgYnV0IGtlZXAgdGhlIHN0YXRlLlxuICAgICAqIC0gaWYgYSBwYXJ0aWFsR3JhcGggaXMgcHJvdmlkZWQsIHdlIG9ubHkgcmVwcm9jZXNzIHRob3NlIG5vZGVzICYgZWRnZXMuXG4gICAgICogLSBpZiBzY2hlZHVsZSBpcyBUUlVFLCB3ZSBzY2hlZHVsZSBhIHJlbmRlciBpbnN0ZWFkIG9mIHN5bmMgcmVuZGVyXG4gICAgICogLSBpZiBza2lwSW5kZXhhdGlvbiBpcyBUUlVFLCB0aGVuIGxhYmVsR3JpZCAmIHByb2dyYW0gaW5kZXhhdGlvbiBhcmUgc2tpcHBlZCAoY2FuIGJlIHVzZWQgaWYgeW91IGhhdmVuJ3QgbW9kaWZ5IHgsIHksIHpJbmRleCAmIHNpemUpXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2gob3B0cykge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuICAgICAgdmFyIHNraXBJbmRleGF0aW9uID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5za2lwSW5kZXhhdGlvbikgIT09IHVuZGVmaW5lZCA/IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5za2lwSW5kZXhhdGlvbiA6IGZhbHNlO1xuICAgICAgdmFyIHNjaGVkdWxlID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zY2hlZHVsZSkgIT09IHVuZGVmaW5lZCA/IG9wdHMuc2NoZWR1bGUgOiBmYWxzZTtcbiAgICAgIHZhciBmdWxsUmVmcmVzaCA9ICFvcHRzIHx8ICFvcHRzLnBhcnRpYWxHcmFwaDtcbiAgICAgIGlmIChmdWxsUmVmcmVzaCkge1xuICAgICAgICAvLyBSZS1pbmRleCBncmFwaCBkYXRhXG4gICAgICAgIHRoaXMuY2xlYXJFZGdlSW5kaWNlcygpO1xuICAgICAgICB0aGlzLmNsZWFyTm9kZUluZGljZXMoKTtcbiAgICAgICAgdGhpcy5ncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczEwLmFkZE5vZGUobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyYXBoLmZvckVhY2hFZGdlKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMTAuYWRkRWRnZShlZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX29wdHMkcGFydGlhbEdyYXBoLCBfb3B0cyRwYXJ0aWFsR3JhcGgyO1xuICAgICAgICB2YXIgbm9kZXMgPSAoKF9vcHRzJHBhcnRpYWxHcmFwaCA9IG9wdHMucGFydGlhbEdyYXBoKSA9PT0gbnVsbCB8fCBfb3B0cyRwYXJ0aWFsR3JhcGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzJHBhcnRpYWxHcmFwaC5ub2RlcykgfHwgW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gKG5vZGVzID09PSBudWxsIHx8IG5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2Rlcy5sZW5ndGgpIHx8IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIC8vIFJlY29tcHV0ZSBub2RlJ3MgZGF0YSAoaWUuIGFwcGx5IHJlZHVjZXIpXG4gICAgICAgICAgdGhpcy51cGRhdGVOb2RlKG5vZGUpO1xuICAgICAgICAgIC8vIEFkZCBub2RlIHRvIHRoZSBwcm9ncmFtIGlmIGxheW91dCBpcyB1bmNoYW5nZWQuXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZG9uZSBpbiB0aGUgcHJvY2VzcyBmdW5jdGlvblxuICAgICAgICAgIGlmIChza2lwSW5kZXhhdGlvbikge1xuICAgICAgICAgICAgdmFyIHByb2dyYW1JbmRleCA9IHRoaXMubm9kZVByb2dyYW1JbmRleFtub2RlXTtcbiAgICAgICAgICAgIGlmIChwcm9ncmFtSW5kZXggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IG5vZGUgXFxcIlwiLmNvbmNhdChub2RlLCBcIlxcXCIgY2FuJ3QgYmUgcmVwYWludFwiKSk7XG4gICAgICAgICAgICB0aGlzLmFkZE5vZGVUb1Byb2dyYW0obm9kZSwgdGhpcy5ub2RlSW5kaWNlc1tub2RlXSwgcHJvZ3JhbUluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVkZ2VzID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwIHx8IChfb3B0cyRwYXJ0aWFsR3JhcGgyID0gb3B0cy5wYXJ0aWFsR3JhcGgpID09PSBudWxsIHx8IF9vcHRzJHBhcnRpYWxHcmFwaDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzJHBhcnRpYWxHcmFwaDIuZWRnZXMpIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfbDQgPSBlZGdlcy5sZW5ndGg7IF9pNCA8IF9sNDsgX2k0KyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW19pNF07XG4gICAgICAgICAgLy8gUmVjb21wdXRlIGVkZ2UncyBkYXRhIChpZS4gYXBwbHkgcmVkdWNlcilcbiAgICAgICAgICB0aGlzLnVwZGF0ZUVkZ2UoZWRnZSk7XG4gICAgICAgICAgLy8gQWRkIGVkZ2UgdG8gdGhlIHByb2dyYW1cbiAgICAgICAgICAvLyBvdGhlcndpc2UgaXQgd2lsbCBiZSBkb25lIGluIHRoZSBwcm9jZXNzIGZ1bmN0aW9uXG4gICAgICAgICAgaWYgKHNraXBJbmRleGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX3Byb2dyYW1JbmRleCA9IHRoaXMuZWRnZVByb2dyYW1JbmRleFtlZGdlXTtcbiAgICAgICAgICAgIGlmIChfcHJvZ3JhbUluZGV4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBlZGdlIFxcXCJcIi5jb25jYXQoZWRnZSwgXCJcXFwiIGNhbid0IGJlIHJlcGFpbnRcIikpO1xuICAgICAgICAgICAgdGhpcy5hZGRFZGdlVG9Qcm9ncmFtKGVkZ2UsIHRoaXMuZWRnZUluZGljZXNbZWRnZV0sIF9wcm9ncmFtSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEbyB3ZSBuZWVkIHRvIGNhbGwgdGhlIHByb2Nlc3MgZnVuY3Rpb24gP1xuICAgICAgaWYgKGZ1bGxSZWZyZXNoIHx8ICFza2lwSW5kZXhhdGlvbikgdGhpcy5uZWVkVG9Qcm9jZXNzID0gdHJ1ZTtcbiAgICAgIGlmIChzY2hlZHVsZSkgdGhpcy5zY2hlZHVsZVJlbmRlcigpO2Vsc2UgdGhpcy5yZW5kZXIoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNjaGVkdWxlIGEgcmVuZGVyIGF0IHRoZSBuZXh0IGF2YWlsYWJsZSBmcmFtZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgc2FmZWx5IGNhbGxlZCBvbiBhIHNhbWUgZnJhbWUgYmVjYXVzZSBpdCBiYXNpY2FsbHlcbiAgICAgKiBkZWJvdW5jZXMgcmVmcmVzaCB0byB0aGUgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNjaGVkdWxlUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlUmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLnJlbmRlckZyYW1lKSB7XG4gICAgICAgIHRoaXMucmVuZGVyRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMTEucmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gc2NoZWR1bGUgYSByZWZyZXNoIChpLmUuIGZ1bGx5IHJlcHJvY2VzcyBncmFwaCBkYXRhIGFuZCByZW5kZXIpXG4gICAgICogYXQgdGhlIG5leHQgYXZhaWxhYmxlIGZyYW1lLlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBzYWZlbHkgY2FsbGVkIG9uIGEgc2FtZSBmcmFtZSBiZWNhdXNlIGl0IGJhc2ljYWxseVxuICAgICAqIGRlYm91bmNlcyByZWZyZXNoIHRvIHRoZSBuZXh0IGZyYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2NoZWR1bGVSZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlUmVmcmVzaChvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWZyZXNoKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRzKSwge30sIHtcbiAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byAodW4pem9vbSwgd2hpbGUgcHJlc2VydmluZyB0aGUgcG9zaXRpb24gb2YgYSB2aWV3cG9ydCBwb2ludC5cbiAgICAgKiBVc2VkIGZvciBpbnN0YW5jZSB0byB6b29tIFwib24gdGhlIG1vdXNlIGN1cnNvclwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpZXdwb3J0VGFyZ2V0XG4gICAgICogQHBhcmFtIG5ld1JhdGlvXG4gICAgICogQHJldHVybiB7Q2FtZXJhU3RhdGV9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Vmlld3BvcnRab29tZWRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3cG9ydFpvb21lZFN0YXRlKHZpZXdwb3J0VGFyZ2V0LCBuZXdSYXRpbykge1xuICAgICAgdmFyIF90aGlzJGNhbWVyYSRnZXRTdGF0ZSA9IHRoaXMuY2FtZXJhLmdldFN0YXRlKCksXG4gICAgICAgIHJhdGlvID0gX3RoaXMkY2FtZXJhJGdldFN0YXRlLnJhdGlvLFxuICAgICAgICBhbmdsZSA9IF90aGlzJGNhbWVyYSRnZXRTdGF0ZS5hbmdsZSxcbiAgICAgICAgeCA9IF90aGlzJGNhbWVyYSRnZXRTdGF0ZS54LFxuICAgICAgICB5ID0gX3RoaXMkY2FtZXJhJGdldFN0YXRlLnk7XG4gICAgICB2YXIgX3RoaXMkc2V0dGluZ3MyID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgbWluQ2FtZXJhUmF0aW8gPSBfdGhpcyRzZXR0aW5nczIubWluQ2FtZXJhUmF0aW8sXG4gICAgICAgIG1heENhbWVyYVJhdGlvID0gX3RoaXMkc2V0dGluZ3MyLm1heENhbWVyYVJhdGlvO1xuICAgICAgaWYgKHR5cGVvZiBtYXhDYW1lcmFSYXRpbyA9PT0gXCJudW1iZXJcIikgbmV3UmF0aW8gPSBNYXRoLm1pbihuZXdSYXRpbywgbWF4Q2FtZXJhUmF0aW8pO1xuICAgICAgaWYgKHR5cGVvZiBtaW5DYW1lcmFSYXRpbyA9PT0gXCJudW1iZXJcIikgbmV3UmF0aW8gPSBNYXRoLm1heChuZXdSYXRpbywgbWluQ2FtZXJhUmF0aW8pO1xuICAgICAgdmFyIHJhdGlvRGlmZiA9IG5ld1JhdGlvIC8gcmF0aW87XG4gICAgICB2YXIgY2VudGVyID0ge1xuICAgICAgICB4OiB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgeTogdGhpcy5oZWlnaHQgLyAyXG4gICAgICB9O1xuICAgICAgdmFyIGdyYXBoTW91c2VQb3NpdGlvbiA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHZpZXdwb3J0VGFyZ2V0KTtcbiAgICAgIHZhciBncmFwaENlbnRlclBvc2l0aW9uID0gdGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgoY2VudGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgeDogKGdyYXBoTW91c2VQb3NpdGlvbi54IC0gZ3JhcGhDZW50ZXJQb3NpdGlvbi54KSAqICgxIC0gcmF0aW9EaWZmKSArIHgsXG4gICAgICAgIHk6IChncmFwaE1vdXNlUG9zaXRpb24ueSAtIGdyYXBoQ2VudGVyUG9zaXRpb24ueSkgKiAoMSAtIHJhdGlvRGlmZikgKyB5LFxuICAgICAgICByYXRpbzogbmV3UmF0aW9cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgYWJzdHJhY3QgcmVjdGFuZ2xlIGNvbnRhaW5pbmcgdGhlIGdyYXBoIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBjYW1lcmEncyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgdmlldydzIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ2aWV3UmVjdGFuZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZXdSZWN0YW5nbGUoKSB7XG4gICAgICB2YXIgcDEgPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0pLFxuICAgICAgICBwMiA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICB4OiB0aGlzLndpZHRoLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSksXG4gICAgICAgIGggPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiB0aGlzLmhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBwMS54LFxuICAgICAgICB5MTogcDEueSxcbiAgICAgICAgeDI6IHAyLngsXG4gICAgICAgIHkyOiBwMi55LFxuICAgICAgICBoZWlnaHQ6IHAyLnkgLSBoLnlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBmcm9tIHRoZSBmcmFtZWQgZ3JhcGggc3lzdGVtIHRvIHRoZSB2aWV3cG9ydCBzeXN0ZW0uIEl0IGFsbG93c1xuICAgICAqIG92ZXJyaWRpbmcgYW55dGhpbmcgdGhhdCBpcyB1c2VkIHRvIGdldCB0aGUgdHJhbnNsYXRpb24gbWF0cml4LCBvciBldmVuIHRoZSBtYXRyaXggaXRzZWxmLlxuICAgICAqXG4gICAgICogQmUgY2FyZWZ1bCBpZiBvdmVycmlkaW5nIGRpbWVuc2lvbnMsIHBhZGRpbmcgb3IgY2FtZXJhU3RhdGUsIGFzIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgbWF0cml4IGlzIG5vdCB0aGUgbGlnaHRlc3RcbiAgICAgKiBvZiBjb21wdXRhdGlvbnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJhbWVkR3JhcGhUb1ZpZXdwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyYW1lZEdyYXBoVG9WaWV3cG9ydChjb29yZGluYXRlcykge1xuICAgICAgdmFyIG92ZXJyaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciByZWNvbXB1dGVNYXRyaXggPSAhIW92ZXJyaWRlLmNhbWVyYVN0YXRlIHx8ICEhb3ZlcnJpZGUudmlld3BvcnREaW1lbnNpb25zIHx8ICEhb3ZlcnJpZGUuZ3JhcGhEaW1lbnNpb25zO1xuICAgICAgdmFyIG1hdHJpeCA9IG92ZXJyaWRlLm1hdHJpeCA/IG92ZXJyaWRlLm1hdHJpeCA6IHJlY29tcHV0ZU1hdHJpeCA/IG1hdHJpeEZyb21DYW1lcmEob3ZlcnJpZGUuY2FtZXJhU3RhdGUgfHwgdGhpcy5jYW1lcmEuZ2V0U3RhdGUoKSwgb3ZlcnJpZGUudmlld3BvcnREaW1lbnNpb25zIHx8IHRoaXMuZ2V0RGltZW5zaW9ucygpLCBvdmVycmlkZS5ncmFwaERpbWVuc2lvbnMgfHwgdGhpcy5nZXRHcmFwaERpbWVuc2lvbnMoKSwgb3ZlcnJpZGUucGFkZGluZyB8fCB0aGlzLmdldFN0YWdlUGFkZGluZygpKSA6IHRoaXMubWF0cml4O1xuICAgICAgdmFyIHZpZXdwb3J0UG9zID0gbXVsdGlwbHlWZWMyKG1hdHJpeCwgY29vcmRpbmF0ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKDEgKyB2aWV3cG9ydFBvcy54KSAqIHRoaXMud2lkdGggLyAyLFxuICAgICAgICB5OiAoMSAtIHZpZXdwb3J0UG9zLnkpICogdGhpcy5oZWlnaHQgLyAyXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgZnJvbSB0aGUgdmlld3BvcnQgc3lzdGVtIHRvIHRoZSBmcmFtZWQgZ3JhcGggc3lzdGVtLiBJdCBhbGxvd3NcbiAgICAgKiBvdmVycmlkaW5nIGFueXRoaW5nIHRoYXQgaXMgdXNlZCB0byBnZXQgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCwgb3IgZXZlbiB0aGUgbWF0cml4IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEJlIGNhcmVmdWwgaWYgb3ZlcnJpZGluZyBkaW1lbnNpb25zLCBwYWRkaW5nIG9yIGNhbWVyYVN0YXRlLCBhcyB0aGUgY29tcHV0YXRpb24gb2YgdGhlIG1hdHJpeCBpcyBub3QgdGhlIGxpZ2h0ZXN0XG4gICAgICogb2YgY29tcHV0YXRpb25zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZpZXdwb3J0VG9GcmFtZWRHcmFwaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWV3cG9ydFRvRnJhbWVkR3JhcGgoY29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBvdmVycmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgcmVjb21wdXRlTWF0cml4ID0gISFvdmVycmlkZS5jYW1lcmFTdGF0ZSB8fCAhIW92ZXJyaWRlLnZpZXdwb3J0RGltZW5zaW9ucyB8fCAhb3ZlcnJpZGUuZ3JhcGhEaW1lbnNpb25zO1xuICAgICAgdmFyIGludk1hdHJpeCA9IG92ZXJyaWRlLm1hdHJpeCA/IG92ZXJyaWRlLm1hdHJpeCA6IHJlY29tcHV0ZU1hdHJpeCA/IG1hdHJpeEZyb21DYW1lcmEob3ZlcnJpZGUuY2FtZXJhU3RhdGUgfHwgdGhpcy5jYW1lcmEuZ2V0U3RhdGUoKSwgb3ZlcnJpZGUudmlld3BvcnREaW1lbnNpb25zIHx8IHRoaXMuZ2V0RGltZW5zaW9ucygpLCBvdmVycmlkZS5ncmFwaERpbWVuc2lvbnMgfHwgdGhpcy5nZXRHcmFwaERpbWVuc2lvbnMoKSwgb3ZlcnJpZGUucGFkZGluZyB8fCB0aGlzLmdldFN0YWdlUGFkZGluZygpLCB0cnVlKSA6IHRoaXMuaW52TWF0cml4O1xuICAgICAgdmFyIHJlcyA9IG11bHRpcGx5VmVjMihpbnZNYXRyaXgsIHtcbiAgICAgICAgeDogY29vcmRpbmF0ZXMueCAvIHRoaXMud2lkdGggKiAyIC0gMSxcbiAgICAgICAgeTogMSAtIGNvb3JkaW5hdGVzLnkgLyB0aGlzLmhlaWdodCAqIDJcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTmFOKHJlcy54KSkgcmVzLnggPSAwO1xuICAgICAgaWYgKGlzTmFOKHJlcy55KSkgcmVzLnkgPSAwO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB0cmFuc2xhdGUgYSBwb2ludCdzIGNvb3JkaW5hdGVzIGZyb20gdGhlIHZpZXdwb3J0IHN5c3RlbSAocGl4ZWwgZGlzdGFuY2UgZnJvbSB0aGUgdG9wLWxlZnQgb2YgdGhlXG4gICAgICogc3RhZ2UpIHRvIHRoZSBncmFwaCBzeXN0ZW0gKHRoZSByZWZlcmVuY2Ugc3lzdGVtIG9mIGRhdGEgYXMgdGhleSBhcmUgaW4gdGhlIGdpdmVuIGdyYXBoIGluc3RhbmNlKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgY2FtZXJhIHdoaWNoIGNhbiBiZSB1c2VmdWwgaWYgeW91IG5lZWQgdG8gdHJhbnNsYXRlIGNvb3JkaW5hdGVzXG4gICAgICogYmFzZWQgb24gYSBkaWZmZXJlbnQgdmlldyB0aGFuIHRoZSBvbmUgYmVpbmcgY3VycmVudGx5IGJlaW5nIGRpc3BsYXllZCBvbiBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVzfSAgICAgICAgICAgICAgICAgIHZpZXdwb3J0UG9pbnRcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVDb252ZXJzaW9uT3ZlcnJpZGV9IG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlld3BvcnRUb0dyYXBoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZXdwb3J0VG9HcmFwaCh2aWV3cG9ydFBvaW50KSB7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uLmludmVyc2UodGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgodmlld3BvcnRQb2ludCwgb3ZlcnJpZGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB0cmFuc2xhdGUgYSBwb2ludCdzIGNvb3JkaW5hdGVzIGZyb20gdGhlIGdyYXBoIHN5c3RlbSAodGhlIHJlZmVyZW5jZSBzeXN0ZW0gb2YgZGF0YSBhcyB0aGV5IGFyZSBpblxuICAgICAqIHRoZSBnaXZlbiBncmFwaCBpbnN0YW5jZSkgdG8gdGhlIHZpZXdwb3J0IHN5c3RlbSAocGl4ZWwgZGlzdGFuY2UgZnJvbSB0aGUgdG9wLWxlZnQgb2YgdGhlIHN0YWdlKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgY2FtZXJhIHdoaWNoIGNhbiBiZSB1c2VmdWwgaWYgeW91IG5lZWQgdG8gdHJhbnNsYXRlIGNvb3JkaW5hdGVzXG4gICAgICogYmFzZWQgb24gYSBkaWZmZXJlbnQgdmlldyB0aGFuIHRoZSBvbmUgYmVpbmcgY3VycmVudGx5IGJlaW5nIGRpc3BsYXllZCBvbiBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVzfSAgICAgICAgICAgICAgICAgIGdyYXBoUG9pbnRcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVDb252ZXJzaW9uT3ZlcnJpZGV9IG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JhcGhUb1ZpZXdwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyYXBoVG9WaWV3cG9ydChncmFwaFBvaW50KSB7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uKGdyYXBoUG9pbnQpLCBvdmVycmlkZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZGlzdGFuY2UgbXVsdGlwbGllciBiZXR3ZWVuIHRoZSBncmFwaCBzeXN0ZW0gYW5kIHRoZVxuICAgICAqIHZpZXdwb3J0IHN5c3RlbS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRHcmFwaFRvVmlld3BvcnRSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmFwaFRvVmlld3BvcnRSYXRpbygpIHtcbiAgICAgIHZhciBncmFwaFAxID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgdmFyIGdyYXBoUDIgPSB7XG4gICAgICAgIHg6IDEsXG4gICAgICAgIHk6IDFcbiAgICAgIH07XG4gICAgICB2YXIgZ3JhcGhEID0gTWF0aC5zcXJ0KE1hdGgucG93KGdyYXBoUDEueCAtIGdyYXBoUDIueCwgMikgKyBNYXRoLnBvdyhncmFwaFAxLnkgLSBncmFwaFAyLnksIDIpKTtcbiAgICAgIHZhciB2aWV3cG9ydFAxID0gdGhpcy5ncmFwaFRvVmlld3BvcnQoZ3JhcGhQMSk7XG4gICAgICB2YXIgdmlld3BvcnRQMiA9IHRoaXMuZ3JhcGhUb1ZpZXdwb3J0KGdyYXBoUDIpO1xuICAgICAgdmFyIHZpZXdwb3J0RCA9IE1hdGguc3FydChNYXRoLnBvdyh2aWV3cG9ydFAxLnggLSB2aWV3cG9ydFAyLngsIDIpICsgTWF0aC5wb3codmlld3BvcnRQMS55IC0gdmlld3BvcnRQMi55LCAyKSk7XG4gICAgICByZXR1cm4gdmlld3BvcnREIC8gZ3JhcGhEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdyYXBoJ3MgYm91bmRpbmcgYm94LlxuICAgICAqXG4gICAgICogQHJldHVybiB7eyB4OiBFeHRlbnQsIHk6IEV4dGVudCB9fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEJCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QkJveCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVFeHRlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ3JhcGgncyBjdXN0b20gYm91bmRpbmcgYm94LCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt7IHg6IEV4dGVudCwgeTogRXh0ZW50IH0gfCBudWxsfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEN1c3RvbUJCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VzdG9tQkJveCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1c3RvbUJCb3g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGdyYXBoJ3MgYm91bmRpbmcgYm94IHdpdGggYSBjdXN0b20gb25lLiBHaXZlIGBudWxsYCBhcyB0aGUgYXJndW1lbnQgdG8gc3RvcCBvdmVycmlkaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q3VzdG9tQkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXN0b21CQm94KGN1c3RvbUJCb3gpIHtcbiAgICAgIHRoaXMuY3VzdG9tQkJveCA9IGN1c3RvbUJCb3g7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzaHV0IHRoZSBjb250YWluZXIgJiByZWxlYXNlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAvLyBFbWl0dGluZyBcImtpbGxcIiBldmVudHMgc28gdGhhdCBwbHVnaW5zIGFuZCBzdWNoIGNhbiBjbGVhbnVwXG4gICAgICB0aGlzLmVtaXQoXCJraWxsXCIpO1xuXG4gICAgICAvLyBSZWxlYXNpbmcgZXZlbnRzXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgICAvLyBSZWxlYXNpbmcgY2FtZXJhIGhhbmRsZXJzXG4gICAgICB0aGlzLnVuYmluZENhbWVyYUhhbmRsZXJzKCk7XG5cbiAgICAgIC8vIFJlbGVhc2luZyBET00gZXZlbnRzICYgY2FwdG9yc1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlUmVzaXplKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iua2lsbCgpO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5raWxsKCk7XG5cbiAgICAgIC8vIFJlbGVhc2luZyBncmFwaCBoYW5kbGVyc1xuICAgICAgdGhpcy51bmJpbmRHcmFwaEhhbmRsZXJzKCk7XG5cbiAgICAgIC8vIFJlbGVhc2luZyBjYWNoZSAmIHN0YXRlXG4gICAgICB0aGlzLmNsZWFySW5kaWNlcygpO1xuICAgICAgdGhpcy5jbGVhclN0YXRlKCk7XG4gICAgICB0aGlzLm5vZGVEYXRhQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMuZWRnZURhdGFDYWNoZSA9IHt9O1xuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzLmNsZWFyKCk7XG5cbiAgICAgIC8vIENsZWFyaW5nIGZyYW1lc1xuICAgICAgaWYgKHRoaXMucmVuZGVyRnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXJGcmFtZSk7XG4gICAgICAgIHRoaXMucmVuZGVyRnJhbWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lKTtcbiAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHRlZE5vZGVzRnJhbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXN0cm95aW5nIGNhbnZhc2VzXG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuZmlyc3RDaGlsZCk7XG5cbiAgICAgIC8vIEtpbGwgcHJvZ3JhbXM6XG4gICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMubm9kZVByb2dyYW1zKSB7XG4gICAgICAgIHRoaXMubm9kZVByb2dyYW1zW3R5cGVdLmtpbGwoKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF90eXBlOCBpbiB0aGlzLm5vZGVIb3ZlclByb2dyYW1zKSB7XG4gICAgICAgIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNbX3R5cGU4XS5raWxsKCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfdHlwZTkgaW4gdGhpcy5lZGdlUHJvZ3JhbXMpIHtcbiAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNbX3R5cGU5XS5raWxsKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm5vZGVQcm9ncmFtcyA9IHt9O1xuICAgICAgdGhpcy5ub2RlSG92ZXJQcm9ncmFtcyA9IHt9O1xuICAgICAgdGhpcy5lZGdlUHJvZ3JhbXMgPSB7fTtcblxuICAgICAgLy8gS2lsbCBhbGwgY2FudmFzL1dlYkdMIGNvbnRleHRzXG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMua2lsbExheWVyKGlkKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVzdHJveWluZyByZW1haW5pbmcgY29sbGVjdGlvbnNcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dHMgPSB7fTtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cyA9IHt9O1xuICAgICAgdGhpcy5lbGVtZW50cyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNjYWxlIHRoZSBnaXZlbiBzaXplIGFjY29yZGluZyB0byB0aGUgY2FtZXJhJ3MgcmF0aW8sIGkuZS5cbiAgICAgKiB6b29taW5nIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7bnVtYmVyP30gc2l6ZSAtICAgICAgICBUaGUgc2l6ZSB0byBzY2FsZSAobm9kZSBzaXplLCBlZGdlIHRoaWNrbmVzcyBldGMuKS5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXI/fSBjYW1lcmFSYXRpbyAtIEEgY2FtZXJhIHJhdGlvIChkZWZhdWx0cyB0byB0aGUgYWN0dWFsIGNhbWVyYSByYXRpbykuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgLSBUaGUgc2NhbGVkIHNpemUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2NhbGVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYWxlU2l6ZSgpIHtcbiAgICAgIHZhciBzaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgICAgdmFyIGNhbWVyYVJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmNhbWVyYS5yYXRpbztcbiAgICAgIHJldHVybiBzaXplIC8gdGhpcy5zZXR0aW5ncy56b29tVG9TaXplUmF0aW9GdW5jdGlvbihjYW1lcmFSYXRpbykgKiAodGhpcy5nZXRTZXR0aW5nKFwiaXRlbVNpemVzUmVmZXJlbmNlXCIpID09PSBcInBvc2l0aW9uc1wiID8gY2FtZXJhUmF0aW8gKiB0aGlzLmdyYXBoVG9WaWV3cG9ydFJhdGlvIDogMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgY29sbGVjdGlvbiBvZiBhbGwgdXNlZCBjYW52YXNlcy5cbiAgICAgKiBBdCB0aGUgbW9tZW50LCB0aGUgaW5zdGFudGlhdGVkIGNhbnZhc2VzIGFyZSB0aGUgZm9sbG93aW5nLCBhbmQgaW4gdGhlXG4gICAgICogZm9sbG93aW5nIG9yZGVyIGluIHRoZSBET006XG4gICAgICogLSBgZWRnZXNgXG4gICAgICogLSBgbm9kZXNgXG4gICAgICogLSBgZWRnZUxhYmVsc2BcbiAgICAgKiAtIGBsYWJlbHNgXG4gICAgICogLSBgaG92ZXJzYFxuICAgICAqIC0gYGhvdmVyTm9kZXNgXG4gICAgICogLSBgbW91c2VgXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQbGFpbk9iamVjdDxIVE1MQ2FudmFzRWxlbWVudD59IC0gVGhlIGNvbGxlY3Rpb24gb2YgY2FudmFzZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FudmFzZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FudmFzZXMoKSB7XG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICBmb3IgKHZhciBsYXllciBpbiB0aGlzLmVsZW1lbnRzKSBpZiAodGhpcy5lbGVtZW50c1tsYXllcl0gaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkgcmVzW2xheWVyXSA9IHRoaXMuZWxlbWVudHNbbGF5ZXJdO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH1dKTtcbn0oVHlwZWRFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIFNpZ21hLmpzIExpYnJhcnkgRW5kcG9pbnRcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgbGlicmFyeSBlbmRwb2ludC5cbiAqIEBtb2R1bGVcbiAqL1xudmFyIFNpZ21hID0gU2lnbWEkMTtcblxuZXhwb3J0IHsgQ2FtZXJhLCBNb3VzZUNhcHRvciwgU2lnbWEkMSBhcyBTaWdtYSwgVG91Y2hDYXB0b3IsIFNpZ21hIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/sigma/dist/sigma.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/sigma/settings/dist/sigma-settings.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/sigma/settings/dist/sigma-settings.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_EDGE_PROGRAM_CLASSES: () => (/* binding */ DEFAULT_EDGE_PROGRAM_CLASSES),\n/* harmony export */   DEFAULT_NODE_PROGRAM_CLASSES: () => (/* binding */ DEFAULT_NODE_PROGRAM_CLASSES),\n/* harmony export */   DEFAULT_SETTINGS: () => (/* binding */ DEFAULT_SETTINGS),\n/* harmony export */   resolveSettings: () => (/* binding */ resolveSettings),\n/* harmony export */   validateSettings: () => (/* binding */ validateSettings)\n/* harmony export */ });\n/* harmony import */ var _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/index-236c62ad.esm.js */ \"(app-pages-browser)/./node_modules/sigma/dist/index-236c62ad.esm.js\");\n/* harmony import */ var _dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/data-11df7124.esm.js */ \"(app-pages-browser)/./node_modules/sigma/dist/data-11df7124.esm.js\");\n\n\n\n\n\n/**\n * Sigma.js Settings\n * =================================\n *\n * The list of settings and some handy functions.\n * @module\n */\n\n/**\n * Sigma.js settings\n * =================================\n */\n\nvar DEFAULT_SETTINGS = {\n  // Performance\n  hideEdgesOnMove: false,\n  hideLabelsOnMove: false,\n  renderLabels: true,\n  renderEdgeLabels: false,\n  enableEdgeEvents: false,\n  // Component rendering\n  defaultNodeColor: \"#999\",\n  defaultNodeType: \"circle\",\n  defaultEdgeColor: \"#ccc\",\n  defaultEdgeType: \"line\",\n  labelFont: \"Arial\",\n  labelSize: 14,\n  labelWeight: \"normal\",\n  labelColor: {\n    color: \"#000\"\n  },\n  edgeLabelFont: \"Arial\",\n  edgeLabelSize: 14,\n  edgeLabelWeight: \"normal\",\n  edgeLabelColor: {\n    attribute: \"color\"\n  },\n  stagePadding: 30,\n  defaultDrawEdgeLabel: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.d,\n  defaultDrawNodeLabel: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.b,\n  defaultDrawNodeHover: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.c,\n  minEdgeThickness: 1.7,\n  antiAliasingFeather: 1,\n  // Mouse and touch settings\n  dragTimeout: 100,\n  draggedEventsTolerance: 3,\n  inertiaDuration: 200,\n  inertiaRatio: 3,\n  zoomDuration: 250,\n  zoomingRatio: 1.7,\n  doubleClickTimeout: 300,\n  doubleClickZoomingRatio: 2.2,\n  doubleClickZoomingDuration: 200,\n  tapMoveTolerance: 10,\n  // Size and scaling\n  zoomToSizeRatioFunction: Math.sqrt,\n  itemSizesReference: \"screen\",\n  autoRescale: true,\n  autoCenter: true,\n  // Labels\n  labelDensity: 1,\n  labelGridCellSize: 100,\n  labelRenderedSizeThreshold: 6,\n  // Reducers\n  nodeReducer: null,\n  edgeReducer: null,\n  // Features\n  zIndex: false,\n  minCameraRatio: null,\n  maxCameraRatio: null,\n  enableCameraZooming: true,\n  enableCameraPanning: true,\n  enableCameraRotation: true,\n  cameraPanBoundaries: null,\n  // Lifecycle\n  allowInvalidContainer: false,\n  // Program classes\n  nodeProgramClasses: {},\n  nodeHoverProgramClasses: {},\n  edgeProgramClasses: {}\n};\nvar DEFAULT_NODE_PROGRAM_CLASSES = {\n  circle: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.N\n};\nvar DEFAULT_EDGE_PROGRAM_CLASSES = {\n  arrow: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.E,\n  line: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.e\n};\nfunction validateSettings(settings) {\n  if (typeof settings.labelDensity !== \"number\" || settings.labelDensity < 0) {\n    throw new Error(\"Settings: invalid `labelDensity`. Expecting a positive number.\");\n  }\n  var minCameraRatio = settings.minCameraRatio,\n    maxCameraRatio = settings.maxCameraRatio;\n  if (typeof minCameraRatio === \"number\" && typeof maxCameraRatio === \"number\" && maxCameraRatio < minCameraRatio) {\n    throw new Error(\"Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`.\");\n  }\n}\nfunction resolveSettings(settings) {\n  var resolvedSettings = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_SETTINGS, settings);\n  resolvedSettings.nodeProgramClasses = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_NODE_PROGRAM_CLASSES, resolvedSettings.nodeProgramClasses);\n  resolvedSettings.edgeProgramClasses = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_EDGE_PROGRAM_CLASSES, resolvedSettings.edgeProgramClasses);\n  return resolvedSettings;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zaWdtYS9zZXR0aW5ncy9kaXN0L3NpZ21hLXNldHRpbmdzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdNO0FBQzFJO0FBQ2pCO0FBQ0Y7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QiwwREFBcUI7QUFDN0Msd0JBQXdCLDBEQUFpQjtBQUN6Qyx3QkFBd0IsMERBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwREFBaUI7QUFDM0I7QUFDQTtBQUNBLFNBQVMsMERBQWdCO0FBQ3pCLFFBQVEsMERBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2REFBTSxHQUFHO0FBQ2xDLHdDQUF3Qyw2REFBTSxHQUFHO0FBQ2pELHdDQUF3Qyw2REFBTSxHQUFHO0FBQ2pEO0FBQ0E7O0FBRTJIIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxlbm92b1xcRGVza3RvcFxcZnJvbnRlbmRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHNpZ21hXFxzZXR0aW5nc1xcZGlzdFxcc2lnbWEtc2V0dGluZ3MuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGQgYXMgZHJhd1N0cmFpZ2h0RWRnZUxhYmVsLCBiIGFzIGRyYXdEaXNjTm9kZUxhYmVsLCBjIGFzIGRyYXdEaXNjTm9kZUhvdmVyLCBOIGFzIE5vZGVDaXJjbGVQcm9ncmFtLCBFIGFzIEVkZ2VBcnJvd1Byb2dyYW0sIGUgYXMgRWRnZVJlY3RhbmdsZVByb2dyYW0gfSBmcm9tICcuLi8uLi9kaXN0L2luZGV4LTIzNmM2MmFkLmVzbS5qcyc7XG5pbXBvcnQgeyBhIGFzIGFzc2lnbiB9IGZyb20gJy4uLy4uL2Rpc3QvZGF0YS0xMWRmNzEyNC5lc20uanMnO1xuaW1wb3J0ICcuLi8uLi9kaXN0L2luaGVyaXRzLWQxYTFlMjliLmVzbS5qcyc7XG5pbXBvcnQgJy4uLy4uL2Rpc3QvY29sb3JzLWJlYjA2ZWIyLmVzbS5qcyc7XG5cbi8qKlxuICogU2lnbWEuanMgU2V0dGluZ3NcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIFRoZSBsaXN0IG9mIHNldHRpbmdzIGFuZCBzb21lIGhhbmR5IGZ1bmN0aW9ucy5cbiAqIEBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIFNpZ21hLmpzIHNldHRpbmdzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG52YXIgREVGQVVMVF9TRVRUSU5HUyA9IHtcbiAgLy8gUGVyZm9ybWFuY2VcbiAgaGlkZUVkZ2VzT25Nb3ZlOiBmYWxzZSxcbiAgaGlkZUxhYmVsc09uTW92ZTogZmFsc2UsXG4gIHJlbmRlckxhYmVsczogdHJ1ZSxcbiAgcmVuZGVyRWRnZUxhYmVsczogZmFsc2UsXG4gIGVuYWJsZUVkZ2VFdmVudHM6IGZhbHNlLFxuICAvLyBDb21wb25lbnQgcmVuZGVyaW5nXG4gIGRlZmF1bHROb2RlQ29sb3I6IFwiIzk5OVwiLFxuICBkZWZhdWx0Tm9kZVR5cGU6IFwiY2lyY2xlXCIsXG4gIGRlZmF1bHRFZGdlQ29sb3I6IFwiI2NjY1wiLFxuICBkZWZhdWx0RWRnZVR5cGU6IFwibGluZVwiLFxuICBsYWJlbEZvbnQ6IFwiQXJpYWxcIixcbiAgbGFiZWxTaXplOiAxNCxcbiAgbGFiZWxXZWlnaHQ6IFwibm9ybWFsXCIsXG4gIGxhYmVsQ29sb3I6IHtcbiAgICBjb2xvcjogXCIjMDAwXCJcbiAgfSxcbiAgZWRnZUxhYmVsRm9udDogXCJBcmlhbFwiLFxuICBlZGdlTGFiZWxTaXplOiAxNCxcbiAgZWRnZUxhYmVsV2VpZ2h0OiBcIm5vcm1hbFwiLFxuICBlZGdlTGFiZWxDb2xvcjoge1xuICAgIGF0dHJpYnV0ZTogXCJjb2xvclwiXG4gIH0sXG4gIHN0YWdlUGFkZGluZzogMzAsXG4gIGRlZmF1bHREcmF3RWRnZUxhYmVsOiBkcmF3U3RyYWlnaHRFZGdlTGFiZWwsXG4gIGRlZmF1bHREcmF3Tm9kZUxhYmVsOiBkcmF3RGlzY05vZGVMYWJlbCxcbiAgZGVmYXVsdERyYXdOb2RlSG92ZXI6IGRyYXdEaXNjTm9kZUhvdmVyLFxuICBtaW5FZGdlVGhpY2tuZXNzOiAxLjcsXG4gIGFudGlBbGlhc2luZ0ZlYXRoZXI6IDEsXG4gIC8vIE1vdXNlIGFuZCB0b3VjaCBzZXR0aW5nc1xuICBkcmFnVGltZW91dDogMTAwLFxuICBkcmFnZ2VkRXZlbnRzVG9sZXJhbmNlOiAzLFxuICBpbmVydGlhRHVyYXRpb246IDIwMCxcbiAgaW5lcnRpYVJhdGlvOiAzLFxuICB6b29tRHVyYXRpb246IDI1MCxcbiAgem9vbWluZ1JhdGlvOiAxLjcsXG4gIGRvdWJsZUNsaWNrVGltZW91dDogMzAwLFxuICBkb3VibGVDbGlja1pvb21pbmdSYXRpbzogMi4yLFxuICBkb3VibGVDbGlja1pvb21pbmdEdXJhdGlvbjogMjAwLFxuICB0YXBNb3ZlVG9sZXJhbmNlOiAxMCxcbiAgLy8gU2l6ZSBhbmQgc2NhbGluZ1xuICB6b29tVG9TaXplUmF0aW9GdW5jdGlvbjogTWF0aC5zcXJ0LFxuICBpdGVtU2l6ZXNSZWZlcmVuY2U6IFwic2NyZWVuXCIsXG4gIGF1dG9SZXNjYWxlOiB0cnVlLFxuICBhdXRvQ2VudGVyOiB0cnVlLFxuICAvLyBMYWJlbHNcbiAgbGFiZWxEZW5zaXR5OiAxLFxuICBsYWJlbEdyaWRDZWxsU2l6ZTogMTAwLFxuICBsYWJlbFJlbmRlcmVkU2l6ZVRocmVzaG9sZDogNixcbiAgLy8gUmVkdWNlcnNcbiAgbm9kZVJlZHVjZXI6IG51bGwsXG4gIGVkZ2VSZWR1Y2VyOiBudWxsLFxuICAvLyBGZWF0dXJlc1xuICB6SW5kZXg6IGZhbHNlLFxuICBtaW5DYW1lcmFSYXRpbzogbnVsbCxcbiAgbWF4Q2FtZXJhUmF0aW86IG51bGwsXG4gIGVuYWJsZUNhbWVyYVpvb21pbmc6IHRydWUsXG4gIGVuYWJsZUNhbWVyYVBhbm5pbmc6IHRydWUsXG4gIGVuYWJsZUNhbWVyYVJvdGF0aW9uOiB0cnVlLFxuICBjYW1lcmFQYW5Cb3VuZGFyaWVzOiBudWxsLFxuICAvLyBMaWZlY3ljbGVcbiAgYWxsb3dJbnZhbGlkQ29udGFpbmVyOiBmYWxzZSxcbiAgLy8gUHJvZ3JhbSBjbGFzc2VzXG4gIG5vZGVQcm9ncmFtQ2xhc3Nlczoge30sXG4gIG5vZGVIb3ZlclByb2dyYW1DbGFzc2VzOiB7fSxcbiAgZWRnZVByb2dyYW1DbGFzc2VzOiB7fVxufTtcbnZhciBERUZBVUxUX05PREVfUFJPR1JBTV9DTEFTU0VTID0ge1xuICBjaXJjbGU6IE5vZGVDaXJjbGVQcm9ncmFtXG59O1xudmFyIERFRkFVTFRfRURHRV9QUk9HUkFNX0NMQVNTRVMgPSB7XG4gIGFycm93OiBFZGdlQXJyb3dQcm9ncmFtLFxuICBsaW5lOiBFZGdlUmVjdGFuZ2xlUHJvZ3JhbVxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgaWYgKHR5cGVvZiBzZXR0aW5ncy5sYWJlbERlbnNpdHkgIT09IFwibnVtYmVyXCIgfHwgc2V0dGluZ3MubGFiZWxEZW5zaXR5IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNldHRpbmdzOiBpbnZhbGlkIGBsYWJlbERlbnNpdHlgLiBFeHBlY3RpbmcgYSBwb3NpdGl2ZSBudW1iZXIuXCIpO1xuICB9XG4gIHZhciBtaW5DYW1lcmFSYXRpbyA9IHNldHRpbmdzLm1pbkNhbWVyYVJhdGlvLFxuICAgIG1heENhbWVyYVJhdGlvID0gc2V0dGluZ3MubWF4Q2FtZXJhUmF0aW87XG4gIGlmICh0eXBlb2YgbWluQ2FtZXJhUmF0aW8gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG1heENhbWVyYVJhdGlvID09PSBcIm51bWJlclwiICYmIG1heENhbWVyYVJhdGlvIDwgbWluQ2FtZXJhUmF0aW8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nczogaW52YWxpZCBjYW1lcmEgcmF0aW8gYm91bmRhcmllcy4gRXhwZWN0aW5nIGBtYXhDYW1lcmFSYXRpb2AgdG8gYmUgZ3JlYXRlciB0aGFuIGBtaW5DYW1lcmFSYXRpb2AuXCIpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgdmFyIHJlc29sdmVkU2V0dGluZ3MgPSBhc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIHNldHRpbmdzKTtcbiAgcmVzb2x2ZWRTZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXMgPSBhc3NpZ24oe30sIERFRkFVTFRfTk9ERV9QUk9HUkFNX0NMQVNTRVMsIHJlc29sdmVkU2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzKTtcbiAgcmVzb2x2ZWRTZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXMgPSBhc3NpZ24oe30sIERFRkFVTFRfRURHRV9QUk9HUkFNX0NMQVNTRVMsIHJlc29sdmVkU2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzKTtcbiAgcmV0dXJuIHJlc29sdmVkU2V0dGluZ3M7XG59XG5cbmV4cG9ydCB7IERFRkFVTFRfRURHRV9QUk9HUkFNX0NMQVNTRVMsIERFRkFVTFRfTk9ERV9QUk9HUkFNX0NMQVNTRVMsIERFRkFVTFRfU0VUVElOR1MsIHJlc29sdmVTZXR0aW5ncywgdmFsaWRhdGVTZXR0aW5ncyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/sigma/settings/dist/sigma-settings.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/sigma/types/dist/sigma-types.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/sigma/types/dist/sigma-types.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedEventEmitter: () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var _dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/inherits-d1a1e29b.esm.js */ \"(app-pages-browser)/./node_modules/sigma/dist/inherits-d1a1e29b.esm.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"(app-pages-browser)/./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n/**\n * Util type to represent maps of typed elements, but implemented with\n * JavaScript objects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * Returns a type similar to T, but with the K set of properties of the type\n * T *required*, and the rest optional.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * Returns a type similar to Partial<T>, but with at least one key set.\n */\n\n/**\n * Custom event emitter types.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nvar TypedEventEmitter = /*#__PURE__*/function (_ref) {\n  function TypedEventEmitter() {\n    var _this;\n    (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, TypedEventEmitter);\n    _this = (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, TypedEventEmitter);\n    _this.rawEmitter = _this;\n    return _this;\n  }\n  (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(TypedEventEmitter, _ref);\n  return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(TypedEventEmitter);\n}(events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter);\n\n/**\n * Event types.\n */\n\n/**\n * Export various other types:\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zaWdtYS90eXBlcy9kaXN0L3NpZ21hLXR5cGVzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStIO0FBQ3pGOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQWU7QUFDbkIsWUFBWSxpRUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLGlFQUFTO0FBQ1gsU0FBUyxpRUFBWTtBQUNyQixDQUFDLENBQUMsZ0RBQVk7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFNkIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGVub3ZvXFxEZXNrdG9wXFxmcm9udGVuZFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcc2lnbWFcXHR5cGVzXFxkaXN0XFxzaWdtYS10eXBlcy5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXyBhcyBfaW5oZXJpdHMsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgYyBhcyBfY2FsbFN1cGVyIH0gZnJvbSAnLi4vLi4vZGlzdC9pbmhlcml0cy1kMWExZTI5Yi5lc20uanMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxuLyoqXG4gKiBVdGlsIHR5cGUgdG8gcmVwcmVzZW50IG1hcHMgb2YgdHlwZWQgZWxlbWVudHMsIGJ1dCBpbXBsZW1lbnRlZCB3aXRoXG4gKiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbi8qKlxuICogUmV0dXJucyBhIHR5cGUgc2ltaWxhciB0byBULCBidXQgd2l0aCB0aGUgSyBzZXQgb2YgcHJvcGVydGllcyBvZiB0aGUgdHlwZVxuICogVCAqcmVxdWlyZWQqLCBhbmQgdGhlIHJlc3Qgb3B0aW9uYWwuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbi8qKlxuICogUmV0dXJucyBhIHR5cGUgc2ltaWxhciB0byBQYXJ0aWFsPFQ+LCBidXQgd2l0aCBhdCBsZWFzdCBvbmUga2V5IHNldC5cbiAqL1xuXG4vKipcbiAqIEN1c3RvbSBldmVudCBlbWl0dGVyIHR5cGVzLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG52YXIgVHlwZWRFdmVudEVtaXR0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9yZWYpIHtcbiAgZnVuY3Rpb24gVHlwZWRFdmVudEVtaXR0ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUeXBlZEV2ZW50RW1pdHRlcik7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFR5cGVkRXZlbnRFbWl0dGVyKTtcbiAgICBfdGhpcy5yYXdFbWl0dGVyID0gX3RoaXM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhUeXBlZEV2ZW50RW1pdHRlciwgX3JlZik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVHlwZWRFdmVudEVtaXR0ZXIpO1xufShFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIEV2ZW50IHR5cGVzLlxuICovXG5cbi8qKlxuICogRXhwb3J0IHZhcmlvdXMgb3RoZXIgdHlwZXM6XG4gKi9cblxuZXhwb3J0IHsgVHlwZWRFdmVudEVtaXR0ZXIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/sigma/types/dist/sigma-types.esm.js\n"));

/***/ })

}]);